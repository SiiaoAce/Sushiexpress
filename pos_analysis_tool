# -*- coding: utf-8 -*-
"""
POS数据分析工具 - 增强版
包含多种分析功能和搜索功能
"""

import pyodbc
import pandas as pd
import tkinter as tk
from tkinter import ttk, filedialog, messagebox
from datetime import datetime, timedelta
import csv
import os
import time
import json
from tkcalendar import DateEntry
import customtkinter as ctk
import sqlite3
from decimal import Decimal
import threading

# SEAutomation.py 配色方案
DARK_BG = "#0f172a"
DARK_PANEL = "#1e293b"
ACCENT_BLUE = "#3b82f6"
BTN_HOVER = "#60a5fa"
ACCENT_GREEN = "#10b981"
ACCENT_RED = "#ef4444"
ACCENT_PURPLE = "#8b5cf6"
ACCENT_ORANGE = "#f97316"
ENTRY_BG = "#334155"
TEXT_COLOR = "#e2e8f0"
PANEL_BG = "#1e293b"
TEXTBOX_BG = "#0f172a"

# SEAutomation.py 字體配置
FONT_TITLE = ("Microsoft JhengHei", 24, "bold")
FONT_BIGBTN = ("Microsoft JhengHei", 16, "bold")
FONT_MID = ("Microsoft JhengHei", 14)
FONT_SUB = ("Microsoft JhengHei", 12)
FONT_ZH = ("Microsoft JhengHei", 12)
FONT_EN = ("Segoe UI", 11, "italic")
FONT_LOG = ("Consolas", 14)
FONT_SMALL = ("Microsoft JhengHei", 10)

# SEAutomation.py 中的發光按鈕類
class GlowButton(ctk.CTkButton):
    """發光效果按鈕（美化版）- 與SEAutomation.py相同"""
    
    def __init__(self, master, text=None, glow_color=ACCENT_BLUE, **kwargs):
        super().__init__(master, text=text, **kwargs)
        self._glow_color = glow_color
        self._setup_style()
        self._bind_events()

    def _setup_style(self):
        self.configure(
            border_width=0,
            fg_color=self._glow_color,
            hover_color=self._adjust_color(self._glow_color, 40),
            text_color='white',
            corner_radius=22,  # 更圓角
            font=("Microsoft JhengHei", 16, "bold"),  # 更大更粗
            height=50,  # 更高
            width=200,  # 更寬
            anchor="center"
        )

    def _bind_events(self):
        self.bind("<Enter>", self._on_enter)
        self.bind("<Leave>", self._on_leave)

    def _on_enter(self, event=None):
        self.configure(border_width=4, border_color=self._adjust_color(self._glow_color, 60), fg_color=self._adjust_color(self._glow_color, 20))

    def _on_leave(self, event=None):
        self.configure(border_width=0, fg_color=self._glow_color)
    
    @staticmethod
    def _adjust_color(color, amount):
        if isinstance(color, tuple) and len(color) >= 3:
            r, g, b = color[:3]
            adjusted = tuple(min(255, max(0, x + amount)) for x in (r, g, b))
            if len(color) == 4:
                return adjusted + (color[3],)
            return adjusted
        else:
            color = color.lstrip('#')
            rgb = tuple(int(color[i:i+2], 16) for i in (0, 2, 4))
            adjusted = tuple(min(255, max(0, x + amount)) for x in rgb)
            return f"#{adjusted[0]:02x}{adjusted[1]:02x}{adjusted[2]:02x}"

# 设置货币格式
def format_currency(amount):
    """格式化货币显示"""
    if amount is None or amount == '':
        return '$0.00'
    try:
        return f"${float(amount):,.2f}"
    except (ValueError, TypeError):
        return '$0.00'

def format_number(number):
    """格式化数字显示（千位分隔符）"""
    if number is None or number == '':
        return '0'
    try:
        return f"{int(float(number)):,}"
    except (ValueError, TypeError):
        return '0'

def format_decimal(number, decimals=2):
    """格式化浮点数字显示（千位分隔符 + 固定小数位）"""
    if number is None or number == '':
        return f"{0:.{decimals}f}"
    try:
        return f"{float(number):,.{decimals}f}"
    except (ValueError, TypeError):
        return f"{0:.{decimals}f}"

class MultiSelectCombobox:
    """多选下拉框类"""
    _active_dropdown = None  # 类变量，跟踪当前活动的dropdown
    
    def __init__(self, parent, width=15, title="选择项目", on_change_callback=None, delay_ms=2000, **kwargs):
        self.parent = parent
        self.width = width
        self.title = title
        self.delay_ms = delay_ms  # 延迟时间（毫秒）
        self.delay_timer = None  # 延迟定时器
        self.values = []
        self.selected_values = []
        self.vars = {}
        self.checkboxes = {}
        self.on_change_callback = on_change_callback  # 添加变化回调
        self.filtered_values = []  # 添加过滤后的值列表
        self.search_entry = None  # 搜索框引用
        
        # 创建主框架
        self.frame = tk.Frame(parent)
        
        # 创建下拉框
        self.combo = ttk.Combobox(self.frame, width=width, state="readonly", **kwargs)
        self.combo.pack(side="left", padx=1)
        
        # 创建下拉按钮
        self.dropdown_btn = ttk.Button(self.frame, text="▼", width=3, command=self.toggle_dropdown)
        self.dropdown_btn.pack(side="left", padx=1)
        
        # 创建下拉窗口
        self.dropdown_window = None
        self.dropdown_frame = None
        
        # 绑定事件
        self.combo.bind('<Button-1>', self.on_click)
        self.combo.bind('<KeyPress>', self.on_key)
        self.dropdown_btn.bind('<Button-1>', self.on_click)
    
    def set_values(self, values):
        """设置选项值"""
        self.values = values
        self.filtered_values = values.copy()  # 初始化过滤后的值
        self.selected_values = []  # 默认不选择任何项目
        self.update_display()
        # 不在这里创建复选框，只在显示下拉窗口时创建
    
    def create_checkboxes(self):
        """创建复选框"""
        if not self.dropdown_frame:
            return
            
        # 清空现有复选框
        for widget in self.dropdown_frame.winfo_children():
            widget.destroy()
        
        self.vars = {}
        self.checkboxes = {}
        
        # 确保filtered_values有值
        if not self.filtered_values:
            self.filtered_values = self.values.copy()
        
        for i, value in enumerate(self.filtered_values):
            var = tk.BooleanVar(value=value in self.selected_values)
            self.vars[value] = var
            
            cb = tk.Checkbutton(
                self.dropdown_frame, 
                text=value, 
                variable=var,
                command=lambda v=value: self.on_checkbox_change(v)
            )
            cb.pack(anchor="w", padx=2, pady=1)
            self.checkboxes[value] = cb
    
    def toggle_dropdown(self):
        """切换下拉窗口"""
        if self.dropdown_window and self.dropdown_window.winfo_exists():
            self.close_dropdown()
        else:
            self.show_dropdown()
    
    def show_dropdown(self):
        """显示下拉窗口"""
        if not self.values:
            return
        
        # 关闭其他活动的dropdown
        if MultiSelectCombobox._active_dropdown and MultiSelectCombobox._active_dropdown != self:
            MultiSelectCombobox._active_dropdown.close_dropdown()
        
        # 创建下拉窗口
        self.dropdown_window = tk.Toplevel(self.parent)
        self.dropdown_window.overrideredirect(True)
        self.dropdown_window.attributes('-topmost', True)
        
        # 计算位置
        x = self.frame.winfo_rootx()
        y = self.frame.winfo_rooty() + self.frame.winfo_height()
        self.dropdown_window.geometry(f"+{x}+{y}")
        
        # 创建标题栏
        title_frame = tk.Frame(self.dropdown_window)
        title_frame.pack(fill="x", padx=2, pady=2)
        
        tk.Label(title_frame, text=self.title).pack(side="left")
        close_btn = ttk.Button(title_frame, text="✕", width=3, command=self.close_dropdown)
        close_btn.pack(side="right")
        
        # 创建搜索框
        search_frame = tk.Frame(self.dropdown_window)
        search_frame.pack(fill="x", padx=2, pady=2)
        
        tk.Label(search_frame, text="搜索:\nSearch:").pack(side="left")
        self.search_entry = ttk.Entry(search_frame, width=15)
        self.search_entry.pack(side="left", padx=2)
        self.search_entry.bind("<KeyRelease>", self.on_search_change)
        
        clear_btn = ttk.Button(search_frame, text="清空\nClear", width=4, command=self.clear_search)
        clear_btn.pack(side="left", padx=2)
        
        # 创建滚动框架
        canvas = tk.Canvas(self.dropdown_window, width=self.width*8, height=min(len(self.values)*25+10, 200))
        scrollbar = ttk.Scrollbar(self.dropdown_window, orient="vertical", command=canvas.yview)
        self.dropdown_frame = tk.Frame(canvas)
        
        self.dropdown_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        
        canvas.create_window((0, 0), window=self.dropdown_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
        
        # 创建复选框
        self.create_checkboxes()
        
        # 确保搜索框引用正确
        if hasattr(self, 'search_entry') and self.search_entry:
            self.search_entry.focus_set()
        
        # 绑定ESC键关闭
        self.dropdown_window.bind("<Escape>", lambda e: self.close_dropdown())
        
        # 绑定失去焦点关闭（延迟执行）
        self.dropdown_window.bind("<FocusOut>", lambda e: self.dropdown_window.after(100, self.check_focus))
        
        # 设置当前dropdown为活动状态
        MultiSelectCombobox._active_dropdown = self
        
        self.dropdown_window.focus_set()
    
    def on_click(self, event):
        """点击下拉框时显示下拉窗口"""
        if self.dropdown_window and self.dropdown_window.winfo_exists():
            self.close_dropdown()
        else:
            self.show_dropdown()
        return "break"
    
    def on_key(self, event):
        """按键事件"""
        if event.keysym == 'Down':
            self.show_dropdown()
            return "break"
    
    
    def on_dropdown_click(self, event):
        """处理下拉窗口点击事件"""
        # 检查点击位置是否在复选框区域内
        widget = event.widget
        if widget == self.dropdown_window:
            # 点击窗口空白区域，不关闭
            return "break"
        return "break"
    
    def check_focus(self):
        """检查焦点，如果失去焦点则关闭"""
        if self.dropdown_window and self.dropdown_window.winfo_exists():
            try:
                # 检查窗口是否还有焦点
                if not self.dropdown_window.focus_get():
                    self.close_dropdown()
            except:
                pass
    
    def close_dropdown(self):
        """关闭下拉窗口"""
        if self.dropdown_window and self.dropdown_window.winfo_exists():
            self.dropdown_window.destroy()
            self.dropdown_window = None
        
        # 清除活动状态
        if MultiSelectCombobox._active_dropdown == self:
            MultiSelectCombobox._active_dropdown = None
    
    def on_checkbox_change(self, value):
        """复选框状态改变"""
        if self.vars[value].get():
            if value not in self.selected_values:
                self.selected_values.append(value)
        else:
            if value in self.selected_values:
                self.selected_values.remove(value)
        
        self.update_display()
        
        # 延迟调用变化回调
        self._schedule_callback()
    
    def _schedule_callback(self):
        """安排延迟回调"""
        # 取消之前的定时器
        if self.delay_timer:
            self.parent.after_cancel(self.delay_timer)
        
        # 显示延迟状态
        if self.selected_values:
            self.combo.set(f"已选择{len(self.selected_values)}项 (选择中...)")
        else:
            self.combo.set("选择中...")
        
        # 设置新的定时器
        self.delay_timer = self.parent.after(self.delay_ms, self._execute_callback)
    
    def _execute_callback(self):
        """执行延迟回调"""
        if self.on_change_callback:
            self.on_change_callback(self.selected_values)
        self.delay_timer = None
        # 更新显示文本
        self.update_display()
    
    def execute_callback_immediately(self):
        """立即执行回调（用于全部选择/取消等操作）"""
        # 取消延迟定时器
        if self.delay_timer:
            self.parent.after_cancel(self.delay_timer)
            self.delay_timer = None
        
        # 立即执行回调
        if self.on_change_callback:
            self.on_change_callback(self.selected_values)
        
        # 更新显示文本
        self.update_display()
    
    def update_display(self):
        """更新显示文本"""
        if not self.selected_values:
            self.combo.set("未选择")
        elif len(self.selected_values) == len(self.values):
            self.combo.set("全部")
        else:
            self.combo.set(f"已选择 {len(self.selected_values)} 项")
    
    def get_selected(self):
        """获取选中的值"""
        return self.selected_values.copy()
    
    def get_selected_for_filter(self):
        """获取用于筛选的选中值
        如果选择了全部，返回None表示不应用筛选
        如果未选择任何，返回空列表表示不应用筛选
        如果选择了部分，返回选中的值列表
        """
        if len(self.selected_values) == 0:
            return None  # 未选择任何，不应用筛选
        elif len(self.selected_values) == len(self.values):
            return None  # 选择了全部，不应用筛选
        else:
            return self.selected_values.copy()  # 选择了部分，应用筛选
    
    def set_selected(self, values):
        """设置选中的值"""
        self.selected_values = values.copy() if values else []
        for value, var in self.vars.items():
            var.set(value in self.selected_values)
        self.update_display()
    
    def select_all(self):
        """选择全部"""
        self.set_selected(self.values)
    
    def select_none(self):
        """取消全部选择"""
        self.set_selected([])
    
    def toggle_all(self):
        """切换全部选择状态"""
        if len(self.selected_values) == len(self.values):
            self.select_none()
        else:
            self.select_all()
    
    def on_search_change(self, event):
        """搜索内容改变时触发"""
        if not hasattr(self, 'search_entry') or not self.search_entry:
            return
            
        search_term = self.search_entry.get().strip().lower()
        if not search_term:
            self.filtered_values = self.values.copy()
        else:
            self.filtered_values = [value for value in self.values if search_term in value.lower()]
        
        # 重新创建复选框
        self.create_checkboxes()
    
    def clear_search(self):
        """清空搜索"""
        if hasattr(self, 'search_entry') and self.search_entry:
            self.search_entry.delete(0, tk.END)
            self.filtered_values = self.values.copy()
            self.create_checkboxes()
    
    def pack(self, **kwargs):
        """打包显示"""
        self.frame.pack(**kwargs)

# 连接配置
SERVER = "52.230.94.233"
USER = "seadmin"
PASSWORD = "$e@dmin11!"
DATABASES = ["sushi_gogo_pos_live", "sushi_express_pos_live"]
TABLE_SALES = "pos_sales_dtls"
TABLE_PAYMENT = "pos_sales_payment_dtls"
TABLE_CANCEL = "pos_cancel_sales_item_dtls"
TABLE_ITEMS = "item_master"

class DatabaseManager:
    def __init__(self):
        self.connection = None
        self.combined_mode = False  # 合併模式標記
        self.actual_database = None  # 實際連接的數據庫
        self._sales_cache = {}  # 销售数据缓存
        self._discount_cache = {}  # 折扣分析缓存
        self._monthly_cache = {}  # 月度汇总缓存
        self._category_cache = {}  # 类别分析缓存
        self._weekly_cache = {}  # 周期产品数据缓存
        self.receipt_db_path = "receipt_database.db"
        self._product_cache = {}  # 产品总览缓存
        self._period_product_cache = {}  # 期间产品总览缓存
        self._payment_cache = {}  # 支付汇总缓存
        self._sales_tc_cache = {}  # 销售TC分析缓存
        self._sales_tc_monthly_cache = {}  # 月度产品分析缓存
        self.performance_tips = [
            "建议在 pos_sales_dtls 表上创建以下索引以提高查询性能：",
            "1. CREATE INDEX IX_pos_sales_dtls_c_date ON pos_sales_dtls (c_date)",
            "2. CREATE INDEX IX_pos_sales_dtls_store_item ON pos_sales_dtls (store_name, item_name)",
            "3. CREATE INDEX IX_pos_sales_dtls_sales_no ON pos_sales_dtls (sales_no, store_name)",
            "4. CREATE INDEX IX_pos_sales_dtls_item_date ON pos_sales_dtls (item_name, c_date)",
            "5. CREATE INDEX IX_pos_sales_payment_dtls_sales ON pos_sales_payment_dtls (sales_no, store_name)",
            "6. CREATE INDEX IX_item_master_item_date ON item_master (item_name, m_date)"
        ]
        self.current_database = None
        self.outlets = []
        self.products = []
        self.payment_names = []
        # 可由GUI注入的日志回调: callable(str, include_db_info: bool)
        self.log_message = None

    def get_local_date_range(self, source_db: str | None = None):
        """查詢本地SQLite中receipt_details的日期範圍，可選按數據庫來源過濾。"""
        try:
            compressed_path = "receipt_database_compressed.db"
            if os.path.exists(compressed_path) and not os.path.exists(self.receipt_db_path):
                from receipt_database_manager import ReceiptDatabaseManager
                manager = ReceiptDatabaseManager()
                manager.decompress_database()
            import sqlite3
            if not os.path.exists(self.receipt_db_path):
                return None, None, 0
            conn = sqlite3.connect(self.receipt_db_path)
            cursor = conn.cursor()
            if source_db:
                cursor.execute(
                    "SELECT MIN(DATE(日期)), MAX(DATE(日期)), COUNT(DISTINCT DATE(日期)) FROM receipt_details WHERE 數據庫來源 = ?",
                    (source_db,)
                )
            else:
                cursor.execute(
                    "SELECT MIN(DATE(日期)), MAX(DATE(日期)), COUNT(DISTINCT DATE(日期)) FROM receipt_details"
                )
            row = cursor.fetchone()
            conn.close()
            return (row[0], row[1], int(row[2] or 0)) if row else (None, None, 0)
        except Exception:
            return None, None, 0

    def get_monthly_summary_from_local(self, date_from=None, date_to=None, outlet_filters=None):
        """從本地SQLite彙總月度數據（門市 x 月）。"""
        try:
            import sqlite3
            compressed_path = "receipt_database_compressed.db"
            if os.path.exists(compressed_path) and not os.path.exists(self.receipt_db_path):
                from receipt_database_manager import ReceiptDatabaseManager
                ReceiptDatabaseManager().decompress_database()
            if not os.path.exists(self.receipt_db_path):
                return []
            conn = sqlite3.connect(self.receipt_db_path)
            where = []
            params = []
            if date_from and date_to:
                where.append("DATE(日期) >= ? AND DATE(日期) <= ?")
                params.extend([date_from, date_to])
            if outlet_filters:
                placeholders = ",".join(["?" for _ in outlet_filters])
                where.append(f"門市 IN ({placeholders})")
                params.extend(outlet_filters)
            where_clause = ("WHERE " + " AND ".join(where)) if where else ""
            query = f"""
                SELECT strftime('%Y-%m', 日期) as 月份,
                       門市,
                       COUNT(DISTINCT 單據號) as 單據數,
                       SUM(淨金額) as 總業績,
                       SUM(總數量) as 總數量
                FROM receipt_details
                {where_clause}
                GROUP BY strftime('%Y-%m', 日期), 門市
                ORDER BY 月份, 門市
            """
            import pandas as pd
            df = pd.read_sql_query(query, conn, params=params)
            conn.close()
            return df.to_dict("records")
        except Exception:
            return []
    
    def get_unique_store_count(self, date_from=None, date_to=None, outlet_filters=None, month_filters=None,
                               weekday_filters=None, category_filters=None, product_filters=None,
                               payment_filters=None):
        """根据筛选条件获取唯一门市数量"""
        if not self.connection:
            return 0

        conditions = []
        params = []

        if date_from:
            conditions.append("CAST(s.c_date as DATE) >= ?")
            params.append(date_from)
        if date_to:
            conditions.append("CAST(s.c_date as DATE) <= ?")
            params.append(date_to)
        if outlet_filters:
            placeholders = ','.join(['?' for _ in outlet_filters])
            conditions.append(f"s.store_name IN ({placeholders})")
            params.extend(outlet_filters)
        if month_filters:
            month_conditions = []
            for month in month_filters:
                month_conditions.append("FORMAT(s.c_date, 'yyyy-MM') = ?")
                params.append(month)
            if month_conditions:
                conditions.append("(" + " OR ".join(month_conditions) + ")")
        if weekday_filters:
            weekday_map = {
                'Sunday': 1, 'Monday': 2, 'Tuesday': 3, 'Wednesday': 4,
                'Thursday': 5, 'Friday': 6, 'Saturday': 7
            }
            weekday_conditions = []
            for weekday in weekday_filters:
                value = weekday_map.get(weekday)
                if value:
                    weekday_conditions.append(f"DATEPART(WEEKDAY, s.c_date) = {value}")
            if weekday_conditions:
                conditions.append("(" + " OR ".join(weekday_conditions) + ")")
        if category_filters:
            placeholders = ','.join(['?' for _ in category_filters])
            conditions.append(f"im.category_code IN ({placeholders})")
            params.extend(category_filters)
        if product_filters:
            placeholders = ','.join(['?' for _ in product_filters])
            conditions.append(f"s.item_name IN ({placeholders})")
            params.extend(product_filters)
        if payment_filters:
            placeholders = ','.join(['?' for _ in payment_filters])
            conditions.append(
                f"EXISTS (SELECT 1 FROM {TABLE_PAYMENT} p WHERE p.sales_no = s.sales_no AND p.store_name = s.store_name AND p.payment_name IN ({placeholders}))"
            )
            params.extend(payment_filters)

        # 排除报废
        conditions.append("s.item_name NOT IN ('WASTAGE', 'Waste', 'waste', 'WASTE')")

        where_clause = ""
        if conditions:
            where_clause = " WHERE " + " AND ".join(conditions)

        query = f"""
            SELECT COUNT(DISTINCT s.store_name)
            FROM {TABLE_SALES} s WITH (NOLOCK)
            LEFT JOIN {TABLE_ITEMS} im ON s.item_name = im.item_name
            {where_clause}
        """

        try:
            cursor = self.connection.cursor()
            cursor.execute(query, params)
            result = cursor.fetchone()
            cursor.close()
            return int(result[0]) if result and result[0] else 0
        except Exception as e:
            print(f"获取唯一门市数量失败: {e}")
            return 0

    def get_performance_calculation_sql(self):
        """根据当前数据库类型返回正确的业绩计算SQL"""
        if self.current_database == "sushi_gogo_pos_live":
            # GOGO数据库：所有单据都直接减去tax_amt，包含所有折扣字段
            return "CAST(s.sub_total as FLOAT) - CAST(ISNULL(s.pro_disc_amt, 0) as FLOAT) - CAST(ISNULL(s.disc_amt, 0) as FLOAT) + CAST(ISNULL(s.svc_amt, 0) as FLOAT) - CAST(ISNULL(s.tax_amt, 0) as FLOAT)"
        else:
            # Express数据库：只有外带商品才减去tax_amt，包含所有折扣字段
            return "CAST(s.sub_total as FLOAT) - CAST(ISNULL(s.pro_disc_amt, 0) as FLOAT) - CAST(ISNULL(s.disc_amt, 0) as FLOAT) + CAST(ISNULL(s.svc_amt, 0) as FLOAT) - CASE WHEN s.take_away_item = 'Y' THEN CAST(ISNULL(s.tax_amt, 0) as FLOAT) ELSE 0 END"
    
    def get_combined_performance_calculation_sql(self, db_name):
        """为合并模式返回指定数据库的业绩计算SQL"""
        if db_name == "sushi_gogo_pos_live":
            # GOGO数据库：所有单据都直接减去tax_amt，包含所有折扣字段
            return "CAST(s.sub_total as FLOAT) - CAST(ISNULL(s.pro_disc_amt, 0) as FLOAT) - CAST(ISNULL(s.disc_amt, 0) as FLOAT) + CAST(ISNULL(s.svc_amt, 0) as FLOAT) - CAST(ISNULL(s.tax_amt, 0) as FLOAT)"
        else:
            # Express数据库：只有外带商品才减去tax_amt，包含所有折扣字段
            return "CAST(s.sub_total as FLOAT) - CAST(ISNULL(s.pro_disc_amt, 0) as FLOAT) - CAST(ISNULL(s.disc_amt, 0) as FLOAT) + CAST(ISNULL(s.svc_amt, 0) as FLOAT) - CASE WHEN s.take_away_item = 'Y' THEN CAST(ISNULL(s.tax_amt, 0) as FLOAT) ELSE 0 END"
    
    def get_combined_cancel_performance_calculation_sql(self, db_name):
        """为合并模式返回指定数据库的取消项目业绩计算SQL（无表别名）"""
        if db_name == "sushi_gogo_pos_live":
            # GOGO数据库：所有单据都直接减去tax_amt，包含所有折扣字段
            return "CAST(sub_total as FLOAT) - CAST(ISNULL(pro_disc_amt, 0) as FLOAT) - CAST(ISNULL(disc_amt, 0) as FLOAT) + CAST(ISNULL(svc_amt, 0) as FLOAT) - CAST(ISNULL(tax_amt, 0) as FLOAT)"
        else:
            # Express数据库：只有外带商品才减去tax_amt，包含所有折扣字段
            return "CAST(sub_total as FLOAT) - CAST(ISNULL(pro_disc_amt, 0) as FLOAT) - CAST(ISNULL(disc_amt, 0) as FLOAT) + CAST(ISNULL(svc_amt, 0) as FLOAT) - CASE WHEN take_away_item = 'Y' THEN CAST(ISNULL(tax_amt, 0) as FLOAT) ELSE 0 END"
    
    def get_database_date_range(self):
        """获取数据库中的数据日期范围"""
        try:
            if not self.connection:
                return None, None, None
            
            cursor = self.connection.cursor()
            
            # 获取最早和最晚的日期
            query = """
                SELECT 
                    MIN(CAST(c_date AS DATE)) as min_date,
                    MAX(CAST(c_date AS DATE)) as max_date,
                    COUNT(DISTINCT CAST(c_date AS DATE)) as total_days
                FROM pos_sales_dtls 
                WHERE item_name NOT IN ('WASTAGE', 'Waste', 'waste', 'WASTE')
            """
            
            cursor.execute(query)
            result = cursor.fetchone()
            cursor.close()
            
            if result and result[0] and result[1]:
                return result[0], result[1], result[2]
            else:
                return None, None, None
                
        except Exception as e:
            print(f"获取数据库日期范围失败: {e}")
            return None, None, None
    
    def _get_cancel_performance_calculation_sql(self):
        """为取消项目表返回正确的业绩计算SQL（无表别名）"""
        if self.current_database == "sushi_gogo_pos_live":
            # GOGO数据库：所有单据都直接减去tax_amt，包含所有折扣字段
            return "CAST(sub_total as FLOAT) - CAST(ISNULL(pro_disc_amt, 0) as FLOAT) - CAST(ISNULL(disc_amt, 0) as FLOAT) + CAST(ISNULL(svc_amt, 0) as FLOAT) - CAST(ISNULL(tax_amt, 0) as FLOAT)"
        else:
            # Express数据库：只有外带商品才减去tax_amt，包含所有折扣字段
            return "CAST(sub_total as FLOAT) - CAST(ISNULL(pro_disc_amt, 0) as FLOAT) - CAST(ISNULL(disc_amt, 0) as FLOAT) + CAST(ISNULL(svc_amt, 0) as FLOAT) - CASE WHEN take_away_item = 'Y' THEN CAST(ISNULL(tax_amt, 0) as FLOAT) ELSE 0 END"
    
    def connect(self, database):
        """连接到指定数据库 - 支持合併模式"""
        try:
            # 数据库名称映射 - 确保使用正确的数据库名称
            db_mapping = {
                'GOGO': 'sushi_gogo_pos_live',
                'Express': 'sushi_express_pos_live', 
                'Plus': 'sushi_plus_pos_live',
                'PLUS': 'sushi_plus_pos_live'  # 兼容性
            }
            
            # 對於"All"選項，連接到第一個數據庫但設置合併模式標記
            if database == "All":
                print("🔀 All選項：設置合併模式，連接到第一個數據庫...")
                self.combined_mode = True
                actual_database = "sushi_gogo_pos_live"  # 第一個數據庫
            else:
                self.combined_mode = False
                # 检查是否是选项键，如果是则映射到实际数据库名称
                actual_database = db_mapping.get(database, database)
            # 尝试不同的ODBC驱动
            drivers = [
                "SQL Server",
                "SQL Server Native Client 11.0",
                "ODBC Driver 17 for SQL Server",
                "ODBC Driver 13 for SQL Server"
            ]
            
            for driver in drivers:
                try:
                    conn_str = f"DRIVER={{{driver}}};SERVER={SERVER};DATABASE={actual_database};UID={USER};PWD={PASSWORD};Connection Timeout=30;TDS_Version=8.0;TrustServerCertificate=yes;Encrypt=no;"
                    self.connection = pyodbc.connect(conn_str)
                    self.current_database = database  # 保存用戶選擇的選項
                    self.actual_database = actual_database  # 保存實際連接的數據庫
                    
                    # 设置TEXT_SIZE以避免TDS协议错误
                    cursor = self.connection.cursor()
                    cursor.execute("SET TEXTSIZE 2147483647")
                    cursor.execute("SET QUERY_GOVERNOR_COST_LIMIT 0")
                    cursor.execute("SET LOCK_TIMEOUT 30000")
                    cursor.close()
                    
                    print(f"使用驱动 {driver} 连接成功")
                    if self.combined_mode:
                        print("✅ 合併模式已啟用")
                    return True
                except Exception as e:
                    print(f"驱动 {driver} 连接失败: {e}")
                    continue
            
            print("所有ODBC驱动都无法连接")
            return False
        except Exception as e:
            print(f"连接失败: {e}")
            return False
    
    def disconnect(self):
        """断开连接"""
        if self.connection:
            self.connection.close()
            self.connection = None
            self.current_database = None
    
    def get_monthly_product_receipt_performance_from_db(self, date_from=None, date_to=None, outlet_filters=None, product_filters=None, database_source=None):
        """從SQL Server獲取月度產品單據業績 - 專門為月-銷售數據設計"""
        try:
            if not self.connection:
                print("❌ 數據庫連接不存在")
                return {}
            
            cursor = self.connection.cursor()
            
            # 構建門市篩選條件
            store_filter = ""
            if outlet_filters and len(outlet_filters) > 0:
                store_list = "', '".join(outlet_filters)
                store_filter = f"AND s.store_name IN ('{store_list}')"
            
            # 構建產品篩選條件
            product_filter_clause = ""
            if product_filters:
                product_list = "', '".join(product_filters)
                product_filter_clause = f"AND s.item_name IN ('{product_list}')"
            
            # 月度產品單據業績查詢：按月份、門市、產品分組
            query = f"""
                WITH ProductReceipts AS (
                    -- 找出包含指定產品的所有單據
                    SELECT DISTINCT 
                        s.item_name,
                        s.sales_no,
                        s.store_name,
                        FORMAT(s.c_date, 'yyyy-MM') as month_key
                    FROM pos_sales_dtls s WITH (NOLOCK)
                    WHERE s.item_name != 'WASTAGE'
                    AND CAST(s.c_date as DATE) >= '{date_from}' AND CAST(s.c_date as DATE) <= '{date_to}'
                    {store_filter}
                    {product_filter_clause}
                ),
                ReceiptTotals AS (
                    -- 計算每張單據的總金額
                    SELECT 
                        s.sales_no,
                        s.store_name,
                        FORMAT(s.c_date, 'yyyy-MM') as month_key,
                        SUM(CAST(s.sub_total as FLOAT) - CAST(ISNULL(s.pro_disc_amt, 0) as FLOAT) - CAST(ISNULL(s.disc_amt, 0) as FLOAT) + CAST(ISNULL(s.svc_amt, 0) as FLOAT) - CASE WHEN s.take_away_item = 'Y' THEN CAST(ISNULL(s.tax_amt, 0) as FLOAT) ELSE 0 END) as receipt_total
                    FROM pos_sales_dtls s WITH (NOLOCK)
                    WHERE s.item_name != 'WASTAGE'
                    AND CAST(s.c_date as DATE) >= '{date_from}' AND CAST(s.c_date as DATE) <= '{date_to}'
                    {store_filter}
                    GROUP BY s.sales_no, s.store_name, FORMAT(s.c_date, 'yyyy-MM')
                )
                SELECT 
                    pr.item_name,
                    pr.month_key,
                    pr.store_name,
                    COUNT(DISTINCT pr.sales_no) as 單據數量,
                    SUM(rt.receipt_total) as 產品單據業績,
                    AVG(rt.receipt_total) as 平均單據金額
                FROM ProductReceipts pr
                INNER JOIN ReceiptTotals rt ON pr.sales_no = rt.sales_no AND pr.store_name = rt.store_name AND pr.month_key = rt.month_key
                GROUP BY pr.item_name, pr.month_key, pr.store_name
                ORDER BY pr.month_key DESC, pr.store_name, pr.item_name
            """
            
            cursor.execute(query)
            rows = cursor.fetchall()
            
            # 轉換為字典格式，使用組合鍵 (product_name, month, store_name)
            result = {}
            for row in rows:
                product_name = row[0]
                month = row[1]
                store_name = row[2]
                key = f"{product_name}_{month}_{store_name}"
                
                result[key] = {
                    '单据数量': int(row[3]),
                    '产品单据业绩': float(row[4]),
                    '平均单据金额': float(row[5])
                }
            
            return result
            
        except Exception as e:
            print(f"❌ 從SQL Server獲取月度產品單據業績失敗: {e}")
            return {}

    def get_period_product_receipt_performance_from_db(self, date_from=None, date_to=None, outlet_filters=None, product_filters=None, database_source=None):
        """從SQL Server獲取期間產品單據業績 - 專門為期間-產品數據設計"""
        try:
            if not self.connection:
                print("❌ 數據庫連接不存在")
                return {}
            
            cursor = self.connection.cursor()
            
            # 構建門市篩選條件
            store_filter = ""
            if outlet_filters and len(outlet_filters) > 0:
                store_list = "', '".join(outlet_filters)
                store_filter = f"AND s.store_name IN ('{store_list}')"
            
            # 構建產品篩選條件
            product_filter_clause = ""
            if product_filters:
                product_list = "', '".join(product_filters)
                product_filter_clause = f"AND s.item_name IN ('{product_list}')"
            
            # 期間產品單據業績查詢：按產品分組，聚合所有門市和日期
            query = f"""
                WITH ProductReceipts AS (
                    -- 找出包含指定產品的所有單據
                    SELECT DISTINCT 
                        s.item_name,
                        s.sales_no,
                        s.store_name,
                        CAST(s.c_date as DATE) as c_date
                    FROM pos_sales_dtls s WITH (NOLOCK)
                    WHERE s.item_name != 'WASTAGE'
                    AND CAST(s.c_date as DATE) >= '{date_from}' AND CAST(s.c_date as DATE) <= '{date_to}'
                    {store_filter}
                    {product_filter_clause}
                ),
                ReceiptTotals AS (
                    -- 計算每張單據的總金額
                    SELECT 
                        s.sales_no,
                        s.store_name,
                        CAST(s.c_date as DATE) as c_date,
                        SUM(CAST(s.sub_total as FLOAT) - CAST(ISNULL(s.pro_disc_amt, 0) as FLOAT) - CAST(ISNULL(s.disc_amt, 0) as FLOAT) + CAST(ISNULL(s.svc_amt, 0) as FLOAT) - CASE WHEN s.take_away_item = 'Y' THEN CAST(ISNULL(s.tax_amt, 0) as FLOAT) ELSE 0 END) as receipt_total
                    FROM pos_sales_dtls s WITH (NOLOCK)
                    WHERE s.item_name != 'WASTAGE'
                    AND CAST(s.c_date as DATE) >= '{date_from}' AND CAST(s.c_date as DATE) <= '{date_to}'
                    {store_filter}
                    GROUP BY s.sales_no, s.store_name, CAST(s.c_date as DATE)
                )
                SELECT 
                    pr.item_name,
                    COUNT(DISTINCT pr.sales_no) as 單據數量,
                    SUM(rt.receipt_total) as 產品單據業績,
                    AVG(rt.receipt_total) as 平均單據金額
                FROM ProductReceipts pr
                INNER JOIN ReceiptTotals rt ON pr.sales_no = rt.sales_no AND pr.store_name = rt.store_name AND pr.c_date = rt.c_date
                GROUP BY pr.item_name
                ORDER BY pr.item_name
            """
            
            cursor.execute(query)
            rows = cursor.fetchall()
            
            # 轉換為字典格式，使用產品名稱作為鍵
            result = {}
            for row in rows:
                product_name = row[0]
                
                result[product_name] = {
                    '单据数量': int(row[1]),
                    '产品单据业绩': float(row[2]),
                    '平均单据金额': float(row[3])
                }
            
            return result
            
        except Exception as e:
            print(f"❌ 從SQL Server獲取期間產品單據業績失敗: {e}")
            return {}

    def get_product_receipt_performance_from_db(self, date_from=None, date_to=None, outlet_filters=None, product_filters=None, database_source=None):
        """從SQL Server獲取指定日期範圍的產品單據業績 - 優化版本，按日期和門市分組"""
        try:
            if not self.connection:
                print("❌ 數據庫連接不存在")
                return {}
            
            cursor = self.connection.cursor()
            
            # 構建門市篩選條件
            store_filter = ""
            if outlet_filters and len(outlet_filters) > 0:
                store_list = "', '".join(outlet_filters)
                store_filter = f"AND s.store_name IN ('{store_list}')"
            
            # 構建產品篩選條件
            product_filter_clause = ""
            if product_filters:
                product_list = "', '".join(product_filters)
                product_filter_clause = f"AND s.item_name IN ('{product_list}')"
            
            # 優化查詢：按日期、門市、產品分組返回詳細數據
            query = f"""
                WITH ProductReceipts AS (
                    -- 找出包含指定產品的所有單據
                    SELECT DISTINCT 
                        s.item_name,
                        s.sales_no,
                        s.store_name,
                        CAST(s.c_date as DATE) as c_date
                    FROM pos_sales_dtls s WITH (NOLOCK)
                    WHERE s.item_name != 'WASTAGE'
                    AND CAST(s.c_date as DATE) >= '{date_from}' AND CAST(s.c_date as DATE) <= '{date_to}'
                    {store_filter}
                    {product_filter_clause}
                ),
                ReceiptTotals AS (
                    -- 計算每張單據的總金額
                    SELECT 
                        s.sales_no,
                        s.store_name,
                        CAST(s.c_date as DATE) as c_date,
                        SUM(CAST(s.sub_total as FLOAT) - CAST(ISNULL(s.pro_disc_amt, 0) as FLOAT) - CAST(ISNULL(s.disc_amt, 0) as FLOAT) + CAST(ISNULL(s.svc_amt, 0) as FLOAT) - CASE WHEN s.take_away_item = 'Y' THEN CAST(ISNULL(s.tax_amt, 0) as FLOAT) ELSE 0 END) as receipt_total
                    FROM pos_sales_dtls s WITH (NOLOCK)
                    WHERE s.item_name != 'WASTAGE'
                    AND CAST(s.c_date as DATE) >= '{date_from}' AND CAST(s.c_date as DATE) <= '{date_to}'
                    {store_filter}
                    GROUP BY s.sales_no, s.store_name, CAST(s.c_date as DATE)
                )
                SELECT 
                    pr.item_name,
                    pr.c_date,
                    pr.store_name,
                    COUNT(DISTINCT pr.sales_no) as 單據數量,
                    SUM(rt.receipt_total) as 產品單據業績,
                    AVG(rt.receipt_total) as 平均單據金額
                FROM ProductReceipts pr
                INNER JOIN ReceiptTotals rt ON pr.sales_no = rt.sales_no AND pr.store_name = rt.store_name AND pr.c_date = rt.c_date
                GROUP BY pr.item_name, pr.c_date, pr.store_name
                ORDER BY pr.c_date DESC, pr.store_name, pr.item_name
            """
            
            cursor.execute(query)
            rows = cursor.fetchall()
            
            # 轉換為字典格式，使用組合鍵 (product_name, date, store_name)
            result = {}
            for row in rows:
                product_name = row[0]
                date = row[1]
                store_name = row[2]
                key = f"{product_name}_{date}_{store_name}"
                
                result[key] = {
                    '单据数量': int(row[3]),
                    '产品单据业绩': float(row[4]),
                    '平均单据金额': float(row[5])
                }
            
            return result
            
        except Exception as e:
            print(f"❌ 從SQL Server獲取產品單據業績失敗: {e}")
            return {}
    
    def get_local_sales_analysis(self, date_from=None, date_to=None, outlet_filters=None, product_filters=None, 
                                month_filters=None, weekday_filters=None, category_filters=None, payment_filters=None):
        """從本地數據庫獲取銷售分析數據"""
        try:
            # 檢查壓縮數據庫是否存在，如果存在則先解壓縮
            compressed_path = "receipt_database_compressed.db"
            if os.path.exists(compressed_path) and not os.path.exists(self.receipt_db_path):
                print("📦 發現壓縮數據庫，正在解壓縮...")
                from receipt_database_manager import ReceiptDatabaseManager
                manager = ReceiptDatabaseManager()
                if not manager.decompress_database():
                    print("❌ 解壓縮失敗，使用壓縮數據庫")
                    return []
            
            if not os.path.exists(self.receipt_db_path):
                print(f"❌ 本地數據庫不存在: {self.receipt_db_path}")
                return []
            
            conn = sqlite3.connect(self.receipt_db_path)
            
            # 構建查詢條件
            where_conditions = []
            params = []
            
            # 日期篩選
            if date_from and date_to:
                where_conditions.append("DATE(日期) >= ? AND DATE(日期) <= ?")
                params.extend([date_from, date_to])
            
            # 門市篩選
            if outlet_filters:
                placeholders = ','.join(['?' for _ in outlet_filters])
                where_conditions.append(f"門市 IN ({placeholders})")
                params.extend(outlet_filters)
            
            # 產品篩選（需要檢查產品列表）
            if product_filters:
                product_conditions = []
                for product in product_filters:
                    product_conditions.append("產品列表 LIKE ?")
                    params.append(f"%{product}%")
                where_conditions.append("(" + " OR ".join(product_conditions) + ")")
            
            # 支付方式篩選
            if payment_filters:
                payment_conditions = []
                for payment in payment_filters:
                    payment_conditions.append("支付方式列表 LIKE ?")
                    params.append(f"%{payment}%")
                where_conditions.append("(" + " OR ".join(payment_conditions) + ")")
            
            where_clause = ""
            if where_conditions:
                where_clause = "WHERE " + " AND ".join(where_conditions)
            
            # 查詢銷售分析數據
            query = f"""
                SELECT 
                    DATE(日期) as 日期,
                    門市,
                    COUNT(*) as 單據數,
                    SUM(淨金額) as 總業績,
                    SUM(總數量) as 總數量,
                    SUM(產品數量) as 總產品數量,
                    SUM(總支付金額) as 總支付金額,
                    SUM(總取消金額) as 總取消金額
                FROM receipt_details
                {where_clause}
                GROUP BY DATE(日期), 門市
                ORDER BY 日期, 門市
            """
            
            df = pd.read_sql_query(query, conn, params=params)
            conn.close()
            
            # 轉換為字典格式
            result = []
            for _, row in df.iterrows():
                result.append({
                    '日期': row['日期'],
                    '門市': row['門市'],
                    '單據數': int(row['單據數']),
                    '總業績': float(row['總業績']),
                    '總數量': float(row['總數量']),
                    '總產品數量': int(row['總產品數量']),
                    '總支付金額': float(row['總支付金額']),
                    '總取消金額': float(row['總取消金額'])
                })
            
            return result
            
        except Exception as e:
            print(f"❌ 從本地數據庫獲取銷售分析數據失敗: {e}")
            return []
    
    def get_local_payment_analysis(self, date_from=None, date_to=None, outlet_filters=None, payment_filters=None):
        """從本地數據庫獲取支付分析數據"""
        try:
            # 檢查壓縮數據庫是否存在，如果存在則先解壓縮
            compressed_path = "receipt_database_compressed.db"
            if os.path.exists(compressed_path) and not os.path.exists(self.receipt_db_path):
                print("📦 發現壓縮數據庫，正在解壓縮...")
                from receipt_database_manager import ReceiptDatabaseManager
                manager = ReceiptDatabaseManager()
                if not manager.decompress_database():
                    print("❌ 解壓縮失敗，使用壓縮數據庫")
                    return []
            
            if not os.path.exists(self.receipt_db_path):
                print(f"❌ 本地數據庫不存在: {self.receipt_db_path}")
                return []
            
            conn = sqlite3.connect(self.receipt_db_path)
            
            # 構建查詢條件
            where_conditions = []
            params = []
            
            # 日期篩選
            if date_from and date_to:
                where_conditions.append("DATE(日期) >= ? AND DATE(日期) <= ?")
                params.extend([date_from, date_to])
            
            # 門市篩選
            if outlet_filters:
                placeholders = ','.join(['?' for _ in outlet_filters])
                where_conditions.append(f"門市 IN ({placeholders})")
                params.extend(outlet_filters)
            
            where_clause = ""
            if where_conditions:
                where_clause = "WHERE " + " AND ".join(where_conditions)
            
            # 查詢支付分析數據（從匯總表）
            query = f"""
                SELECT 
                    支付方式,
                    數據庫來源,
                    支付次數,
                    總支付金額,
                    平均支付金額
                FROM payment_summary
                ORDER BY 總支付金額 DESC
            """
            
            df = pd.read_sql_query(query, conn, params=params)
            conn.close()
            
            # 轉換為字典格式
            result = []
            for _, row in df.iterrows():
                result.append({
                    '支付方式': row['支付方式'],
                    '數據庫來源': row['數據庫來源'],
                    '支付次數': int(row['支付次數']),
                    '總支付金額': float(row['總支付金額']),
                    '平均支付金額': float(row['平均支付金額'])
                })
            
            return result
            
        except Exception as e:
            print(f"❌ 從本地數據庫獲取支付分析數據失敗: {e}")
            return []
    
    def get_categories_by_payment(self, payment_filters):
        """根据支付方式获取类别列表"""
        if not self.connection or not payment_filters:
            return []
        
        try:
            cursor = self.connection.cursor()
            
            # 构建支付方式条件
            payment_conditions = " OR ".join([f"p.payment_name = '{payment}'" for payment in payment_filters])
            
            query = f"""
                SELECT DISTINCT im.category_code
                FROM {TABLE_SALES} s
                INNER JOIN {TABLE_PAYMENT} p ON s.sales_no = p.sales_no
                INNER JOIN item_master im ON s.item_name = im.item_name
                WHERE ({payment_conditions})
                ORDER BY im.category_code
            """
            
            try:
                cursor.execute(query)
                results = cursor.fetchall()
            except Exception as query_error:
                print(f"查询执行失败: {query_error}")
                print(f"查询语句: {query[:200]}...")
                cursor.close()
                return []
            finally:
                cursor.close()
            
            return [row[0] for row in results if row[0]]
        except Exception as e:
            print(f"获取类别失败: {e}")
            return []
    
    def get_products_by_filters(self, outlet_filters, month_filters, payment_filters):
        """根据筛选条件获取产品列表"""
        if not self.connection:
            return []
        
        try:
            cursor = self.connection.cursor()
            
            # 构建WHERE条件
            conditions = []
            if outlet_filters and len(outlet_filters) > 0:
                outlet_conditions = " OR ".join([f"s.store_name = '{outlet}'" for outlet in outlet_filters])
                conditions.append(f"({outlet_conditions})")
            if month_filters and len(month_filters) > 0:
                month_conditions = " OR ".join([f"FORMAT(CAST(s.c_date AS DATE), 'yyyy-MM') = '{month}'" for month in month_filters])
                conditions.append(f"({month_conditions})")
            if payment_filters and len(payment_filters) > 0:
                payment_conditions = " OR ".join([f"p.payment_name = '{payment}'" for payment in payment_filters])
                conditions.append(f"({payment_conditions})")
            
            where_clause = ""
            if conditions:
                where_clause = "WHERE " + " AND ".join(conditions)
            
            join_clause = ""
            if payment_filters and len(payment_filters) > 0:
                join_clause = f"INNER JOIN {TABLE_PAYMENT} p ON s.sales_no = p.sales_no"
            
            query = f"""
                SELECT DISTINCT s.item_name
                FROM {TABLE_SALES} s
                {join_clause}
                {where_clause}
                ORDER BY s.item_name
            """
            
            try:
                cursor.execute(query)
                results = cursor.fetchall()
            except Exception as query_error:
                print(f"查询执行失败: {query_error}")
                print(f"查询语句: {query[:200]}...")
                cursor.close()
                return []
            finally:
                cursor.close()
            
            return [row[0] for row in results if row[0]]
        except Exception as e:
            print(f"获取产品失败: {e}")
            return []
    
    def search_products(self, search_term, outlet_filters, month_filters, payment_filters, category_filters):
        """搜索产品"""
        if not self.connection:
            return []
        
        try:
            cursor = self.connection.cursor()
            
            # 构建WHERE条件
            conditions = [f"s.item_name LIKE '%{search_term}%'"]
            
            if outlet_filters and len(outlet_filters) > 0:
                outlet_conditions = " OR ".join([f"s.store_name = '{outlet}'" for outlet in outlet_filters])
                conditions.append(f"({outlet_conditions})")
            if month_filters and len(month_filters) > 0:
                month_conditions = " OR ".join([f"FORMAT(CAST(s.c_date AS DATE), 'yyyy-MM') = '{month}'" for month in month_filters])
                conditions.append(f"({month_conditions})")
            if payment_filters and len(payment_filters) > 0:
                payment_conditions = " OR ".join([f"p.payment_name = '{payment}'" for payment in payment_filters])
                conditions.append(f"({payment_conditions})")
            if category_filters and len(category_filters) > 0:
                category_conditions = " OR ".join([f"im.category_code = '{category}'" for category in category_filters])
                conditions.append(f"({category_conditions})")
            
            where_clause = "WHERE " + " AND ".join(conditions)
            
            join_clause = ""
            if payment_filters and len(payment_filters) > 0:
                join_clause += f"INNER JOIN {TABLE_PAYMENT} p ON s.sales_no = p.sales_no"
            if category_filters and len(category_filters) > 0:
                join_clause += f" INNER JOIN item_master im ON s.item_name = im.item_name"
            
            query = f"""
                SELECT DISTINCT s.item_name
                FROM {TABLE_SALES} s
                {join_clause}
                {where_clause}
                ORDER BY s.item_name
            """
            
            try:
                cursor.execute(query)
                results = cursor.fetchall()
            except Exception as query_error:
                print(f"查询执行失败: {query_error}")
                print(f"查询语句: {query[:200]}...")
                cursor.close()
                return []
            finally:
                cursor.close()
            
            return [row[0] for row in results if row[0]]
        except Exception as e:
            print(f"搜索产品失败: {e}")
            return []
    
    def get_outlets(self):
        """获取门市列表 - 支持合併模式"""
        if not self.connection:
            return []

        # 如果是合併模式，执行合併查询
        if self.combined_mode:
            return self.get_combined_outlets()

        try:
            cursor = self.connection.cursor()
            cursor.execute("SELECT DISTINCT store_name FROM pos_sales_dtls ORDER BY store_name")
            results = cursor.fetchall()
            self.outlets = [row[0] for row in results if row[0]]
            cursor.close()
            return self.outlets
        except Exception as e:
            print(f"获取门市列表失败: {e}")
            return []
    
    def get_products(self):
        """获取产品列表"""
        if not self.connection:
            return []
        
        try:
            cursor = self.connection.cursor()
            cursor.execute("SELECT DISTINCT item_name FROM pos_sales_dtls WHERE item_name IS NOT NULL ORDER BY item_name")
            results = cursor.fetchall()
            self.products = [row[0] for row in results if row[0]]
            cursor.close()
            return self.products
        except Exception as e:
            print(f"获取产品列表失败: {e}")
            return []
    
    def get_payment_names(self):
        """获取支付方式列表"""
        if not self.connection:
            return []
        
        try:
            cursor = self.connection.cursor()
            cursor.execute("SELECT DISTINCT payment_name FROM pos_sales_payment_dtls WHERE payment_name IS NOT NULL ORDER BY payment_name")
            results = cursor.fetchall()
            self.payment_names = [row[0] for row in results if row[0]]
            cursor.close()
            return self.payment_names
        except Exception as e:
            print(f"获取支付方式列表失败: {e}")
            return []
    
    def get_months(self):
        """获取月份列表"""
        if not self.connection:
            return []
        
        try:
            cursor = self.connection.cursor()
            cursor.execute("SELECT DISTINCT FORMAT(c_date, 'yyyy-MM') as month FROM pos_sales_dtls ORDER BY month DESC")
            results = cursor.fetchall()
            months = [row[0] for row in results if row[0]]
            cursor.close()
            return months
        except Exception as e:
            print(f"获取月份列表失败: {e}")
            return []
    
    def get_categories(self):
        """获取类别列表"""
        if not self.connection:
            return []
        
        try:
            cursor = self.connection.cursor()
            # 获取最新的category_code，按m_date排序
            cursor.execute("""
                SELECT DISTINCT im.category_code 
                FROM item_master im
                INNER JOIN (
                    SELECT item_name, MAX(m_date) as max_date
                    FROM item_master
                    GROUP BY item_name
                ) latest ON im.item_name = latest.item_name AND im.m_date = latest.max_date
                WHERE im.category_code IS NOT NULL
                ORDER BY im.category_code
            """)
            results = cursor.fetchall()
            categories = [row[0] for row in results if row[0]]
            cursor.close()
            return categories
        except Exception as e:
            print(f"获取类别列表失败: {e}")
            return []
    
    def get_sales_data(self, date_from=None, date_to=None, outlet_filters=None, product_filters=None, search_term=None, month_filters=None, weekday_filters=None, category_filters=None, payment_filters=None, use_excel_cache=True):
        """获取销售数据 - 优化版本，支持合併模式"""
        print(f"🔍 开始获取销售数据:")
        print(f"   - 日期范围: {date_from} 到 {date_to}")
        print(f"   - 门店筛选: {outlet_filters}")
        print(f"   - 产品筛选: {product_filters}")
        print(f"   - 月份筛选: {month_filters}")
        print(f"   - 星期筛选: {weekday_filters}")
        print(f"   - 类别筛选: {category_filters}")
        print(f"   - 支付方式筛选: {payment_filters}")
        print(f"   - 使用Excel缓存: {use_excel_cache}")
        print(f"   - 合併模式: {self.combined_mode}")
        
        # 如果是合併模式，执行合併查询
        if self.combined_mode:
            return self.get_combined_sales_data(date_from, date_to, outlet_filters, product_filters, search_term, month_filters, weekday_filters, category_filters, payment_filters)
        
        # 检查Excel缓存（优先级：月度文件 > 单日压缩文件 > Excel文件）
        if use_excel_cache and date_from and date_to:
            from datetime import datetime
            
            # 解析日期，获取月份
            current_date = datetime.strptime(date_from, '%Y-%m-%d')
            month_str = current_date.strftime('%Y-%m')
            
            # 1. 优先检查已导出的数据文件
            # 确定当前数据库 - 强制使用数据库管理器连接的实际数据库
            if hasattr(self, 'current_database') and self.current_database:
                current_db = self.current_database
            else:
                current_db = 'GOGO'
                print("⚠️ 无法确定当前数据库，默认使用GOGO。请确保数据库连接正确。")
            
            # 将完整数据库名称转换为简化名称（用于文件查找）
            db_name_mapping = {
                'sushi_gogo_pos_live': 'GOGO',
                'sushi_express_pos_live': 'Express', 
                'sushi_plus_pos_live': 'PLUS'
            }
            simplified_db_name = db_name_mapping.get(current_db, current_db)
            
            export_dir = "new_staged_export_specific_data"
            
            # 支持活动分析的日期范围 -- 增加跨月检查
            start_date = datetime.strptime(date_from, '%Y-%m-%d')
            end_date = datetime.strptime(date_to, '%Y-%m-%d')
            
            current_check_date = start_date
            all_stored_data = []
            
            while current_check_date <= end_date:
                # 检查是否有对应月份的导出文件（支持两种命名格式）
                month_str = current_check_date.strftime('%Y-%m')
                month_str_dash = month_str  # 2025-09
                month_str_underscore = month_str.replace('-', '_')  # 2025_09
                
                exported_monthly_file_dash = f"{export_dir}/{simplified_db_name}_sales_raw_{month_str_dash}.pkl.gz"
                exported_monthly_file_underscore = f"{export_dir}/{simplified_db_name}_sales_raw_{month_str_underscore}.pkl.gz"
                
                # 优先使用连字符格式（与您的导出文件匹配）
                exported_monthly_file = exported_monthly_file_dash if os.path.exists(exported_monthly_file_dash) else exported_monthly_file_underscore
                
                if os.path.exists(exported_monthly_file):
                    print(f"📁 从已导出月度文件读取数据: {exported_monthly_file}")
                    try:
                        import gzip
                        import pickle
                        with gzip.open(exported_monthly_file, 'rb') as f:
                            monthly_data = pickle.load(f)
                        
                        all_stored_data.extend(monthly_data)
                    except Exception as e:
                        print(f"✗ 已导出月度文件读取失败: {e}, 月份:{month_str}")
                # 移动到下一个月份
                if current_check_date.month == 12:
                    current_check_date = datetime(current_check_date.year + 1, 1, 1)
                else:
                    current_check_date = datetime(current_check_date.year, current_check_date.month + 1, 1)
            
            # 有缓存数据则筛选期间
            if all_stored_data:
                sales_data = []
                for record in all_stored_data:
                    record_date = record.get('c_date', '')
                    record_date_str = None
                    
                    if isinstance(record_date, str):
                        try:
                            if 'T' in record_date:
                                record_date_dt = datetime.fromisoformat(record_date.replace('Z', '+00:00'))
                                record_date_str = record_date_dt.strftime('%Y-%m-%d')
                            else:
                                record_date_str = record_date.split()[0]  # 只取日期部分
                        except:
                            record_date_str = record_date.split()[0]
                    elif hasattr(record_date, 'date'):
                        record_date_str = str(record_date.date())
                    elif isinstance(record_date, datetime):
                        record_date_str = record_date.strftime('%Y-%m-%d')
                    
                    if record_date_str and date_from <= record_date_str <= date_to:
                        sales_data.append(record)
                
                if sales_data:
                    # 应用星期筛选
                    if weekday_filters and len(weekday_filters) > 0:
                        weekday_mapping = {
                            'Sunday': 0, 'Monday': 1, 'Tuesday': 2, 'Wednesday': 3, 
                            'Thursday': 4, 'Friday': 5, 'Saturday': 6
                        }
                        filtered_sales_data = []
                        for record in sales_data:
                            record_date = record.get('c_date', '')
                            if isinstance(record_date, str):
                                try:
                                    if 'T' in record_date:
                                        record_date_dt = datetime.fromisoformat(record_date.replace('Z', '+00:00'))
                                    else:
                                        record_date_dt = datetime.strptime(record_date.split()[0], '%Y-%m-%d')
                                except:
                                    continue
                            elif hasattr(record_date, 'date'):
                                record_date_dt = datetime.combine(record_date.date(), datetime.min.time())
                            elif isinstance(record_date, datetime):
                                record_date_dt = record_date
                            else:
                                continue
                            
                            weekday_name = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'][record_date_dt.weekday()]
                            if weekday_name in weekday_filters:
                                filtered_sales_data.append(record)
                        
                        sales_data = filtered_sales_data
                        print(f"✓ 应用星期筛选后，共 {len(sales_data)} 条记录")
                    
                    # 应用支付方式筛选 - 严格匹配，与期间-产品数据保持一致
                    if payment_filters and len(payment_filters) > 0:
                        filtered_sales_data = []
                        for record in sales_data:
                            payment_methods_str = record.get('payment_methods', '')
                            # 检查是否所有支付方式都在筛选列表中
                            payment_methods_list = [pm.strip() for pm in payment_methods_str.split(',') if pm.strip()]
                            if all(pm.upper() in [p.upper() for p in payment_filters] for pm in payment_methods_list):
                                filtered_sales_data.append(record)
                        sales_data = filtered_sales_data
                        print(f"✓ 应用支付方式筛选后，共 {len(sales_data)} 条记录")
                    
                    print(f"✓ 从按月导出的缓存文件读取并筛选出期间数据，共 {len(sales_data)} 条记录")
                    return sales_data
                else:
                    print(f"⚠️ 未在已导出月度文件中找到 {date_from} 到 {date_to} 期间的数据")
            else:
                print(f"⚠️ 未找到匹配月份的导出月度文件，将查询数据库")
            
            # 2. 尝试本地月度文件
            monthly_file = f"cache/monthly_sales_{month_str.replace('-', '_')}.pkl.gz"
            if os.path.exists(monthly_file):
                print(f"📁 从月度缓存读取数据: {monthly_file}")
                try:
                    import gzip
                    import pickle
                    with gzip.open(monthly_file, 'rb') as f:
                        monthly_data = pickle.load(f)
                    
                    # 从月度数据中筛选指定日期的数据
                    sales_data = []
                    for record in monthly_data:
                        record_date = record.get('c_date', '')
                        if isinstance(record_date, str) and record_date.startswith(date_from):
                            sales_data.append(record)
                        elif hasattr(record_date, 'date') and str(record_date.date()) == date_from:
                            sales_data.append(record)
                    
                    print(f"✓ 从月度文件读取成功，筛选出 {len(sales_data)} 条记录")
                    return sales_data
                except Exception as e:
                    print(f"✗ 月度文件读取失败: {e}，尝试单日文件")
            
            # 3. 尝试已导出的单日文件（支持两种命名格式）
            date_str_dash = date_from  # 2025-09-09
            date_str_underscore = date_from.replace('-', '_')  # 2025_09_09
            
            exported_daily_file_dash = f"{export_dir}/{simplified_db_name}_sales_raw_{date_str_dash}.pkl.gz"
            exported_daily_file_underscore = f"{export_dir}/{simplified_db_name}_sales_raw_{date_str_underscore}.pkl.gz"
            
            # 优先使用连字符格式
            exported_daily_file = exported_daily_file_dash if os.path.exists(exported_daily_file_dash) else exported_daily_file_underscore
            if os.path.exists(exported_daily_file):
                print(f"📁 从已导出单日文件读取数据: {exported_daily_file}")
                try:
                    import gzip
                    import pickle
                    with gzip.open(exported_daily_file, 'rb') as f:
                        sales_data = pickle.load(f)
                    print(f"✓ 从已导出单日文件读取成功，共 {len(sales_data)} 条记录")
                    return sales_data
                except Exception as e:
                    print(f"✗ 已导出单日文件读取失败: {e}，尝试本地缓存文件")
            
            # 4. 尝试本地单日压缩文件
            compressed_file = f"cache/sales_{date_from.replace('-', '_')}.pkl.gz"
            print(f"🔍 检查本地缓存文件: {compressed_file}")
            print(f"🔍 文件是否存在: {os.path.exists(compressed_file)}")
            
            if os.path.exists(compressed_file):
                file_size = os.path.getsize(compressed_file)
                print(f"📁 从本地单日压缩缓存读取数据: {compressed_file} (大小: {file_size} 字节)")
                try:
                    import gzip
                    import pickle
                    with gzip.open(compressed_file, 'rb') as f:
                        sales_data = pickle.load(f)
                    print(f"✓ 从本地单日压缩文件读取成功，共 {len(sales_data)} 条记录")
                    return sales_data
                except Exception as e:
                    print(f"✗ 本地单日压缩文件读取失败: {e}，尝试Excel文件")
                    print(f"✗ 错误详情: {str(e)}")
            else:
                print(f"✗ 本地缓存文件不存在: {compressed_file}")
            
            # 5. 尝试已导出的Excel文件（支持两种命名格式）
            date_str_dash = date_from  # 2025-09-09
            date_str_underscore = date_from.replace('-', '_')  # 2025_09_09
            
            exported_excel_file_dash = f"{export_dir}/{simplified_db_name}_sales_raw_{date_str_dash}.xlsx"
            exported_excel_file_underscore = f"{export_dir}/{simplified_db_name}_sales_raw_{date_str_underscore}.xlsx"
            
            # 优先使用连字符格式
            exported_excel_file = exported_excel_file_dash if os.path.exists(exported_excel_file_dash) else exported_excel_file_underscore
            if os.path.exists(exported_excel_file):
                print(f"📁 从已导出Excel文件读取数据: {exported_excel_file}")
                try:
                    import pandas as pd
                    df = pd.read_excel(exported_excel_file)
                    sales_data = df.to_dict('records')
                    print(f"✓ 从已导出Excel读取成功，共 {len(sales_data)} 条记录")
                    return sales_data
                except Exception as e:
                    print(f"✗ 已导出Excel读取失败: {e}，尝试本地Excel文件")
            
            # 6. 备用本地Excel文件
            excel_file = f"cache/sales_{date_from.replace('-', '_')}.xlsx"
            if os.path.exists(excel_file):
                print(f"📁 从本地Excel缓存读取数据: {excel_file}")
                try:
                    import pandas as pd
                    df = pd.read_excel(excel_file)
                    sales_data = df.to_dict('records')
                    print(f"✓ 从本地Excel读取成功，共 {len(sales_data)} 条记录")
                    return sales_data
                except Exception as e:
                    print(f"✗ 本地Excel读取失败: {e}，将从数据库查询")
        
        if not self.connection:
            print("✗ 数据库连接不存在")
            return []
        
        # 生成缓存键
        cache_key = f"{self.current_database}_{date_from}_{date_to}_{outlet_filters}_{product_filters}_{month_filters}_{weekday_filters}_{category_filters}_{payment_filters}"
        
        # 检查缓存
        if hasattr(self, '_sales_cache') and cache_key in self._sales_cache:
            print("✓ 使用缓存的销售数据")
            return self._sales_cache[cache_key]
        
        try:
            cursor = self.connection.cursor()
            
            # 构建WHERE条件
            conditions = []
            
            if date_from:
                conditions.append(f"CAST(s.c_date AS DATE) >= '{date_from}'")
            if date_to:
                conditions.append(f"CAST(s.c_date AS DATE) <= '{date_to}'")
            if outlet_filters and len(outlet_filters) > 0:
                outlet_conditions = " OR ".join([f"s.store_name = '{outlet}'" for outlet in outlet_filters])
                conditions.append(f"({outlet_conditions})")
            if product_filters and len(product_filters) > 0:
                product_conditions = " OR ".join([f"s.item_name = '{product}'" for product in product_filters])
                conditions.append(f"({product_conditions})")
            if month_filters and len(month_filters) > 0:
                month_conditions = " OR ".join([f"FORMAT(CAST(s.c_date AS DATE), 'yyyy-MM') = '{month}'" for month in month_filters])
                conditions.append(f"({month_conditions})")
            if weekday_filters and len(weekday_filters) > 0:
                print(f"应用星期筛选: {weekday_filters}")
                # 使用DATEPART来获取星期几，1=Sunday, 2=Monday, ..., 7=Saturday
                weekday_mapping = {
                    'Sunday': 1, 'Monday': 2, 'Tuesday': 3, 'Wednesday': 4, 
                    'Thursday': 5, 'Friday': 6, 'Saturday': 7
                }
                weekday_values = [str(weekday_mapping.get(weekday, 0)) for weekday in weekday_filters if weekday_mapping.get(weekday, 0) > 0]
                if weekday_values:
                    weekday_conditions = " OR ".join([f"DATEPART(WEEKDAY, s.c_date) = {value}" for value in weekday_values])
                    conditions.append(f"({weekday_conditions})")
                    print(f"星期筛选SQL条件: {weekday_conditions}")
            if search_term:
                conditions.append(f"(s.item_name LIKE '%{search_term}%' OR s.store_name LIKE '%{search_term}%' OR s.sales_no LIKE '%{search_term}%')")
            
            # 排除WASTAGE及其变体 - 优化版本，使用NOT IN代替多个LIKE
            conditions.append("s.item_name NOT IN ('WASTAGE', 'Waste', 'waste', 'WASTE')")
            
            # 简化类别信息获取 - 暂时禁用JOIN来测试基本查询
            join_clause = ""
            # 暂时注释掉JOIN，先确保基本查询工作
            # if category_filters and len(category_filters) > 0:
            #     # 有类别筛选时使用INNER JOIN
            #     join_clause = f"""
            #         INNER JOIN (
            #             SELECT DISTINCT item_name, category_code
            #             FROM item_master WITH (NOLOCK)
            #             WHERE category_code IN ({','.join([f"'{cat}'" for cat in category_filters])})
            #         ) im ON s.item_name = im.item_name
            #     """
            # else:
            #     # 没有类别筛选时使用LEFT JOIN获取所有类别
            #     join_clause = f"""
            #         LEFT JOIN (
            #             SELECT DISTINCT item_name, category_code
            #             FROM item_master WITH (NOLOCK)
            #         ) im ON s.item_name = im.item_name
            #     """
            
            # 支付方式筛选逻辑
            # 如果payment_filters为None，表示未选择任何支付方式，不应用筛选
            # 如果payment_filters为空列表[]，表示选择了全部支付方式，不应用筛选
            # 如果payment_filters有值，表示选择了特定支付方式，应用筛选
            if payment_filters is not None and len(payment_filters) > 0:
                # 优化支付方式筛选 - 使用IN代替EXISTS
                payment_conditions = ",".join([f"'{method}'" for method in payment_filters])
                conditions.append(f"EXISTS (SELECT 1 FROM {TABLE_PAYMENT} p WITH (NOLOCK) WHERE s.sales_no = p.sales_no AND s.store_name = p.store_name AND p.payment_name IN ({payment_conditions}))")
            
            where_clause = ""
            if conditions:
                where_clause = " WHERE " + " AND ".join(conditions)
            
            # 查询销售数据 - 高性能优化版本
            query = f"""
                SELECT
                    s.store_name,
                    s.sales_no,
                    s.item_name,
                    s.qty,
                    s.disc_amt,
                    s.disc_name,
                    s.pro_disc_amt,
                    s.sub_total,
                    s.svc_amt,
                    s.tax_amt,
                    s.c_date,
                    s.order_datetime,
                    {self.get_performance_calculation_sql()} as total_amt,
                    COALESCE(im.category_code, '未分类') as category_code
                FROM {TABLE_SALES} s WITH (NOLOCK)
                LEFT JOIN item_master im WITH (NOLOCK) ON s.item_name = im.item_name
                {where_clause}
                ORDER BY s.c_date DESC, s.store_name, s.sales_no
                OPTION (RECOMPILE, MAXDOP 4)
            """
            
            # 添加调试信息
            print(f"🔍 SQL查询调试信息:")
            print(f"   - 表名: {TABLE_SALES}")
            print(f"   - WHERE子句: {where_clause}")
            print(f"   - JOIN子句: LEFT JOIN item_master im WITH (NOLOCK) ON s.item_name = im.item_name")
            print(f"   - 查询前100个字符: {query[:100]}...")
            
            # 测试item_master表
            try:
                test_cursor = self.connection.cursor()
                test_cursor.execute("SELECT TOP 3 item_name, category_code FROM item_master WHERE category_code IS NOT NULL")
                test_results = test_cursor.fetchall()
                print(f"🔍 item_master测试查询结果: {len(test_results)} 条记录")
                for row in test_results:
                    print(f"   - {row[0]} -> {row[1]}")
                test_cursor.close()
            except Exception as e:
                print(f"🔍 item_master测试查询失败: {e}")
                
            # 如果item_master没有category_code，尝试其他字段
            try:
                test_cursor2 = self.connection.cursor()
                test_cursor2.execute("SELECT TOP 1 * FROM item_master")
                test_result2 = test_cursor2.fetchone()
                if test_result2:
                    columns = [desc[0] for desc in test_cursor2.description]
                    print(f"🔍 item_master表字段: {columns}")
                test_cursor2.close()
            except Exception as e:
                print(f"🔍 item_master表结构查询失败: {e}")
            
            # 执行查询并添加性能监控
            import time
            start_time = time.time()
            
            try:
                cursor.execute(query)
                results = cursor.fetchall()
            except Exception as query_error:
                print(f"查询执行失败: {query_error}")
                print(f"查询语句: {query[:200]}...")
                cursor.close()
                return []
            finally:
                cursor.close()
            
            end_time = time.time()
            query_time = end_time - start_time
            
            # 添加提示信息
            print(f"✓ 获取销售数据成功，共 {len(results)} 条记录，耗时: {query_time:.2f} 秒")
            
            # 获取支付方式信息
            payment_info = {}
            if results:
                try:
                    payment_cursor = self.connection.cursor()
                    # 获取所有销售记录的支付方式信息
                    sales_keys = [(row[0], row[1]) for row in results]  # (store_name, sales_no)
                    if sales_keys:
                        # 构建IN子句
                        placeholders = ','.join(['(?, ?)' for _ in sales_keys])
                        payment_query = f"""
                            SELECT store_name, sales_no, payment_name
                            FROM {TABLE_PAYMENT}
                            WHERE (store_name, sales_no) IN ({placeholders})
                        """
                        payment_params = []
                        for store_name, sales_no in sales_keys:
                            payment_params.extend([store_name, sales_no])
                        
                        payment_cursor.execute(payment_query, payment_params)
                        payment_results = payment_cursor.fetchall()
                        
                        # 构建支付方式映射
                        for payment_row in payment_results:
                            store_name, sales_no, payment_name = payment_row
                            key = f"{store_name}-{sales_no}"
                            if key not in payment_info:
                                payment_info[key] = []
                            payment_info[key].append(payment_name)
                    
                    payment_cursor.close()
                except Exception as e:
                    print(f"获取支付方式信息失败: {e}")
                    payment_info = {}
            
            # 验证查询结果
            if not results:
                print("查询返回空结果")
                return []
            
            print(f"查询成功，返回 {len(results)} 条记录")
            
            # 转换数据
            sales_data = []
            for i, row in enumerate(results):
                sub_total = float(row[7]) if row[7] else 0.0
                pro_disc_amt = float(row[6]) if row[6] else 0.0
                svc_amt = float(row[8]) if row[8] else 0.0
                tax_amt = float(row[9]) if row[9] else 0.0
                # 根据数据库类型计算业绩
                if self.current_database == "sushi_gogo_pos_live":
                    # GOGO数据库：所有单据都直接减去tax_amt
                    total_amt = sub_total - pro_disc_amt + svc_amt - tax_amt
                else:
                    # Express数据库：只有外带商品才减去tax_amt
                    take_away_item = str(row[4]) if row[4] else 'N'
                    if take_away_item == 'Y':
                        total_amt = sub_total - pro_disc_amt + svc_amt - tax_amt
                    else:
                        total_amt = sub_total - pro_disc_amt + svc_amt
                
                sales_data.append({
                    'store_name': str(row[0]) if row[0] else '',
                    'sales_no': str(row[1]) if row[1] else '',
                    'item_name': str(row[2]) if row[2] else '',
                    'qty': float(row[3]) if row[3] else 0.0,
                    'disc_amt': float(row[4]) if row[4] else 0.0,
                    'disc_name': str(row[5]) if row[5] else '',
                    'pro_disc_amt': pro_disc_amt,
                    'sub_total': sub_total,
                    'svc_amt': svc_amt,
                    'tax_amt': tax_amt,
                    'c_date': row[10],
                    'order_datetime': row[11],
                    'total_amt': total_amt,
                    'month': row[10].strftime('%Y-%m') if row[10] else '',
                    'category_code': str(row[13]) if row[13] else '未分类',
                    'payment_methods': ','.join(payment_info.get(f"{row[0]}-{row[1]}", []))
                })
            
            # 存储到缓存
            if not hasattr(self, '_sales_cache'):
                self._sales_cache = {}
            self._sales_cache[cache_key] = sales_data
            
            # 限制缓存大小
            if len(self._sales_cache) > 10:
                # 删除最旧的缓存项
                oldest_key = next(iter(self._sales_cache))
                del self._sales_cache[oldest_key]
            
            # 导出到Excel缓存（单日数据）
            if use_excel_cache and date_from and date_to and date_from == date_to:
                self.export_to_excel_cache(sales_data, date_from)
                # 检查是否需要合并月度数据
                self.check_and_merge_monthly_data(date_from)
            
            return sales_data
            
        except Exception as e:
            print(f"获取销售数据失败: {e}")
            import traceback
            print("详细错误信息:")
            traceback.print_exc()
            return []
    
    def export_to_excel_cache(self, sales_data, date_str):
        """导出数据到Excel缓存文件 - 压缩优化版本"""
        try:
            import pandas as pd
            import os
            import gzip
            import pickle
            
            # 创建cache目录
            cache_dir = "cache"
            if not os.path.exists(cache_dir):
                os.makedirs(cache_dir)
            
            # 生成文件名 - 使用压缩格式
            excel_file = f"{cache_dir}/sales_{date_str.replace('-', '_')}.xlsx"
            compressed_file = f"{cache_dir}/sales_{date_str.replace('-', '_')}.pkl.gz"
            
            # 导出到Excel（保持兼容性）
            df = pd.DataFrame(sales_data)
            df.to_excel(excel_file, index=False, engine='openpyxl')
            
            # 导出压缩版本
            with gzip.open(compressed_file, 'wb') as f:
                pickle.dump(sales_data, f, protocol=pickle.HIGHEST_PROTOCOL)
            
            # 获取文件大小
            excel_size = os.path.getsize(excel_file) / (1024 * 1024)  # MB
            compressed_size = os.path.getsize(compressed_file) / (1024 * 1024)  # MB
            compression_ratio = (1 - compressed_size / excel_size) * 100 if excel_size > 0 else 0
            
            print(f"📊 Excel缓存已生成:")
            print(f"   标准文件: {excel_file} ({excel_size:.2f} MB)")
            print(f"   压缩文件: {compressed_file} ({compressed_size:.2f} MB)")
            print(f"   压缩率: {compression_ratio:.1f}%，记录数: {len(sales_data)}")
            
        except Exception as e:
            print(f"✗ Excel缓存导出失败: {e}")
    
    def check_and_merge_monthly_data(self, date_str):
        """检查并合并月度数据"""
        try:
            from datetime import datetime
            import os
            import glob
            
            # 解析当前日期
            current_date = datetime.strptime(date_str, '%Y-%m-%d')
            current_month = current_date.strftime('%Y-%m')
            
            # 检查是否是月末（下个月的第一天）
            next_month = current_date.replace(day=1)
            if next_month.month == 12:
                next_month = next_month.replace(year=next_month.year + 1, month=1)
            else:
                next_month = next_month.replace(month=next_month.month + 1)
            
            # 如果今天是下个月的第一天，说明上个月已经结束
            if current_date.date() == next_month.date():
                previous_month = current_date.replace(day=1)
                previous_month_str = previous_month.strftime('%Y-%m')
                print(f"📅 检测到月份结束，开始合并 {previous_month_str} 的数据...")
                self.merge_monthly_files(previous_month_str)
            
        except Exception as e:
            print(f"✗ 月度合并检查失败: {e}")
    
    def merge_monthly_files(self, month_str):
        """合并指定月份的所有单日文件为月度文件"""
        try:
            import os
            import glob
            import gzip
            import pickle
            from datetime import datetime
            
            cache_dir = "cache"
            if not os.path.exists(cache_dir):
                return
            
            # 查找该月的所有单日文件
            daily_files = glob.glob(f"{cache_dir}/sales_{month_str.replace('-', '_')}_*.pkl.gz")
            
            if len(daily_files) < 2:  # 如果只有1个或没有文件，不需要合并
                print(f"ℹ️ {month_str} 只有 {len(daily_files)} 个文件，跳过合并")
                return
            
            print(f"📊 开始合并 {month_str} 的 {len(daily_files)} 个单日文件...")
            
            # 合并所有数据
            merged_data = []
            total_records = 0
            total_size = 0
            
            for file_path in sorted(daily_files):
                try:
                    with gzip.open(file_path, 'rb') as f:
                        daily_data = pickle.load(f)
                    
                    merged_data.extend(daily_data)
                    total_records += len(daily_data)
                    total_size += os.path.getsize(file_path)
                    
                    print(f"   ✓ 已合并: {os.path.basename(file_path)} ({len(daily_data)} 条记录)")
                    
                except Exception as e:
                    print(f"   ✗ 合并失败: {os.path.basename(file_path)} - {e}")
            
            if merged_data:
                # 生成月度文件名
                monthly_file = f"{cache_dir}/monthly_sales_{month_str.replace('-', '_')}.pkl.gz"
                
                # 保存合并后的数据
                with gzip.open(monthly_file, 'wb') as f:
                    pickle.dump(merged_data, f, protocol=pickle.HIGHEST_PROTOCOL)
                
                monthly_size = os.path.getsize(monthly_file)
                compression_ratio = (1 - monthly_size / total_size) * 100 if total_size > 0 else 0
                
                print(f"📦 月度合并完成:")
                print(f"   - 月度文件: {monthly_file}")
                print(f"   - 总记录数: {total_records}")
                print(f"   - 合并前总大小: {total_size/1024/1024:.2f} MB")
                print(f"   - 合并后大小: {monthly_size/1024/1024:.2f} MB")
                print(f"   - 压缩率: {compression_ratio:.1f}%")
                
                # 可选：删除单日文件（保留原始文件）
                print(f"ℹ️ 保留原始单日文件，月度文件已创建")
                
            else:
                print(f"✗ 没有有效数据可以合并")
                
        except Exception as e:
            print(f"✗ 月度文件合并失败: {e}")
    
    def manual_merge_monthly_data(self, month_str):
        """手动合并指定月份的数据"""
        try:
            print(f"🔧 手动合并 {month_str} 的数据...")
            self.merge_monthly_files(month_str)
        except Exception as e:
            print(f"✗ 手动合并失败: {e}")
    
    def get_cache_statistics(self):
        """获取缓存文件统计信息"""
        try:
            import os
            import glob
            from datetime import datetime
            
            cache_dir = "cache"
            if not os.path.exists(cache_dir):
                print("📊 缓存目录不存在")
                return
            
            # 统计单日文件
            daily_files = glob.glob(f"{cache_dir}/sales_*.pkl.gz")
            excel_files = glob.glob(f"{cache_dir}/sales_*.xlsx")
            monthly_files = glob.glob(f"{cache_dir}/monthly_sales_*.pkl.gz")
            
            print(f"📊 缓存文件统计:")
            print(f"   - 单日压缩文件: {len(daily_files)} 个")
            print(f"   - 单日Excel文件: {len(excel_files)} 个")
            print(f"   - 月度压缩文件: {len(monthly_files)} 个")
            
            # 计算总大小
            total_size = 0
            for file_path in daily_files + excel_files + monthly_files:
                total_size += os.path.getsize(file_path)
            
            print(f"   - 总占用空间: {total_size/1024/1024:.2f} MB")
            
            # 显示月度文件详情
            if monthly_files:
                print(f"📅 月度文件详情:")
                for monthly_file in sorted(monthly_files):
                    filename = os.path.basename(monthly_file)
                    file_size = os.path.getsize(monthly_file) / (1024 * 1024)
                    print(f"   - {filename}: {file_size:.2f} MB")
            
        except Exception as e:
            print(f"✗ 获取缓存统计失败: {e}")
    
    def get_payment_methods_for_sales(self, sales_results):
        """为销售数据获取支付方式信息"""
        if not self.connection or not sales_results:
            return {}
        
        try:
            cursor = self.connection.cursor()
            payment_dict = {}
            
            # 构建销售记录的唯一标识符列表
            sales_keys = []
            for i, row in enumerate(sales_results):
                store_name = str(row[0]) if row[0] else ''
                sales_no = str(row[1]) if row[1] else ''
                
                if not store_name or not sales_no:
                    payment_dict[i] = '无支付信息'
                else:
                    sales_keys.append((i, store_name, sales_no))
            
            if not sales_keys:
                return payment_dict
            
            # 批量查询支付方式，提高效率
            print(f"正在查询 {len(sales_keys)} 条销售记录的支付方式...")
            
            # 构建批量查询条件
            where_conditions = []
            for i, store_name, sales_no in sales_keys:
                store_name_escaped = store_name.replace("'", "''")
                sales_no_escaped = sales_no.replace("'", "''")
                where_conditions.append(f"(store_name = '{store_name_escaped}' AND sales_no = '{sales_no_escaped}')")
            
            # 批量查询支付方式 - 优化版本
            batch_query = f"""
                SELECT store_name, sales_no, payment_name
                FROM {TABLE_PAYMENT} WITH (NOLOCK)
                WHERE {' OR '.join(where_conditions)}
                ORDER BY store_name, sales_no
                OPTION (RECOMPILE)
            """
            
            try:
                cursor.execute(batch_query)
                payment_results = cursor.fetchall()
                
                # 将支付方式结果按销售记录分组
                payment_groups = {}
                for result in payment_results:
                    store_name = str(result[0]) if result[0] else ''
                    sales_no = str(result[1]) if result[1] else ''
                    payment_name = str(result[2]) if result[2] else ''
                    
                    key = f"{store_name}|{sales_no}"
                    if key not in payment_groups:
                        payment_groups[key] = []
                    if payment_name:
                        payment_groups[key].append(payment_name)
                
                # 为每个销售记录分配支付方式
                for i, store_name, sales_no in sales_keys:
                    key = f"{store_name}|{sales_no}"
                    if key in payment_groups and payment_groups[key]:
                        payment_dict[i] = ', '.join(payment_groups[key])
                    else:
                        payment_dict[i] = '无支付信息'
                
                print(f"✓ 成功获取支付方式信息，共 {len(payment_results)} 条支付记录")
                
            except Exception as e:
                print(f"批量查询支付方式失败: {e}")
                # 如果批量查询失败，回退到单独查询
                for i, store_name, sales_no in sales_keys:
                    try:
                        store_name_escaped = store_name.replace("'", "''")
                        sales_no_escaped = sales_no.replace("'", "''")
                        
                        query = f"""
                            SELECT payment_name
                            FROM {TABLE_PAYMENT}
                            WHERE store_name = '{store_name_escaped}' 
                            AND sales_no = '{sales_no_escaped}'
                        """
                        
                        cursor.execute(query)
                        results = cursor.fetchall()
                        
                        if results:
                            payment_methods = [str(result[0]) for result in results if result[0]]
                            payment_dict[i] = ', '.join(payment_methods) if payment_methods else '无支付信息'
                        else:
                            payment_dict[i] = '无支付信息'
                            
                    except Exception as e2:
                        print(f"单独查询支付方式失败 {store_name}-{sales_no}: {e2}")
                        payment_dict[i] = '无支付信息'
            
            cursor.close()
            return payment_dict
            
        except Exception as e:
            print(f"获取支付方式信息失败: {e}")
            return {}
    
    def get_payment_summary(self, date_from=None, date_to=None, outlet_filters=None, month_filters=None, category_filters=None, payment_filters=None):
        """获取支付方式汇总（優先本地，失敗回退SQL Server）"""
        # 先嘗試本地SQLite彙總
        try:
            local_result = self.get_local_payment_analysis(
                date_from=date_from,
                date_to=date_to,
                outlet_filters=outlet_filters,
                payment_filters=payment_filters,
            )
            if local_result:
                if self.log_message:
                    self.log_message("📦 使用本地SQLite支付分析數據", include_db_info=False)
                return local_result
            else:
                if self.log_message:
                    self.log_message("ℹ 本地SQLite無數據，回退到SQL Server", include_db_info=False)
        except Exception as _e:
            if self.log_message:
                self.log_message("⚠️ 讀取本地SQLite支付分析失敗，回退到SQL Server", include_db_info=False)
        if not self.connection:
            return []
        
        # 检查缓存
        cache_key = f"payment_{self.current_database}_{date_from}_{date_to}_{outlet_filters}_{month_filters}_{category_filters}_{payment_filters}"
        if hasattr(self, '_payment_cache') and cache_key in self._payment_cache:
            print("✓ 使用缓存的支付汇总数据")
            return self._payment_cache[cache_key]
        
        try:
            cursor = self.connection.cursor()
            
            # 构建WHERE条件
            conditions = []
            if date_from:
                conditions.append(f"CAST(p.c_date AS DATE) >= '{date_from}'")
            if date_to:
                conditions.append(f"CAST(p.c_date AS DATE) <= '{date_to}'")
            if outlet_filters and len(outlet_filters) > 0:
                outlet_conditions = " OR ".join([f"p.store_name = '{outlet}'" for outlet in outlet_filters])
                conditions.append(f"({outlet_conditions})")
            if month_filters and len(month_filters) > 0:
                month_conditions = " OR ".join([f"FORMAT(CAST(p.c_date AS DATE), 'yyyy-MM') = '{month}'" for month in month_filters])
                conditions.append(f"({month_conditions})")
            
            # 添加支付方式筛选条件 - 正确处理合并的支付方式
            if payment_filters and len(payment_filters) > 0:
                # 检查是否选择了Delivery Sales相关的支付方式
                delivery_methods = ['GRAB FOOD', 'FOOD PANDA', 'DELIVEROO']
                selected_delivery_methods = [method for method in payment_filters if method in delivery_methods]
                
                payment_conditions = []
                for method in payment_filters:
                    if method in delivery_methods:
                        # 如果是外送平台的原始名称，直接匹配
                        payment_conditions.append(f"p.payment_name = '{method}'")
                    elif method == 'Delivery Sales':
                        # 如果选择了Delivery Sales，需要包含所有外送平台的原始名称
                        payment_conditions.append("p.payment_name IN ('GRAB FOOD', 'FOOD PANDA', 'DELIVEROO')")
                    else:
                        # 其他支付方式直接匹配
                        payment_conditions.append(f"p.payment_name = '{method}'")
                
                if payment_conditions:
                    conditions.append(f"({' OR '.join(payment_conditions)})")
            
            # 总是需要JOIN销售表来排除WASTAGE和获取正确的总金额计算
            join_clause = ""
            if category_filters and len(category_filters) > 0:
                join_clause = f"""
                    INNER JOIN item_master im ON s.item_name = im.item_name
                """
                category_conditions = " OR ".join([f"im.category_code = '{category}'" for category in category_filters])
                conditions.append(f"({category_conditions})")
            
            where_clause = ""
            if conditions:
                where_clause = " WHERE " + " AND ".join(conditions)
            
            # 构建支付方式合并逻辑 - 根据筛选条件动态调整
            delivery_case = ""
            if payment_filters and len(payment_filters) > 0:
                # 检查是否选择了外送平台的支付方式
                selected_delivery_methods = [method for method in payment_filters if method in ['GRAB FOOD', 'FOOD PANDA', 'DELIVEROO']]
                if selected_delivery_methods:
                    # 如果选择了外送平台支付方式，将它们合并为Delivery Sales
                    delivery_methods_str = "', '".join(selected_delivery_methods)
                    delivery_case = f"WHEN p.payment_name IN ('{delivery_methods_str}') THEN 'Delivery Sales'"
                else:
                    # 如果没有选择任何外送平台支付方式，不进行合并
                    delivery_case = ""
            else:
                # 如果没有筛选条件，使用默认合并逻辑
                delivery_case = "WHEN p.payment_name IN ('GRAB FOOD', 'FOOD PANDA', 'DELIVEROO') THEN 'Delivery Sales'"
            
            # 查询支付汇总 - 按单据和支付方式分组计算，排除WASTAGE，与月-销售数据保持一致
            # 单据数计算也要排除WASTAGE，只计算非WASTAGE产品的单据
            query = f"""
                SELECT 
                    p.store_name as 门市,
                    FORMAT(p.c_date, 'yyyy-MM') as 月份,
                    CASE 
                        {delivery_case}
                        ELSE p.payment_name
                    END as 支付方式,
                    COUNT(DISTINCT CASE WHEN s.item_name != 'WASTAGE' THEN CONCAT(p.store_name, '-', p.sales_no, '-', p.c_date) END) as 使用次数,
                    SUM(CASE WHEN s.item_name != 'WASTAGE' THEN 
                        {self.get_performance_calculation_sql()}
                    ELSE 0 END) as 总金额
                FROM {TABLE_PAYMENT} p
                INNER JOIN {TABLE_SALES} s ON p.store_name = s.store_name 
                    AND p.sales_no = s.sales_no 
                    AND p.c_date = s.c_date
                {join_clause}
                {where_clause}
                GROUP BY p.store_name, FORMAT(p.c_date, 'yyyy-MM'), 
                    CASE 
                        {delivery_case}
                        ELSE p.payment_name
                    END
                ORDER BY 月份 DESC, p.store_name, 总金额 DESC
            """
            
            try:
                cursor.execute(query)
                results = cursor.fetchall()
                # 不要在这里关闭cursor，因为后续查询还需要使用
            except Exception as e:
                cursor.close()
                print(f"支付分析查询错误: {e}")
                print(f"查询语句: {query}")
                raise e
            
            # 获取总数据用于计算占比 - 修復：應該包含支付方式篩選條件
            # 重新构建WHERE条件，包含支付方式筛选
            total_conditions = []
            if date_from:
                total_conditions.append(f"CAST(s.c_date AS DATE) >= '{date_from}'")
            if date_to:
                total_conditions.append(f"CAST(s.c_date AS DATE) <= '{date_to}'")
            if outlet_filters and len(outlet_filters) > 0:
                outlet_conditions = " OR ".join([f"s.store_name = '{outlet}'" for outlet in outlet_filters])
                total_conditions.append(f"({outlet_conditions})")
            if month_filters and len(month_filters) > 0:
                month_conditions = " OR ".join([f"FORMAT(CAST(s.c_date AS DATE), 'yyyy-MM') = '{month}'" for month in month_filters])
                total_conditions.append(f"({month_conditions})")
            
            # 修復：添加支付方式篩選條件到總計查詢
            if payment_filters and len(payment_filters) > 0:
                # 检查是否选择了Delivery Sales相关的支付方式
                delivery_methods = ['GRAB FOOD', 'FOOD PANDA', 'DELIVEROO']
                selected_delivery_methods = [method for method in payment_filters if method in delivery_methods]
                
                payment_conditions = []
                for method in payment_filters:
                    if method in delivery_methods:
                        # 如果是外送平台的原始名称，直接匹配
                        payment_conditions.append(f"p.payment_name = '{method}'")
                    elif method == 'Delivery Sales':
                        # 如果选择了Delivery Sales，需要包含所有外送平台的原始名称
                        payment_conditions.append("p.payment_name IN ('GRAB FOOD', 'FOOD PANDA', 'DELIVEROO')")
                    else:
                        # 其他支付方式直接匹配
                        payment_conditions.append(f"p.payment_name = '{method}'")
                
                if payment_conditions:
                    total_conditions.append(f"EXISTS (SELECT 1 FROM {TABLE_PAYMENT} p WHERE p.sales_no = s.sales_no AND p.store_name = s.store_name AND ({' OR '.join(payment_conditions)}))")
            
            # 添加类别筛选条件（如果有的话）
            total_join_clause = ""
            if category_filters and len(category_filters) > 0:
                total_join_clause = f"""
                    INNER JOIN item_master im ON s.item_name = im.item_name
                """
                category_conditions = " OR ".join([f"im.category_code = '{category}'" for category in category_filters])
                total_conditions.append(f"({category_conditions})")
            
            total_where_clause = ""
            if total_conditions:
                total_where_clause = " WHERE " + " AND ".join(total_conditions)
            
            total_query = f"""
                SELECT 
                    COUNT(DISTINCT CASE WHEN s.item_name != 'WASTAGE' THEN CONCAT(s.store_name, '-', s.sales_no, '-', s.c_date) END) as 总次数,
                    SUM(CASE WHEN s.item_name != 'WASTAGE' THEN 
                        {self.get_performance_calculation_sql()}
                        - ISNULL(CAST(c.cancel_amount as FLOAT), 0)
                    ELSE 0 END) as 总金额
                FROM {TABLE_SALES} s
                LEFT JOIN (
                    SELECT 
                        sales_no, 
                        store_name, 
                        item_name,
                        SUM({self._get_cancel_performance_calculation_sql()}) as cancel_amount
                    FROM {TABLE_CANCEL} WITH (NOLOCK)
                    GROUP BY sales_no, store_name, item_name
                ) c ON s.sales_no = c.sales_no AND s.store_name = c.store_name AND s.item_name = c.item_name
                {total_join_clause}
                {total_where_clause}
            """
            
            try:
                cursor.execute(total_query)
                total_result = cursor.fetchone()
                total_count = int(total_result[0]) if total_result[0] else 0
                total_amount = float(total_result[1]) if total_result[1] else 0.0
                print(f"DEBUG: 总单据数查询结果: {total_count}")
                print(f"DEBUG: 总金额查询结果: {total_amount}")
                print(f"DEBUG: 总查询SQL: {total_query}")
            except Exception as e:
                print(f"DEBUG: 总查询错误: {e}")
                total_count = 0
                total_amount = 0.0
            
            # 获取各店总数据 - 需要重新查询以确保单据数不重复计算
            store_totals = {}
            for row in results:
                store_name = str(row[0]) if row[0] else ''
                if store_name not in store_totals:
                    store_totals[store_name] = {'count': 0, 'amount': 0.0}
                # 注意：这里不能直接累加单据数，因为同一张单据可能出现在多个支付方式中
                # 金额可以累加，但单据数需要重新查询
                store_totals[store_name]['amount'] += float(row[4]) if row[4] else 0.0
            
            # 重新查询各店的实际单据数（不重复计算）- 直接查询销售表
            for store_name in store_totals.keys():
                # 构建门店查询条件，直接查询销售表
                # 清理门店名称，移除可能的额外字符
                clean_store_name = store_name.strip()
                store_conditions = [f"s.store_name = '{clean_store_name}'"]
                print(f"DEBUG: 查询门店: '{clean_store_name}'")
                if date_from:
                    store_conditions.append(f"CAST(s.c_date AS DATE) >= '{date_from}'")
                if date_to:
                    store_conditions.append(f"CAST(s.c_date AS DATE) <= '{date_to}'")
                if month_filters and len(month_filters) > 0:
                    month_conditions = " OR ".join([f"FORMAT(CAST(s.c_date AS DATE), 'yyyy-MM') = '{month}'" for month in month_filters])
                    store_conditions.append(f"({month_conditions})")
                
                # 修復：添加支付方式篩選條件到門店查詢
                if payment_filters and len(payment_filters) > 0:
                    delivery_methods = ['GRAB FOOD', 'FOOD PANDA', 'DELIVEROO']
                    payment_conditions = []
                    for method in payment_filters:
                        if method in delivery_methods:
                            payment_conditions.append(f"p.payment_name = '{method}'")
                        elif method == 'Delivery Sales':
                            payment_conditions.append("p.payment_name IN ('GRAB FOOD', 'FOOD PANDA', 'DELIVEROO')")
                        else:
                            payment_conditions.append(f"p.payment_name = '{method}'")
                    
                    if payment_conditions:
                        store_conditions.append(f"EXISTS (SELECT 1 FROM {TABLE_PAYMENT} p WHERE p.sales_no = s.sales_no AND p.store_name = s.store_name AND ({' OR '.join(payment_conditions)}))")
                
                # 添加类别筛选条件（如果有的话）
                store_join_clause = ""
                if category_filters and len(category_filters) > 0:
                    store_join_clause = f"""
                        INNER JOIN item_master im ON s.item_name = im.item_name
                    """
                    category_conditions = " OR ".join([f"im.category_code = '{category}'" for category in category_filters])
                    store_conditions.append(f"({category_conditions})")
                
                store_where_clause = " WHERE " + " AND ".join(store_conditions)
                
                store_count_query = f"""
                    SELECT COUNT(DISTINCT CASE WHEN s.item_name != 'WASTAGE' THEN CONCAT(s.store_name, '-', s.sales_no, '-', s.c_date) END) as 总次数
                    FROM {TABLE_SALES} s
                    {store_join_clause}
                    {store_where_clause}
                """
                try:
                    cursor.execute(store_count_query)
                    store_count_result = cursor.fetchone()
                    store_totals[store_name]['count'] = int(store_count_result[0]) if store_count_result[0] else 0
                    print(f"DEBUG: 门店 {store_name} 单据数查询结果: {store_totals[store_name]['count']}")
                    print(f"DEBUG: 门店查询SQL: {store_count_query}")
                except Exception as e:
                    print(f"DEBUG: 门店单据数查询错误: {e}")
                    store_totals[store_name]['count'] = 0
            
            # 转换数据并计算占比，按门店和月份分组
            payment_data = []
            store_month_data = {}  # 用于存储每个门店每个月份的数据
            
            for row in results:
                store_name = str(row[0]) if row[0] else ''
                month = str(row[1]) if row[1] else ''
                payment_method = str(row[2]) if row[2] else ''
                count = int(row[3]) if row[3] else 0
                amount = float(row[4]) if row[4] else 0.0
                print(f"DEBUG: 处理数据行 - 门店: '{store_name}', 月份: '{month}', 支付方式: '{payment_method}', 单据数: {count}, 金额: {amount}")
                
                # 计算占比
                count_ratio = (count / total_count * 100) if total_count > 0 else 0
                amount_ratio = (amount / total_amount * 100) if total_amount > 0 else 0
                
                # 计算该店占比
                store_total = store_totals.get(store_name, {'count': 0, 'amount': 0.0})
                store_count_ratio = (count / store_total['count'] * 100) if store_total['count'] > 0 else 0
                store_amount_ratio = (amount / store_total['amount'] * 100) if store_total['amount'] > 0 else 0
                
                # 计算平均金额 = 总金额 / 使用次数
                avg_amount = round(amount / count, 2) if count > 0 else 0.0
                
                # 存储到分组数据结构中
                if store_name not in store_month_data:
                    store_month_data[store_name] = {}
                if month not in store_month_data[store_name]:
                    store_month_data[store_name][month] = []
                
                store_month_data[store_name][month].append({
                    '门市': store_name,
                    '月份': month,
                    '支付方式': payment_method,
                    '使用次数': count,
                    '总金额': amount,
                    '平均金额': avg_amount,
                    '次数占比(%)': round(count_ratio, 2),
                    '金额占比(%)': round(amount_ratio, 2),
                    '该店次数占比(%)': round(store_count_ratio, 2),
                    '该店金额占比(%)': round(store_amount_ratio, 2)
                })
            
            # 按门店和月份组织数据，并在每个门店的每个月份后添加总计行
            for store_name in sorted(store_month_data.keys()):
                for month in sorted(store_month_data[store_name].keys()):
                    month_data = store_month_data[store_name][month]
                    
                    # 添加该门店该月份的所有支付方式数据
                    for data in month_data:
                        payment_data.append(data)
                    
                    # 计算该门店该月份的总计 - 需要重新查询以确保单据数不重复计算
                    month_total_amount = sum(item['总金额'] for item in month_data)
                    
                    # 重新查询该门店该月份的实际单据数（不重复计算）- 直接查询销售表
                    # 清理门店名称，移除可能的额外字符
                    clean_store_name = store_name.strip()
                    month_conditions = [
                        f"s.store_name = '{clean_store_name}'",
                        f"FORMAT(s.c_date, 'yyyy-MM') = '{month}'"
                    ]
                    print(f"DEBUG: 查询门店月份: '{clean_store_name}' - '{month}'")
                    if date_from:
                        month_conditions.append(f"CAST(s.c_date AS DATE) >= '{date_from}'")
                    if date_to:
                        month_conditions.append(f"CAST(s.c_date AS DATE) <= '{date_to}'")
                    
                    # 修復：添加支付方式篩選條件到月份查詢
                    if payment_filters and len(payment_filters) > 0:
                        delivery_methods = ['GRAB FOOD', 'FOOD PANDA', 'DELIVEROO']
                        payment_conditions = []
                        for method in payment_filters:
                            if method in delivery_methods:
                                payment_conditions.append(f"p.payment_name = '{method}'")
                            elif method == 'Delivery Sales':
                                payment_conditions.append("p.payment_name IN ('GRAB FOOD', 'FOOD PANDA', 'DELIVEROO')")
                            else:
                                payment_conditions.append(f"p.payment_name = '{method}'")
                        
                        if payment_conditions:
                            month_conditions.append(f"EXISTS (SELECT 1 FROM {TABLE_PAYMENT} p WHERE p.sales_no = s.sales_no AND p.store_name = s.store_name AND ({' OR '.join(payment_conditions)}))")
                    
                    # 添加类别筛选条件（如果有的话）
                    month_join_clause = ""
                    if category_filters and len(category_filters) > 0:
                        month_join_clause = f"""
                            INNER JOIN item_master im ON s.item_name = im.item_name
                        """
                        category_conditions = " OR ".join([f"im.category_code = '{category}'" for category in category_filters])
                        month_conditions.append(f"({category_conditions})")
                    
                    month_where_clause = " WHERE " + " AND ".join(month_conditions)
                    
                    month_count_query = f"""
                        SELECT COUNT(DISTINCT CASE WHEN s.item_name != 'WASTAGE' THEN CONCAT(s.store_name, '-', s.sales_no, '-', s.c_date) END) as 总次数
                        FROM {TABLE_SALES} s
                        {month_join_clause}
                        {month_where_clause}
                    """
                    try:
                        cursor.execute(month_count_query)
                        month_count_result = cursor.fetchone()
                        month_total_count = int(month_count_result[0]) if month_count_result[0] else 0
                        print(f"DEBUG: 门店 {store_name} 月份 {month} 单据数查询结果: {month_total_count}")
                        print(f"DEBUG: 查询SQL: {month_count_query}")
                        
                        # 添加详细调试：检查各个支付方式的单据数总和
                        individual_counts = sum(item['使用次数'] for item in month_data)
                        print(f"DEBUG: 各支付方式单据数总和: {individual_counts}")
                        print(f"DEBUG: 唯一单据数: {month_total_count}")
                        print(f"DEBUG: 差异: {individual_counts - month_total_count}")
                        
                    except Exception as e:
                        print(f"DEBUG: 门店月份单据数查询错误: {e}")
                        month_total_count = 0
                    
                    month_avg_amount = round(month_total_amount / month_total_count, 2) if month_total_count > 0 else 0.0
                    
                    # 计算该门店该月份总计的占比
                    month_count_ratio = (month_total_count / total_count * 100) if total_count > 0 else 0
                    month_amount_ratio = (month_total_amount / total_amount * 100) if total_amount > 0 else 0
                    
                    # 添加该门店该月份的总计行
                    payment_data.append({
                        '门市': f'【{store_name} {month} 总计】',
                        '月份': month,
                        '支付方式': '',
                        '使用次数': month_total_count,
                        '总金额': month_total_amount,
                        '平均金额': month_avg_amount,
                        '次数占比(%)': round(month_count_ratio, 2),
                        '金额占比(%)': round(month_amount_ratio, 2),
                        '该店次数占比(%)': 100.00,
                        '该店金额占比(%)': 100.00
                    })
                    print(f"DEBUG: 添加门店月份总计行 - 门店: {store_name}, 月份: {month}, 单据数: {month_total_count}, 金额: {month_total_amount}")
            
            # 添加全总计 - 使用已经计算好的total_count和total_amount，避免重复计算
            if payment_data:
                grand_total_count = total_count  # 使用已经查询好的总单据数
                grand_total_amount = sum(item['总金额'] for item in payment_data if not item['门市'].startswith('【'))
                
                payment_data.append({
                    '门市': '【全总计】',
                    '月份': '',
                    '支付方式': '',
                    '使用次数': grand_total_count,
                    '总金额': grand_total_amount,
                    '平均金额': round(grand_total_amount / grand_total_count, 2) if grand_total_count > 0 else 0.0,
                    '次数占比(%)': 100.00,
                    '金额占比(%)': 100.00,
                    '该店次数占比(%)': 100.00,
                    '该店金额占比(%)': 100.00
                })
            
            # 存储到缓存
            if not hasattr(self, '_payment_cache'):
                self._payment_cache = {}
            self._payment_cache[cache_key] = payment_data
            
            # 限制缓存大小
            if len(self._payment_cache) > 10:
                # 删除最旧的缓存项
                oldest_key = next(iter(self._payment_cache))
                del self._payment_cache[oldest_key]
            
            # 关闭游标
            cursor.close()
            return payment_data
            
        except Exception as e:
            print(f"获取支付汇总失败: {e}")
            if 'cursor' in locals():
                cursor.close()
            return []
    
    def _get_store_receipt_count(self, store_name, date_from=None, date_to=None, outlet_filters=None, month_filters=None, category_filters=None, payment_filters=None):
        """獲取指定門店的實際單據數（不重複計算）"""
        if not self.connection:
            return 0
        
        try:
            cursor = self.connection.cursor()
            
            # 構建WHERE條件
            conditions = [f"s.store_name = '{store_name}'"]
            if date_from:
                conditions.append(f"CAST(s.c_date AS DATE) >= '{date_from}'")
            if date_to:
                conditions.append(f"CAST(s.c_date AS DATE) <= '{date_to}'")
            if month_filters and len(month_filters) > 0:
                month_conditions = " OR ".join([f"FORMAT(CAST(s.c_date AS DATE), 'yyyy-MM') = '{month}'" for month in month_filters])
                conditions.append(f"({month_conditions})")
            
            # 添加類別篩選條件
            join_clause = ""
            if category_filters and len(category_filters) > 0:
                join_clause = "INNER JOIN item_master im ON s.item_name = im.item_name"
                category_conditions = " OR ".join([f"im.category_code = '{category}'" for category in category_filters])
                conditions.append(f"({category_conditions})")
            
            # 添加支付方式篩選條件
            if payment_filters and len(payment_filters) > 0:
                payment_conditions = " OR ".join([f"p.payment_name = '{payment}'" for payment in payment_filters])
                conditions.append(f"EXISTS (SELECT 1 FROM {TABLE_PAYMENT} p WHERE p.sales_no = s.sales_no AND p.store_name = s.store_name AND ({payment_conditions}))")
            
            where_clause = " WHERE " + " AND ".join(conditions)
            
            query = f"""
                SELECT COUNT(DISTINCT CONCAT(s.store_name, '-', s.sales_no)) as 总单据数
                FROM {TABLE_SALES} s
                {join_clause}
                {where_clause}
                AND s.item_name != 'WASTAGE'
            """
            
            cursor.execute(query)
            result = cursor.fetchone()
            cursor.close()
            
            return int(result[0]) if result and result[0] else 0
            
        except Exception as e:
            print(f"獲取門店單據數失敗: {e}")
            return 0
        """获取折扣分析"""
        if not self.connection:
            return []
        
        # 检查缓存
        cache_key = f"discount_{self.current_database}_{date_from}_{date_to}_{outlet_filters}_{month_filters}_{weekday_filters}_{category_filters}_{payment_filters}"
        if hasattr(self, '_discount_cache') and cache_key in self._discount_cache:
            print("✓ 使用缓存的折扣分析数据")
            return self._discount_cache[cache_key]
        
        try:
            cursor = self.connection.cursor()
            
            # 构建WHERE条件
            conditions = []
            if date_from:
                conditions.append(f"CAST(s.c_date AS DATE) >= '{date_from}'")
            if date_to:
                conditions.append(f"CAST(s.c_date AS DATE) <= '{date_to}'")
            if outlet_filters and len(outlet_filters) > 0:
                outlet_conditions = " OR ".join([f"s.store_name = '{outlet}'" for outlet in outlet_filters])
                conditions.append(f"({outlet_conditions})")
            if month_filters and len(month_filters) > 0:
                month_conditions = " OR ".join([f"FORMAT(CAST(s.c_date AS DATE), 'yyyy-MM') = '{month}'" for month in month_filters])
                conditions.append(f"({month_conditions})")
            
            # 添加折扣条件
            conditions.append("s.disc_amt > 0")
            
            # 如果有类别筛选，需要JOIN item_master表
            join_clause = ""
            if category_filters and len(category_filters) > 0:
                join_clause = f"""
                    INNER JOIN (
                        SELECT item_name, category_code
                        FROM item_master im1
                        WHERE im1.m_date = (
                            SELECT MAX(m_date) 
                            FROM item_master im2 
                            WHERE im2.item_name = im1.item_name
                        )
                    ) im ON s.item_name = im.item_name
                """
                category_conditions = " OR ".join([f"im.category_code = '{category}'" for category in category_filters])
                conditions.append(f"({category_conditions})")
            
            # 支付方式筛选逻辑
            # 如果payment_filters为None，表示未选择任何支付方式，不应用筛选
            # 如果payment_filters为空列表[]，表示选择了全部支付方式，不应用筛选
            # 如果payment_filters有值，表示选择了特定支付方式，应用筛选
            if payment_filters is not None and len(payment_filters) > 0:
                payment_conditions = " OR ".join([f"p.payment_name = '{method}'" for method in payment_filters])
                conditions.append(f"EXISTS (SELECT 1 FROM {TABLE_PAYMENT} p WHERE s.sales_no = p.sales_no AND s.store_name = p.store_name AND ({payment_conditions}))")
            
            where_clause = ""
            if conditions:
                where_clause = " WHERE " + " AND ".join(conditions)
            
            # 查询折扣分析 - 加上月份，支持类别筛选
            query = f"""
                SELECT 
                    s.store_name as 门市,
                    FORMAT(s.c_date, 'yyyy-MM') as 月份,
                    ISNULL(s.disc_name, '') as 折扣名称,
                    SUM(CAST(s.disc_amt as FLOAT)) as 折扣金额,
                    COUNT(*) as 折扣次数
                FROM {TABLE_SALES} s
                {join_clause}
                {where_clause}
                GROUP BY s.store_name, FORMAT(s.c_date, 'yyyy-MM'), ISNULL(s.disc_name, '')
                ORDER BY 月份 DESC, s.store_name, 折扣金额 DESC
            """
            
            try:
                cursor.execute(query)
                results = cursor.fetchall()
            except Exception as query_error:
                print(f"查询执行失败: {query_error}")
                print(f"查询语句: {query[:200]}...")
                cursor.close()
                return []
            finally:
                cursor.close()
            
            # 获取每个门市每个月的总金额和总单据数用于计算占比
            outlet_month_totals = {}
            
            # 先获取所有涉及的门市和月份组合
            cursor = self.connection.cursor()
            try:
                cursor.execute(query)
                results = cursor.fetchall()
            except Exception as query_error:
                print(f"查询执行失败: {query_error}")
                print(f"查询语句: {query[:200]}...")
                cursor.close()
                return []
            finally:
                cursor.close()
            
            # 获取每个门市每个月的总金额和总单据数
            for row in results:
                store_name = str(row[0]) if row[0] else ''
                month = str(row[1]) if row[1] else ''
                
                if store_name not in outlet_month_totals:
                    outlet_month_totals[store_name] = {}
                
                if month not in outlet_month_totals[store_name]:
                    # 获取该门市该月的总金额和总单据数
                    month_start = f"{month}-01"
                    if month == datetime.now().strftime('%Y-%m'):
                        # 如果是当前月份，使用当前日期
                        month_end = datetime.now().strftime('%Y-%m-%d')
                    else:
                        # 其他月份使用月末
                        next_month = datetime.strptime(month + '-01', '%Y-%m-%d') + timedelta(days=32)
                        month_end = (next_month.replace(day=1) - timedelta(days=1)).strftime('%Y-%m-%d')
                    
                    total_query = f"""
                        SELECT 
                            SUM(CAST(sub_total as FLOAT)) as 总金额,
                            COUNT(DISTINCT CONCAT(store_name, '-', sales_no)) as 总单据数
                        FROM {TABLE_SALES}
                        WHERE store_name = '{store_name}'
                        AND c_date >= '{month_start}'
                        AND c_date <= '{month_end}'
                    """
                    
                    try:
                        cursor = self.connection.cursor()
                        cursor.execute(total_query)
                        total_result = cursor.fetchone()
                        cursor.close()
                        
                        if total_result:
                            outlet_month_totals[store_name][month] = {
                                'total_amount': float(total_result[0]) if total_result[0] else 0.0,
                                'total_receipts': int(total_result[1]) if total_result[1] else 0
                            }
                        else:
                            outlet_month_totals[store_name][month] = {'total_amount': 0.0, 'total_receipts': 0}
                    except:
                        outlet_month_totals[store_name][month] = {'total_amount': 0.0, 'total_receipts': 0}
            
            # 转换数据并计算占比
            discount_data = []
            total_disc_amt = 0.0
            total_disc_count = 0
            
            # 先计算每个折扣名称的全系统总使用次数
            discount_name_totals = {}
            for row in results:
                disc_name = str(row[2]) if row[2] else ''
                disc_count = int(row[4]) if row[4] else 0
                if disc_name not in discount_name_totals:
                    discount_name_totals[disc_name] = 0
                discount_name_totals[disc_name] += disc_count
            
            for row in results:
                store_name = str(row[0]) if row[0] else ''
                month = str(row[1]) if row[1] else ''
                disc_name = str(row[2]) if row[2] else ''
                disc_amt = float(row[3]) if row[3] else 0.0
                disc_count = int(row[4]) if row[4] else 0
                
                # 累计总计
                total_disc_amt += disc_amt
                total_disc_count += disc_count
                
                # 获取该门市该月的总金额和总单据数
                outlet_month_total = outlet_month_totals.get(store_name, {}).get(month, {'total_amount': 0.0, 'total_receipts': 0})
                store_month_amount = outlet_month_total['total_amount']
                store_month_receipts = outlet_month_total['total_receipts']
                
                # 计算占比
                disc_ratio = (disc_amt / store_month_amount * 100) if store_month_amount > 0 else 0
                count_ratio = (disc_count / store_month_receipts * 100) if store_month_receipts > 0 else 0
                
                discount_data.append({
                    '门市': store_name,
                    '月份': month,
                    '折扣名称': disc_name,
                    '折扣金额': disc_amt,
                    '折扣占比(%)': round(disc_ratio, 2),
                    '折扣次数': disc_count,
                    '折扣次数占比(%)': round(count_ratio, 2),
                    '全門市折扣總次數': discount_name_totals.get(disc_name, 0)
                })
            
            # 添加详细的总计结构
            if discount_data:
                # 按门市分组计算各店总计
                store_totals = {}
                month_totals = {}
                grand_total_disc_amt = 0.0
                grand_total_disc_count = 0
                
                for data in discount_data:
                    store = data['门市']
                    month = data['月份']
                    disc_amt = data['折扣金额']
                    disc_count = data['折扣次数']
                    
                    # 各店总计
                    if store not in store_totals:
                        store_totals[store] = {'disc_amt': 0.0, 'disc_count': 0}
                    store_totals[store]['disc_amt'] += disc_amt
                    store_totals[store]['disc_count'] += disc_count
                    
                    # 月份总计
                    if month not in month_totals:
                        month_totals[month] = {'disc_amt': 0.0, 'disc_count': 0}
                    month_totals[month]['disc_amt'] += disc_amt
                    month_totals[month]['disc_count'] += disc_count
                    
                    # 全总计
                    grand_total_disc_amt += disc_amt
                    grand_total_disc_count += disc_count
                
                # 添加各店总计
                for store, totals in store_totals.items():
                    discount_data.append({
                        '门市': f'【{store} 总计】',
                        '月份': '',
                        '折扣名称': '',
                        '折扣金额': totals['disc_amt'],
                        '折扣占比(%)': 0.00,  # 总计行不显示占比
                        '折扣次数': totals['disc_count'],
                        '折扣次数占比(%)': 0.00,  # 总计行不显示占比
                        '全門市折扣總次數': 0  # 总计行不显示全門市折扣總次數
                    })
                
                # 添加月份总计
                for month, totals in month_totals.items():
                    discount_data.append({
                        '门市': f'【{month} 月份总计】',
                        '月份': month,
                        '折扣名称': '',
                        '折扣金额': totals['disc_amt'],
                        '折扣占比(%)': 0.00,  # 总计行不显示占比
                        '折扣次数': totals['disc_count'],
                        '折扣次数占比(%)': 0.00,  # 总计行不显示占比
                        '全門市折扣總次數': 0  # 总计行不显示全門市折扣總次數
                    })
                
                # 添加全总计
                discount_data.append({
                    '门市': '【全总计】',
                    '月份': '',
                    '折扣名称': '',
                    '折扣金额': grand_total_disc_amt,
                    '折扣占比(%)': 0.00,  # 总计行不显示占比
                    '折扣次数': grand_total_disc_count,
                    '折扣次数占比(%)': 0.00,  # 总计行不显示占比
                    '折扣名称总数': 0  # 总计行不显示折扣名称总数
                })
            
            # 存储到缓存
            if not hasattr(self, '_discount_cache'):
                self._discount_cache = {}
            self._discount_cache[cache_key] = discount_data
            
            # 限制缓存大小
            if len(self._discount_cache) > 10:
                # 删除最旧的缓存项
                oldest_key = next(iter(self._discount_cache))
                del self._discount_cache[oldest_key]
            
            return discount_data
            
        except Exception as e:
            print(f"获取折扣分析失败: {e}")
            return []
    
    def get_monthly_summary_optimized(self, date_from=None, date_to=None, outlet_filters=None, product_filters=None, month_filters=None, category_filters=None, payment_filters=None):
        """获取月度汇总 - 优化版本（包含产品单据业绩）"""
        if not self.connection:
            return []
        
        # 检查缓存
        cache_key = f"monthly_{self.current_database}_{date_from}_{date_to}_{outlet_filters}_{product_filters}_{month_filters}_{category_filters}_{payment_filters}"
        if hasattr(self, '_monthly_cache') and cache_key in self._monthly_cache:
            print("✓ 使用缓存的月度汇总数据")
            return self._monthly_cache[cache_key]
        
        # 检查日期范围，如果范围太大给出警告
        if date_from and date_to:
            from_date = datetime.strptime(date_from, '%Y-%m-%d')
            to_date = datetime.strptime(date_to, '%Y-%m-%d')
            days_diff = (to_date - from_date).days
            
            if days_diff > 30:
                print(f"⚠️ 警告: 查询日期范围较大 ({days_diff} 天)，可能需要较长时间...")
            elif days_diff > 7:
                print(f"ℹ️ 提示: 查询日期范围为 {days_diff} 天，正在处理...")
        
        try:
            cursor = self.connection.cursor()
            
            # 构建WHERE条件 - 优化日期筛选性能
            conditions = []
            if date_from:
                # 使用日期范围而不是CAST，提高索引使用效率
                conditions.append(f"s.c_date >= '{date_from} 00:00:00'")
            if date_to:
                conditions.append(f"s.c_date <= '{date_to} 23:59:59'")
            if outlet_filters and len(outlet_filters) > 0:
                outlet_conditions = " OR ".join([f"s.store_name = '{outlet}'" for outlet in outlet_filters])
                conditions.append(f"({outlet_conditions})")
            if product_filters and len(product_filters) > 0:
                product_conditions = " OR ".join([f"s.item_name = '{product}'" for product in product_filters])
                conditions.append(f"({product_conditions})")
            if month_filters and len(month_filters) > 0:
                month_conditions = " OR ".join([f"FORMAT(s.c_date, 'yyyy-MM') = '{month}'" for month in month_filters])
                conditions.append(f"({month_conditions})")
            
            # 排除WASTAGE及其变体 - 优化版本，使用NOT IN代替多个LIKE
            conditions.append("s.item_name NOT IN ('WASTAGE', 'Waste', 'waste', 'WASTE')")
            
            # 如果有类别筛选，添加类别条件
            if category_filters and len(category_filters) > 0:
                category_conditions = " OR ".join([f"im.category_code = '{category}'" for category in category_filters])
                conditions.append(f"({category_conditions})")
            
            # 如果有支付方式筛选，需要JOIN支付表
            if payment_filters and len(payment_filters) > 0:
                payment_conditions = " OR ".join([f"p.payment_name = '{method}'" for method in payment_filters])
                # 仅按门市+单据号匹配，避免因c_date微差导致漏数
                conditions.append(f"EXISTS (SELECT 1 FROM {TABLE_PAYMENT} p WHERE s.sales_no = p.sales_no AND s.store_name = p.store_name AND ({payment_conditions}))")
            
            where_clause = ""
            if conditions:
                where_clause = " WHERE " + " AND ".join(conditions)
            
            # 优化查询 - 简化item_master JOIN，添加更多索引提示
            query = f"""
                SELECT 
                    s.store_name as 门市,
                    s.item_name as 产品,
                    FORMAT(s.c_date, 'yyyy-MM') as 月份,
                    ISNULL(im.category_code, '') as 类别,
                    SUM(CAST(s.qty as FLOAT)) as 卖出量,
                    SUM(CAST(s.sub_total as FLOAT)) as 金额,
                    SUM({self.get_performance_calculation_sql()}) as 总金额,
                    COUNT(DISTINCT CONCAT(s.store_name, '-', s.sales_no)) as 单据数
                FROM {TABLE_SALES} s WITH (NOLOCK)
                LEFT JOIN item_master im WITH (NOLOCK) ON s.item_name = im.item_name
                {where_clause}
                GROUP BY s.store_name, s.item_name, FORMAT(s.c_date, 'yyyy-MM'), im.category_code
                ORDER BY 月份 DESC, s.store_name, s.item_name
                OPTION (RECOMPILE, MAXDOP 4)
            """
            
            # 设置查询超时和进度提示
            try:
                cursor.execute(query)
                results = cursor.fetchall()
            except Exception as query_error:
                print(f"查询执行失败: {query_error}")
                print(f"查询语句: {query[:200]}...")
                cursor.close()
                return []
            finally:
                cursor.close()
            
            # 转换数据并计算各店总计
            monthly_data = []
            store_totals = {}  # 按门店存储总计数据
            
            for row in results:
                store_name = str(row[0]) if row[0] else ''
                product = str(row[1]) if row[1] else ''
                month = str(row[2]) if row[2] else ''
                category = str(row[3]) if row[3] else ''
                qty = float(row[4]) if row[4] else 0.0
                amount = float(row[5]) if row[5] else 0.0
                total_amount_item = float(row[6]) if row[6] else 0.0
                receipt_count = int(row[7]) if row[7] else 0
                
                # 累计各店总计
                if store_name not in store_totals:
                    store_totals[store_name] = {
                        'qty': 0.0, 'amount': 0.0, 'total_amount': 0.0, 'receipt_count': 0
                    }
                store_totals[store_name]['qty'] += qty
                store_totals[store_name]['amount'] += amount
                store_totals[store_name]['total_amount'] += total_amount_item
                # 修復：不要累加單據數，因為同一張單據可能有多個產品
                # store_totals[store_name]['receipt_count'] += receipt_count
                
                monthly_data.append({
                    '月份': month,
                    '门市': store_name,
                    '类别': category,
                    '产品': product,
                    '卖出量': qty,
                    '金额': amount,
                    '总金额': total_amount_item,
                    '单据数': receipt_count,
                    '产品单据业绩': 0.0,  # 稍后计算
                    '金额占比(%)': 0.0,  # 稍后计算
                    '单据占比(%)': 0.0,   # 稍后计算
                    '产品单据业绩占比(%)': 0.0  # 稍后计算
                })
            
            # 获取产品单据业绩数据 - 使用專門的月度函數
            receipt_performance_data = self.get_monthly_product_receipt_performance_from_db(
                date_from=date_from, 
                date_to=date_to, 
                outlet_filters=outlet_filters,
                product_filters=product_filters,
                database_source=self.current_database
            )
            
            # 计算各店内的占比
            for data in monthly_data:
                store_name = data['门市']
                if store_name in store_totals:
                    store_total = store_totals[store_name]
                    # 计算基于该门店的占比
                    amount_ratio = (data['总金额'] / store_total['total_amount'] * 100) if store_total['total_amount'] > 0 else 0
                    receipt_ratio = (data['单据数'] / store_total['receipt_count'] * 100) if store_total['receipt_count'] > 0 else 0
                    data['金额占比(%)'] = round(amount_ratio, 2)
                    data['单据占比(%)'] = round(receipt_ratio, 2)
                    
                    # 计算产品单据业绩 - 使用組合鍵 (product_name, month, store_name)
                    month = data['月份']
                    product_name = data['产品']
                    key = f"{product_name}_{month}_{store_name}"
                    if key in receipt_performance_data:
                        data['产品单据业绩'] = receipt_performance_data[key]['产品单据业绩']
                        # 计算产品单据业绩占比
                        receipt_performance_ratio = (data['产品单据业绩'] / store_total['total_amount'] * 100) if store_total['total_amount'] > 0 else 0
                        data['产品单据业绩占比(%)'] = round(receipt_performance_ratio, 2)
                    else:
                        data['产品单据业绩'] = 0.0
                        data['产品单据业绩占比(%)'] = 0.0
            
            # 添加详细的总计结构
            if monthly_data:
                # 计算月份总计和全总计
                month_totals = {}
                grand_total_qty = 0.0
                grand_total_amount = 0.0
                grand_total_total_amount = 0.0
                grand_total_receipt_count = 0
                
                for data in monthly_data:
                    month = data['月份']
                    qty = data['卖出量']
                    amount = data['金额']
                    total_amount = data['总金额']
                    receipt_count = data['单据数']
                    
                    # 月份总计
                    if month not in month_totals:
                        month_totals[month] = {
                            'qty': 0.0, 'amount': 0.0, 'total_amount': 0.0, 'receipt_count': 0
                        }
                    month_totals[month]['qty'] += qty
                    month_totals[month]['amount'] += amount
                    month_totals[month]['total_amount'] += total_amount
                    # 修復：不要累加單據數，因為同一張單據可能有多個產品
                    # month_totals[month]['receipt_count'] += receipt_count
                    
                    # 全总计
                    grand_total_qty += qty
                    grand_total_amount += amount
                    grand_total_total_amount += total_amount
                    # 修復：不要累加單據數，因為同一張單據可能有多個產品
                    # grand_total_receipt_count += receipt_count
                
                # 添加各店总计（使用已有的store_totals）
                for store, totals in store_totals.items():
                    monthly_data.append({
                        '月份': f'【{store} 总计】',
                        '门市': store,
                        '类别': '',
                        '产品': '',
                        '卖出量': totals['qty'],
                        '金额': totals['amount'],
                        '总金额': totals['total_amount'],
                        '单据数': totals['receipt_count'],
                        '产品单据业绩': 0.0,  # 总计行不显示
                        '金额占比(%)': 0.00,  # 总计行不显示占比
                        '单据占比(%)': 0.00,  # 总计行不显示占比
                        '产品单据业绩占比(%)': 0.0  # 总计行不显示占比
                    })
                
                # 添加月份总计
                for month, totals in month_totals.items():
                    monthly_data.append({
                        '月份': f'【{month} 月份总计】',
                        '门市': '',
                        '类别': '',
                        '产品': '',
                        '卖出量': totals['qty'],
                        '金额': totals['amount'],
                        '总金额': totals['total_amount'],
                        '单据数': totals['receipt_count'],
                        '产品单据业绩': 0.0,  # 总计行不显示
                        '金额占比(%)': 0.00,  # 总计行不显示占比
                        '单据占比(%)': 0.00,  # 总计行不显示占比
                        '产品单据业绩占比(%)': 0.0  # 总计行不显示占比
                    })
                
                # 添加全总计
                monthly_data.append({
                    '月份': '【全总计】',
                    '门市': '',
                    '类别': '',
                    '产品': '',
                    '卖出量': grand_total_qty,
                    '金额': grand_total_amount,
                    '总金额': grand_total_total_amount,
                    '单据数': grand_total_receipt_count,
                    '产品单据业绩': 0.0,  # 总计行不显示
                    '金额占比(%)': 0.00,
                    '单据占比(%)': 0.00,
                    '产品单据业绩占比(%)': 0.0
                })
            
            # 存储到缓存
            if not hasattr(self, '_monthly_cache'):
                self._monthly_cache = {}
            self._monthly_cache[cache_key] = monthly_data
            
            # 限制缓存大小
            if len(self._monthly_cache) > 10:
                # 删除最旧的缓存项
                oldest_key = next(iter(self._monthly_cache))
                del self._monthly_cache[oldest_key]
            
            return monthly_data
            
        except Exception as e:
            print(f"获取月度汇总失败: {e}")
            return []

    def get_monthly_summary(self, date_from=None, date_to=None, outlet_filters=None, product_filters=None, month_filters=None, category_filters=None, payment_filters=None):
        """获取月度汇总"""
        if not self.connection:
            return []
        
        try:
            cursor = self.connection.cursor()
            
            # 构建WHERE条件
            conditions = []
            if date_from:
                conditions.append(f"CAST(s.c_date AS DATE) >= '{date_from}'")
            if date_to:
                conditions.append(f"CAST(s.c_date AS DATE) <= '{date_to}'")
            if outlet_filters and len(outlet_filters) > 0:
                outlet_conditions = " OR ".join([f"s.store_name = '{outlet}'" for outlet in outlet_filters])
                conditions.append(f"({outlet_conditions})")
            if product_filters and len(product_filters) > 0:
                product_conditions = " OR ".join([f"s.item_name = '{product}'" for product in product_filters])
                conditions.append(f"({product_conditions})")
            if month_filters and len(month_filters) > 0:
                month_conditions = " OR ".join([f"FORMAT(CAST(s.c_date AS DATE), 'yyyy-MM') = '{month}'" for month in month_filters])
                conditions.append(f"({month_conditions})")
            
            # 排除WASTAGE及其变体 - 优化版本，使用NOT IN代替多个LIKE
            conditions.append("s.item_name NOT IN ('WASTAGE', 'Waste', 'waste', 'WASTE')")
            
            # 如果有类别筛选，添加类别条件
            if category_filters and len(category_filters) > 0:
                category_conditions = " OR ".join([f"im.category_code = '{category}'" for category in category_filters])
                conditions.append(f"({category_conditions})")
            
            # 如果有支付方式筛选，需要JOIN支付表
            if payment_filters and len(payment_filters) > 0:
                payment_conditions = " OR ".join([f"p.payment_name = '{method}'" for method in payment_filters])
                # 仅按门市+单据号匹配，避免因c_date微差导致漏数
                conditions.append(f"EXISTS (SELECT 1 FROM {TABLE_PAYMENT} p WHERE s.sales_no = p.sales_no AND s.store_name = p.store_name AND ({payment_conditions}))")
            
            where_clause = ""
            if conditions:
                where_clause = " WHERE " + " AND ".join(conditions)
            
            # 查询月度汇总 - 优化版本，添加索引提示（保持原有正确逻辑）
            query = f"""
                SELECT 
                    s.store_name as 门市,
                    s.item_name as 产品,
                    FORMAT(s.c_date, 'yyyy-MM') as 月份,
                    ISNULL(im.category_code, '') as 类别,
                    SUM(CAST(s.qty as FLOAT)) as 卖出量,
                    SUM(CAST(s.sub_total as FLOAT)) as 金额,
                    SUM({self.get_performance_calculation_sql()}) as 总金额,
                    COUNT(*) as 单据数
                FROM {TABLE_SALES} s WITH (NOLOCK)
                LEFT JOIN (
                    SELECT item_name, category_code
                    FROM item_master im1 WITH (NOLOCK)
                    WHERE im1.m_date = (
                        SELECT MAX(m_date) 
                        FROM item_master im2 WITH (NOLOCK)
                        WHERE im2.item_name = im1.item_name
                    )
                ) im ON s.item_name = im.item_name
                {where_clause}
                GROUP BY s.store_name, s.item_name, FORMAT(s.c_date, 'yyyy-MM'), im.category_code
                ORDER BY 月份 DESC, s.store_name, s.item_name
                OPTION (RECOMPILE)
            """
            
            try:
                cursor.execute(query)
                results = cursor.fetchall()
            except Exception as query_error:
                print(f"查询执行失败: {query_error}")
                print(f"查询语句: {query[:200]}...")
                cursor.close()
                return []
            finally:
                cursor.close()
            
            # 转换数据并计算各店总计
            monthly_data = []
            store_totals = {}  # 按门店存储总计数据
            
            for row in results:
                store_name = str(row[0]) if row[0] else ''
                product = str(row[1]) if row[1] else ''
                month = str(row[2]) if row[2] else ''
                category = str(row[3]) if row[3] else ''
                qty = float(row[4]) if row[4] else 0.0
                amount = float(row[5]) if row[5] else 0.0
                total_amount_item = float(row[6]) if row[6] else 0.0
                receipt_count = int(row[7]) if row[7] else 0
                
                # 累计各店总计
                if store_name not in store_totals:
                    store_totals[store_name] = {
                        'qty': 0.0, 'amount': 0.0, 'total_amount': 0.0, 'receipt_count': 0
                    }
                store_totals[store_name]['qty'] += qty
                store_totals[store_name]['amount'] += amount
                store_totals[store_name]['total_amount'] += total_amount_item
                # 修復：不要累加單據數，因為同一張單據可能有多個產品
                # store_totals[store_name]['receipt_count'] += receipt_count
                
                monthly_data.append({
                    '月份': month,
                    '门市': store_name,
                    '类别': category,
                    '产品': product,
                    '卖出量': qty,
                    '金额': amount,
                    '总金额': total_amount_item,
                    '单据数': receipt_count,
                    '产品单据业绩': 0.0,  # 稍后计算
                    '金额占比(%)': 0.0,  # 稍后计算
                    '单据占比(%)': 0.0,   # 稍后计算
                    '产品单据业绩占比(%)': 0.0  # 稍后计算
                })
            
            # 获取产品单据业绩数据 - 使用專門的月度函數
            receipt_performance_data = self.get_monthly_product_receipt_performance_from_db(
                date_from=date_from, 
                date_to=date_to, 
                outlet_filters=outlet_filters,
                product_filters=product_filters,
                database_source=self.current_database
            )
            
            # 计算各店内的占比
            for data in monthly_data:
                store_name = data['门市']
                if store_name in store_totals:
                    store_total = store_totals[store_name]
                    # 计算基于该门店的占比
                    amount_ratio = (data['总金额'] / store_total['total_amount'] * 100) if store_total['total_amount'] > 0 else 0
                    receipt_ratio = (data['单据数'] / store_total['receipt_count'] * 100) if store_total['receipt_count'] > 0 else 0
                    data['金额占比(%)'] = round(amount_ratio, 2)
                    data['单据占比(%)'] = round(receipt_ratio, 2)
                    
                    # 计算产品单据业绩 - 使用組合鍵 (product_name, month, store_name)
                    month = data['月份']
                    product_name = data['产品']
                    key = f"{product_name}_{month}_{store_name}"
                    if key in receipt_performance_data:
                        data['产品单据业绩'] = receipt_performance_data[key]['产品单据业绩']
                        # 计算产品单据业绩占比
                        receipt_performance_ratio = (data['产品单据业绩'] / store_total['total_amount'] * 100) if store_total['total_amount'] > 0 else 0
                        data['产品单据业绩占比(%)'] = round(receipt_performance_ratio, 2)
                    else:
                        data['产品单据业绩'] = 0.0
                        data['产品单据业绩占比(%)'] = 0.0
            
            # 添加详细的总计结构
            if monthly_data:
                # 计算月份总计和全总计
                month_totals = {}
                grand_total_qty = 0.0
                grand_total_amount = 0.0
                grand_total_total_amount = 0.0
                grand_total_receipt_count = 0
                
                for data in monthly_data:
                    month = data['月份']
                    qty = data['卖出量']
                    amount = data['金额']
                    total_amount = data['总金额']
                    receipt_count = data['单据数']
                    
                    # 月份总计
                    if month not in month_totals:
                        month_totals[month] = {
                            'qty': 0.0, 'amount': 0.0, 'total_amount': 0.0, 'receipt_count': 0
                        }
                    month_totals[month]['qty'] += qty
                    month_totals[month]['amount'] += amount
                    month_totals[month]['total_amount'] += total_amount
                    # 修復：不要累加單據數，因為同一張單據可能有多個產品
                    # month_totals[month]['receipt_count'] += receipt_count
                    
                    # 全总计
                    grand_total_qty += qty
                    grand_total_amount += amount
                    grand_total_total_amount += total_amount
                    # 修復：不要累加單據數，因為同一張單據可能有多個產品
                    # grand_total_receipt_count += receipt_count
                
                # 添加各店总计（使用已有的store_totals）
                for store, totals in store_totals.items():
                    monthly_data.append({
                        '月份': f'【{store} 总计】',
                        '门市': store,
                        '类别': '',
                        '产品': '',
                        '卖出量': totals['qty'],
                        '金额': totals['amount'],
                        '总金额': totals['total_amount'],
                        '单据数': totals['receipt_count'],
                        '金额占比(%)': 0.00,  # 总计行不显示占比
                        '单据占比(%)': 0.00  # 总计行不显示占比
                    })
                
                # 添加月份总计
                for month, totals in month_totals.items():
                    monthly_data.append({
                        '月份': f'【{month} 月份总计】',
                    '门市': '',
                    '类别': '',
                    '产品': '',
                        '卖出量': totals['qty'],
                        '金额': totals['amount'],
                        '总金额': totals['total_amount'],
                        '单据数': totals['receipt_count'],
                        '金额占比(%)': 0.00,  # 总计行不显示占比
                        '单据占比(%)': 0.00  # 总计行不显示占比
                    })
                
                # 添加全总计
                monthly_data.append({
                    '月份': '【全总计】',
                    '门市': '',
                    '类别': '',
                    '产品': '',
                    '卖出量': grand_total_qty,
                    '金额': grand_total_amount,
                    '总金额': grand_total_total_amount,
                    '单据数': grand_total_receipt_count,
                    '金额占比(%)': 0.00,  # 总计行不显示占比
                    '单据占比(%)': 0.00  # 总计行不显示占比
                })
            
            return monthly_data
            
        except Exception as e:
            print(f"获取月度汇总失败: {e}")
            return []
    
    def get_sales_analysis(self, date_from=None, date_to=None, outlet_filters=None, month_filters=None, weekday_filters=None, category_filters=None, payment_filters=None):
        """获取Sales分析 - 按日期和门市汇总"""
        if not self.connection:
            return []
        
        try:
            cursor = self.connection.cursor()
            
            # 构建WHERE条件
            conditions = []
            
            if date_from:
                conditions.append(f"CAST(s.c_date AS DATE) >= '{date_from}'")
            if date_to:
                conditions.append(f"CAST(s.c_date AS DATE) <= '{date_to}'")
            if outlet_filters and len(outlet_filters) > 0:
                outlet_conditions = " OR ".join([f"s.store_name = '{outlet}'" for outlet in outlet_filters])
                conditions.append(f"({outlet_conditions})")
            if month_filters and len(month_filters) > 0:
                month_conditions = " OR ".join([f"FORMAT(CAST(s.c_date AS DATE), 'yyyy-MM') = '{month}'" for month in month_filters])
                conditions.append(f"({month_conditions})")
            if category_filters and len(category_filters) > 0:
                category_conditions = " OR ".join([f"s.item_category = '{category}'" for category in category_filters])
                conditions.append(f"({category_conditions})")
            if payment_filters and len(payment_filters) > 0:
                payment_conditions = " OR ".join([f"p.payment_name = '{payment}'" for payment in payment_filters])
                conditions.append(f"({payment_conditions})")
            
            # 排除WASTAGE及其变体 - 优化版本，使用NOT IN代替多个LIKE
            conditions.append("s.item_name NOT IN ('WASTAGE', 'Waste', 'waste', 'WASTE')")
            
            where_clause = ""
            if conditions:
                where_clause = " WHERE " + " AND ".join(conditions)
            
            # 查询Sales分析
            query = f"""
                SELECT 
                    FORMAT(s.c_date, 'yyyy-MM-dd') as 日期,
                    s.store_name as 门市,
                    SUM({self.get_performance_calculation_sql()}
                        - ISNULL(CAST(c.cancel_amount as FLOAT), 0)) as 总业绩,
                    COUNT(DISTINCT CONCAT(s.store_name, '-', s.sales_no)) as 单据数
                FROM pos_sales_dtls s
                LEFT JOIN pos_sales_payment_dtls p ON s.sales_no = p.sales_no AND s.store_name = p.store_name AND s.c_date = p.c_date
                {where_clause}
                AND s.item_name != 'WASTAGE'
                GROUP BY FORMAT(s.c_date, 'yyyy-MM-dd'), s.store_name
                ORDER BY FORMAT(s.c_date, 'yyyy-MM-dd'), s.store_name
            """
            
            cursor.execute(query)
            results = cursor.fetchall()
            
            sales_data = []
            for row in results:
                sales_data.append({
                    '日期': row[0],
                    '门市': row[1],
                    '总业绩': float(row[2]) if row[2] else 0.0,
                    '单据数': int(row[3]) if row[3] else 0
                })
            
            return sales_data
            
        except Exception as e:
            print(f"获取Sales分析失败: {e}")
            return []
    
    def get_tc_analysis(self, date_from=None, date_to=None, outlet_filters=None, product_filters=None, month_filters=None, weekday_filters=None, category_filters=None, payment_filters=None):
        """获取TC分析 - 门市业绩对比分析"""
        if not self.connection:
            return []
        
        try:
            cursor = self.connection.cursor()
            
            # 构建WHERE条件
            conditions = []
            
            if date_from:
                conditions.append(f"CAST(s.c_date AS DATE) >= '{date_from}'")
            if date_to:
                conditions.append(f"CAST(s.c_date AS DATE) <= '{date_to}'")
            if outlet_filters and len(outlet_filters) > 0:
                outlet_conditions = " OR ".join([f"s.store_name = '{outlet}'" for outlet in outlet_filters])
                conditions.append(f"({outlet_conditions})")
            if month_filters and len(month_filters) > 0:
                month_conditions = " OR ".join([f"FORMAT(CAST(s.c_date AS DATE), 'yyyy-MM') = '{month}'" for month in month_filters])
                conditions.append(f"({month_conditions})")
            if category_filters and len(category_filters) > 0:
                category_conditions = " OR ".join([f"s.item_category = '{category}'" for category in category_filters])
                conditions.append(f"({category_conditions})")
            if payment_filters and len(payment_filters) > 0:
                payment_conditions = " OR ".join([f"p.payment_name = '{payment}'" for payment in payment_filters])
                conditions.append(f"({payment_conditions})")
            
            # 排除WASTAGE及其变体 - 优化版本，使用NOT IN代替多个LIKE
            conditions.append("s.item_name NOT IN ('WASTAGE', 'Waste', 'waste', 'WASTE')")
            
            where_clause = ""
            if conditions:
                where_clause = " WHERE " + " AND ".join(conditions)
            
            # 查询TC分析
            query = f"""
                SELECT 
                    s.store_name as 门市,
                    SUM({self.get_performance_calculation_sql()}
                        - ISNULL(CAST(c.cancel_amount as FLOAT), 0)) as 总业绩,
                    COUNT(DISTINCT CONCAT(s.store_name, '-', s.sales_no)) as 总单据数,
                    SUM(CASE WHEN s.item_name IN ({','.join([f"'{product}'" for product in product_filters]) if product_filters and len(product_filters) > 0 else "''"}) THEN CAST(s.sub_total as FLOAT) - CAST(ISNULL(s.pro_disc_amt, 0) as FLOAT) + CAST(ISNULL(s.svc_amt, 0) as FLOAT) - 
                        CASE WHEN s.take_away_item = 'Y' THEN CAST(ISNULL(s.tax_amt, 0) as FLOAT) ELSE 0 END
                        - ISNULL(CAST(c.cancel_amount as FLOAT), 0) ELSE 0 END) as 产品业绩,
                    COUNT(DISTINCT CASE WHEN s.item_name IN ({','.join([f"'{product}'" for product in product_filters]) if product_filters and len(product_filters) > 0 else "''"}) THEN s.sales_no ELSE NULL END) as 产品单据数
                FROM pos_sales_dtls s
                LEFT JOIN pos_sales_payment_dtls p ON s.sales_no = p.sales_no AND s.store_name = p.store_name AND s.c_date = p.c_date
                {where_clause}
                AND s.item_name != 'WASTAGE'
                GROUP BY s.store_name
                ORDER BY s.store_name
            """
            
            cursor.execute(query)
            results = cursor.fetchall()
            
            tc_data = []
            for row in results:
                total_amount = float(row[1]) if row[1] else 0.0
                total_receipts = int(row[2]) if row[2] else 0
                product_amount = float(row[3]) if row[3] else 0.0
                product_receipts = int(row[4]) if row[4] else 0
                
                # 计算占比
                amount_percentage = (product_amount / total_amount * 100) if total_amount > 0 else 0.0
                receipt_percentage = (product_receipts / total_receipts * 100) if total_receipts > 0 else 0.0
                
                tc_data.append({
                    '门市': row[0],
                    '总业绩': total_amount,
                    '总单据数': total_receipts,
                    '产品业绩': product_amount,
                    '产品单据数': product_receipts,
                    '业绩占比(%)': amount_percentage,
                    '单据数占比(%)': receipt_percentage
                })
            
            return tc_data
            
        except Exception as e:
            print(f"获取TC分析失败: {e}")
            return []
    
    def get_sales_tc_analysis(self, date_from=None, date_to=None, outlet_filters=None, product_filters=None, month_filters=None, weekday_filters=None, category_filters=None, payment_filters=None):
        """获取销售TC分析 - 优化版本"""
        print(f"get_sales_tc_analysis 被调用，参数: date_from={date_from}, date_to={date_to}")
        print(f"数据库连接状态: {self.connection is not None}")
        if not self.connection:
            print("❌ 数据库未连接，无法执行日-产品分析查询")
            return []
        
        # 检查缓存
        cache_key = f"sales_tc_{self.current_database}_{date_from}_{date_to}_{outlet_filters}_{product_filters}_{month_filters}_{weekday_filters}_{category_filters}_{payment_filters}"
        if hasattr(self, '_sales_tc_cache') and cache_key in self._sales_tc_cache:
            print("✓ 使用缓存的销售TC分析数据")
            return self._sales_tc_cache[cache_key]
        
        try:
            cursor = self.connection.cursor()
            
            # 构建基础WHERE条件
            conditions = []
            
            if date_from and date_to:
                conditions.append(f"s.c_date >= '{date_from} 00:00:00' AND s.c_date <= '{date_to} 23:59:59'")
            if outlet_filters and len(outlet_filters) > 0:
                outlet_conditions = " OR ".join([f"s.store_name = '{outlet}'" for outlet in outlet_filters])
                conditions.append(f"({outlet_conditions})")
            if month_filters and len(month_filters) > 0:
                month_conditions = " OR ".join([f"FORMAT(s.c_date, 'yyyy-MM') = '{month}'" for month in month_filters])
                conditions.append(f"({month_conditions})")
            if weekday_filters and len(weekday_filters) > 0:
                print(f"应用星期筛选: {weekday_filters}")
                # 使用DATEPART来获取星期几，1=Sunday, 2=Monday, ..., 7=Saturday
                weekday_mapping = {
                    'Sunday': 1, 'Monday': 2, 'Tuesday': 3, 'Wednesday': 4, 
                    'Thursday': 5, 'Friday': 6, 'Saturday': 7
                }
                weekday_values = [str(weekday_mapping.get(weekday, 0)) for weekday in weekday_filters if weekday_mapping.get(weekday, 0) > 0]
                if weekday_values:
                    weekday_conditions = " OR ".join([f"DATEPART(WEEKDAY, s.c_date) = {value}" for value in weekday_values])
                    conditions.append(f"({weekday_conditions})")
                    print(f"星期筛选SQL条件: {weekday_conditions}")
            if category_filters and len(category_filters) > 0:
                category_conditions = " OR ".join([f"s.item_category = '{category}'" for category in category_filters])
                conditions.append(f"({category_conditions})")
            if payment_filters and len(payment_filters) > 0:
                payment_conditions = " OR ".join([f"p.payment_name = '{payment}'" for payment in payment_filters])
                conditions.append(f"EXISTS (SELECT 1 FROM pos_sales_payment_dtls p WHERE s.sales_no = p.sales_no AND s.store_name = p.store_name AND ({payment_conditions}))")
            
            # 排除WASTAGE及其变体 - 优化版本，使用NOT IN代替多个LIKE
            conditions.append("s.item_name NOT IN ('WASTAGE', 'Waste', 'waste', 'WASTE')")
            
            
            # 构建额外的WHERE条件（不包含日期条件，因为日期条件会单独添加）
            additional_conditions = []
            if outlet_filters and len(outlet_filters) > 0:
                outlet_conditions = " OR ".join([f"s.store_name = '{outlet}'" for outlet in outlet_filters])
                additional_conditions.append(f"({outlet_conditions})")
            if month_filters and len(month_filters) > 0:
                month_conditions = " OR ".join([f"FORMAT(s.c_date, 'yyyy-MM') = '{month}'" for month in month_filters])
                additional_conditions.append(f"({month_conditions})")
            if weekday_filters and len(weekday_filters) > 0:
                weekday_mapping = {
                    'Sunday': 1, 'Monday': 2, 'Tuesday': 3, 'Wednesday': 4, 
                    'Thursday': 5, 'Friday': 6, 'Saturday': 7
                }
                weekday_values = [str(weekday_mapping.get(weekday, 0)) for weekday in weekday_filters if weekday_mapping.get(weekday, 0) > 0]
                if weekday_values:
                    weekday_conditions = " OR ".join([f"DATEPART(WEEKDAY, s.c_date) = {value}" for value in weekday_values])
                    additional_conditions.append(f"({weekday_conditions})")
            if category_filters and len(category_filters) > 0:
                category_conditions = " OR ".join([f"s.item_category = '{category}'" for category in category_filters])
                additional_conditions.append(f"({category_conditions})")
            if payment_filters and len(payment_filters) > 0:
                payment_conditions = " OR ".join([f"p.payment_name = '{payment}'" for payment in payment_filters])
                additional_conditions.append(f"EXISTS (SELECT 1 FROM pos_sales_payment_dtls p WHERE s.sales_no = p.sales_no AND s.store_name = p.store_name AND ({payment_conditions}))")
            
            additional_where = ""
            if additional_conditions:
                additional_where = " AND " + " AND ".join(additional_conditions)
            
            where_clause = ""
            if conditions:
                where_clause = " WHERE " + " AND ".join(conditions)
            
            # 构建产品筛选条件
            product_condition = ""
            if product_filters and len(product_filters) > 0:
                product_list = "','".join(product_filters)
                product_condition = f"AND s.item_name IN ('{product_list}')"
            # 如果没有选择产品，不添加额外的筛选条件，让所有产品都包含在产品业绩中
            
            # 优化的查询 - 使用CTE提高性能
            query = f"""
                WITH DailyTotals AS (
                    SELECT 
                        FORMAT(s.c_date, 'yyyy-MM-dd') as 日期,
                        s.store_name as 门市,
                        SUM({self.get_performance_calculation_sql()} - 
                            ISNULL(CAST(c.cancel_amount as FLOAT), 0)) as 总业绩,
                        COUNT(DISTINCT CONCAT(s.store_name, '-', s.sales_no)) as 总单据数,
                        SUM(CAST(ISNULL(s.qty, 0) as FLOAT) - ISNULL(CAST(c.cancel_qty as FLOAT), 0)) as 总销售数量
                    FROM pos_sales_dtls s
                    LEFT JOIN (
                        SELECT 
                            sales_no, 
                            store_name, 
                            item_name,
                            SUM({self._get_cancel_performance_calculation_sql()}) as cancel_amount,
                            SUM(CAST(qty as FLOAT)) as cancel_qty
                        FROM pos_cancel_sales_item_dtls WITH (NOLOCK)
                        GROUP BY sales_no, store_name, item_name
                    ) c ON s.sales_no = c.sales_no AND s.store_name = c.store_name AND s.item_name = c.item_name
                    WHERE s.item_name != 'WASTAGE'
                    {f"AND s.c_date >= '{date_from} 00:00:00' AND s.c_date <= '{date_to} 23:59:59'" if date_from and date_to else ""}
                    {f"AND ({' OR '.join([f's.store_name = \'{outlet}\'' for outlet in outlet_filters])})" if outlet_filters and len(outlet_filters) > 0 else ""}
                    {additional_where if 'additional_where' in locals() else ""}
                    GROUP BY FORMAT(s.c_date, 'yyyy-MM-dd'), s.store_name
                ),
                ProductTotals AS (
                    SELECT 
                        FORMAT(s.c_date, 'yyyy-MM-dd') as 日期,
                        s.store_name as 门市,
                        SUM({self.get_performance_calculation_sql()} - 
                            ISNULL(CAST(c.cancel_amount as FLOAT), 0)) as 产品业绩,
                        COUNT(DISTINCT CONCAT(s.store_name, '-', s.sales_no)) as 产品单据数,
                        SUM(CAST(ISNULL(s.qty, 0) as FLOAT) - ISNULL(CAST(c.cancel_qty as FLOAT), 0)) as 产品销售数量
                    FROM pos_sales_dtls s
                    LEFT JOIN (
                        SELECT 
                            sales_no, 
                            store_name, 
                            item_name,
                            SUM({self._get_cancel_performance_calculation_sql()}) as cancel_amount,
                            SUM(CAST(qty as FLOAT)) as cancel_qty
                        FROM pos_cancel_sales_item_dtls WITH (NOLOCK)
                        GROUP BY sales_no, store_name, item_name
                    ) c ON s.sales_no = c.sales_no AND s.store_name = c.store_name AND s.item_name = c.item_name
                    WHERE s.item_name != 'WASTAGE'
                    {f"AND s.c_date >= '{date_from} 00:00:00' AND s.c_date <= '{date_to} 23:59:59'" if date_from and date_to else ""}
                    {additional_where if 'additional_where' in locals() else ""}
                    {product_condition}
                    GROUP BY FORMAT(s.c_date, 'yyyy-MM-dd'), s.store_name
                ),
                ProductReceiptPerformance AS (
                    SELECT
                        FORMAT(target_item.c_date, 'yyyy-MM-dd') as 日期,
                        target_item.store_name as 门市,
                        SUM(receipt_totals.receipt_total) as 产品单据业绩
                    FROM (
                        -- 获取目标产品的单据信息
                        SELECT DISTINCT s.c_date, s.store_name, s.sales_no
                        FROM pos_sales_dtls s WITH (NOLOCK)
                        WHERE s.item_name != 'WASTAGE'
                        {f"AND s.c_date >= '{date_from} 00:00:00' AND s.c_date <= '{date_to} 23:59:59'" if date_from and date_to else ""}
                        {f"AND ({' OR '.join([f's.store_name = \'{outlet}\'' for outlet in outlet_filters])})" if outlet_filters and len(outlet_filters) > 0 else ""}
                        {additional_where if 'additional_where' in locals() else ""}
                        {product_condition}
                    ) target_item
                    INNER JOIN (
                        -- 计算每个单据的总金额
                        SELECT 
                            s.c_date,
                            s.store_name,
                            s.sales_no,
                            SUM(CAST(s.sub_total as FLOAT) - CAST(ISNULL(s.pro_disc_amt, 0) as FLOAT) - CAST(ISNULL(s.disc_amt, 0) as FLOAT) + CAST(ISNULL(s.svc_amt, 0) as FLOAT) - CASE WHEN s.take_away_item = 'Y' THEN CAST(ISNULL(s.tax_amt, 0) as FLOAT) ELSE 0 END) as receipt_total
                        FROM pos_sales_dtls s WITH (NOLOCK)
                        WHERE s.item_name != 'WASTAGE'
                        {f"AND s.c_date >= '{date_from} 00:00:00' AND s.c_date <= '{date_to} 23:59:59'" if date_from and date_to else ""}
                        {f"AND ({' OR '.join([f's.store_name = \'{outlet}\'' for outlet in outlet_filters])})" if outlet_filters and len(outlet_filters) > 0 else ""}
                        GROUP BY s.c_date, s.store_name, s.sales_no
                    ) receipt_totals ON target_item.sales_no = receipt_totals.sales_no AND target_item.store_name = receipt_totals.store_name AND target_item.c_date = receipt_totals.c_date
                    GROUP BY FORMAT(target_item.c_date, 'yyyy-MM-dd'), target_item.store_name
                )
                SELECT 
                    dt.日期,
                    dt.门市,
                    dt.总业绩,
                    dt.总单据数,
                    dt.总销售数量,
                    ISNULL(pt.产品业绩, 0) as 产品业绩,
                    ISNULL(pt.产品单据数, 0) as 产品单据数,
                    ISNULL(pt.产品销售数量, 0) as 产品销售数量,
                    ISNULL(prp.产品单据业绩, 0) as 产品单据业绩
                FROM DailyTotals dt
                LEFT JOIN ProductTotals pt ON dt.日期 = pt.日期 AND dt.门市 = pt.门市
                LEFT JOIN ProductReceiptPerformance prp ON dt.日期 = prp.日期 AND dt.门市 = prp.门市
                ORDER BY dt.日期, dt.门市
                OPTION (RECOMPILE, MAXDOP 4)
            """
            
            print(f"开始执行销售TC分析查询...")
            print(f"查询参数: date_from={date_from}, date_to={date_to}")
            print(f"筛选条件: outlet_filters={outlet_filters}, product_filters={product_filters}, month_filters={month_filters}, weekday_filters={weekday_filters}, category_filters={category_filters}, payment_filters={payment_filters}")
            print(f"SQL查询: {query}")
            start_time = time.time()
            
            # 添加数据库连接状态检查
            if not self.connection:
                print("❌ 数据库连接为空，无法执行日-产品分析查询")
                return []
            
            try:
                # 先执行简单测试查询
                test_query = f"SELECT COUNT(*) FROM pos_sales_dtls WHERE CAST(c_date as DATE) = '{date_from}'"
                print(f"🔍 执行测试查询: {test_query}")
                cursor.execute(test_query)
                test_result = cursor.fetchone()
                print(f"🔍 测试查询结果 - {date_from} 的记录数: {test_result[0] if test_result else 0}")
                
                if test_result and test_result[0] == 0:
                    print(f"❌ {date_from} 没有销售数据")
                    return []
                
                cursor.execute(query)
                results = cursor.fetchall()
                
                end_time = time.time()
                print(f"销售TC分析查询完成，耗时: {end_time - start_time:.2f} 秒")
                print(f"销售TC分析查询结果: {len(results)} 条记录")
                if results:
                    print(f"第一条记录: {results[0]}")
                else:
                    print(f"查询返回0条记录，请检查筛选条件和数据库中的数据")
            except Exception as query_error:
                print(f"❌ 日-产品分析SQL查询执行失败: {query_error}")
                print(f"❌ 查询语句: {query}")
                import traceback
                print(f"错误详情: {traceback.format_exc()}")
                return []
            
            sales_tc_data = []
            for row in results:
                total_amount = float(row[2]) if row[2] else 0.0
                total_receipts = int(row[3]) if row[3] else 0
                total_quantity = float(row[4]) if row[4] else 0.0
                product_amount = float(row[5]) if row[5] else 0.0
                product_receipts = int(row[6]) if row[6] else 0
                product_quantity = float(row[7]) if row[7] else 0.0
                product_receipt_performance = float(row[8]) if row[8] else 0.0
                
                # 计算占比
                amount_percentage = (product_amount / total_amount * 100) if total_amount > 0 else 0.0
                receipt_percentage = (product_receipts / total_receipts * 100) if total_receipts > 0 else 0.0
                quantity_percentage = (product_quantity / total_quantity * 100) if total_quantity > 0 else 0.0
                product_receipt_performance_percentage = (product_receipt_performance / total_amount * 100) if total_amount > 0 else 0.0
                
                sales_tc_data.append({
                    '日期': row[0],
                    '门市': row[1],
                    '总业绩': total_amount,
                    '总单据数': total_receipts,
                    '总销售数量': total_quantity,
                    '产品业绩': product_amount,
                    '产品单据数': product_receipts,
                    '产品销售数量': product_quantity,
                    '产品单据业绩': product_receipt_performance,
                    '业绩占比(%)': amount_percentage,
                    '单据数占比(%)': receipt_percentage,
                    '销售数量占比(%)': quantity_percentage,
                    '产品单据业绩占比(%)': product_receipt_performance_percentage
                })
            
            # 存储到缓存
            if not hasattr(self, '_sales_tc_cache'):
                self._sales_tc_cache = {}
            self._sales_tc_cache[cache_key] = sales_tc_data
            
            # 限制缓存大小
            if len(self._sales_tc_cache) > 10:
                # 删除最旧的缓存项
                oldest_key = next(iter(self._sales_tc_cache))
                del self._sales_tc_cache[oldest_key]
            
            return sales_tc_data
            
        except Exception as e:
            import traceback
            error_details = traceback.format_exc()
            print(f"获取销售TC分析失败: {e}")
            print(f"错误详情: {error_details}")
            return []
    
    def get_sales_tc_monthly_analysis(self, date_from=None, date_to=None, outlet_filters=None, product_filters=None, month_filters=None, weekday_filters=None, category_filters=None, payment_filters=None):
        """获取销售TC月度汇总分析 - 优化版本"""
        if not self.connection:
            return []
        
        # 检查缓存
        cache_key = f"sales_tc_monthly_{self.current_database}_{date_from}_{date_to}_{outlet_filters}_{product_filters}_{month_filters}_{weekday_filters}_{category_filters}_{payment_filters}"
        if hasattr(self, '_sales_tc_monthly_cache') and cache_key in self._sales_tc_monthly_cache:
            print("✓ 使用缓存的月度产品分析数据")
            return self._sales_tc_monthly_cache[cache_key]
        
        try:
            cursor = self.connection.cursor()
            
            # 构建基础WHERE条件
            conditions = []
            
            if date_from and date_to:
                conditions.append(f"s.c_date >= '{date_from} 00:00:00' AND s.c_date <= '{date_to} 23:59:59'")
            if outlet_filters and len(outlet_filters) > 0:
                outlet_conditions = " OR ".join([f"s.store_name = '{outlet}'" for outlet in outlet_filters])
                conditions.append(f"({outlet_conditions})")
            if month_filters and len(month_filters) > 0:
                month_conditions = " OR ".join([f"FORMAT(s.c_date, 'yyyy-MM') = '{month}'" for month in month_filters])
                conditions.append(f"({month_conditions})")
            if weekday_filters and len(weekday_filters) > 0:
                print(f"应用星期筛选: {weekday_filters}")
                # 使用DATEPART来获取星期几，1=Sunday, 2=Monday, ..., 7=Saturday
                weekday_mapping = {
                    'Sunday': 1, 'Monday': 2, 'Tuesday': 3, 'Wednesday': 4, 
                    'Thursday': 5, 'Friday': 6, 'Saturday': 7
                }
                weekday_values = [str(weekday_mapping.get(weekday, 0)) for weekday in weekday_filters if weekday_mapping.get(weekday, 0) > 0]
                if weekday_values:
                    weekday_conditions = " OR ".join([f"DATEPART(WEEKDAY, s.c_date) = {value}" for value in weekday_values])
                    conditions.append(f"({weekday_conditions})")
                    print(f"星期筛选SQL条件: {weekday_conditions}")
            if category_filters and len(category_filters) > 0:
                category_conditions = " OR ".join([f"s.item_category = '{category}'" for category in category_filters])
                conditions.append(f"({category_conditions})")
            if payment_filters and len(payment_filters) > 0:
                payment_conditions = " OR ".join([f"p.payment_name = '{payment}'" for payment in payment_filters])
                conditions.append(f"EXISTS (SELECT 1 FROM pos_sales_payment_dtls p WHERE s.sales_no = p.sales_no AND s.store_name = p.store_name AND ({payment_conditions}))")
            
            # 排除WASTAGE及其变体 - 优化版本，使用NOT IN代替多个LIKE
            conditions.append("s.item_name NOT IN ('WASTAGE', 'Waste', 'waste', 'WASTE')")
            
            where_clause = ""
            if conditions:
                where_clause = " WHERE " + " AND ".join(conditions)
            
            # 构建产品筛选条件
            product_condition = ""
            if product_filters and len(product_filters) > 0:
                product_list = "','".join(product_filters)
                product_condition = f"AND s.item_name IN ('{product_list}')"
            # 如果没有选择产品，不添加额外的筛选条件，让所有产品都包含在产品业绩中
            
            # 使用本地數據庫獲取產品單據業績
            receipt_performance_data = self.get_product_receipt_performance_from_db(
                date_from=date_from, 
                date_to=date_to, 
                product_filters=product_filters,
                database_source=self.current_database
            )
            
            # 簡化的月度查詢
            query = f"""
                    SELECT 
                        FORMAT(s.c_date, 'yyyy-MM') as 月份,
                        s.store_name as 门市,
                        SUM({self.get_performance_calculation_sql()}) as 总业绩,
                        COUNT(DISTINCT CONCAT(s.store_name, '-', s.sales_no)) as 总单据数,
                    SUM(CAST(ISNULL(s.qty, 0) as FLOAT)) as 总销售数量,
                        SUM({self.get_performance_calculation_sql()}) as 产品业绩,
                        COUNT(DISTINCT CONCAT(s.store_name, '-', s.sales_no)) as 产品单据数,
                    SUM(CAST(ISNULL(s.qty, 0) as FLOAT)) as 产品销售数量,
                    0 as 产品单据业绩
                    FROM pos_sales_dtls s
                    {where_clause}
                    GROUP BY FORMAT(s.c_date, 'yyyy-MM'), s.store_name
                ORDER BY FORMAT(s.c_date, 'yyyy-MM'), s.store_name
                OPTION (RECOMPILE, MAXDOP 4)
            """
            
            print(f"开始执行销售TC月度汇总查询...")
            print(f"查询参数: date_from={date_from}, date_to={date_to}")
            print(f"筛选条件: outlet_filters={outlet_filters}, product_filters={product_filters}, month_filters={month_filters}, weekday_filters={weekday_filters}, category_filters={category_filters}, payment_filters={payment_filters}")
            print(f"SQL查询: {query}")
            start_time = time.time()
            
            try:
                # 先执行简单测试查询
                test_query = f"SELECT COUNT(*) FROM pos_sales_dtls WHERE CAST(c_date as DATE) = '{date_from}'"
                print(f"🔍 执行测试查询: {test_query}")
                cursor.execute(test_query)
                test_result = cursor.fetchone()
                print(f"🔍 测试查询结果 - {date_from} 的记录数: {test_result[0] if test_result else 0}")
                
                if test_result and test_result[0] == 0:
                    print(f"❌ {date_from} 没有销售数据")
                    return []
                
                cursor.execute(query)
                results = cursor.fetchall()
                
                end_time = time.time()
                print(f"销售TC月度汇总查询完成，耗时: {end_time - start_time:.2f} 秒")
                print(f"销售TC月度汇总查询结果: {len(results)} 条记录")
                if results:
                    print(f"第一条记录: {results[0]}")
                else:
                    print(f"月度查询返回0条记录，请检查筛选条件和数据库中的数据")
                    
            except Exception as query_error:
                print(f"❌ 月度产品分析SQL查询执行失败: {query_error}")
                print(f"❌ 查询语句: {query}")
                import traceback
                print(f"错误详情: {traceback.format_exc()}")
                return []
            
            # 計算總的產品單據業績
            total_product_receipt_performance = sum(
                data['产品单据业绩'] for data in receipt_performance_data.values()
            )
            
            sales_tc_monthly_data = []
            for row in results:
                month = str(row[0]) if row[0] else ''
                store = str(row[1]) if row[1] else ''
                total_sales = float(row[2]) if row[2] else 0.0
                total_receipts = int(row[3]) if row[3] else 0
                total_quantity = float(row[4]) if row[4] else 0.0
                product_sales = float(row[5]) if row[5] else 0.0
                product_receipts = int(row[6]) if row[6] else 0
                product_quantity = float(row[7]) if row[7] else 0.0
                
                # 從本地數據庫獲取產品單據業績（月度匯總）- 按門市分別計算
                product_receipt_performance = 0.0
                if receipt_performance_data:
                    # 月-銷售數據：按各門市的單據分別計算產品單據業績
                    # 根據該門市的產品業績占總業績的比例來分配產品單據業績
                    total_all_product_sales = sum(float(row[5]) for row in results)  # 所有門市的產品業績總和
                    if total_all_product_sales > 0 and product_sales > 0:
                        # 按該門市產品業績占總產品業績的比例分配產品單據業績
                        product_sales_ratio = product_sales / total_all_product_sales
                        total_product_receipt_performance = sum(data['产品单据业绩'] for data in receipt_performance_data.values())
                        product_receipt_performance = total_product_receipt_performance * product_sales_ratio
                
                # 计算占比
                sales_ratio = (product_sales / total_sales * 100) if total_sales > 0 else 0
                receipt_ratio = (product_receipts / total_receipts * 100) if total_receipts > 0 else 0
                quantity_ratio = (product_quantity / total_quantity * 100) if total_quantity > 0 else 0
                product_receipt_performance_ratio = (product_receipt_performance / total_sales * 100) if total_sales > 0 else 0
                
                sales_tc_monthly_data.append({
                    '月份': month,
                    '门市': store,
                    '总业绩': total_sales,
                    '总单据数': total_receipts,
                    '总销售数量': total_quantity,
                    '产品业绩': product_sales,
                    '产品单据数': product_receipts,
                    '产品销售数量': product_quantity,
                    '产品单据业绩': product_receipt_performance,
                    '业绩占比(%)': round(sales_ratio, 2),
                    '单据数占比(%)': round(receipt_ratio, 2),
                    '销售数量占比(%)': round(quantity_ratio, 2),
                    '产品单据业绩占比(%)': round(product_receipt_performance_ratio, 2)
                })
            
            # 存储到缓存
            if not hasattr(self, '_sales_tc_monthly_cache'):
                self._sales_tc_monthly_cache = {}
            self._sales_tc_monthly_cache[cache_key] = sales_tc_monthly_data
            
            # 限制缓存大小
            if len(self._sales_tc_monthly_cache) > 10:
                oldest_key = next(iter(self._sales_tc_monthly_cache))
                del self._sales_tc_monthly_cache[oldest_key]
            
            return sales_tc_monthly_data
            
        except Exception as e:
            print(f"获取销售TC月度汇总失败: {e}")
            return []
    
    def _build_exists_conditions(self, date_from, date_to, outlet_filters, month_filters, category_filters, payment_filters):
        """构建EXISTS子句的条件"""
        conditions = []
        
        # 日期筛选
        if date_from and date_to:
            conditions.append(f"CAST(s2.c_date AS DATE) >= '{date_from}'")
            conditions.append(f"CAST(s2.c_date AS DATE) <= '{date_to}'")
        elif date_from:
            conditions.append(f"CAST(s2.c_date AS DATE) >= '{date_from}'")
        elif date_to:
            conditions.append(f"CAST(s2.c_date AS DATE) <= '{date_to}'")
        
        # 门市筛选
        if outlet_filters and len(outlet_filters) > 0:
            outlet_conditions = " OR ".join([f"s2.store_name = '{outlet}'" for outlet in outlet_filters])
            conditions.append(f"({outlet_conditions})")
        
        # 月份筛选
        if month_filters and len(month_filters) > 0:
            month_conditions = " OR ".join([f"FORMAT(CAST(s2.c_date AS DATE), 'yyyy-MM') = '{month}'" for month in month_filters])
            conditions.append(f"({month_conditions})")
        
        # 类别筛选
        if category_filters and len(category_filters) > 0:
            category_conditions = " OR ".join([f"s2.item_category = '{category}'" for category in category_filters])
            conditions.append(f"({category_conditions})")
        
        # 支付方式筛选
        if payment_filters and len(payment_filters) > 0:
            payment_conditions = " OR ".join([f"p.payment_name = '{payment}'" for payment in payment_filters])
            conditions.append(f"EXISTS (SELECT 1 FROM pos_sales_payment_dtls p WHERE s2.sales_no = p.sales_no AND s2.store_name = p.store_name AND ({payment_conditions}))")
        
        if conditions:
            return " AND " + " AND ".join(conditions)
        return ""

    def _get_cancel_adjustment_sql(self, date_from=None, date_to=None, outlet_filters=None, month_filters=None, category_filters=None, payment_filters=None):
        """获取取消项目调整的SQL子查询"""
        # 构建取消项目的WHERE条件
        cancel_conditions = []
        
        # 日期筛选
        if date_from and date_to:
            cancel_conditions.append(f"c.c_date BETWEEN '{date_from}' AND '{date_to}'")
        elif date_from:
            cancel_conditions.append(f"c.c_date >= '{date_from}'")
        elif date_to:
            cancel_conditions.append(f"c.c_date <= '{date_to}'")
        
        # 门店筛选
        if outlet_filters and len(outlet_filters) > 0:
            outlet_list = "', '".join(outlet_filters)
            cancel_conditions.append(f"c.store_name IN ('{outlet_list}')")
        
        # 月份筛选
        if month_filters and len(month_filters) > 0:
            month_list = "', '".join(month_filters)
            cancel_conditions.append(f"FORMAT(c.c_date, 'yyyy-MM') IN ('{month_list}')")
        
        # 类别筛选
        if category_filters and len(category_filters) > 0:
            category_list = "', '".join(category_filters)
            cancel_conditions.append(f"EXISTS (SELECT 1 FROM item_master im WHERE im.item_name = c.item_name AND im.category_code IN ('{category_list}'))")
        
        # 支付方式筛选
        if payment_filters and len(payment_filters) > 0:
            payment_conditions = " OR ".join([f"p.payment_name = '{payment}'" for payment in payment_filters])
            cancel_conditions.append(f"EXISTS (SELECT 1 FROM pos_sales_payment_dtls p WHERE c.sales_no = p.sales_no AND c.store_name = p.store_name AND ({payment_conditions}))")
        
        # 构建完整的取消项目调整SQL
        cancel_where = ""
        if cancel_conditions:
            cancel_where = " AND " + " AND ".join(cancel_conditions)
        
        # 根据数据库类型确定取消项目的计算方式
        if self.current_database == "sushi_gogo_pos_live":
            # GOGO数据库：所有取消项目都直接减去tax_amt
            cancel_calculation = "CAST(c.sub_total as FLOAT) - CAST(ISNULL(c.pro_disc_amt, 0) as FLOAT) + CAST(ISNULL(c.svc_amt, 0) as FLOAT) - CAST(ISNULL(c.tax_amt, 0) as FLOAT)"
        else:
            # Express数据库：只有外带取消项目才减去tax_amt
            cancel_calculation = "CAST(c.sub_total as FLOAT) - CAST(ISNULL(c.pro_disc_amt, 0) as FLOAT) + CAST(ISNULL(c.svc_amt, 0) as FLOAT) - CASE WHEN c.take_away_item = 'Y' THEN CAST(ISNULL(c.tax_amt, 0) as FLOAT) ELSE 0 END"
        
        cancel_sql = f"""
        - ISNULL((
            SELECT SUM({cancel_calculation})
            FROM pos_cancel_sales_item_dtls c WITH (NOLOCK)
            WHERE c.sales_no = s.sales_no 
                AND c.store_name = s.store_name 
                AND c.item_name = s.item_name
                AND c.c_date = s.c_date
                {cancel_where}
        ), 0)"""
        
        return cancel_sql

    def get_product_association_analysis(self, selected_product, date_from=None, date_to=None, outlet_filters=None, month_filters=None, weekday_filters=None, category_filters=None, payment_filters=None):
        """获取产品关联分析"""
        try:
            print(f"开始产品关联分析查询: {selected_product}")
            print(f"查询参数: date_from={date_from}, date_to={date_to}")
            print(f"筛选条件: outlet_filters={outlet_filters}, month_filters={month_filters}, weekday_filters={weekday_filters}, category_filters={category_filters}, payment_filters={payment_filters}")
            if not self.connection:
                print("数据库未连接，尝试重新连接...")
                try:
                    # 使用当前数据库连接
                    if hasattr(self, 'current_database') and self.current_database:
                        self.connect(self.current_database)
                    else:
                        # 如果没有当前数据库信息，使用默认的GOGO数据库
                        self.connect("sushi_gogo_pos_live")
                    
                    if not self.connection:
                        print("重新连接失败")
                        return []
                    print("重新连接成功")
                except Exception as e:
                    print(f"重新连接失败: {e}")
                    return []
            
            print(f"数据库连接状态: {self.connection is not None}")
            print(f"查询参数: date_from={date_from}, date_to={date_to}, outlet_filters={outlet_filters}")
            
            cursor = self.connection.cursor()
            
            # 构建筛选条件
            conditions = []
            
            # 日期筛选
            if date_from and date_to:
                conditions.append(f"CAST(s.c_date AS DATE) >= '{date_from}'")
                conditions.append(f"CAST(s.c_date AS DATE) <= '{date_to}'")
            elif date_from:
                conditions.append(f"CAST(s.c_date AS DATE) >= '{date_from}'")
            elif date_to:
                conditions.append(f"CAST(s.c_date AS DATE) <= '{date_to}'")
            
            # 门市筛选
            if outlet_filters and len(outlet_filters) > 0:
                outlet_conditions = " OR ".join([f"s.store_name = '{outlet}'" for outlet in outlet_filters])
                conditions.append(f"({outlet_conditions})")
            
            # 月份筛选
            if month_filters and len(month_filters) > 0:
                month_conditions = " OR ".join([f"FORMAT(CAST(s.c_date AS DATE), 'yyyy-MM') = '{month}'" for month in month_filters])
                conditions.append(f"({month_conditions})")
            
            # 类别筛选
            if category_filters and len(category_filters) > 0:
                category_conditions = " OR ".join([f"s.item_category = '{category}'" for category in category_filters])
                conditions.append(f"({category_conditions})")
            
            # 支付方式筛选
            if payment_filters and len(payment_filters) > 0:
                payment_conditions = " OR ".join([f"p.payment_name = '{payment}'" for payment in payment_filters])
                conditions.append(f"EXISTS (SELECT 1 FROM pos_sales_payment_dtls p WHERE s.sales_no = p.sales_no AND s.store_name = p.store_name AND ({payment_conditions}))")
            
            # 排除WASTAGE及其变体 - 优化版本，使用NOT IN代替多个LIKE
            conditions.append("s.item_name NOT IN ('WASTAGE', 'Waste', 'waste', 'WASTE')")
            
            where_clause = ""
            if conditions:
                where_clause = " WHERE " + " AND ".join(conditions)
            
            # 查询产品关联分析 - 优化版本，使用CTE提高性能
            selected_product_query = f"""
                WITH SelectedProductData AS (
                    SELECT 
                        FORMAT(s.c_date, 'yyyy-MM') as 月份,
                        s.store_name as 门市,
                        s.sales_no,
                        SUM(CAST(s.qty as FLOAT)) as 总数量,
                        SUM({self.get_performance_calculation_sql()} - 
                            ISNULL(CAST(c.cancel_amount as FLOAT), 0)) as 总业绩
                    FROM pos_sales_dtls s
                    LEFT JOIN (
                        SELECT 
                            sales_no, 
                            store_name, 
                            item_name,
                            SUM({self._get_cancel_performance_calculation_sql()}) as cancel_amount
                        FROM pos_cancel_sales_item_dtls WITH (NOLOCK)
                        GROUP BY sales_no, store_name, item_name
                    ) c ON s.sales_no = c.sales_no AND s.store_name = c.store_name AND s.item_name = c.item_name
                    WHERE s.item_name = '{selected_product}'
                    {f"AND s.c_date >= '{date_from} 00:00:00' AND s.c_date <= '{date_to} 23:59:59'" if date_from and date_to else ""}
                    {f"AND ({' OR '.join([f's.store_name = \'{outlet}\'' for outlet in outlet_filters])})" if outlet_filters and len(outlet_filters) > 0 else ""}
                    {f"AND ({' OR '.join([f'FORMAT(CAST(s.c_date AS DATE), \'yyyy-MM\') = \'{month}\'' for month in month_filters])})" if month_filters and len(month_filters) > 0 else ""}
                    {f"AND ({' OR '.join([f's.item_category = \'{category}\'' for category in category_filters])})" if category_filters and len(category_filters) > 0 else ""}
                    {f"AND EXISTS (SELECT 1 FROM pos_sales_payment_dtls p WHERE s.sales_no = p.sales_no AND s.store_name = p.store_name AND ({' OR '.join([f'p.payment_name = \'{payment}\'' for payment in payment_filters])}))" if payment_filters and len(payment_filters) > 0 else ""}
                    AND s.item_name NOT IN ('WASTAGE', 'Waste', 'waste', 'WASTE')
                    GROUP BY FORMAT(s.c_date, 'yyyy-MM'), s.store_name, s.sales_no
                )
                SELECT 
                    月份,
                    门市,
                    '{selected_product}' as 产品名称,
                    SUM(总数量) as 总数量,
                    COUNT(DISTINCT sales_no) as 总单据数,
                    SUM(总业绩) as 总业绩
                FROM SelectedProductData
                GROUP BY 月份, 门市
            """
            
            print(f"执行选中产品查询...")
            print(f"SQL查询: {selected_product_query}")
            print(f"查询参数: selected_product='{selected_product}', date_from='{date_from}', date_to='{date_to}'")
            print(f"筛选条件: outlet_filters={outlet_filters}, month_filters={month_filters}, category_filters={category_filters}, payment_filters={payment_filters}")
            cursor.execute(selected_product_query)
            selected_product_results = cursor.fetchall()
            
            print(f"选中产品查询结果: {len(selected_product_results)} 条记录")
            if selected_product_results:
                print(f"第一条记录: {selected_product_results[0]}")
            else:
                print(f"查询返回0条记录，请检查产品名称、筛选条件和数据库中的数据")
            
            if not selected_product_results:
                print(f"未找到产品 '{selected_product}' 的数据")
                return []
            
            print(f"找到 {len(selected_product_results)} 个门市/月份组合包含产品 '{selected_product}'")
            
            # 获取同单据中的其他产品信息 - 修改为显示整张单据业绩
            other_products_query = f"""
                WITH SelectedProductSales AS (
                    SELECT DISTINCT s.sales_no, s.store_name, FORMAT(s.c_date, 'yyyy-MM') as 月份
                    FROM pos_sales_dtls s
                    WHERE s.item_name = '{selected_product}'
                    {f"AND s.c_date >= '{date_from} 00:00:00' AND s.c_date <= '{date_to} 23:59:59'" if date_from and date_to else ""}
                    {f"AND ({' OR '.join([f's.store_name = \'{outlet}\'' for outlet in outlet_filters])})" if outlet_filters and len(outlet_filters) > 0 else ""}
                    {f"AND ({' OR '.join([f'FORMAT(CAST(s.c_date AS DATE), \'yyyy-MM\') = \'{month}\'' for month in month_filters])})" if month_filters and len(month_filters) > 0 else ""}
                    {f"AND ({' OR '.join([f's.item_category = \'{category}\'' for category in category_filters])})" if category_filters and len(category_filters) > 0 else ""}
                    {f"AND EXISTS (SELECT 1 FROM pos_sales_payment_dtls p WHERE s.sales_no = p.sales_no AND s.store_name = p.store_name AND ({' OR '.join([f'p.payment_name = \'{payment}\'' for payment in payment_filters])}))" if payment_filters and len(payment_filters) > 0 else ""}
                    AND s.item_name NOT IN ('WASTAGE', 'Waste', 'waste', 'WASTE')
                ),
                ReceiptTotals AS (
                    SELECT 
                        s.sales_no,
                        s.store_name,
                        SUM({self.get_performance_calculation_sql()} - 
                            ISNULL(CAST(c.cancel_amount as FLOAT), 0)) as 整张单据业绩
                    FROM pos_sales_dtls s
                    LEFT JOIN (
                        SELECT 
                            sales_no, 
                            store_name, 
                            item_name,
                            SUM({self._get_cancel_performance_calculation_sql()}) as cancel_amount
                        FROM pos_cancel_sales_item_dtls WITH (NOLOCK)
                        GROUP BY sales_no, store_name, item_name
                    ) c ON s.sales_no = c.sales_no AND s.store_name = c.store_name AND s.item_name = c.item_name
                    WHERE s.item_name != 'WASTAGE'
                    {f"AND s.c_date >= '{date_from} 00:00:00' AND s.c_date <= '{date_to} 23:59:59'" if date_from and date_to else ""}
                    {f"AND ({' OR '.join([f's.store_name = \'{outlet}\'' for outlet in outlet_filters])})" if outlet_filters and len(outlet_filters) > 0 else ""}
                    {f"AND ({' OR '.join([f'FORMAT(CAST(s.c_date AS DATE), \'yyyy-MM\') = \'{month}\'' for month in month_filters])})" if month_filters and len(month_filters) > 0 else ""}
                    {f"AND ({' OR '.join([f's.item_category = \'{category}\'' for category in category_filters])})" if category_filters and len(category_filters) > 0 else ""}
                    {f"AND EXISTS (SELECT 1 FROM pos_sales_payment_dtls p WHERE s.sales_no = p.sales_no AND s.store_name = p.store_name AND ({' OR '.join([f'p.payment_name = \'{payment}\'' for payment in payment_filters])}))" if payment_filters and len(payment_filters) > 0 else ""}
                    AND s.item_name NOT IN ('WASTAGE', 'Waste', 'waste', 'WASTE')
                    GROUP BY s.sales_no, s.store_name
                )
                SELECT 
                    sp.月份,
                    sp.store_name as 门市,
                    s.item_name as 产品名称,
                    SUM(CAST(s.qty as FLOAT)) as 数量,
                    COUNT(DISTINCT CONCAT(s.store_name, '-', s.sales_no)) as 单据数,
                    SUM(rt.整张单据业绩) as 单据业绩,
                    s.sales_no  -- 添加单据号用于排序
                FROM pos_sales_dtls s
                INNER JOIN SelectedProductSales sp ON s.sales_no = sp.sales_no AND s.store_name = sp.store_name
                INNER JOIN ReceiptTotals rt ON s.sales_no = rt.sales_no AND s.store_name = rt.store_name
                WHERE s.item_name != '{selected_product}'
                AND s.item_name != 'WASTAGE'
                {where_clause.replace('WHERE ', ' AND ') if where_clause else ''}
                GROUP BY sp.月份, sp.store_name, s.item_name, s.sales_no
                ORDER BY sp.月份, sp.store_name, s.sales_no, s.item_name
            """
            
            print(f"执行其他产品查询: {other_products_query}")
            cursor.execute(other_products_query)
            other_products_results = cursor.fetchall()
            
            print(f"其他产品查询结果: {len(other_products_results)} 条记录")
            if other_products_results:
                print(f"第一条其他产品记录: {other_products_results[0]}")
            
            print(f"找到 {len(other_products_results)} 个其他产品与 '{selected_product}' 在同一单据中")
            
            # 获取每个其他产品的总数量（用于计算占比）
            other_products_totals = {}
            if other_products_results:
                # 获取所有其他产品的名称
                other_product_names = list(set([row[2] for row in other_products_results]))
                
                # 批量查询所有其他产品的总数量
                if other_product_names:
                    product_names_str = "', '".join(other_product_names)
                    batch_total_query = f"""
                        SELECT 
                            FORMAT(s.c_date, 'yyyy-MM') as 月份,
                            s.store_name as 门市,
                            s.item_name as 产品名称,
                            SUM(CAST(s.qty as FLOAT)) as 总数量,
                            COUNT(DISTINCT CONCAT(s.store_name, '-', s.sales_no)) as 总单据数
                        FROM pos_sales_dtls s
                        {where_clause}
                        AND s.item_name IN ('{product_names_str}')
                        AND s.item_name != 'WASTAGE'
                        GROUP BY FORMAT(s.c_date, 'yyyy-MM'), s.store_name, s.item_name
                    """
                    try:
                        cursor.execute(batch_total_query)
                        total_results = cursor.fetchall()
                        for total_row in total_results:
                            月份, 门市, 产品名称, 总数量, 总单据数 = total_row
                            key = (月份, 门市, 产品名称)
                            other_products_totals[key] = (总数量, 总单据数)
                    except Exception as e:
                        print(f"批量查询其他产品总数量失败: {e}")
            
            # 合并结果
            results = []
            
            # 按门店分组处理
            store_groups = {}
            
            # 添加选中产品的基本信息
            for row in selected_product_results:
                月份, 门市, 产品名称, 总数量, 总单据数, 总业绩 = row
                key = (月份, 门市)
                if key not in store_groups:
                    store_groups[key] = {
                        'selected_product': row,
                        'other_products': [],
                        'other_receipts': set()  # 添加用于收集其他产品的单据号
                    }
                store_groups[key]['selected_product'] = row
            
            # 添加其他产品信息
            for row in other_products_results:
                月份, 门市, 产品名称, 数量, 单据数, 单据业绩, 单据号 = row
                key = (月份, 门市)
                if key not in store_groups:
                    store_groups[key] = {
                        'selected_product': None,
                        'other_products': [],
                        'other_receipts': set()  # 添加用于收集其他产品的单据号
                    }
                # 只保留前6个字段，去掉单据号
                store_groups[key]['other_products'].append(row[:6])
                # 收集其他产品的单据号
                store_groups[key]['other_receipts'].add(单据号)
            
            # 计算全部总数
            total_selected_qty = 0
            total_selected_receipts = 0
            total_selected_sales = 0
            total_other_qty = 0
            total_other_receipts = 0
            total_other_sales = 0
            
            # 处理每个门店的数据
            for (月份, 门市), group_data in store_groups.items():
                selected_product = group_data['selected_product']
                other_products = group_data['other_products']
                
                if selected_product:
                    # 添加搜索产品行
                    产品名称, 总数量, 总单据数, 总业绩 = selected_product[2], selected_product[3], selected_product[4], selected_product[5]
                    results.append((
                        月份, 门市, 产品名称, 
                        round(float(总数量), 2), 
                        总单据数, 
                        round(float(总业绩), 2), 
                        '100.00', 
                        '100.00'
                    ))
                    
                    # 累计到全部总数
                    total_selected_qty += float(总数量)
                    total_selected_receipts += 总单据数
                    total_selected_sales += float(总业绩)
                
                if other_products:
                    # 计算其他产品的总数量
                    其他产品总数量 = sum(float(row[3]) for row in other_products)
                    
                    # 计算包含其他产品的单据数（去重）
                    其他产品单据数 = len(group_data.get('other_receipts', set()))
                    
                    # 计算所有相关单据的总业绩
                    # 由于每个产品行都显示整张单据的业绩，我们需要去重后求和
                    单据业绩集合 = set()
                    for row in other_products:
                        单据业绩集合.add(float(row[5]))  # 每张单据的业绩
                    所有单据总业绩 = sum(单据业绩集合)
                    
                    # 添加"Total Other Item"行
                    results.append((
                        月份, 门市, "Total Other Item", 
                        round(其他产品总数量, 2), 
                        其他产品单据数,  # 使用包含其他产品的单据数
                        round(所有单据总业绩, 2),  # 使用所有单据的总业绩
                        '100.00', 
                        '100.00'
                    ))
                    
                    # 累计到全部总数
                    total_other_qty += 其他产品总数量
                    total_other_receipts += 其他产品单据数
                    total_other_sales += 所有单据总业绩
                    
                    # 添加各个其他产品行
                    for row in other_products:
                        产品名称, 数量, 单据数, 单据业绩 = row[2], row[3], row[4], row[5]
                        
                        # 数量占比 = 自身产品数量 / 其他产品总数量 * 100
                        数量占比 = round((float(数量) / 其他产品总数量) * 100, 2) if 其他产品总数量 > 0 else 0
                        
                        # 单据占比 = 自身产品单据数 / 搜索产品单据数 * 100
                        单据占比 = round((单据数 / 总单据数) * 100, 2) if 总单据数 > 0 else 0
                        
                        results.append((
                            月份, 门市, 产品名称, 
                            round(float(数量), 2), 
                            单据数, 
                            round(float(单据业绩), 2), 
                            f"{数量占比:.2f}", 
                            f"{单据占比:.2f}"
                        ))
            
            # 添加全部总数行
            if total_selected_qty > 0 or total_other_qty > 0:
                results.append((
                    "全部\nTotal", "全部\nTotal", "全部总数\nGrand Total", 
                    round(total_selected_qty + total_other_qty, 2), 
                    total_selected_receipts + total_other_receipts, 
                    round(total_selected_sales + total_other_sales, 2), 
                    '100.00', 
                    '100.00'
                ))
            
            return results
            
        except Exception as e:
            import traceback
            error_details = traceback.format_exc()
            print(f"获取产品关联分析失败: {e}")
            print(f"错误详情: {error_details}")
            return []
    
    def get_brand_analysis(self, date_from=None, date_to=None, outlet_filters=None, month_filters=None, weekday_filters=None, category_filters=None, payment_filters=None):
        """获取品牌分析数据"""
        if not self.connection:
            return []
        
        try:
            cursor = self.connection.cursor()
            
            # 构建WHERE条件
            conditions = []
            
            if date_from:
                conditions.append(f"CAST(s.c_date AS DATE) >= '{date_from}'")
            if date_to:
                conditions.append(f"CAST(s.c_date AS DATE) <= '{date_to}'")
            if outlet_filters and len(outlet_filters) > 0:
                outlet_conditions = " OR ".join([f"s.store_name = '{outlet}'" for outlet in outlet_filters])
                conditions.append(f"({outlet_conditions})")
            if month_filters and len(month_filters) > 0:
                month_conditions = " OR ".join([f"FORMAT(s.c_date, 'yyyy-MM') = '{month}'" for month in month_filters])
                conditions.append(f"({month_conditions})")
            if weekday_filters and len(weekday_filters) > 0:
                print(f"应用星期筛选: {weekday_filters}")
                # 使用DATEPART来获取星期几，1=Sunday, 2=Monday, ..., 7=Saturday
                weekday_mapping = {
                    'Sunday': 1, 'Monday': 2, 'Tuesday': 3, 'Wednesday': 4, 
                    'Thursday': 5, 'Friday': 6, 'Saturday': 7
                }
                weekday_values = [str(weekday_mapping.get(weekday, 0)) for weekday in weekday_filters if weekday_mapping.get(weekday, 0) > 0]
                if weekday_values:
                    weekday_conditions = " OR ".join([f"DATEPART(WEEKDAY, s.c_date) = {value}" for value in weekday_values])
                    conditions.append(f"({weekday_conditions})")
                    print(f"星期筛选SQL条件: {weekday_conditions}")
            if category_filters and len(category_filters) > 0:
                category_conditions = " OR ".join([f"im.category_code = '{category}'" for category in category_filters])
                conditions.append(f"({category_conditions})")
            if payment_filters and len(payment_filters) > 0:
                payment_conditions = " OR ".join([f"p.payment_name = '{method}'" for method in payment_filters])
                conditions.append(f"EXISTS (SELECT 1 FROM {TABLE_PAYMENT} p WHERE s.sales_no = p.sales_no AND s.store_name = p.store_name AND s.c_date = p.c_date AND ({payment_conditions}))")
            
            # 排除WASTAGE及其变体 - 优化版本，使用NOT IN代替多个LIKE
            conditions.append("s.item_name NOT IN ('WASTAGE', 'Waste', 'waste', 'WASTE')")
            
            # 构建JOIN子句
            join_clause = ""
            if category_filters and len(category_filters) > 0:
                join_clause = f"LEFT JOIN {TABLE_ITEMS} im ON s.item_name = im.item_name"
            
            # 构建WHERE子句
            where_clause = ""
            if conditions:
                where_clause = "WHERE " + " AND ".join(conditions)
            
            # 构建查询SQL
            query = f"""
                WITH BrandData AS (
                    SELECT
                        FORMAT(s.c_date, 'yyyy-MM') as 月份,
                        s.store_name as 门市,
                        CASE 
                            WHEN s.item_name LIKE '%SUSHI%' OR s.item_name LIKE '%SASHIMI%' THEN 'SUSHI'
                            WHEN s.item_name LIKE '%RAMEN%' OR s.item_name LIKE '%UDON%' THEN 'NOODLES'
                            WHEN s.item_name LIKE '%TEMPURA%' THEN 'TEMPURA'
                            WHEN s.item_name LIKE '%DONBURI%' OR s.item_name LIKE '%DON%' THEN 'DONBURI'
                            WHEN s.item_name LIKE '%SALAD%' THEN 'SALAD'
                            WHEN s.item_name LIKE '%DRINK%' OR s.item_name LIKE '%BEVERAGE%' THEN 'BEVERAGE'
                            ELSE 'OTHER'
                        END as 品牌,
                        SUM(CAST(s.qty as FLOAT)) as 数量,
                        COUNT(DISTINCT CONCAT(s.store_name, '-', s.sales_no)) as 单据数,
                        SUM(CAST(s.sub_total as FLOAT) - CAST(ISNULL(s.pro_disc_amt, 0) as FLOAT) + CAST(ISNULL(s.svc_amt, 0) as FLOAT) -
                            CASE WHEN s.take_away_item = 'Y' THEN CAST(ISNULL(s.tax_amt, 0) as FLOAT) ELSE 0 END
                            ) as 业绩
                    FROM {TABLE_SALES} s
                    {join_clause}
                    {where_clause}
                    GROUP BY FORMAT(s.c_date, 'yyyy-MM'), s.store_name, 
                        CASE 
                            WHEN s.item_name LIKE '%SUSHI%' OR s.item_name LIKE '%SASHIMI%' THEN 'SUSHI'
                            WHEN s.item_name LIKE '%RAMEN%' OR s.item_name LIKE '%UDON%' THEN 'NOODLES'
                            WHEN s.item_name LIKE '%TEMPURA%' THEN 'TEMPURA'
                            WHEN s.item_name LIKE '%DONBURI%' OR s.item_name LIKE '%DON%' THEN 'DONBURI'
                            WHEN s.item_name LIKE '%SALAD%' THEN 'SALAD'
                            WHEN s.item_name LIKE '%DRINK%' OR s.item_name LIKE '%BEVERAGE%' THEN 'BEVERAGE'
                            ELSE 'OTHER'
                        END
                )
                SELECT
                    月份,
                    门市,
                    品牌,
                    SUM(数量) as 总数量,
                    SUM(单据数) as 总单据数,
                    SUM(业绩) as 总业绩
                FROM BrandData
                GROUP BY 月份, 门市, 品牌
                ORDER BY 月份, 门市, 总业绩 DESC
            """
            
            print(f"开始执行品牌分析查询...")
            start_time = time.time()
            cursor.execute(query)
            results = cursor.fetchall()
            end_time = time.time()
            print(f"品牌分析查询完成，耗时: {end_time - start_time:.2f} 秒")
            print(f"品牌分析查询结果: {len(results)} 条记录")
            if results:
                print(f"第一条记录: {results[0]}")
            
            return results
            
        except Exception as e:
            print(f"获取品牌分析失败: {e}")
            return []
    
    def get_brand_daily_breakdown(self, date_from=None, date_to=None, outlet_filters=None, month_filters=None, weekday_filters=None, category_filters=None, payment_filters=None):
        """获取品牌每日细项分析数据 - 与月销售数据使用完全相同的查询逻辑"""
        if not self.connection:
            return []
        
        try:
            cursor = self.connection.cursor()
            
            # 构建筛选条件 - 与月销售数据完全相同
            conditions = []
            
            # 日期筛选 - 与月销售数据相同的格式
            if date_from and date_to:
                conditions.append(f"s.c_date >= '{date_from} 00:00:00' AND s.c_date <= '{date_to} 23:59:59'")
            elif month_filters and len(month_filters) > 0:
                month_conditions = " OR ".join([f"FORMAT(s.c_date, 'yyyy-MM') = '{month}'" for month in month_filters])
                conditions.append(f"({month_conditions})")
            
            # 星期筛选
            if weekday_filters and len(weekday_filters) > 0:
                weekday_mapping = {
                    'Sunday': 1, 'Monday': 2, 'Tuesday': 3, 'Wednesday': 4, 
                    'Thursday': 5, 'Friday': 6, 'Saturday': 7
                }
                weekday_values = [str(weekday_mapping.get(weekday, 0)) for weekday in weekday_filters if weekday_mapping.get(weekday, 0) > 0]
                if weekday_values:
                    weekday_conditions = " OR ".join([f"DATEPART(WEEKDAY, s.c_date) = {value}" for value in weekday_values])
                    conditions.append(f"({weekday_conditions})")
            
            # 门店筛选 - 与月销售数据相同的格式
            if outlet_filters and len(outlet_filters) > 0:
                outlet_conditions = " OR ".join([f"s.store_name = '{outlet}'" for outlet in outlet_filters])
                conditions.append(f"({outlet_conditions})")
            
            # 类别筛选 - 与月销售数据相同的格式
            if category_filters and len(category_filters) > 0:
                category_conditions = " OR ".join([f"im.category_code = '{category}'" for category in category_filters])
                conditions.append(f"({category_conditions})")
            
            # 支付方式筛选 - 与月销售数据相同的格式
            if payment_filters and len(payment_filters) > 0:
                payment_conditions = " OR ".join([f"p.payment_name = '{method}'" for method in payment_filters])
                conditions.append(f"EXISTS (SELECT 1 FROM {TABLE_PAYMENT} p WHERE s.sales_no = p.sales_no AND s.store_name = p.store_name AND ({payment_conditions}))")
            
            # 排除WASTAGE及其变体 - 与月销售数据相同的格式
            conditions.append("s.item_name NOT LIKE '%WASTAGE%'")
            conditions.append("s.item_name NOT LIKE '%Waste%'")
            conditions.append("s.item_name NOT LIKE '%waste%'")
            conditions.append("s.item_name NOT LIKE '%WASTE%'")
            
            where_clause = ""
            if conditions:
                where_clause = " WHERE " + " AND ".join(conditions)
            
            # 获取业绩计算SQL - 与月销售数据完全相同
            performance_sql = self.get_performance_calculation_sql()
            
            # 修复每日细项查询 - 避免重复计算业绩
            query = f"""
                WITH DailyReceipts AS (
                    SELECT 
                        FORMAT(s.c_date, 'yyyy-MM-dd') as 日期,
                        s.store_name as 门市,
                        s.sales_no,
                        SUM({performance_sql}) as 单据业绩,
                        MAX(s.take_away_item) as take_away_item,
                        STRING_AGG(DISTINCT p.payment_name, ',') as payment_methods
                    FROM {TABLE_SALES} s WITH (NOLOCK)
                LEFT JOIN item_master im WITH (NOLOCK) ON s.item_name = im.item_name
                    LEFT JOIN {TABLE_PAYMENT} p WITH (NOLOCK) ON s.sales_no = p.sales_no AND s.store_name = p.store_name
                    {where_clause}
                    GROUP BY FORMAT(s.c_date, 'yyyy-MM-dd'), s.store_name, s.sales_no
                )
                SELECT 
                    dr.日期,
                    dr.门市,
                    'ALL' as 品牌,
                    SUM(dr.单据业绩) as 总业绩,
                    COUNT(DISTINCT CONCAT(dr.门市, '-', dr.sales_no)) as 总单据数,
                    SUM(CASE WHEN dr.take_away_item = 'N' THEN dr.单据业绩 ELSE 0 END) as DI业绩,
                    COUNT(DISTINCT CASE WHEN dr.take_away_item = 'N' THEN dr.sales_no END) as DI单据数,
                    SUM(CASE WHEN dr.take_away_item = 'Y' THEN dr.单据业绩 ELSE 0 END) as 外带业绩,
                    COUNT(DISTINCT CASE WHEN dr.take_away_item = 'Y' THEN dr.sales_no END) as 外带单据数,
                    SUM(CASE WHEN dr.payment_methods LIKE '%GRAB FOOD%' OR dr.payment_methods LIKE '%FOOD PANDA%' OR dr.payment_methods LIKE '%DELIVEROO%' THEN dr.单据业绩 ELSE 0 END) as 配送业绩,
                    COUNT(DISTINCT CASE WHEN dr.payment_methods LIKE '%GRAB FOOD%' OR dr.payment_methods LIKE '%FOOD PANDA%' OR dr.payment_methods LIKE '%DELIVEROO%' THEN dr.sales_no END) as 配送单据数,
                    SUM(CASE WHEN dr.payment_methods LIKE '%FOOD PANDA%' THEN dr.单据业绩 ELSE 0 END) as FOOD_PANDA业绩,
                    COUNT(DISTINCT CASE WHEN dr.payment_methods LIKE '%FOOD PANDA%' THEN dr.sales_no END) as FOOD_PANDA单据数,
                    SUM(CASE WHEN dr.payment_methods LIKE '%GRAB FOOD%' THEN dr.单据业绩 ELSE 0 END) as GRAB_FOOD业绩,
                    COUNT(DISTINCT CASE WHEN dr.payment_methods LIKE '%GRAB FOOD%' THEN dr.sales_no END) as GRAB_FOOD单据数,
                    SUM(CASE WHEN dr.payment_methods LIKE '%DELIVEROO%' THEN dr.单据业绩 ELSE 0 END) as DELIVEROO业绩,
                    COUNT(DISTINCT CASE WHEN dr.payment_methods LIKE '%DELIVEROO%' THEN dr.sales_no END) as DELIVEROO单据数
                FROM DailyReceipts dr
                GROUP BY dr.日期, dr.门市
                ORDER BY dr.日期, dr.门市
                OPTION (RECOMPILE, MAXDOP 4)
            """
            
            cursor.execute(query)
            results = cursor.fetchall()
            
            # 转换数据格式并添加每日总计行
            data = []
            daily_totals = {}  # 存储每日总计
            
            for row in results:
                try:
                    if len(row) < 17:
                        continue
                    
                    row_data = {
                    '日期': row[0],
                    '门市': row[1],
                    '品牌': row[2],
                    '总业绩': float(row[3]) if row[3] else 0.0,
                    '总单据数': int(row[4]) if row[4] else 0,
                        '总单据大小': float(row[3]) / int(row[4]) if row[4] and int(row[4]) > 0 else 0.0,
                        'DI业绩': float(row[5]) if row[5] else 0.0,
                        'DI单据数': int(row[6]) if row[6] else 0,
                        'DI单据大小': float(row[5]) / int(row[6]) if row[6] and int(row[6]) > 0 else 0.0,
                        '外带业绩': float(row[7]) if row[7] else 0.0,
                        '外带单据数': int(row[8]) if row[8] else 0,
                        '外带单据大小': float(row[7]) / int(row[8]) if row[8] and int(row[8]) > 0 else 0.0,
                        '配送业绩': float(row[9]) if row[9] else 0.0,
                        '配送单据数': int(row[10]) if row[10] else 0,
                        '配送单据大小': float(row[9]) / int(row[10]) if row[10] and int(row[10]) > 0 else 0.0,
                        'FOOD_PANDA业绩': float(row[11]) if row[11] else 0.0,
                        'FOOD_PANDA单据数': int(row[12]) if row[12] else 0,
                        'FOOD_PANDA单据大小': float(row[11]) / int(row[12]) if row[12] and int(row[12]) > 0 else 0.0,
                        'GRAB_FOOD业绩': float(row[13]) if row[13] else 0.0,
                        'GRAB_FOOD单据数': int(row[14]) if row[14] else 0,
                        'GRAB_FOOD单据大小': float(row[13]) / int(row[14]) if row[14] and int(row[14]) > 0 else 0.0,
                        'DELIVEROO业绩': float(row[15]) if row[15] else 0.0,
                        'DELIVEROO单据数': int(row[16]) if row[16] else 0,
                        'DELIVEROO单据大小': float(row[15]) / int(row[16]) if row[16] and int(row[16]) > 0 else 0.0,
                        'is_daily_total': False  # 标记是否为每日总计行
                    }
                    
                    data.append(row_data)
                    
                    # 累加每日总计
                    date_key = row[0]
                    if date_key not in daily_totals:
                        daily_totals[date_key] = {
                            '总业绩': 0.0, '总单据数': 0, 'DI业绩': 0.0, 'DI单据数': 0,
                            '外带业绩': 0.0, '外带单据数': 0, '配送业绩': 0.0, '配送单据数': 0,
                            'FOOD_PANDA业绩': 0.0, 'FOOD_PANDA单据数': 0,
                            'GRAB_FOOD业绩': 0.0, 'GRAB_FOOD单据数': 0,
                            'DELIVEROO业绩': 0.0, 'DELIVEROO单据数': 0
                        }
                    
                    daily_totals[date_key]['总业绩'] += float(row[3]) if row[3] else 0.0
                    daily_totals[date_key]['总单据数'] += int(row[4]) if row[4] else 0
                    daily_totals[date_key]['DI业绩'] += float(row[5]) if row[5] else 0.0
                    daily_totals[date_key]['DI单据数'] += int(row[6]) if row[6] else 0
                    daily_totals[date_key]['外带业绩'] += float(row[7]) if row[7] else 0.0
                    daily_totals[date_key]['外带单据数'] += int(row[8]) if row[8] else 0
                    daily_totals[date_key]['配送业绩'] += float(row[9]) if row[9] else 0.0
                    daily_totals[date_key]['配送单据数'] += int(row[10]) if row[10] else 0
                    daily_totals[date_key]['FOOD_PANDA业绩'] += float(row[11]) if row[11] else 0.0
                    daily_totals[date_key]['FOOD_PANDA单据数'] += int(row[12]) if row[12] else 0
                    daily_totals[date_key]['GRAB_FOOD业绩'] += float(row[13]) if row[13] else 0.0
                    daily_totals[date_key]['GRAB_FOOD单据数'] += int(row[14]) if row[14] else 0
                    daily_totals[date_key]['DELIVEROO业绩'] += float(row[15]) if row[15] else 0.0
                    daily_totals[date_key]['DELIVEROO单据数'] += int(row[16]) if row[16] else 0
                    
                except Exception as e:
                    continue
            
            # 添加每日总计行
            for date_key, totals in daily_totals.items():
                daily_total_row = {
                    '日期': date_key,
                    '门市': '每日总计',
                    '品牌': 'ALL',
                    '总业绩': totals['总业绩'],
                    '总单据数': totals['总单据数'],
                    '总单据大小': totals['总业绩'] / totals['总单据数'] if totals['总单据数'] > 0 else 0.0,
                    'DI业绩': totals['DI业绩'],
                    'DI单据数': totals['DI单据数'],
                    'DI单据大小': totals['DI业绩'] / totals['DI单据数'] if totals['DI单据数'] > 0 else 0.0,
                    '外带业绩': totals['外带业绩'],
                    '外带单据数': totals['外带单据数'],
                    '外带单据大小': totals['外带业绩'] / totals['外带单据数'] if totals['外带单据数'] > 0 else 0.0,
                    '配送业绩': totals['配送业绩'],
                    '配送单据数': totals['配送单据数'],
                    '配送单据大小': totals['配送业绩'] / totals['配送单据数'] if totals['配送单据数'] > 0 else 0.0,
                    'FOOD_PANDA业绩': totals['FOOD_PANDA业绩'],
                    'FOOD_PANDA单据数': totals['FOOD_PANDA单据数'],
                    'FOOD_PANDA单据大小': totals['FOOD_PANDA业绩'] / totals['FOOD_PANDA单据数'] if totals['FOOD_PANDA单据数'] > 0 else 0.0,
                    'GRAB_FOOD业绩': totals['GRAB_FOOD业绩'],
                    'GRAB_FOOD单据数': totals['GRAB_FOOD单据数'],
                    'GRAB_FOOD单据大小': totals['GRAB_FOOD业绩'] / totals['GRAB_FOOD单据数'] if totals['GRAB_FOOD单据数'] > 0 else 0.0,
                    'DELIVEROO业绩': totals['DELIVEROO业绩'],
                    'DELIVEROO单据数': totals['DELIVEROO单据数'],
                    'DELIVEROO单据大小': totals['DELIVEROO业绩'] / totals['DELIVEROO单据数'] if totals['DELIVEROO单据数'] > 0 else 0.0,
                    'is_daily_total': True  # 标记为每日总计行
                }
                
                data.append(daily_total_row)
            
            # 按日期和门市排序
            data.sort(key=lambda x: (x['日期'], 1 if x['门市'] == '每日总计' else 0, x['门市']))
            
            cursor.close()
            return data
            
        except Exception as e:
            return []
    
    def get_brand_period_summary(self, date_from=None, date_to=None, outlet_filters=None, month_filters=None, weekday_filters=None, category_filters=None, payment_filters=None):
        """获取品牌期间汇总分析数据"""
        if not self.connection:
            return []
        
        try:
            cursor = self.connection.cursor()
            
            # 构建筛选条件
            conditions = []
            
            # 日期筛选
            if date_from and date_to:
                conditions.append(f"s.c_date >= '{date_from} 00:00:00' AND s.c_date <= '{date_to} 23:59:59'")
            elif month_filters and len(month_filters) > 0:
                month_conditions = " OR ".join([f"FORMAT(s.c_date, 'yyyy-MM') = '{month}'" for month in month_filters])
                conditions.append(f"({month_conditions})")
            
            # 星期筛选
            if weekday_filters and len(weekday_filters) > 0:
                weekday_mapping = {
                    'Sunday': 1, 'Monday': 2, 'Tuesday': 3, 'Wednesday': 4, 
                    'Thursday': 5, 'Friday': 6, 'Saturday': 7
                }
                weekday_values = [str(weekday_mapping.get(weekday, 0)) for weekday in weekday_filters if weekday_mapping.get(weekday, 0) > 0]
                if weekday_values:
                    weekday_conditions = " OR ".join([f"DATEPART(WEEKDAY, s.c_date) = {value}" for value in weekday_values])
                    conditions.append(f"({weekday_conditions})")
            
            # 门店筛选
            if outlet_filters and len(outlet_filters) > 0:
                outlet_conditions = " OR ".join([f"s.store_name = '{outlet}'" for outlet in outlet_filters])
                conditions.append(f"({outlet_conditions})")
            
            # 类别筛选
            if category_filters and len(category_filters) > 0:
                category_conditions = " OR ".join([f"im.category_code = '{category}'" for category in category_filters])
                conditions.append(f"({category_conditions})")
            
            # 支付方式筛选
            if payment_filters and len(payment_filters) > 0:
                payment_conditions = " OR ".join([f"p.payment_name = '{method}'" for method in payment_filters])
                conditions.append(f"EXISTS (SELECT 1 FROM {TABLE_PAYMENT} p WHERE s.sales_no = p.sales_no AND s.store_name = p.store_name AND ({payment_conditions}))")
            
            # 排除WASTAGE及其变体 - 优化版本，使用NOT IN代替多个LIKE
            conditions.append("s.item_name NOT IN ('WASTAGE', 'Waste', 'waste', 'WASTE')")
            
            where_clause = ""
            if conditions:
                where_clause = " WHERE " + " AND ".join(conditions)
            
            # 构建JOIN子句
            join_clause = f"LEFT JOIN {TABLE_ITEMS} im ON s.item_name = im.item_name"
            if payment_filters and len(payment_filters) > 0:
                join_clause += f" LEFT JOIN {TABLE_PAYMENT} p ON s.sales_no = p.sales_no AND s.store_name = p.store_name"
            
            # 不需要品牌分类，使用固定值
            brand_case = "'ALL'"
            
            # 计算期间显示格式
            period_display = f"""
                CASE 
                    WHEN '{date_from}' IS NOT NULL AND '{date_to}' IS NOT NULL 
                    THEN CONCAT(FORMAT(CAST('{date_from}' as DATE), 'd/M'), ' - ', FORMAT(CAST('{date_to}' as DATE), 'd/M'))
                    ELSE CONCAT(FORMAT(MIN(s.c_date), 'd/M'), ' - ', FORMAT(MAX(s.c_date), 'd/M'))
                END
            """
            
            # 计算天数
            days_calculation = f"""
                CASE 
                    WHEN '{date_from}' IS NOT NULL AND '{date_to}' IS NOT NULL 
                    THEN DATEDIFF(DAY, '{date_from}', '{date_to}') + 1
                    ELSE DATEDIFF(DAY, MIN(s.c_date), MAX(s.c_date)) + 1
                END
            """
            
            # 查询期间汇总数据 - 与月-销售数据保持一致（不包含取消项目处理）
            query = f"""
                WITH PeriodBrandData AS (
                    SELECT 
                        {period_display} as 期间,
                        s.store_name as 门市,
                        {brand_case} as 品牌,
                        {days_calculation} as 天数,
                        -- 总业绩计算 - 与月-销售数据保持一致
                        SUM({self.get_performance_calculation_sql()}) as 总业绩,
                        COUNT(DISTINCT CONCAT(s.store_name, '-', s.sales_no)) as 总单据数,
                        -- DI业绩 (take_away_item = 'N')
                        SUM(CASE WHEN s.take_away_item = 'N' THEN 
                            {self.get_performance_calculation_sql()}
                        ELSE 0 END) as DI业绩,
                        COUNT(DISTINCT CASE WHEN s.take_away_item = 'N' THEN s.sales_no END) as DI单据数,
                        -- 外带业绩 (take_away_item = 'Y' 且不是配送支付方式)
                        SUM(CASE WHEN s.take_away_item = 'Y' AND (p.payment_name IS NULL OR p.payment_name NOT IN ('GRAB FOOD', 'FOOD PANDA', 'DELIVEROO')) THEN 
                            {self.get_performance_calculation_sql()}
                        ELSE 0 END) as 外带业绩,
                        COUNT(DISTINCT CASE WHEN s.take_away_item = 'Y' AND (p.payment_name IS NULL OR p.payment_name NOT IN ('GRAB FOOD', 'FOOD PANDA', 'DELIVEROO')) THEN s.sales_no END) as 外带单据数,
                        -- 配送业绩 (通过支付方式判断)
                        SUM(CASE WHEN p.payment_name IN ('GRAB FOOD', 'FOOD PANDA', 'DELIVEROO') THEN 
                            {self.get_performance_calculation_sql()}
                        ELSE 0 END) as 配送业绩,
                        COUNT(DISTINCT CASE WHEN p.payment_name IN ('GRAB FOOD', 'FOOD PANDA', 'DELIVEROO') THEN s.sales_no END) as 配送单据数,
                        -- FOOD PANDA业绩
                        SUM(CASE WHEN p.payment_name = 'FOOD PANDA' THEN 
                            {self.get_performance_calculation_sql()}
                        ELSE 0 END) as FOOD_PANDA业绩,
                        COUNT(DISTINCT CASE WHEN p.payment_name = 'FOOD PANDA' THEN s.sales_no END) as FOOD_PANDA单据数,
                        -- GRAB FOOD业绩
                        SUM(CASE WHEN p.payment_name = 'GRAB FOOD' THEN 
                            {self.get_performance_calculation_sql()}
                        ELSE 0 END) as GRAB_FOOD业绩,
                        COUNT(DISTINCT CASE WHEN p.payment_name = 'GRAB FOOD' THEN s.sales_no END) as GRAB_FOOD单据数,
                        -- DELIVEROO业绩
                        SUM(CASE WHEN p.payment_name = 'DELIVEROO' THEN 
                            {self.get_performance_calculation_sql()}
                        ELSE 0 END) as DELIVEROO业绩,
                        COUNT(DISTINCT CASE WHEN p.payment_name = 'DELIVEROO' THEN s.sales_no END) as DELIVEROO单据数
                    FROM {TABLE_SALES} s WITH (NOLOCK)
                    LEFT JOIN {TABLE_PAYMENT} p ON s.sales_no = p.sales_no AND s.store_name = p.store_name
                    {join_clause}
                    {where_clause}
                    GROUP BY s.store_name
                )
                SELECT 
                    期间,
                    门市,
                    品牌,
                    天数,
                    总业绩,
                    总单据数,
                    CASE WHEN 总单据数 > 0 THEN 总业绩 / 总单据数 ELSE 0 END as 总单据大小,
                    CASE WHEN 天数 > 0 THEN 总业绩 / 天数 ELSE 0 END as 总业绩_日均,
                    CASE WHEN 天数 > 0 THEN 总单据数 / 天数 ELSE 0 END as 总单据数_日均,
                    CASE WHEN 天数 > 0 AND 总单据数 > 0 THEN (总业绩 / 总单据数) ELSE 0 END as 总单据大小_日均,
                    DI业绩,
                    DI单据数,
                    CASE WHEN DI单据数 > 0 THEN DI业绩 / DI单据数 ELSE 0 END as DI单据大小,
                    CASE WHEN 天数 > 0 THEN DI业绩 / 天数 ELSE 0 END as DI业绩_日均,
                    CASE WHEN 天数 > 0 THEN DI单据数 / 天数 ELSE 0 END as DI单据数_日均,
                    CASE WHEN 天数 > 0 AND DI单据数 > 0 THEN (DI业绩 / DI单据数) ELSE 0 END as DI单据大小_日均,
                    外带业绩,
                    外带单据数,
                    CASE WHEN 外带单据数 > 0 THEN 外带业绩 / 外带单据数 ELSE 0 END as 外带单据大小,
                    CASE WHEN 天数 > 0 THEN 外带业绩 / 天数 ELSE 0 END as 外带业绩_日均,
                    CASE WHEN 天数 > 0 THEN 外带单据数 / 天数 ELSE 0 END as 外带单据数_日均,
                    CASE WHEN 天数 > 0 AND 外带单据数 > 0 THEN (外带业绩 / 外带单据数) ELSE 0 END as 外带单据大小_日均,
                    配送业绩,
                    配送单据数,
                    CASE WHEN 配送单据数 > 0 THEN 配送业绩 / 配送单据数 ELSE 0 END as 配送单据大小,
                    CASE WHEN 天数 > 0 THEN 配送业绩 / 天数 ELSE 0 END as 配送业绩_日均,
                    CASE WHEN 天数 > 0 THEN 配送单据数 / 天数 ELSE 0 END as 配送单据数_日均,
                    CASE WHEN 天数 > 0 AND 配送单据数 > 0 THEN (配送业绩 / 配送单据数) ELSE 0 END as 配送单据大小_日均,
                    FOOD_PANDA业绩,
                    FOOD_PANDA单据数,
                    CASE WHEN FOOD_PANDA单据数 > 0 THEN FOOD_PANDA业绩 / FOOD_PANDA单据数 ELSE 0 END as FOOD_PANDA单据大小,
                    CASE WHEN 天数 > 0 THEN FOOD_PANDA业绩 / 天数 ELSE 0 END as FOOD_PANDA业绩_日均,
                    CASE WHEN 天数 > 0 THEN FOOD_PANDA单据数 / 天数 ELSE 0 END as FOOD_PANDA单据数_日均,
                    CASE WHEN 天数 > 0 AND FOOD_PANDA单据数 > 0 THEN (FOOD_PANDA业绩 / FOOD_PANDA单据数) ELSE 0 END as FOOD_PANDA单据大小_日均,
                    GRAB_FOOD业绩,
                    GRAB_FOOD单据数,
                    CASE WHEN GRAB_FOOD单据数 > 0 THEN GRAB_FOOD业绩 / GRAB_FOOD单据数 ELSE 0 END as GRAB_FOOD单据大小,
                    CASE WHEN 天数 > 0 THEN GRAB_FOOD业绩 / 天数 ELSE 0 END as GRAB_FOOD业绩_日均,
                    CASE WHEN 天数 > 0 THEN GRAB_FOOD单据数 / 天数 ELSE 0 END as GRAB_FOOD单据数_日均,
                    CASE WHEN 天数 > 0 AND GRAB_FOOD单据数 > 0 THEN (GRAB_FOOD业绩 / GRAB_FOOD单据数) ELSE 0 END as GRAB_FOOD单据大小_日均,
                    DELIVEROO业绩,
                    DELIVEROO单据数,
                    CASE WHEN DELIVEROO单据数 > 0 THEN DELIVEROO业绩 / DELIVEROO单据数 ELSE 0 END as DELIVEROO单据大小,
                    CASE WHEN 天数 > 0 THEN DELIVEROO业绩 / 天数 ELSE 0 END as DELIVEROO业绩_日均,
                    CASE WHEN 天数 > 0 THEN DELIVEROO单据数 / 天数 ELSE 0 END as DELIVEROO单据数_日均,
                    CASE WHEN 天数 > 0 AND DELIVEROO单据数 > 0 THEN (DELIVEROO业绩 / DELIVEROO单据数) ELSE 0 END as DELIVEROO单据大小_日均
                FROM PeriodBrandData
                ORDER BY 门市, 品牌
                OPTION (RECOMPILE, MAXDOP 4)
            """
            
            print(f"开始执行品牌期间汇总查询...")
            start_time = time.time()
            cursor.execute(query)
            results = cursor.fetchall()
            end_time = time.time()
            print(f"品牌期间汇总查询完成，耗时: {end_time - start_time:.2f} 秒")
            print(f"品牌期间汇总查询结果: {len(results)} 条记录")
            
            # 转换数据格式
            data = []
            for row in results:
                data.append({
                    '期间': row[0],
                    '门市': row[1],
                    '品牌': row[2],
                    '天数': int(row[3]) if row[3] else 1,
                    '总业绩': float(row[4]) if row[4] else 0.0,
                    '总单据数': int(row[5]) if row[5] else 0,
                    '总单据大小': float(row[6]) if row[6] else 0.0,
                    '总业绩_日均': float(row[7]) if row[7] else 0.0,
                    '总单据数_日均': float(row[8]) if row[8] else 0.0,
                    '总单据大小_日均': float(row[9]) if row[9] else 0.0,
                    'DI业绩': float(row[10]) if row[10] else 0.0,
                    'DI单据数': int(row[11]) if row[11] else 0,
                    'DI单据大小': float(row[12]) if row[12] else 0.0,
                    'DI业绩_日均': float(row[13]) if row[13] else 0.0,
                    'DI单据数_日均': float(row[14]) if row[14] else 0.0,
                    'DI单据大小_日均': float(row[15]) if row[15] else 0.0,
                    '外带业绩': float(row[16]) if row[16] else 0.0,
                    '外带单据数': int(row[17]) if row[17] else 0,
                    '外带单据大小': float(row[18]) if row[18] else 0.0,
                    '外带业绩_日均': float(row[19]) if row[19] else 0.0,
                    '外带单据数_日均': float(row[20]) if row[20] else 0.0,
                    '外带单据大小_日均': float(row[21]) if row[21] else 0.0,
                    '配送业绩': float(row[22]) if row[22] else 0.0,
                    '配送单据数': int(row[23]) if row[23] else 0,
                    '配送单据大小': float(row[24]) if row[24] else 0.0,
                    '配送业绩_日均': float(row[25]) if row[25] else 0.0,
                    '配送单据数_日均': float(row[26]) if row[26] else 0.0,
                    '配送单据大小_日均': float(row[27]) if row[27] else 0.0,
                    'FOOD_PANDA业绩': float(row[28]) if row[28] else 0.0,
                    'FOOD_PANDA单据数': int(row[29]) if row[29] else 0,
                    'FOOD_PANDA单据大小': float(row[30]) if row[30] else 0.0,
                    'FOOD_PANDA业绩_日均': float(row[31]) if row[31] else 0.0,
                    'FOOD_PANDA单据数_日均': float(row[32]) if row[32] else 0.0,
                    'FOOD_PANDA单据大小_日均': float(row[33]) if row[33] else 0.0,
                    'GRAB_FOOD业绩': float(row[34]) if row[34] else 0.0,
                    'GRAB_FOOD单据数': int(row[35]) if row[35] else 0,
                    'GRAB_FOOD单据大小': float(row[36]) if row[36] else 0.0,
                    'GRAB_FOOD业绩_日均': float(row[37]) if row[37] else 0.0,
                    'GRAB_FOOD单据数_日均': float(row[38]) if row[38] else 0.0,
                    'GRAB_FOOD单据大小_日均': float(row[39]) if row[39] else 0.0,
                    'DELIVEROO业绩': float(row[40]) if row[40] else 0.0,
                    'DELIVEROO单据数': int(row[41]) if row[41] else 0,
                    'DELIVEROO单据大小': float(row[42]) if row[42] else 0.0,
                    'DELIVEROO业绩_日均': float(row[43]) if row[43] else 0.0,
                    'DELIVEROO单据数_日均': float(row[44]) if row[44] else 0.0,
                    'DELIVEROO单据大小_日均': float(row[45]) if row[45] else 0.0
                })
            
            cursor.close()
            return data
            
        except Exception as e:
            print(f"获取品牌期间汇总失败: {e}")
            return []
    
    def get_category_analysis(self, date_from=None, date_to=None, outlet_filters=None, month_filters=None, weekday_filters=None, category_filters=None, payment_filters=None):
        """获取类别分析数据"""
        if not self.connection:
            return []
        
        # 检查缓存
        cache_key = f"category_{self.current_database}_{date_from}_{date_to}_{outlet_filters}_{month_filters}_{weekday_filters}_{category_filters}_{payment_filters}"
        if hasattr(self, '_category_cache') and cache_key in self._category_cache:
            print("✓ 使用缓存的类别分析数据")
            return self._category_cache[cache_key]
        
        try:
            cursor = self.connection.cursor()
            
            # 构建筛选条件
            conditions = []
            
            # 日期筛选
            if date_from and date_to:
                conditions.append(f"s.c_date >= '{date_from} 00:00:00' AND s.c_date <= '{date_to} 23:59:59'")
            elif month_filters and len(month_filters) > 0:
                month_conditions = " OR ".join([f"FORMAT(s.c_date, 'yyyy-MM') = '{month}'" for month in month_filters])
                conditions.append(f"({month_conditions})")
            
            # 星期筛选
            if weekday_filters and len(weekday_filters) > 0:
                weekday_mapping = {
                    'Sunday': 1, 'Monday': 2, 'Tuesday': 3, 'Wednesday': 4, 
                    'Thursday': 5, 'Friday': 6, 'Saturday': 7
                }
                weekday_values = [str(weekday_mapping.get(weekday, 0)) for weekday in weekday_filters if weekday_mapping.get(weekday, 0) > 0]
                if weekday_values:
                    weekday_conditions = " OR ".join([f"DATEPART(WEEKDAY, s.c_date) = {value}" for value in weekday_values])
                    conditions.append(f"({weekday_conditions})")
            
            # 门店筛选
            if outlet_filters and len(outlet_filters) > 0:
                outlet_conditions = " OR ".join([f"s.store_name = '{outlet}'" for outlet in outlet_filters])
                conditions.append(f"({outlet_conditions})")
            
            # 类别筛选
            if category_filters and len(category_filters) > 0:
                category_conditions = " OR ".join([f"im.category_code = '{category}'" for category in category_filters])
                conditions.append(f"({category_conditions})")
            
            # 支付方式筛选
            if payment_filters and len(payment_filters) > 0:
                payment_conditions = " OR ".join([f"p.payment_name = '{method}'" for method in payment_filters])
                conditions.append(f"EXISTS (SELECT 1 FROM {TABLE_PAYMENT} p WHERE s.sales_no = p.sales_no AND s.store_name = p.store_name AND ({payment_conditions}))")
            
            # 排除WASTAGE及其变体 - 优化版本，使用NOT IN代替多个LIKE
            conditions.append("s.item_name NOT IN ('WASTAGE', 'Waste', 'waste', 'WASTE')")
            
            where_clause = ""
            if conditions:
                where_clause = " WHERE " + " AND ".join(conditions)
            
            # 构建JOIN子句
            join_clause = f"LEFT JOIN {TABLE_ITEMS} im ON s.item_name = im.item_name"
            if payment_filters and len(payment_filters) > 0:
                join_clause += f" LEFT JOIN {TABLE_PAYMENT} p ON s.sales_no = p.sales_no AND s.store_name = p.store_name"
            
            # 查询类别分析数据
            query = f"""
                WITH CategoryData AS (
                    SELECT 
                        FORMAT(s.c_date, 'yyyy-MM') as 月份,
                        s.store_name as 门市,
                        ISNULL(im.category_code, '未分类') as 类别,
                        -- 总业绩计算
                        SUM({self.get_performance_calculation_sql()}) as 总业绩,
                        COUNT(DISTINCT CONCAT(s.store_name, '-', s.sales_no)) as 总单据数,
                        -- DI业绩 (take_away_item = 'N')
                        SUM(CASE WHEN s.take_away_item = 'N' THEN 
                            CAST(s.sub_total as FLOAT) - CAST(ISNULL(s.pro_disc_amt, 0) as FLOAT) + CAST(ISNULL(s.svc_amt, 0) as FLOAT) - 
                            CASE WHEN s.take_away_item = 'Y' THEN CAST(ISNULL(s.tax_amt, 0) as FLOAT) ELSE 0 END
                        ELSE 0 END) as DI业绩,
                        COUNT(DISTINCT CASE WHEN s.take_away_item = 'N' THEN s.sales_no END) as DI单据数,
                        -- 外带业绩 (take_away_item = 'Y')
                        SUM(CASE WHEN s.take_away_item = 'Y' THEN 
                            CAST(s.sub_total as FLOAT) - CAST(ISNULL(s.pro_disc_amt, 0) as FLOAT) + CAST(ISNULL(s.svc_amt, 0) as FLOAT) - 
                            CASE WHEN s.take_away_item = 'Y' THEN CAST(ISNULL(s.tax_amt, 0) as FLOAT) ELSE 0 END
                        ELSE 0 END) as 外带业绩,
                        COUNT(DISTINCT CASE WHEN s.take_away_item = 'Y' THEN s.sales_no END) as 外带单据数,
                        -- 配送业绩 (暂时设为0)
                        0.0 as 配送业绩,
                        0 as 配送单据数,
                        -- FOOD PANDA业绩 (暂时设为0)
                        0.0 as FOOD_PANDA业绩,
                        0 as FOOD_PANDA单据数,
                        -- GRAB FOOD业绩 (暂时设为0)
                        0.0 as GRAB_FOOD业绩,
                        0 as GRAB_FOOD单据数,
                        -- DELIVEROO业绩 (暂时设为0)
                        0.0 as DELIVEROO业绩,
                        0 as DELIVEROO单据数
                    FROM {TABLE_SALES} s WITH (NOLOCK)
                    {join_clause}
                    {where_clause}
                    GROUP BY FORMAT(s.c_date, 'yyyy-MM'), s.store_name, ISNULL(im.category_code, '未分类')
                )
                SELECT 
                    月份,
                    门市,
                    类别,
                    总业绩,
                    总单据数,
                    CASE WHEN 总单据数 > 0 THEN 总业绩 / 总单据数 ELSE 0 END as 总单据大小,
                    DI业绩,
                    DI单据数,
                    CASE WHEN DI单据数 > 0 THEN DI业绩 / DI单据数 ELSE 0 END as DI单据大小,
                    外带业绩,
                    外带单据数,
                    CASE WHEN 外带单据数 > 0 THEN 外带业绩 / 外带单据数 ELSE 0 END as 外带单据大小,
                    配送业绩,
                    配送单据数,
                    CASE WHEN 配送单据数 > 0 THEN 配送业绩 / 配送单据数 ELSE 0 END as 配送单据大小,
                    FOOD_PANDA业绩,
                    FOOD_PANDA单据数,
                    CASE WHEN FOOD_PANDA单据数 > 0 THEN FOOD_PANDA业绩 / FOOD_PANDA单据数 ELSE 0 END as FOOD_PANDA单据大小,
                    GRAB_FOOD业绩,
                    GRAB_FOOD单据数,
                    CASE WHEN GRAB_FOOD单据数 > 0 THEN GRAB_FOOD业绩 / GRAB_FOOD单据数 ELSE 0 END as GRAB_FOOD单据大小,
                    DELIVEROO业绩,
                    DELIVEROO单据数,
                    CASE WHEN DELIVEROO单据数 > 0 THEN DELIVEROO业绩 / DELIVEROO单据数 ELSE 0 END as DELIVEROO单据大小
                FROM CategoryData
                ORDER BY 月份 DESC, 门市, 类别
                OPTION (RECOMPILE, MAXDOP 4)
            """
            
            print(f"开始执行类别分析查询...")
            start_time = time.time()
            cursor.execute(query)
            results = cursor.fetchall()
            end_time = time.time()
            print(f"类别分析查询完成，耗时: {end_time - start_time:.2f} 秒")
            print(f"类别分析查询结果: {len(results)} 条记录")
            
            # 转换数据格式
            data = []
            for row in results:
                data.append({
                    '月份': row[0],
                    '门市': row[1],
                    '类别': row[2],
                    '总业绩': float(row[3]) if row[3] else 0.0,
                    '总单据数': int(row[4]) if row[4] else 0,
                    '总单据大小': float(row[5]) if row[5] else 0.0,
                    'DI业绩': float(row[6]) if row[6] else 0.0,
                    'DI单据数': int(row[7]) if row[7] else 0,
                    'DI单据大小': float(row[8]) if row[8] else 0.0,
                    '外带业绩': float(row[9]) if row[9] else 0.0,
                    '外带单据数': int(row[10]) if row[10] else 0,
                    '外带单据大小': float(row[11]) if row[11] else 0.0,
                    '配送业绩': float(row[12]) if row[12] else 0.0,
                    '配送单据数': int(row[13]) if row[13] else 0,
                    '配送单据大小': float(row[14]) if row[14] else 0.0,
                    'FOOD_PANDA业绩': float(row[15]) if row[15] else 0.0,
                    'FOOD_PANDA单据数': int(row[16]) if row[16] else 0,
                    'FOOD_PANDA单据大小': float(row[17]) if row[17] else 0.0,
                    'GRAB_FOOD业绩': float(row[18]) if row[18] else 0.0,
                    'GRAB_FOOD单据数': int(row[19]) if row[19] else 0,
                    'GRAB_FOOD单据大小': float(row[20]) if row[20] else 0.0,
                    'DELIVEROO业绩': float(row[21]) if row[21] else 0.0,
                    'DELIVEROO单据数': int(row[22]) if row[22] else 0,
                    'DELIVEROO单据大小': float(row[23]) if row[23] else 0.0
                })
            
            cursor.close()
            
            # 存储到缓存
            if not hasattr(self, '_category_cache'):
                self._category_cache = {}
            self._category_cache[cache_key] = data
            
            # 限制缓存大小
            if len(self._category_cache) > 10:
                # 删除最旧的缓存项
                oldest_key = next(iter(self._category_cache))
                del self._category_cache[oldest_key]
            
            return data
            
        except Exception as e:
            print(f"获取类别分析失败: {e}")
            return []
    
    def get_weekly_product_data(self, date_from=None, date_to=None, outlet_filters=None, month_filters=None, 
                               weekday_filters=None, category_filters=None, payment_filters=None):
        """获取周期产品数据 - 按周显示数据，支持合併模式"""
        # 如果是合併模式，执行合併查询
        if self.combined_mode:
            return self.get_combined_weekly_product_data(date_from, date_to, outlet_filters, month_filters, weekday_filters, category_filters, payment_filters)
        
        # 检查缓存
        cache_key = f"weekly_{self.current_database}_{date_from}_{date_to}_{outlet_filters}_{month_filters}_{weekday_filters}_{category_filters}_{payment_filters}"
        if hasattr(self, '_weekly_cache') and cache_key in self._weekly_cache:
            print("✓ 使用缓存的周期产品数据")
            print(f"DEBUG: 缓存键: {cache_key}")
            cached_data = self._weekly_cache[cache_key]
            print(f"DEBUG: 缓存数据条数: {len(cached_data) if cached_data else 0}")
            return cached_data
        
        try:
            cursor = self.connection.cursor()
            query = ""  # 初始化query变量，避免在异常处理中访问未定义的变量
            
            # 构建WHERE条件
            conditions = []
            params = []
            
            # 日期筛选 - 直接使用字符串替换
            if date_from and date_to:
                conditions.append(f"s.c_date >= '{date_from} 00:00:00' AND s.c_date <= '{date_to} 23:59:59'")
            
            # 门店筛选
            if outlet_filters and len(outlet_filters) > 0:
                outlet_conditions = " OR ".join([f"s.store_name = '{outlet}'" for outlet in outlet_filters])
                conditions.append(f"({outlet_conditions})")
            
            # 月份筛选
            if month_filters and len(month_filters) > 0:
                month_conditions = " OR ".join([f"FORMAT(CAST(s.c_date AS DATE), 'yyyy-MM') = '{month}'" for month in month_filters])
                conditions.append(f"({month_conditions})")
            
            # 星期筛选
            if weekday_filters and len(weekday_filters) > 0:
                weekday_mapping = {
                    'Sunday': 1, 'Monday': 2, 'Tuesday': 3, 'Wednesday': 4, 
                    'Thursday': 5, 'Friday': 6, 'Saturday': 7
                }
                weekday_values = [str(weekday_mapping.get(weekday, 0)) for weekday in weekday_filters if weekday_mapping.get(weekday, 0) > 0]
                if weekday_values:
                    weekday_conditions = " OR ".join([f"DATEPART(WEEKDAY, s.c_date) = {value}" for value in weekday_values])
                    conditions.append(f"({weekday_conditions})")
            
            # 类别筛选
            join_clause = ""
            if category_filters and len(category_filters) > 0:
                join_clause = f"""
                    INNER JOIN (
                        SELECT item_name, category_code
                        FROM {TABLE_ITEMS} im1
                        WHERE im1.m_date = (
                            SELECT MAX(m_date) 
                            FROM {TABLE_ITEMS} im2 
                            WHERE im2.item_name = im1.item_name
                        )
                    ) im ON s.item_name = im.item_name
                """
                category_conditions = " OR ".join([f"im.category_code = '{category}'" for category in category_filters])
                conditions.append(f"({category_conditions})")
            
            # 支付方式筛选 - 严格匹配，只有当销售记录的所有支付方式都在筛选列表中时才包括
            if payment_filters and len(payment_filters) > 0:
                placeholders = ','.join([f"'{payment}'" for payment in payment_filters])
                conditions.append(f"""NOT EXISTS (
                    SELECT 1 FROM {TABLE_PAYMENT} p
                    WHERE p.sales_no = s.sales_no AND p.store_name = s.store_name
                    AND p.payment_name NOT IN ({placeholders})
                )""")
            
            # 排除wastage主产品 - 与期间-产品数据保持一致
            conditions.append("s.item_name != 'WASTAGE'")
            
            where_clause = ""
            if conditions:
                where_clause = " WHERE " + " AND ".join(conditions)
            
            # 查询周期产品数据 - 使用与期间-产品数据完全相同的逻辑，只是按周分组
            query = f"""
                    SELECT 
                    CONCAT(FORMAT(DATEADD(DAY, -(DATEPART(WEEKDAY, s.c_date) - 2), CAST(s.c_date as DATE)), 'd/M'), ' - ', 
                           FORMAT(DATEADD(DAY, 6, DATEADD(DAY, -(DATEPART(WEEKDAY, s.c_date) - 2), CAST(s.c_date as DATE))), 'd/M')) as 期间,
                        s.item_name as 产品名称,
                    ISNULL(im.category_code, '未分类') as 类别,
                    7 as 天数,
                SUM({self.get_performance_calculation_sql()} - 
                        ISNULL(CAST(c.cancel_amount as FLOAT), 0)) as 总业绩,
                    COUNT(DISTINCT CONCAT(s.store_name, '-', s.sales_no)) as 总单据数,
                    SUM(CAST(s.qty as FLOAT) - ISNULL(CAST(c.cancel_qty as FLOAT), 0)) as 销售总数,
                    SUM(CASE WHEN p.sales_no IS NOT NULL THEN CAST(s.qty as FLOAT) ELSE 0 END) as 报废数量,
                    SUM(CAST(s.sub_total as FLOAT)) as 销售金额,
                    DATEPART(WEEK, s.c_date) as 周数
                    FROM {TABLE_SALES} s WITH (NOLOCK)
                LEFT JOIN {TABLE_ITEMS} im ON s.item_name = im.item_name
                LEFT JOIN (
                    SELECT DISTINCT store_name, sales_no
                    FROM {TABLE_PAYMENT} WITH (NOLOCK)
                    WHERE payment_name = 'WASTAGE'
                ) p ON s.store_name = p.store_name AND s.sales_no = p.sales_no
                    LEFT JOIN (
                        SELECT 
                            sales_no, 
                            store_name, 
                            item_name,
                        SUM({self._get_cancel_performance_calculation_sql()}) as cancel_amount,
                        SUM(CAST(qty as FLOAT)) as cancel_qty
                        FROM {TABLE_CANCEL} WITH (NOLOCK)
                        GROUP BY sales_no, store_name, item_name
                    ) c ON s.sales_no = c.sales_no AND s.store_name = c.store_name AND s.item_name = c.item_name
                    {join_clause}
                    {where_clause}
                GROUP BY s.item_name, im.category_code, DATEPART(WEEK, s.c_date),
                             DATEADD(DAY, -(DATEPART(WEEKDAY, s.c_date) - 2), CAST(s.c_date as DATE))
                ORDER BY 总业绩 DESC
                OPTION (RECOMPILE, MAXDOP 4)
            """
            
            print(f"执行周期产品数据查询...")
            print(f"WHERE子句: {where_clause}")
            print(f"SQL查询: {query}")
            
            # 添加数据库连接状态检查
            if not self.connection:
                print("❌ 数据库连接为空，无法执行查询")
                return []
            
            try:
                cursor.execute(query)
                results = cursor.fetchall()
                print(f"周期产品数据查询结果: {len(results)} 条记录")
                if results:
                    print(f"第一条记录: {results[0]}")
                else:
                    print(f"查询返回0条记录，请检查筛选条件和数据库中的数据")
                    # 添加一个简单的测试查询来检查数据库中是否有数据
                    test_query = f"SELECT COUNT(*) as total_records FROM {TABLE_SALES} WHERE c_date >= '{date_from} 00:00:00' AND c_date <= '{date_to} 23:59:59'"
                    print(f"执行测试查询: {test_query}")
                    cursor.execute(test_query)
                    test_result = cursor.fetchone()
                    print(f"测试查询结果 - 该日期范围内的总记录数: {test_result[0] if test_result else 0}")
            except Exception as query_error:
                print(f"❌ SQL查询执行失败: {query_error}")
                import traceback
                print(f"错误详情: {traceback.format_exc()}")
                return []
            
            # 计算总计数据
            total_sales = sum(float(row[4]) if row[4] else 0.0 for row in results)
            total_receipts = sum(int(row[5]) if row[5] else 0 for row in results)
            total_quantity = sum(float(row[6]) if row[6] else 0.0 for row in results)
            total_wastage = sum(float(row[7]) if len(row) > 7 and row[7] else 0.0 for row in results)
            
            # 转换数据格式 - 与期间-产品数据保持一致
            data = []
            for row in results:
                sales = float(row[4]) if row[4] else 0.0
                quantity = float(row[6]) if row[6] else 0.0
                wastage_qty = float(row[7]) if len(row) > 7 and row[7] else 0.0
                amount = float(row[8]) if len(row) > 8 and row[8] else 0.0
                days = int(row[3]) if row[3] else 1
                
                sales_ratio = (sales / total_sales * 100) if total_sales > 0 else 0
                quantity_ratio = (quantity / total_quantity * 100) if total_quantity > 0 else 0
                total_qty_with_wastage = wastage_qty + quantity
                wastage_ratio = (wastage_qty / total_qty_with_wastage * 100) if total_qty_with_wastage > 0 else 0
                
                data.append({
                    '期间': row[0],
                    '产品名称': row[1],
                    '类别': row[2],
                    '天数': days,
                    '总业绩': sales,
                    '总单据数': int(row[5]) if row[5] else 0,
                    '销售总数': quantity,
                    '报废数量': wastage_qty,
                    '销售金额': amount,
                    '业绩占比': sales_ratio,
                    '数量占比': quantity_ratio,
                    '报废占比': wastage_ratio,
                    '总业绩_日均': sales / days if days > 0 else 0,
                    '总单据数_日均': (int(row[5]) if row[5] else 0) / days if days > 0 else 0,
                    '销售总数_日均': quantity / days if days > 0 else 0,
                    '报废数量_日均': wastage_qty / days if days > 0 else 0,
                    '周数': row[9] if len(row) > 9 else 0
                })
            
            cursor.close()
            print(f"周期产品数据查询完成，共 {len(data)} 条记录")
            
            # 存储到缓存
            if not hasattr(self, '_weekly_cache'):
                self._weekly_cache = {}
            self._weekly_cache[cache_key] = data
            
            # 限制缓存大小
            if len(self._weekly_cache) > 10:
                # 删除最旧的缓存项
                oldest_key = next(iter(self._weekly_cache))
                del self._weekly_cache[oldest_key]
            
            return data
            
        except Exception as e:
            print(f"获取周期产品数据失败: {e}")
            print(f"SQL查询: {query}")
            print(f"参数: {params}")
            return []

    def get_performance_comparison(self, date_from=None, date_to=None, outlet_filters=None, month_filters=None, 
                                 weekday_filters=None, category_filters=None, payment_filters=None, 
                                 comparison_method="date", comparison_date_from=None, comparison_date_to=None, comparison_weeks=None):
        """获取业绩对比分析 - 支持多种对比方式"""
        try:
            cursor = self.connection.cursor()
            query = ""  # 初始化query变量，避免在异常处理中访问未定义的变量
            
            # 构建WHERE条件
            conditions = []
            params = []
            
            # 日期筛选 - 直接使用字符串替换
            if date_from and date_to:
                conditions.append(f"s.c_date >= '{date_from} 00:00:00' AND s.c_date <= '{date_to} 23:59:59'")
            
            # 门店筛选
            if outlet_filters and len(outlet_filters) > 0:
                outlet_conditions = " OR ".join([f"s.store_name = '{outlet}'" for outlet in outlet_filters])
                conditions.append(f"({outlet_conditions})")
            
            # 月份筛选
            if month_filters and len(month_filters) > 0:
                month_conditions = " OR ".join([f"FORMAT(CAST(s.c_date AS DATE), 'yyyy-MM') = '{month}'" for month in month_filters])
                conditions.append(f"({month_conditions})")
            
            # 星期筛选
            if weekday_filters and len(weekday_filters) > 0:
                weekday_mapping = {
                    'Sunday': 1, 'Monday': 2, 'Tuesday': 3, 'Wednesday': 4, 
                    'Thursday': 5, 'Friday': 6, 'Saturday': 7
                }
                weekday_values = [str(weekday_mapping.get(weekday, 0)) for weekday in weekday_filters if weekday_mapping.get(weekday, 0) > 0]
                if weekday_values:
                    weekday_conditions = " OR ".join([f"DATEPART(WEEKDAY, s.c_date) = {value}" for value in weekday_values])
                    conditions.append(f"({weekday_conditions})")
            
            # 类别筛选
            join_clause = ""
            if category_filters and len(category_filters) > 0:
                join_clause = f"""
                    INNER JOIN (
                        SELECT item_name, category_code
                        FROM {TABLE_ITEMS} im1
                        WHERE im1.m_date = (
                            SELECT MAX(m_date) 
                            FROM {TABLE_ITEMS} im2 
                            WHERE im2.item_name = im1.item_name
                        )
                    ) im ON s.item_name = im.item_name
                """
                category_conditions = " OR ".join([f"im.category_code = '{category}'" for category in category_filters])
                conditions.append(f"({category_conditions})")
            
            # 支付方式筛选
            if payment_filters and len(payment_filters) > 0:
                payment_conditions = " OR ".join(["p.payment_name = ?" for _ in payment_filters])
                conditions.append(f"EXISTS (SELECT 1 FROM {TABLE_PAYMENT} p WHERE s.sales_no = p.sales_no AND s.store_name = p.store_name AND ({payment_conditions}))")
                params.extend(payment_filters)
            
            # 业绩对比中需要包含WASTAGE来计算报废数量，所以不排除WASTAGE
            # conditions.append("s.item_name != 'WASTAGE'")
            
            where_clause = ""
            if conditions:
                where_clause = " WHERE " + " AND ".join(conditions)
            
            # 根据对比方式计算对比期间
            if comparison_method == "date" and comparison_date_from and comparison_date_to:
                # 对比特定日期范围
                compare_date_from_str = comparison_date_from.strftime('%Y-%m-%d')
                compare_date_to_str = comparison_date_to.strftime('%Y-%m-%d')
                period_display = f"CONCAT(FORMAT(CAST('{date_from}' as DATE), 'd/M'), ' - ', FORMAT(CAST('{date_to}' as DATE), 'd/M'))"
                compare_period_display = f"CONCAT(FORMAT(CAST('{compare_date_from_str}' as DATE), 'd/M'), ' - ', FORMAT(CAST('{compare_date_to_str}' as DATE), 'd/M'))"
                compare_where = f"CAST(s.c_date as DATE) >= '{compare_date_from_str}' AND CAST(s.c_date as DATE) <= '{compare_date_to_str}'"
            elif comparison_method == "week":
                # 对比周期 - 支持多选
                if not comparison_weeks:
                    comparison_weeks = ["上一周期"]  # 默认选择
                
                # 当前周期
                period_display = f"CONCAT(FORMAT(CAST('{date_from}' as DATE), 'd/M'), ' - ', FORMAT(CAST('{date_to}' as DATE), 'd/M'))"
                
                # 根据选择的周期计算对比期间
                if "上一周期" in comparison_weeks:
                    # 上一周期
                    compare_period_display = f"CONCAT(FORMAT(DATEADD(DAY, -7, CAST('{date_from}' as DATE)), 'd/M'), ' - ', FORMAT(DATEADD(DAY, -7, CAST('{date_to}' as DATE)), 'd/M'))"
                    compare_where = f"CAST(s.c_date as DATE) >= DATEADD(DAY, -7, CAST('{date_from}' as DATE)) AND CAST(s.c_date as DATE) <= DATEADD(DAY, -7, CAST('{date_to}' as DATE))"
                elif "上个月同期" in comparison_weeks:
                    # 上个月同期
                    compare_period_display = f"CONCAT(FORMAT(DATEADD(MONTH, -1, CAST('{date_from}' as DATE)), 'd/M'), ' - ', FORMAT(DATEADD(MONTH, -1, CAST('{date_to}' as DATE)), 'd/M'))"
                    compare_where = f"CAST(s.c_date as DATE) >= DATEADD(MONTH, -1, CAST('{date_from}' as DATE)) AND CAST(s.c_date as DATE) <= DATEADD(MONTH, -1, CAST('{date_to}' as DATE))"
                else:
                    # 默认上一周期
                    compare_period_display = f"CONCAT(FORMAT(DATEADD(DAY, -7, CAST('{date_from}' as DATE)), 'd/M'), ' - ', FORMAT(DATEADD(DAY, -7, CAST('{date_to}' as DATE)), 'd/M'))"
                    compare_where = f"CAST(s.c_date as DATE) >= DATEADD(DAY, -7, CAST('{date_from}' as DATE)) AND CAST(s.c_date as DATE) <= DATEADD(DAY, -7, CAST('{date_to}' as DATE))"
            else:
                # 默认上个月同期
                period_display = f"CONCAT(FORMAT(CAST('{date_from}' as DATE), 'd/M'), ' - ', FORMAT(CAST('{date_to}' as DATE), 'd/M'))"
                compare_period_display = f"CONCAT(FORMAT(DATEADD(MONTH, -1, CAST('{date_from}' as DATE)), 'd/M'), ' - ', FORMAT(DATEADD(MONTH, -1, CAST('{date_to}' as DATE)), 'd/M'))"
                compare_where = f"CAST(s.c_date as DATE) >= DATEADD(MONTH, -1, CAST('{date_from}' as DATE)) AND CAST(s.c_date as DATE) <= DATEADD(MONTH, -1, CAST('{date_to}' as DATE))"
            
            # 查询业绩对比数据 - 完全简化版本避免嵌套聚合函数错误
            query = f"""
                WITH SelectedPeriodData AS (
                    SELECT 
                        s.item_name as 产品名称,
                        {period_display} as 期间,
                        SUM({self.get_performance_calculation_sql()}) as 总业绩,
                        COUNT(DISTINCT CONCAT(s.store_name, '-', s.sales_no)) as 总单据,
                        SUM({self.get_performance_calculation_sql()}) as 产品业绩,
                        COUNT(DISTINCT CONCAT(s.store_name, '-', s.sales_no)) as 产品单据,
                        SUM(CAST(s.qty as FLOAT)) as 报废数量
                    FROM {TABLE_SALES} s WITH (NOLOCK)
                    {join_clause}
                    {where_clause}
                    GROUP BY s.item_name
                ),
                ComparePeriodData AS (
                    SELECT 
                        s.item_name as 产品名称,
                        {compare_period_display} as 期间,
                        SUM({self.get_performance_calculation_sql()}) as 总业绩,
                        COUNT(DISTINCT CONCAT(s.store_name, '-', s.sales_no)) as 总单据,
                        SUM({self.get_performance_calculation_sql()}) as 产品业绩,
                        COUNT(DISTINCT CONCAT(s.store_name, '-', s.sales_no)) as 产品单据,
                        SUM(CAST(s.qty as FLOAT)) as 报废数量
                    FROM {TABLE_SALES} s WITH (NOLOCK)
                    {join_clause}
                    WHERE {compare_where}
                    GROUP BY s.item_name
                )
                SELECT 
                    产品名称,
                    期间,
                    总业绩,
                    总单据,
                    CASE WHEN 总单据 > 0 THEN 总业绩 / 总单据 ELSE 0 END as 平均单据,
                    产品业绩,
                    产品单据,
                    报废数量,
                    CASE WHEN 总业绩 > 0 THEN (产品业绩 / 总业绩) * 100 ELSE 0 END as 业绩占比,
                    CASE WHEN 总单据 > 0 THEN (产品单据 / 总单据) * 100 ELSE 0 END as 单据占比
                FROM SelectedPeriodData
                UNION ALL
                SELECT 
                    产品名称,
                    期间,
                    总业绩,
                    总单据,
                    CASE WHEN 总单据 > 0 THEN 总业绩 / 总单据 ELSE 0 END as 平均单据,
                    产品业绩,
                    产品单据,
                    报废数量,
                    CASE WHEN 总业绩 > 0 THEN (产品业绩 / 总业绩) * 100 ELSE 0 END as 业绩占比,
                    CASE WHEN 总单据 > 0 THEN (产品单据 / 总单据) * 100 ELSE 0 END as 单据占比
                FROM ComparePeriodData
                ORDER BY 期间, 产品名称
                OPTION (RECOMPILE, MAXDOP 4)
            """
            
            print(f"执行业绩对比查询...")
            print(f"WHERE子句: {where_clause}")
            print(f"参数: {params}")
            cursor.execute(query, params)
            results = cursor.fetchall()
            
            # 转换数据格式
            data = []
            for row in results:
                data.append({
                    '产品名称': row[0],
                    '期间': row[1],
                    '总业绩': float(row[2]) if row[2] else 0.0,
                    '总单据': int(row[3]) if row[3] else 0,
                    '平均单据': float(row[4]) if row[4] else 0.0,
                    '产品业绩': float(row[5]) if row[5] else 0.0,
                    '产品单据': int(row[6]) if row[6] else 0,
                    '报废数量': float(row[7]) if row[7] else 0.0,
                    '业绩占比': float(row[8]) if row[8] else 0.0,
                    '单据占比': float(row[9]) if row[9] else 0.0
                })
            
            cursor.close()
            print(f"业绩对比查询完成，共 {len(data)} 条记录")
            return data
            
        except Exception as e:
            print(f"获取业绩对比失败: {e}")
            print(f"SQL查询: {query}")
            print(f"参数: {params}")
            return []

    def get_combined_product_overview(self, date_from=None, date_to=None, outlet_filters=None, product_filters=None, month_filters=None, 
                                    weekday_filters=None, category_filters=None, payment_filters=None):
        """获取合并的产品总览分析 - 从所有数据库合并数据"""
        try:
            print("🔄 执行合并产品总览查询...")
            
            # 所有数据库列表
            databases = ["sushi_gogo_pos_live", "sushi_express_pos_live", "sushi_plus_pos_live"]
            all_results = []
            
            # 为每个数据库执行查询
            for db_name in databases:
                try:
                    print(f"📊 查询数据库: {db_name}")
                    
                    # 构建查询SQL
                    conditions = []
                    params = []
                    
                    # 日期筛选
                    if date_from and date_to:
                        conditions.append(f"CAST(s.c_date as DATE) >= '{date_from}' AND CAST(s.c_date as DATE) <= '{date_to}'")
                    
                    # 门店筛选
                    if outlet_filters:
                        outlet_conditions = " OR ".join([f"s.store_name LIKE '%{outlet}%'" for outlet in outlet_filters])
                        conditions.append(f"({outlet_conditions})")
                    
                    # 产品筛选
                    if product_filters:
                        product_conditions = " OR ".join([f"s.item_name LIKE '%{product}%'" for product in product_filters])
                        conditions.append(f"({product_conditions})")
                    
                    # 排除wastage
                    conditions.append("s.item_name NOT IN ('WASTAGE', 'Waste', 'waste', 'WASTE')")
                    
                    where_clause = ""
                    if conditions:
                        where_clause = " WHERE " + " AND ".join(conditions)
                    
                    # 构建查询
                    query = f"""
                        SELECT
                            s.item_name,
                            COALESCE(im.category_code, '未分类') as category_code,
                            SUM(s.qty) as total_qty,
                            SUM({self.get_combined_performance_calculation_sql(db_name)}) as total_amount,
                            COUNT(DISTINCT s.sales_no) as receipt_count,
                            COUNT(DISTINCT s.store_name) as store_count,
                            AVG({self.get_combined_performance_calculation_sql(db_name)}) as avg_amount
                        FROM {db_name}.dbo.{TABLE_SALES} s WITH (NOLOCK)
                        LEFT JOIN {db_name}.dbo.{TABLE_ITEMS} im WITH (NOLOCK) ON s.item_name = im.item_name
                        {where_clause}
                        GROUP BY s.item_name, COALESCE(im.category_code, '未分类')
                        ORDER BY total_amount DESC
                    """
                    
                    # 执行查询
                    cursor = self.connection.cursor()
                    cursor.execute(query)
                    results = cursor.fetchall()
                    
                    # 添加数据库标识
                    for row in results:
                        row_dict = {
                            'item_name': row[0],
                            'category_code': row[1],
                            'total_qty': row[2],
                            'total_amount': row[3],
                            'receipt_count': row[4],
                            'store_count': row[5],
                            'avg_amount': row[6],
                            'database': db_name
                        }
                        all_results.append(row_dict)
                    
                    cursor.close()
                    print(f"✅ {db_name}: 获取到 {len(results)} 条产品记录")
                    
                except Exception as e:
                    print(f"❌ 查询数据库 {db_name} 失败: {e}")
                    continue
            
            # 合并相同产品的数据
            merged_results = {}
            for result in all_results:
                key = f"{result['item_name']}_{result['category_code']}"
                if key not in merged_results:
                    merged_results[key] = {
                        'item_name': result['item_name'],
                        'category_code': result['category_code'],
                        'total_qty': 0,
                        'total_amount': 0,
                        'receipt_count': 0,
                        'store_count': set(),
                        'avg_amount': 0,
                        'databases': []
                    }
                
                merged_results[key]['total_qty'] += float(result['total_qty'])
                merged_results[key]['total_amount'] += float(result['total_amount'])
                # 修復：不要累加單據數，因為同一張單據可能有多個產品
                # merged_results[key]['receipt_count'] += int(result['receipt_count'])
                merged_results[key]['store_count'].add(result['database'])
                merged_results[key]['databases'].append(result['database'])
            
            # 转换最终结果
            final_results = []
            for key, data in merged_results.items():
                final_results.append({
                    'item_name': data['item_name'],
                    'category_code': data['category_code'],
                    'total_qty': data['total_qty'],
                    'total_amount': data['total_amount'],
                    'receipt_count': data['receipt_count'],
                    'store_count': len(data['store_count']),
                    'avg_amount': data['total_amount'] / data['total_qty'] if data['total_qty'] > 0 else 0,
                    'databases': list(set(data['databases']))
                })
            
            # 按总金额排序
            final_results.sort(key=lambda x: x['total_amount'], reverse=True)
            
            print(f"✅ 合并完成: 总共 {len(final_results)} 个产品")
            return final_results
            
        except Exception as e:
            print(f"❌ 合并产品总览查询失败: {e}")
            return []

    def get_combined_sales_data(self, date_from=None, date_to=None, outlet_filters=None, product_filters=None, search_term=None, month_filters=None, weekday_filters=None, category_filters=None, payment_filters=None):
        """获取合并的销售数据 - 从所有数据库合并数据"""
        try:
            print("🔄 执行合并销售数据查询...")
            
            # 所有数据库列表
            databases = ["sushi_gogo_pos_live", "sushi_express_pos_live", "sushi_plus_pos_live"]
            all_results = []
            
            # 为每个数据库执行查询
            for db_name in databases:
                try:
                    print(f"📊 查询数据库: {db_name}")
                    
                    # 构建查询SQL
                    conditions = []
                    
                    # 日期筛选
                    if date_from and date_to:
                        conditions.append(f"CAST(s.c_date as DATE) >= '{date_from}' AND CAST(s.c_date as DATE) <= '{date_to}'")
                    
                    # 门店筛选
                    if outlet_filters:
                        outlet_conditions = " OR ".join([f"s.store_name LIKE '%{outlet}%'" for outlet in outlet_filters])
                        conditions.append(f"({outlet_conditions})")
                    
                    # 产品筛选
                    if product_filters:
                        product_conditions = " OR ".join([f"s.item_name LIKE '%{product}%'" for product in product_filters])
                        conditions.append(f"({product_conditions})")
                    
                    # 搜索词筛选
                    if search_term:
                        conditions.append(f"(s.item_name LIKE '%{search_term}%' OR s.store_name LIKE '%{search_term}%')")
                    
                    # 排除wastage
                    conditions.append("s.item_name NOT IN ('WASTAGE', 'Waste', 'waste', 'WASTE')")
                    
                    where_clause = ""
                    if conditions:
                        where_clause = " WHERE " + " AND ".join(conditions)
                    
                    # 构建查询
                    query = f"""
                        SELECT
                            s.store_name,
                            s.sales_no,
                            s.item_name,
                            s.qty,
                            s.disc_amt,
                            s.disc_name,
                            s.pro_disc_amt,
                            s.sub_total,
                            s.svc_amt,
                            s.tax_amt,
                            s.c_date,
                            s.order_datetime,
                            {self.get_combined_performance_calculation_sql(db_name)} as total_amt,
                            COALESCE(im.category_code, '未分类') as category_code
                        FROM {db_name}.dbo.{TABLE_SALES} s WITH (NOLOCK)
                        LEFT JOIN {db_name}.dbo.{TABLE_ITEMS} im WITH (NOLOCK) ON s.item_name = im.item_name
                        {where_clause}
                        ORDER BY s.c_date DESC, s.store_name, s.sales_no
                    """
                    
                    # 执行查询
                    cursor = self.connection.cursor()
                    cursor.execute(query)
                    results = cursor.fetchall()
                    
                    # 添加数据库标识
                    for row in results:
                        row_dict = {
                            'store_name': row[0],
                            'sales_no': row[1],
                            'item_name': row[2],
                            'qty': row[3],
                            'disc_amt': row[4],
                            'disc_name': row[5],
                            'pro_disc_amt': row[6],
                            'sub_total': row[7],
                            'svc_amt': row[8],
                            'tax_amt': row[9],
                            'c_date': row[10],
                            'order_datetime': row[11],
                            'total_amt': row[12],
                            'category_code': row[13],
                            'database': db_name
                        }
                        all_results.append(row_dict)
                    
                    cursor.close()
                    print(f"✅ {db_name}: 获取到 {len(results)} 条销售记录")
                    
                except Exception as e:
                    print(f"❌ 查询数据库 {db_name} 失败: {e}")
                    continue
            
            print(f"✅ 合并完成: 总共 {len(all_results)} 条销售记录")
            return all_results
            
        except Exception as e:
            print(f"❌ 合并销售数据查询失败: {e}")
            return []

    def get_combined_outlets(self):
        """获取合并的门市列表 - 从所有数据库合并数据"""
        try:
            print("🔄 执行合并门市列表查询...")
            
            # 所有数据库列表
            databases = ["sushi_gogo_pos_live", "sushi_express_pos_live", "sushi_plus_pos_live"]
            all_outlets = set()
            
            # 为每个数据库执行查询
            for db_name in databases:
                try:
                    print(f"📊 查询数据库: {db_name}")
                    
                    # 构建查询
                    query = f"""
                        SELECT DISTINCT store_name 
                        FROM {db_name}.dbo.{TABLE_SALES} 
                        WHERE store_name IS NOT NULL AND store_name != ''
                        ORDER BY store_name
                    """
                    
                    # 执行查询
                    cursor = self.connection.cursor()
                    cursor.execute(query)
                    results = cursor.fetchall()
                    
                    # 添加到集合中
                    for row in results:
                        if row[0]:
                            all_outlets.add(row[0])
                    
                    cursor.close()
                    print(f"✅ {db_name}: 获取到 {len(results)} 个门市")
                    
                except Exception as e:
                    print(f"❌ 查询数据库 {db_name} 失败: {e}")
                    continue
            
            # 转换为排序列表
            combined_outlets = sorted(list(all_outlets))
            self.outlets = combined_outlets
            
            print(f"✅ 合并完成: 总共 {len(combined_outlets)} 个门市")
            return combined_outlets
            
        except Exception as e:
            print(f"❌ 合并门市列表查询失败: {e}")
            return []

    def get_combined_period_product_overview(self, date_from=None, date_to=None, outlet_filters=None, product_filters=None, month_filters=None, 
                                           weekday_filters=None, category_filters=None, payment_filters=None):
        """获取合并的期间产品总览分析 - 从所有数据库合并数据"""
        try:
            print("🔄 执行合并期间产品总览查询...")
            
            # 所有数据库列表
            databases = ["sushi_gogo_pos_live", "sushi_express_pos_live", "sushi_plus_pos_live"]
            all_results = []
            
            # 为每个数据库执行查询
            for db_name in databases:
                try:
                    print(f"📊 查询数据库: {db_name}")
                    
                    # 构建查询SQL
                    conditions = []
                    
                    # 日期筛选
                    if date_from and date_to:
                        conditions.append(f"CAST(s.c_date as DATE) >= '{date_from}' AND CAST(s.c_date as DATE) <= '{date_to}'")
                    
                    # 门店筛选
                    if outlet_filters:
                        outlet_conditions = " OR ".join([f"s.store_name LIKE '%{outlet}%'" for outlet in outlet_filters])
                        conditions.append(f"({outlet_conditions})")
                    
                    # 产品筛选
                    if product_filters:
                        product_conditions = " OR ".join([f"s.item_name LIKE '%{product}%'" for product in product_filters])
                        conditions.append(f"({product_conditions})")
                    
                    # 排除wastage
                    conditions.append("s.item_name NOT IN ('WASTAGE', 'Waste', 'waste', 'WASTE')")
                    
                    where_clause = ""
                    if conditions:
                        where_clause = " WHERE " + " AND ".join(conditions)
                    
                    # 期间显示
                    if date_from and date_to:
                        period_display = f"'{date_from} 到 {date_to}'"
                        days_calculation = f"DATEDIFF(day, '{date_from}', '{date_to}') + 1"
                    else:
                        period_display = "'全部期间'"
                        days_calculation = "COUNT(DISTINCT CAST(s.c_date as DATE))"
                    
                    # 构建查询
                    query = f"""
                        SELECT
                            {period_display} as 期间,
                            s.item_name as 产品名称,
                            ISNULL(im.category_code, '未分类') as 类别,
                            SUM(s.qty - ISNULL(CAST(c.cancel_qty as FLOAT), 0)) as 销售数量,
                            SUM({self.get_combined_performance_calculation_sql(db_name)} - ISNULL(CAST(c.cancel_amount as FLOAT), 0)) as 总业绩,
                            COUNT(DISTINCT CONCAT(s.store_name, '-', s.sales_no)) as 单据数,
                            COUNT(DISTINCT s.store_name) as 门市数,
                            AVG({self.get_combined_performance_calculation_sql(db_name)} - ISNULL(CAST(c.cancel_amount as FLOAT), 0)) as 平均业绩,
                            SUM(s.qty - ISNULL(CAST(c.cancel_qty as FLOAT), 0)) / {days_calculation} as 销售数量_日均,
                            SUM({self.get_combined_performance_calculation_sql(db_name)} - ISNULL(CAST(c.cancel_amount as FLOAT), 0)) / {days_calculation} as 总业绩_日均,
                            COUNT(DISTINCT CONCAT(s.store_name, '-', s.sales_no)) / {days_calculation} as 单据数_日均
                        FROM {db_name}.dbo.{TABLE_SALES} s WITH (NOLOCK)
                        LEFT JOIN {db_name}.dbo.{TABLE_ITEMS} im WITH (NOLOCK) ON s.item_name = im.item_name
                        LEFT JOIN (
                            SELECT 
                                sales_no, 
                                store_name, 
                                item_name,
                                SUM({self.get_combined_cancel_performance_calculation_sql(db_name)}) as cancel_amount,
                                SUM(CAST(qty as FLOAT)) as cancel_qty
                            FROM {db_name}.dbo.{TABLE_CANCEL} WITH (NOLOCK)
                            GROUP BY sales_no, store_name, item_name
                        ) c ON s.sales_no = c.sales_no AND s.store_name = c.store_name AND s.item_name = c.item_name
                        {where_clause}
                        GROUP BY s.item_name, im.category_code
                        ORDER BY 总业绩 DESC
                    """
                    
                    # 执行查询
                    cursor = self.connection.cursor()
                    cursor.execute(query)
                    results = cursor.fetchall()
                    
                    # 添加数据库标识
                    for row in results:
                        row_dict = {
                            '期间': row[0],
                            '产品名称': row[1],
                            '类别': row[2],
                            '销售数量': row[3],
                            '总业绩': row[4],
                            '单据数': row[5],
                            '门市数': row[6],
                            '平均业绩': row[7],
                            '销售数量_日均': row[8],
                            '总业绩_日均': row[9],
                            '单据数_日均': row[10],
                            'database': db_name
                        }
                        all_results.append(row_dict)
                    
                    cursor.close()
                    print(f"✅ {db_name}: 获取到 {len(results)} 条期间产品记录")
                    
                except Exception as e:
                    print(f"❌ 查询数据库 {db_name} 失败: {e}")
                    continue
            
            # 合并相同产品的数据
            merged_results = {}
            for result in all_results:
                key = f"{result['产品名称']}_{result['类别']}"
                if key not in merged_results:
                    merged_results[key] = {
                        '期间': result['期间'],
                        '产品名称': result['产品名称'],
                        '类别': result['类别'],
                        '销售数量': 0,
                        '总业绩': 0,
                        '单据数': 0,
                        '门市数': set(),
                        '平均业绩': 0,
                        '销售数量_日均': 0,
                        '总业绩_日均': 0,
                        '单据数_日均': 0,
                        'databases': []
                    }
                
                merged_results[key]['销售数量'] += float(result['销售数量'])
                merged_results[key]['总业绩'] += float(result['总业绩'])
                # 修復：不要累加單據數，因為同一張單據可能有多個產品
                # merged_results[key]['单据数'] += int(result['单据数'])
                merged_results[key]['门市数'].add(result['database'])
                merged_results[key]['databases'].append(result['database'])
            
            # 修復：重新計算正確的單據數
            for key, data in merged_results.items():
                product_name = data['产品名称']
                category = data['类别']
                
                # 重新查詢該產品的實際單據數
                total_receipt_count = 0
                for db_name in databases:
                    try:
                        # 構建查詢條件
                        conditions = [f"s.item_name = '{product_name}'"]
                        if date_from and date_to:
                            conditions.append(f"CAST(s.c_date as DATE) >= '{date_from}' AND CAST(s.c_date as DATE) <= '{date_to}'")
                        if outlet_filters:
                            outlet_conditions = " OR ".join([f"s.store_name LIKE '%{outlet}%'" for outlet in outlet_filters])
                            conditions.append(f"({outlet_conditions})")
                        
                        where_clause = " WHERE " + " AND ".join(conditions)
                        
                        receipt_query = f"""
                            SELECT COUNT(DISTINCT CONCAT(s.store_name, '-', s.sales_no)) as 单据数
                            FROM {db_name}.dbo.{TABLE_SALES} s WITH (NOLOCK)
                            {where_clause}
                            AND s.item_name != 'WASTAGE'
                        """
                        
                        cursor = self.connection.cursor()
                        cursor.execute(receipt_query)
                        result = cursor.fetchone()
                        cursor.close()
                        
                        if result and result[0]:
                            total_receipt_count += int(result[0])
                            
                    except Exception as e:
                        print(f"計算產品 {product_name} 在 {db_name} 的單據數失敗: {e}")
                        continue
                
                data['单据数'] = total_receipt_count
            
            # 转换最终结果
            final_results = []
            for key, data in merged_results.items():
                final_results.append({
                    '期间': data['期间'],
                    '产品名称': data['产品名称'],
                    '类别': data['类别'],
                    '销售数量': data['销售数量'],
                    '总业绩': data['总业绩'],
                    '总单据数': data['单据数'],  # 使用正确的字段名称
                    '门市数': len(data['门市数']),
                    '平均业绩': data['总业绩'] / data['销售数量'] if data['销售数量'] > 0 else 0,
                    '销售数量_日均': data['销售数量_日均'],
                    '总业绩_日均': data['总业绩_日均'],
                    '总单据数_日均': data['单据数_日均'],  # 使用正确的字段名称
                    'databases': list(set(data['databases']))
                })
            
            # 按总业绩排序
            final_results.sort(key=lambda x: x['总业绩'], reverse=True)
            
            print(f"✅ 合并完成: 总共 {len(final_results)} 个期间产品")
            return final_results
            
        except Exception as e:
            print(f"❌ 合并期间产品总览查询失败: {e}")
            return []

    def get_product_overview(self, date_from=None, date_to=None, outlet_filters=None, product_filters=None, month_filters=None, 
                           weekday_filters=None, category_filters=None, payment_filters=None):
        """获取产品总览分析 - 支持合併模式"""
        # 检查缓存
        cache_key = f"product_{self.current_database}_{date_from}_{date_to}_{outlet_filters}_{product_filters}_{month_filters}_{weekday_filters}_{category_filters}_{payment_filters}"
        if hasattr(self, '_product_cache') and cache_key in self._product_cache:
            print("✓ 使用缓存的产品总览数据")
            return self._product_cache[cache_key]
        
        # 如果是組合模式，執行合併查詢
        if self.combined_mode:
            return self.get_combined_product_overview(date_from, date_to, outlet_filters, product_filters, 
                                                     month_filters, weekday_filters, category_filters, payment_filters)
        
        try:
            cursor = self.connection.cursor()
            query = ""  # 初始化query变量，避免在异常处理中访问未定义的变量
            
            # 构建WHERE条件
            conditions = []
            params = []
            
            # 日期筛选
            if date_from and date_to:
                # 使用CAST确保日期格式匹配
                conditions.append("CAST(s.c_date as DATE) >= ? AND CAST(s.c_date as DATE) <= ?")
                params.extend([date_from, date_to])
            
            # 门店筛选
            if outlet_filters:
                placeholders = ','.join(['?' for _ in outlet_filters])
                conditions.append(f"s.store_name IN ({placeholders})")
                params.extend(outlet_filters)
            
            # 月份筛选
            if month_filters:
                month_conditions = []
                for month in month_filters:
                    month_conditions.append("FORMAT(s.c_date, 'yyyy-MM') = ?")
                    params.append(month)
                conditions.append(f"({' OR '.join(month_conditions)})")
            
            # 星期筛选
            if weekday_filters:
                weekday_conditions = []
                weekday_map = {
                    'Monday': 2, 'Tuesday': 3, 'Wednesday': 4, 'Thursday': 5, 
                    'Friday': 6, 'Saturday': 7, 'Sunday': 1
                }
                for weekday in weekday_filters:
                    if weekday in weekday_map:
                        weekday_conditions.append(f"DATEPART(WEEKDAY, s.c_date) = {weekday_map[weekday]}")
                if weekday_conditions:
                    conditions.append(f"({' OR '.join(weekday_conditions)})")
            
            # 类别筛选
            if category_filters:
                placeholders = ','.join(['?' for _ in category_filters])
                conditions.append(f"im.category_code IN ({placeholders})")
                params.extend(category_filters)
            
            # 产品筛选
            if product_filters:
                placeholders = ','.join(['?' for _ in product_filters])
                conditions.append(f"s.item_name IN ({placeholders})")
                params.extend(product_filters)
            
            # 支付方式筛选
            if payment_filters:
                placeholders = ','.join(['?' for _ in payment_filters])
                conditions.append(f"EXISTS (SELECT 1 FROM {TABLE_PAYMENT} p WHERE s.sales_no = p.sales_no AND s.store_name = p.store_name AND p.payment_name IN ({placeholders}))")
                params.extend(payment_filters)
            
            # 排除wastage
            conditions.append("s.item_name != 'WASTAGE'")
            
            # 构建WHERE子句
            where_clause = ""
            if conditions:
                where_clause = " WHERE " + " AND ".join(conditions)
            
            # 计算期间显示
            if date_from and date_to:
                period_display = f"'{date_from.split('-')[2]}/{date_from.split('-')[1]} - {date_to.split('-')[2]}/{date_to.split('-')[1]}'"
                days_calculation = f"DATEDIFF(day, '{date_from}', '{date_to}') + 1"
            else:
                period_display = "FORMAT(s.c_date, 'yyyy-MM')"
                days_calculation = "1"
            
            # 先执行一个简单的测试查询来检查数据是否存在
            test_query = f"""
                SELECT TOP 5 
                    s.c_date,
                    s.item_name,
                    s.sub_total,
                    s.qty,
                    s.sales_no
                FROM {TABLE_SALES} s WITH (NOLOCK)
                WHERE s.item_name != 'WASTAGE'
                {f"AND CAST(s.c_date as DATE) >= '{date_from}' AND CAST(s.c_date as DATE) <= '{date_to}'" if date_from and date_to else ""}
                ORDER BY s.c_date DESC
            """
            
            print(f"执行测试查询...")
            cursor.execute(test_query)
            test_rows = cursor.fetchall()
            print(f"测试查询结果: {len(test_rows)} 条记录")
            if test_rows:
                print(f"第一条测试记录: {test_rows[0]}")
            else:
                print("❌ 测试查询没有返回数据，可能日期范围内没有数据")
                return []
            
            # 直接從SQL Server獲取指定日期範圍的產品單據業績
            receipt_performance_data = self.get_product_receipt_performance_from_db(
                date_from=date_from, 
                date_to=date_to, 
                outlet_filters=outlet_filters,  # 傳遞門市篩選
                product_filters=None,  # 不使用產品過濾器
                database_source=self.current_database
            )
            
            # 构建SQL查询 - 按天聚合产品数据（簡化版本）
            query = f"""
                SELECT 
                    CAST(s.c_date as DATE) as 日期,
                    FORMAT(s.c_date, 'yyyy-MM') as 月份,
                    s.store_name as 门市,
                    s.item_name as 产品名称,
                    ISNULL(im.category_code, '未分类') as 类别,
                    SUM({self.get_performance_calculation_sql()}) as 总业绩,
                    COUNT(DISTINCT CONCAT(s.store_name, '-', s.sales_no)) as 总单据数,
                    SUM(CAST(s.qty as FLOAT)) as 销售总数,
                    SUM(CASE WHEN w.sales_no IS NOT NULL THEN CAST(s.qty as FLOAT) ELSE 0 END) as 报废数量,
                    SUM(CAST(s.sub_total as FLOAT)) as 销售金额,
                    0 as 产品单据业绩
                FROM {TABLE_SALES} s WITH (NOLOCK)
                LEFT JOIN {TABLE_ITEMS} im ON s.item_name = im.item_name
                LEFT JOIN (
                    SELECT DISTINCT store_name, sales_no
                    FROM {TABLE_PAYMENT} WITH (NOLOCK)
                    WHERE payment_name = 'WASTAGE'
                ) w ON s.store_name = w.store_name AND s.sales_no = w.sales_no
                {where_clause}
                GROUP BY CAST(s.c_date as DATE), FORMAT(s.c_date, 'yyyy-MM'), s.store_name, s.item_name, im.category_code
                ORDER BY 日期 DESC, s.store_name, s.item_name
                OPTION (RECOMPILE, MAXDOP 4)
            """
            
            print(f"执行产品总览查询...")
            print(f"WHERE子句: {where_clause}")
            print(f"参数: {params}")
            cursor.execute(query, params)
            rows = cursor.fetchall()
            
            # 修復：按日期和門市分組計算總計數據
            # 先獲取產品單據業績數據
            receipt_performance_data_all = self.get_product_receipt_performance_from_db(
                date_from=date_from, 
                date_to=date_to, 
                outlet_filters=outlet_filters,
                product_filters=None  # 查詢所有產品
            )
            
            # 按日期和門市分組計算總計
            daily_store_totals = {}  # key: (date, store), value: {sales, quantity, receipt_performance}
            daily_all_totals = {}    # key: date, value: {sales, quantity, receipt_performance} - 用於 "All" 門市
            
            for row in rows:
                row_date = row[0]      # 日期
                store_name = row[2]    # 门市
                sales = float(row[5]) if row[5] else 0.0  # 总业绩
                quantity = float(row[7]) if row[7] else 0.0  # 销售总数
                
                # 使用組合鍵來獲取該產品在該日期和門市下的產品單據業績
                product_name = row[3]  # 产品名称
                key = f"{product_name}_{row_date}_{store_name}"
                product_receipt_performance = 0.0
                if key in receipt_performance_data_all:
                    product_receipt_performance = receipt_performance_data_all[key]['产品单据业绩']
                
                # 累加到該日期和門市的總計
                daily_store_key = (row_date, store_name)
                if daily_store_key not in daily_store_totals:
                    daily_store_totals[daily_store_key] = {
                        'sales': 0.0,
                        'quantity': 0.0,
                        'receipt_performance': 0.0
                    }
                
                daily_store_totals[daily_store_key]['sales'] += sales
                daily_store_totals[daily_store_key]['quantity'] += quantity
                daily_store_totals[daily_store_key]['receipt_performance'] += product_receipt_performance
                
                # 同時累加到該日期的 "All" 總計
                if row_date not in daily_all_totals:
                    daily_all_totals[row_date] = {
                        'sales': 0.0,
                        'quantity': 0.0,
                        'receipt_performance': 0.0
                    }
                
                daily_all_totals[row_date]['sales'] += sales
                daily_all_totals[row_date]['quantity'] += quantity
                daily_all_totals[row_date]['receipt_performance'] += product_receipt_performance
            
            
            # 现在处理数据并计算占比
            data = []
            for row in rows:
                sales = float(row[5]) if row[5] else 0.0  # 总业绩
                quantity = float(row[7]) if row[7] else 0.0  # 销售总数
                wastage_qty = float(row[8]) if row[8] else 0.0  # 报废数量
                amount = float(row[9]) if row[9] else 0.0  # 销售金额
                product_name = row[3]  # 产品名称
                
                # 使用組合鍵來獲取該產品在該日期和門市下的產品單據業績
                row_date = row[0]
                store_name = row[2]
                key = f"{product_name}_{row_date}_{store_name}"
                product_receipt_performance = 0.0
                if key in receipt_performance_data_all:
                    product_receipt_performance = receipt_performance_data_all[key]['产品单据业绩']
                
                # 獲取該日期和門市的總計數據
                if store_name == 'All':
                    # 對於 "All" 門市，使用該日期的所有門市總計
                    daily_totals = daily_all_totals.get(row_date, {
                        'sales': 0.0, 'quantity': 0.0, 'receipt_performance': 0.0
                    })
                else:
                    # 對於具體門市，使用該日期和門市的總計
                    daily_store_key = (row_date, store_name)
                    daily_totals = daily_store_totals.get(daily_store_key, {
                        'sales': 0.0, 'quantity': 0.0, 'receipt_performance': 0.0
                    })
                
                # 计算占比（基於該日期和門市的總計）
                sales_ratio = (sales / daily_totals['sales'] * 100) if daily_totals['sales'] > 0 else 0
                quantity_ratio = (quantity / daily_totals['quantity'] * 100) if daily_totals['quantity'] > 0 else 0
                product_receipt_performance_ratio = (product_receipt_performance / daily_totals['receipt_performance'] * 100) if daily_totals['receipt_performance'] > 0 else 0
                
                
                total_qty_with_wastage = wastage_qty + quantity
                wastage_ratio = (wastage_qty / total_qty_with_wastage * 100) if total_qty_with_wastage > 0 else 0
                
                data.append({
                    '日期': row[0].strftime('%Y-%m-%d') if hasattr(row[0], 'strftime') else str(row[0]),
                    '月份': row[1],
                    '门市': row[2],
                    '产品名称': product_name,
                    '类别': row[4],
                    '总业绩': sales,
                    '总单据数': int(row[6]) if row[6] else 0,
                    '销售总数': quantity,
                    '报废数量': wastage_qty,
                    '销售金额': amount,
                    '产品单据业绩': product_receipt_performance,
                    '业绩占比': sales_ratio,
                    '数量占比': quantity_ratio,
                    '报废占比': wastage_ratio,
                    '产品单据业绩占比': product_receipt_performance_ratio
                })
            
            cursor.close()
            print(f"产品总览查询完成，共 {len(data)} 条记录")
            
            # 存储到缓存
            if not hasattr(self, '_product_cache'):
                self._product_cache = {}
            self._product_cache[cache_key] = data
            
            # 限制缓存大小
            if len(self._product_cache) > 10:
                # 删除最旧的缓存项
                oldest_key = next(iter(self._product_cache))
                del self._product_cache[oldest_key]
            
            return data
            
        except Exception as e:
            print(f"获取产品总览分析失败: {e}")
            print(f"SQL查询: {query}")
            print(f"参数: {params}")
            return []
    
    def get_period_product_overview(self, date_from=None, date_to=None, outlet_filters=None, product_filters=None, month_filters=None, 
                                   weekday_filters=None, category_filters=None, payment_filters=None):
        """获取期间产品总览分析 - 按产品汇总版本，支持合併模式"""
        # 如果是合併模式，执行合併查询
        if self.combined_mode:
            return self.get_combined_period_product_overview(date_from, date_to, outlet_filters, product_filters, month_filters, weekday_filters, category_filters, payment_filters)
        
        # 检查缓存
        cache_key = f"period_product_{self.current_database}_{date_from}_{date_to}_{outlet_filters}_{product_filters}_{month_filters}_{weekday_filters}_{category_filters}_{payment_filters}"
        if hasattr(self, '_period_product_cache') and cache_key in self._period_product_cache:
            cached_data = self._period_product_cache[cache_key]
            if cached_data:
                print("✓ 使用缓存的期间产品总览数据")
                return cached_data
            else:
                # 缓存为空结果时，重新查询以防数据更新
                print("ℹ 缓存的期间产品总览数据为空，重新查询...")
                del self._period_product_cache[cache_key]
        
        try:
            cursor = self.connection.cursor()
            query = ""  # 初始化query变量，避免在异常处理中访问未定义的变量
            
            # 构建WHERE条件
            conditions = []
            params = []
            
            # 日期筛选
            if date_from and date_to:
                conditions.append("CAST(s.c_date as DATE) >= ? AND CAST(s.c_date as DATE) <= ?")
                params.extend([date_from, date_to])
                
                # 使用单据统计数据库，不需要额外参数
            
            # 门店筛选
            if outlet_filters:
                placeholders = ','.join(['?' for _ in outlet_filters])
                conditions.append(f"s.store_name IN ({placeholders})")
                params.extend(outlet_filters)
                
                # 使用单据统计数据库，不需要额外参数
            
            # 月份筛选
            if month_filters:
                month_conditions = []
                for month in month_filters:
                    month_conditions.append("FORMAT(s.c_date, 'yyyy-MM') = ?")
                    params.append(month)
                conditions.append(f"({' OR '.join(month_conditions)})")
            
            # 星期筛选
            if weekday_filters:
                weekday_conditions = []
                weekday_map = {
                    'Monday': 2, 'Tuesday': 3, 'Wednesday': 4, 'Thursday': 5, 
                    'Friday': 6, 'Saturday': 7, 'Sunday': 1
                }
                for weekday in weekday_filters:
                    if weekday in weekday_map:
                        weekday_conditions.append(f"DATEPART(WEEKDAY, s.c_date) = {weekday_map[weekday]}")
                if weekday_conditions:
                    conditions.append(f"({' OR '.join(weekday_conditions)})")
            
            # 类别筛选
            if category_filters:
                placeholders = ','.join(['?' for _ in category_filters])
                conditions.append(f"im.category_code IN ({placeholders})")
                params.extend(category_filters)
            
            # 产品筛选
            if product_filters:
                placeholders = ','.join(['?' for _ in product_filters])
                conditions.append(f"s.item_name IN ({placeholders})")
                params.extend(product_filters)
                
                # 使用单据统计数据库，不需要额外参数

            # 支付方式筛选 - 严格匹配，只有当销售记录的所有支付方式都在筛选列表中时才包括
            if payment_filters:
                placeholders = ','.join([f"'{payment}'" for payment in payment_filters])
                conditions.append(f"""NOT EXISTS (
                    SELECT 1 FROM {TABLE_PAYMENT} p
                    WHERE p.sales_no = s.sales_no AND p.store_name = s.store_name
                    AND p.payment_name NOT IN ({placeholders})
                )""")

            # 排除wastage主产品
            conditions.append("s.item_name != 'WASTAGE'")
            
            # 构建WHERE子句
            where_clause = ""
            if conditions:
                where_clause = " WHERE " + " AND ".join(conditions)
            
            # 额外构建报废查询条件
            wastage_conditions = []
            wastage_params = []
            
            if date_from and date_to:
                wastage_conditions.append("CAST(c.c_date as DATE) >= ?")
                wastage_conditions.append("CAST(c.c_date as DATE) <= ?")
                wastage_params.extend([date_from, date_to])
            
            if outlet_filters:
                placeholders = ','.join(['?' for _ in outlet_filters])
                wastage_conditions.append(f"c.store_name IN ({placeholders})")
                wastage_params.extend(outlet_filters)
            
            if month_filters:
                month_clauses = []
                for month in month_filters:
                    month_clauses.append("FORMAT(c.c_date, 'yyyy-MM') = ?")
                    wastage_params.append(month)
                if month_clauses:
                    wastage_conditions.append("(" + " OR ".join(month_clauses) + ")")
            
            if weekday_filters:
                weekday_map = {
                    'Monday': 2, 'Tuesday': 3, 'Wednesday': 4, 'Thursday': 5,
                    'Friday': 6, 'Saturday': 7, 'Sunday': 1
                }
                weekday_clauses = []
                for weekday in weekday_filters:
                    if weekday in weekday_map:
                        weekday_clauses.append(f"DATEPART(WEEKDAY, c.c_date) = {weekday_map[weekday]}")
                if weekday_clauses:
                    wastage_conditions.append("(" + " OR ".join(weekday_clauses) + ")")
            
            if category_filters:
                placeholders = ','.join(['?' for _ in category_filters])
                wastage_conditions.append(f"im_w.category_code IN ({placeholders})")
                wastage_params.extend(category_filters)
            
            if product_filters:
                placeholders = ','.join(['?' for _ in product_filters])
                wastage_conditions.append(f"COALESCE(c.product_item_name, c.item_name) IN ({placeholders})")
                wastage_params.extend(product_filters)
            
            if payment_filters:
                placeholders = ','.join(['?' for _ in payment_filters])
                wastage_conditions.append(
                    f"EXISTS (SELECT 1 FROM {TABLE_PAYMENT} p WITH (NOLOCK) WHERE p.sales_no = c.sales_no AND p.store_name = c.store_name AND p.payment_name IN ({placeholders}))"
                )
                wastage_params.extend(payment_filters)
            
            # 计算期间显示
            if date_from and date_to:
                period_display = f"'{date_from.split('-')[2]}/{date_from.split('-')[1]} - {date_to.split('-')[2]}/{date_to.split('-')[1]}'"
                days_calculation = f"DATEDIFF(day, '{date_from}', '{date_to}') + 1"
            else:
                period_display = "'全部期间'"
                days_calculation = "COUNT(DISTINCT CAST(s.c_date as DATE))"
            
            # 期间产品总览查询 - 按产品汇总（使用单据统计数据库计算产品单据业绩）
            query = f"""
                SELECT
                    {period_display} as 期间,
                    s.item_name as 产品名称,
                    ISNULL(im.category_code, '未分类') as 类别,
                    {days_calculation} as 天数,
                    SUM({self.get_performance_calculation_sql()} - 
                        ISNULL(CAST(c.cancel_amount as FLOAT), 0)) as 总业绩,
                    COUNT(DISTINCT CONCAT(s.store_name, '-', s.sales_no)) as 总单据数,
                SUM(CAST(s.qty as FLOAT) - ISNULL(CAST(c.cancel_qty as FLOAT), 0)) as 销售总数,
                SUM(CASE WHEN p.sales_no IS NOT NULL THEN CAST(s.qty as FLOAT) ELSE 0 END) as 报废数量,
                    SUM(CAST(s.sub_total as FLOAT)) as 销售金额,
                    0 as 产品单据业绩
            FROM {TABLE_SALES} s WITH (NOLOCK)
            LEFT JOIN {TABLE_ITEMS} im ON s.item_name = im.item_name
            LEFT JOIN (
                SELECT DISTINCT store_name, sales_no
                FROM {TABLE_PAYMENT} WITH (NOLOCK)
                WHERE payment_name = 'WASTAGE'
            ) p ON s.store_name = p.store_name AND s.sales_no = p.sales_no
            LEFT JOIN (
                SELECT 
                    sales_no, 
                    store_name, 
                    item_name,
                    SUM({self._get_cancel_performance_calculation_sql()}) as cancel_amount,
                    SUM(CAST(qty as FLOAT)) as cancel_qty
                FROM {TABLE_CANCEL} WITH (NOLOCK)
                GROUP BY sales_no, store_name, item_name
            ) c ON s.sales_no = c.sales_no AND s.store_name = c.store_name AND s.item_name = c.item_name
            {where_clause}
            GROUP BY s.item_name, im.category_code
            ORDER BY 总业绩 DESC
            OPTION (RECOMPILE, MAXDOP 4)
            """

            print(f"执行期间产品总览查询...")
            print(f"WHERE子句: {where_clause}")
            print(f"参数: {params}")
            print(f"SQL查询: {query}")
            if hasattr(self, 'log_message'):
                self.log_message(f"调试: 期间产品SQL开始执行，参数: {params}")
            
            try:
                # 先执行简单测试查询
                test_query = f"SELECT COUNT(*) FROM {TABLE_SALES} WHERE CAST(c_date as DATE) = '{date_from}'"
                print(f"🔍 执行测试查询: {test_query}")
                cursor.execute(test_query)
                test_result = cursor.fetchone()
                print(f"🔍 测试查询结果 - {date_from} 的记录数: {test_result[0] if test_result else 0}")
                
                if test_result and test_result[0] == 0:
                    print(f"❌ {date_from} 没有销售数据")
                    return []
                
                # 修復參數綁定問題：使用字符串替換而不是參數綁定
                if params:
                    # 將參數直接替換到SQL中
                    query_with_params = query
                    param_index = 0
                    for i, param in enumerate(params):
                        if isinstance(param, str):
                            query_with_params = query_with_params.replace('?', f"'{param}'", 1)
                        else:
                            query_with_params = query_with_params.replace('?', str(param), 1)
                        param_index += 1
                    cursor.execute(query_with_params)
                else:
                    cursor.execute(query)
                
                rows = cursor.fetchall()
                print(f"期间产品总览查询返回 {len(rows)} 条记录")
                if hasattr(self, 'log_message'):
                    self.log_message(f"调试: 期间产品查询返回 {len(rows)} 条记录")
                
                # 计算总计数据
                total_sales = sum(float(row[4]) if row[4] else 0.0 for row in rows)
                total_receipts = sum(int(row[5]) if row[5] else 0 for row in rows)
                total_quantity = sum(float(row[6]) if row[6] else 0.0 for row in rows)
                total_wastage = sum(float(row[7]) if len(row) > 7 and row[7] else 0.0 for row in rows)
                total_product_receipt_performance = sum(float(row[9]) if len(row) > 9 and row[9] else 0.0 for row in rows)
                    
            except Exception as query_error:
                print(f"❌ 期间产品分析SQL查询执行失败: {query_error}")
                print(f"❌ 查询语句: {query}")
                print(f"❌ 参数: {params}")
                import traceback
                print(f"错误详情: {traceback.format_exc()}")
                return []
            
            data = []
            for row in rows:
                sales = float(row[4]) if row[4] else 0.0
                quantity = float(row[6]) if row[6] else 0.0
                wastage_qty = float(row[7]) if len(row) > 7 and row[7] else 0.0
                amount = float(row[8]) if len(row) > 8 and row[8] else 0.0
                product_receipt_performance = float(row[9]) if len(row) > 9 and row[9] else 0.0
                days = int(row[3]) if row[3] else 1
                
                sales_ratio = (sales / total_sales * 100) if total_sales > 0 else 0
                quantity_ratio = (quantity / total_quantity * 100) if total_quantity > 0 else 0
                total_qty_with_wastage = wastage_qty + quantity
                wastage_ratio = (wastage_qty / total_qty_with_wastage * 100) if total_qty_with_wastage > 0 else 0
                product_receipt_performance_ratio = (product_receipt_performance / total_product_receipt_performance * 100) if total_product_receipt_performance > 0 else 0
                
                data.append({
                    '期间': row[0],
                    '产品名称': row[1],
                    '类别': row[2],
                    '天数': days,
                    '总业绩': sales,
                    '总单据数': int(row[5]) if row[5] else 0,
                    '销售总数': quantity,
                    '报废数量': wastage_qty,
                    '销售金额': amount,
                    '产品单据业绩': product_receipt_performance,
                    '业绩占比': sales_ratio,
                    '数量占比': quantity_ratio,
                    '报废占比': wastage_ratio,
                    '产品单据业绩占比': product_receipt_performance_ratio,
                    '总业绩_日均': sales / days if days > 0 else 0,
                    '总单据数_日均': (int(row[5]) if row[5] else 0) / days if days > 0 else 0,
                    '销售总数_日均': quantity / days if days > 0 else 0,
                    '报废数量_日均': wastage_qty / days if days > 0 else 0,
                    '产品单据业绩_日均': product_receipt_performance / days if days > 0 else 0
                })
            
            cursor.close()
            print(f"期间产品总览查询完成，共 {len(data)} 条记录")
            
            # 從單據明細數據庫獲取產品單據業績 - 使用專門的期間函數
            receipt_performance_data = self.get_period_product_receipt_performance_from_db(
                date_from=date_from, 
                date_to=date_to, 
                outlet_filters=outlet_filters,
                product_filters=product_filters,
                database_source=self.current_database
            )
            
            # 計算所有產品的總業績
            total_all_sales = sum(float(d['总业绩']) for d in data)
            
            # 更新產品單據業績數據 - 期間產品總覽直接使用產品單據業績
            for item in data:
                product_name = item['产品名称']
                if product_name in receipt_performance_data:
                    receipt_data = receipt_performance_data[product_name]
                    product_sales = item['总业绩']
                    
                    # 期間產品總覽：直接使用該產品的產品單據業績，不進行分配
                    allocated_receipt_performance = receipt_data['产品单据业绩']
                    average_receipt_amount = receipt_data['平均单据金额']
                    receipt_count = receipt_data['单据数量']
                    
                    print(f"✅ 更新 {product_name} 產品單據業績: ${allocated_receipt_performance:.2f} (平均單據: ${average_receipt_amount:.2f}, 單據數: {receipt_count})")
                    
                    item['产品单据业绩'] = allocated_receipt_performance
                    # 重新計算產品單據業績占比：產品單據業績 / 所有產品的總業績 * 100%
                    item['产品单据业绩占比'] = (allocated_receipt_performance / total_all_sales * 100) if total_all_sales > 0 else 0
                    item['产品单据业绩_日均'] = allocated_receipt_performance / item['天数'] if item['天数'] > 0 else 0
            
            # 存储到缓存（仅缓存非空结果）
            if data:
                if not hasattr(self, '_period_product_cache'):
                    self._period_product_cache = {}
                self._period_product_cache[cache_key] = data
            
            # 限制缓存大小
            if hasattr(self, '_period_product_cache') and len(self._period_product_cache) > 10:
                oldest_key = next(iter(self._period_product_cache))
                del self._period_product_cache[oldest_key]
            
            return data
            
        except Exception as e:
            print(f"获取期间产品总览分析失败: {e}")
            print(f"SQL查询: {query}")
            print(f"参数: {params}")
            return []
    
    def get_combined_weekly_product_data(self, date_from=None, date_to=None, outlet_filters=None, product_filters=None, month_filters=None, 
                                        weekday_filters=None, category_filters=None, payment_filters=None):
        """获取合并的周期产品数据 - 从所有数据库合并数据"""
        try:
            print("🔄 执行合并周期产品数据查询...")
            print(f"查询参数: date_from={date_from}, date_to={date_to}")
            print(f"筛选条件: outlet_filters={outlet_filters}, product_filters={product_filters}, month_filters={month_filters}, weekday_filters={weekday_filters}, category_filters={category_filters}, payment_filters={payment_filters}")
            
            # 所有数据库列表
            databases = ["sushi_gogo_pos_live", "sushi_express_pos_live", "sushi_plus_pos_live"]
            all_results = []
            
            # 为每个数据库执行查询
            for db_name in databases:
                try:
                    print(f"📊 查询数据库: {db_name}")
                    
                    # 构建查询SQL
                    conditions = []
                    
                    # 日期筛选
                    if date_from and date_to:
                        conditions.append(f"CAST(s.c_date as DATE) >= '{date_from}' AND CAST(s.c_date as DATE) <= '{date_to}'")
                    
                    # 门店筛选
                    if outlet_filters:
                        outlet_conditions = " OR ".join([f"s.store_name LIKE '%{outlet}%'" for outlet in outlet_filters])
                        conditions.append(f"({outlet_conditions})")
                    
                    # 产品筛选
                    if product_filters:
                        product_conditions = " OR ".join([f"s.item_name LIKE '%{product}%'" for product in product_filters])
                        conditions.append(f"({product_conditions})")
                    
                    # 排除wastage
                    conditions.append("s.item_name != 'WASTAGE'")
                    
                    where_clause = ""
                    if conditions:
                        where_clause = " WHERE " + " AND ".join(conditions)
                    
                    # 查询周期产品数据 - 按周分组，与期间-产品数据保持一致
                    query = f"""
                        WITH WeeklyProductData AS (
                            SELECT 
                                s.item_name as 产品名称,
                                DATEPART(WEEK, s.c_date) as 周数,
                                DATEADD(DAY, -(DATEPART(WEEKDAY, s.c_date) - 2), CAST(s.c_date as DATE)) as 周开始日期,
                                DATEADD(DAY, 6, DATEADD(DAY, -(DATEPART(WEEKDAY, s.c_date) - 2), CAST(s.c_date as DATE))) as 周结束日期,
                                SUM({self.get_combined_performance_calculation_sql(db_name)} - 
                                    ISNULL(CAST(c.cancel_amount as FLOAT), 0)) as 产品业绩,
                                COUNT(DISTINCT CONCAT(s.store_name, '-', s.sales_no)) as 产品单据数,
                                SUM(CAST(s.qty as FLOAT) - ISNULL(CAST(c.cancel_qty as FLOAT), 0)) as 销售数量
                            FROM {db_name}.dbo.sales s WITH (NOLOCK)
                            LEFT JOIN {db_name}.dbo.item_master im ON s.item_name = im.item_name
                            LEFT JOIN (
                                SELECT DISTINCT store_name, sales_no
                                FROM {db_name}.dbo.payment WITH (NOLOCK)
                                WHERE payment_name = 'WASTAGE'
                            ) p ON s.store_name = p.store_name AND s.sales_no = p.sales_no
                            LEFT JOIN (
                                SELECT 
                                    sales_no, 
                                    store_name, 
                                    item_name,
                                    SUM({self.get_combined_cancel_performance_calculation_sql(db_name)}) as cancel_amount,
                                    SUM(CAST(qty as FLOAT)) as cancel_qty
                                FROM {db_name}.dbo.cancel WITH (NOLOCK)
                                GROUP BY sales_no, store_name, item_name
                            ) c ON s.sales_no = c.sales_no AND s.store_name = c.store_name AND s.item_name = c.item_name
                            {where_clause}
                            GROUP BY s.item_name, DATEPART(WEEK, s.c_date), 
                                     DATEADD(DAY, -(DATEPART(WEEKDAY, s.c_date) - 2), CAST(s.c_date as DATE))
                        ),
                        WeeklyTotals AS (
                            SELECT 
                                周数,
                                周开始日期,
                                周结束日期,
                                SUM(产品业绩) as 总业绩,
                                SUM(产品单据数) as 总单据数,
                                SUM(销售数量) as 总销售数量
                            FROM WeeklyProductData
                            GROUP BY 周数, 周开始日期, 周结束日期
                        )
                        SELECT 
                            产品名称,
                            周数,
                            CONCAT(FORMAT(周开始日期, 'd/M'), ' - ', FORMAT(周结束日期, 'd/M')) as 期间,
                            产品业绩,
                            产品单据数,
                            销售数量,
                            CASE WHEN DATEDIFF(DAY, 周开始日期, 周结束日期) + 1 > 0 
                                 THEN 产品业绩 / (DATEDIFF(DAY, 周开始日期, 周结束日期) + 1) 
                                 ELSE 0 END as 日均业绩,
                            'Product' as 类型
                        FROM WeeklyProductData
                        UNION ALL
                        SELECT 
                            '=== 周总计 ===' as 产品名称,
                            周数,
                            CONCAT(FORMAT(周开始日期, 'd/M'), ' - ', FORMAT(周结束日期, 'd/M')) as 期间,
                            总业绩 as 产品业绩,
                            总单据数 as 产品单据数,
                            总销售数量 as 销售数量,
                            CASE WHEN DATEDIFF(DAY, 周开始日期, 周结束日期) + 1 > 0 
                                 THEN 总业绩 / (DATEDIFF(DAY, 周开始日期, 周结束日期) + 1) 
                                 ELSE 0 END as 日均业绩,
                            'Total' as 类型
                        FROM WeeklyTotals
                        ORDER BY 周数, 类型, 产品业绩 DESC
                        OPTION (RECOMPILE, MAXDOP 4)
                    """
                    
                    cursor = self.connection.cursor()
                    cursor.execute(query)
                    results = cursor.fetchall()
                    cursor.close()
                    
                    # 转换数据格式
                    for row in results:
                        all_results.append({
                            '产品名称': row[0],
                            '周数': row[1],
                            '期间': row[2],
                            '产品业绩': float(row[3]) if row[3] else 0.0,
                            '产品单据数': int(row[4]) if row[4] else 0,
                            '销售数量': float(row[5]) if row[5] else 0.0,
                            '日均业绩': float(row[6]) if row[6] else 0.0,
                            '类型': row[7] if len(row) > 7 else 'Product',
                            '数据库': db_name
                        })
                    
                    print(f"✅ {db_name} 查询完成，获得 {len(results)} 条记录")
                    
                except Exception as e:
                    print(f"❌ 查询数据库 {db_name} 失败: {e}")
                    continue
            
            print(f"🔄 合并周期产品数据查询完成，共 {len(all_results)} 条记录")
            return all_results
            
        except Exception as e:
            print(f"❌ 合并周期产品数据查询失败: {e}")
            return []

    def get_discount_analysis(self, date_from=None, date_to=None, outlet_filters=None, month_filters=None, weekday_filters=None, category_filters=None, payment_filters=None):
        """获取折扣分析"""
        if not self.connection:
            return []
        
        # 检查缓存
        cache_key = f"discount_{self.current_database}_{date_from}_{date_to}_{outlet_filters}_{month_filters}_{weekday_filters}_{category_filters}_{payment_filters}"
        if hasattr(self, '_discount_cache') and cache_key in self._discount_cache:
            print("✓ 使用缓存的折扣分析数据")
            return self._discount_cache[cache_key]
        
        try:
            cursor = self.connection.cursor()
            
            # 构建WHERE条件
            conditions = []
            if date_from:
                conditions.append(f"CAST(s.c_date AS DATE) >= '{date_from}'")
            if date_to:
                conditions.append(f"CAST(s.c_date AS DATE) <= '{date_to}'")
            if outlet_filters and len(outlet_filters) > 0:
                outlet_conditions = " OR ".join([f"s.store_name = '{outlet}'" for outlet in outlet_filters])
                conditions.append(f"({outlet_conditions})")
            if month_filters and len(month_filters) > 0:
                month_conditions = " OR ".join([f"FORMAT(CAST(s.c_date AS DATE), 'yyyy-MM') = '{month}'" for month in month_filters])
                conditions.append(f"({month_conditions})")
            
            # 添加折扣条件
            conditions.append("s.disc_amt > 0")
            
            # 如果有类别筛选，需要JOIN item_master表
            join_clause = ""
            if category_filters and len(category_filters) > 0:
                category_conditions = " OR ".join([f"im.category_code = '{category}'" for category in category_filters])
                conditions.append(f"({category_conditions})")
                join_clause = "LEFT JOIN item_master im ON s.item_name = im.item_name"
            
            where_clause = ""
            if conditions:
                where_clause = " WHERE " + " AND ".join(conditions)
            
            query = f"""
                WITH DiscountSummary AS (
                    SELECT 
                        s.store_name as 门市,
                        FORMAT(CAST(s.c_date AS DATE), 'yyyy-MM') as 月份,
                        s.disc_name as 折扣名称,
                        SUM(CAST(s.disc_amt AS FLOAT)) as 折扣金额,
                        COUNT(*) as 折扣次数
                    FROM pos_sales_dtls s WITH (NOLOCK)
                    {join_clause}
                    {where_clause}
                    GROUP BY s.store_name, FORMAT(CAST(s.c_date AS DATE), 'yyyy-MM'), s.disc_name
                ),
                TotalDiscounts AS (
                    SELECT 
                        SUM(折扣金额) as 总折扣金额,
                        SUM(折扣次数) as 总折扣次数
                    FROM DiscountSummary
                )
                SELECT 
                    ds.门市,
                    ds.月份,
                    ds.折扣名称,
                    ds.折扣金额,
                    ds.折扣次数,
                    CASE WHEN td.总折扣金额 > 0 THEN (ds.折扣金额 / td.总折扣金额 * 100) ELSE 0 END as 折扣占比,
                    CASE WHEN td.总折扣次数 > 0 THEN (ds.折扣次数 / td.总折扣次数 * 100) ELSE 0 END as 折扣次数占比,
                    SUM(ds.折扣次数) OVER (PARTITION BY ds.折扣名称) as 全門市折扣總次數
                FROM DiscountSummary ds
                CROSS JOIN TotalDiscounts td
                ORDER BY ds.门市, ds.月份, ds.折扣金额 DESC
            """
            
            print(f"折扣分析查询: {query}")
            cursor.execute(query)
            results = cursor.fetchall()
            
            # 转换为字典格式
            discount_data = []
            for row in results:
                discount_data.append({
                    '门市': row[0],
                    '月份': row[1],
                    '折扣名称': row[2],
                    '折扣金额': float(row[3]),
                    '折扣次数': row[4],
                    '折扣占比(%)': float(row[5]),
                    '折扣次数占比(%)': float(row[6]),
                    '全門市折扣總次數': row[7]
                })
            
            # 缓存结果
            if not hasattr(self, '_discount_cache'):
                self._discount_cache = {}
            self._discount_cache[cache_key] = discount_data
            
            print(f"✓ 折扣分析查询完成，共 {len(discount_data)} 条记录")
            return discount_data
            
        except Exception as e:
            print(f"❌ 折扣分析查询失败: {e}")
            return []

class POSAnalysisGUI:
    def __init__(self):
        self.db_manager = DatabaseManager()
        # 將GUI的log_message注入給DatabaseManager，用於數據源提示
        self.db_manager.log_message = lambda msg, include_db_info=False: self.log_message(msg, include_db_info)
        self.receipt_db_manager = None  # 延遲初始化
        
        # 初始化數據庫選項配置
        self.DATABASE_OPTIONS = {
            "GOGO": {"cn": "GOGO", "en": "GOGO", "db": "sushi_gogo_pos_live", "color": "#3498db", "selected_color": "#2980b9", "icon": "📊"},
            "Express": {"cn": "Express", "en": "Express", "db": "sushi_express_pos_live", "color": "#f1c40f", "selected_color": "#d68910", "icon": "📈"},
            "Plus": {"cn": "Plus", "en": "Plus", "db": "sushi_plus_pos_live", "color": "#e74c3c", "selected_color": "#c0392b", "icon": "⭐"},
            "All": {"cn": "全部", "en": "All", "db": "All", "color": "#9b59b6", "selected_color": "#8e44ad", "icon": "🌟"}
        }
        
        # 所有數據庫列表，用於All選項的合併查詢
        self.ALL_DATABASES = ["sushi_gogo_pos_live", "sushi_express_pos_live", "sushi_plus_pos_live"]
        
        # 使用 customtkinter 主窗口，設定為 SEAutomation.py 風格的暗主題
        self.root = ctk.CTk()
        self.root.title("POS数据分析工具 - 增强版\nPOS Data Analysis Tool - Enhanced")
        self.root.geometry("1600x1000")
        
        # 設定 customtkinter 主題和背景色
        ctk.set_appearance_mode("light")  # 亮主題但使用自定義顏色
        self.root.configure(fg_color='#FFFFFF')  # 純白背景
        
        # 数据存储变量
        self.sales_data = None
        self.payment_data = None
        self.discount_data = None
        self.monthly_data = None
        self.sales_tc_analysis_data = None
        self.sales_tc_monthly_data = None
        self.product_association_data = None
        
        # 智能缓存系统
        self.cached_sales_data = []  # 缓存的完整销售数据
        self.cache_date_range = None  # 缓存数据的日期范围
        self.cache_database = None    # 缓存数据的数据库
        self.product_overview_outlet_filters = []
        self.product_overview_store_count = 1
        self.period_product_outlet_filters = []
        self.period_product_store_count = 1
        self.weekly_product_outlet_filters = []
        self.weekly_product_store_count = 1
        # 移除包含支付方式的缓存控制，简化逻辑
        
        # 导出相关变量
        self.export_cancelled = False
        self.export_progress_bar = None
        self.export_progress_window = None
        self.simple_progress_window = None
        self.simple_progress_bar = None
        
        # 初始化活动记录列表 - 按数据库分类
        self.activity_records = {
            'GOGO': [],
            'Express': [],
            'PLUS': []
        }
        
        # 加载活动记录
        self.load_activity_records()
        
        # 自動讀取 PromotionRecords.xlsx 文件
        self.auto_load_promotion_records()
        
        # 為現有活動記錄補充分析結果
        self.analyze_existing_activities()
        
        self.setup_ui()
        self.setup_ui_complete()
    
    def save_activity_records(self):
        """保存活动记录到文件"""
        try:
            import json
            import os
            os.makedirs('cache', exist_ok=True)
            
            with open('cache/activity_records.json', 'w', encoding='utf-8') as f:
                json.dump(self.activity_records, f, ensure_ascii=False, indent=2)
            print(f"✅ 活动记录已保存到文件")
        except Exception as e:
            print(f"❌ 保存活动记录失败: {e}")
    
    def load_activity_records(self):
        """从文件加载活动记录"""
        try:
            import json
            import os
            
            # 确保活动记录字典包含所有数据库
            if not hasattr(self, 'activity_records'):
                self.activity_records = {
                    'GOGO': [],
                    'Express': [],
                    'PLUS': [],
                    'All': []
                }
            
            activity_file = 'cache/activity_records.json'
            if os.path.exists(activity_file):
                with open(activity_file, 'r', encoding='utf-8') as f:
                    loaded_records = json.load(f)
                    if isinstance(loaded_records, dict):
                        # 合并加载的记录到现有记录，并确保支付方式格式正确
                        for db_name, records in loaded_records.items():
                            if isinstance(records, list):
                                # 确保支付方式是列表格式
                                for record in records:
                                    if 'payment_methods' in record and isinstance(record['payment_methods'], str):
                                        # 如果支付方式是字符串，转换为列表
                                        if ',' in record['payment_methods']:
                                            record['payment_methods'] = [pm.strip() for pm in record['payment_methods'].split(',')]
                                        else:
                                            record['payment_methods'] = [record['payment_methods']] if record['payment_methods'] else []
                                self.activity_records[db_name] = records
                        print(f"✅ 已加载活动记录，Express: {len(self.activity_records.get('Express', []))}, GOGO: {len(self.activity_records.get('GOGO', []))}, PLUS: {len(self.activity_records.get('PLUS', []))}")
            else:
                print(f"📁 活动记录文件不存在，将使用空的记录列表")
                # 确保所有数据库都有空列表
                for db_name in ['GOGO', 'Express', 'PLUS', 'All']:
                    if db_name not in self.activity_records:
                        self.activity_records[db_name] = []
        except Exception as e:
            print(f"❌ 加载活动记录失败: {e}")
            # 如果加载失败，确保至少有一个基本的记录结构
            if not hasattr(self, 'activity_records'):
                self.activity_records = {
                    'GOGO': [],
                    'Express': [],
                    'PLUS': [],
                    'All': []
                }
    
    def toggle_date_filter(self):
        """切换日期筛选开关"""
        if self.use_date_filter.get():
            # 启用日期筛选
            self.date_from.config(state='normal')
            self.date_to.config(state='normal')
            self.log_message("✓ 已启用日期筛选")
        else:
            # 禁用日期筛选
            self.date_from.config(state='disabled')
            self.date_to.config(state='disabled')
            self.log_message("ℹ 已禁用日期筛选，将使用月份筛选")
    
    def toggle_product_display(self):
        """切换产品详细显示开关"""
        print(f"🔧 显示详细开关被触发，当前状态: {self.show_product_details.get()}")
        if self.show_product_details.get():
            self.log_message("✓ 已启用产品详细显示")
        else:
            self.log_message("ℹ 已禁用产品详细显示，只显示总计")
        
        # 自动重新显示当前数据
        self.refresh_current_display()
    
    def toggle_daily_average(self):
        """切换日均显示开关"""
        print(f"🔧 日均显示开关被触发，当前状态: {self.show_daily_average.get()}")
        if self.show_daily_average.get():
            self.log_message("✓ 已启用日均显示")
        else:
            self.log_message("ℹ 已禁用日均显示")
        
        # 自动重新显示当前数据
        self.refresh_current_display()
    
    def calculate_daily_average(self, data, date_range_days=None):
        """计算日均数据"""
        if not data:
            return data
        
        if date_range_days is None:
            # 从日期范围计算天数
            if hasattr(self, 'date_from') and hasattr(self, 'date_to'):
                try:
                    from_date = self.date_from.get_date()
                    to_date = self.date_to.get_date()
                    date_range_days = (to_date - from_date).days + 1
                except:
                    date_range_days = 1
            else:
                date_range_days = 1
        
        if date_range_days <= 0:
            date_range_days = 1
        
        # 复制数据并计算日均
        avg_data = []
        for item in data:
            avg_item = item.copy()
            # 对数值字段计算日均
            for key, value in avg_item.items():
                if isinstance(value, (int, float)) and value > 0:
                    # 占比类字段不做日均
                    if '占比' in key or '%' in key:
                        continue
                    # 检查是否为金额、数量等需要计算日均的字段
                    if any(keyword in key for keyword in ['金额', 'Amount', '数量', 'Count', '次数', '金额', '产品单据业绩']):
                        avg_item[key] = round(value / date_range_days, 2)
            avg_data.append(avg_item)
        
        return avg_data
    
    def toggle_store_average(self):
        """切换单店平均开关"""
        if self.show_store_average.get():
            self.log_message("✓ 已启用单店平均显示")
        else:
            self.log_message("ℹ 已禁用单店平均显示")
        self.refresh_current_display()
    
    def toggle_brand_daily_average(self):
        """切换品牌期间汇总日均显示开关"""
        if self.show_brand_daily_average.get():
            self.log_message("✓ 已启用品牌期间汇总日均显示")
        else:
            self.log_message("ℹ 已禁用品牌期间汇总日均显示")
        
        # 自动重新显示当前数据
        self.refresh_current_display()
    
    def toggle_product_daily_average(self):
        """切换产品总览日均显示开关"""
        if self.show_product_daily_average.get():
            self.log_message("✓ 已启用产品总览日均显示")
        else:
            self.log_message("ℹ 已禁用产品总览日均显示，显示总数据")
        
        # 自动重新显示当前数据
        self.refresh_current_display()
    
    def toggle_performance_details(self):
        """切换业绩对比详细显示开关"""
        if self.show_performance_details.get():
            self.log_message("✓ 已启用业绩对比详细显示")
        else:
            self.log_message("ℹ 已禁用业绩对比详细显示，只显示总计")
        
        # 重新显示业绩对比数据
        if hasattr(self, 'performance_comparison_data') and self.performance_comparison_data:
            self.display_performance_comparison()
    
    def toggle_filter_panel(self):
        """切换筛选面板显示/隐藏"""
        if self.filter_toggle_var.get():
            # 隐藏筛选面板
            self.filter_frame.grid_remove()
            self.filter_toggle_var.set(False)
            self.filter_toggle_btn.config(text="🔍 显示筛选\nShow Filters")
            self.log_message("ℹ 已隐藏筛选面板")
            # 重新配置notebook行权重
            self._reconfigure_grid_weights()
        else:
            # 显示筛选面板
            self.filter_frame.grid(row=1, column=0, sticky="ew", padx=5, pady=5)
            self.filter_toggle_var.set(True)
            self.filter_toggle_btn.config(text="🔍 隐藏筛选\nHide Filters")
            self.log_message("✓ 已显示筛选面板")
            # 重新配置notebook行权重
            self._reconfigure_grid_weights()
    
    
    def toggle_analysis_panel(self):
        """切换分析面板显示/隐藏 - 新版本"""
        current_state = self.analysis_toggle_var.get()
        self.log_message(f"🔍 当前分析面板状态: {current_state}")
        
        if current_state:
            # 隐藏分析面板
            self.log_message("🔍 准备隐藏分析面板...")
            if hasattr(self, 'function_frame'):
                self.function_frame.grid_remove()
                self.log_message("✓ function_frame已隐藏")
            else:
                self.log_message("✗ function_frame不存在")
            
            self.analysis_toggle_var.set(False)
            self.analysis_toggle_btn.config(text="📊 显示分析\nShow Analysis")
            self.log_message("ℹ 已隐藏分析按钮面板")
            
            # 重新配置grid权重
            self._reconfigure_grid_weights()
        else:
            # 显示分析面板
            self.log_message("🔍 准备显示分析面板...")
            if hasattr(self, 'function_frame'):
                self.function_frame.grid(row=2, column=0, sticky="ew", padx=10, pady=10)
                self.log_message("✓ function_frame已显示")
            else:
                self.log_message("✗ function_frame不存在")
            
            self.analysis_toggle_var.set(True)
            self.analysis_toggle_btn.config(text="📊 隐藏分析\nHide Analysis")
            self.log_message("✓ 已显示分析按钮面板")
            
            # 重新配置grid权重
            self._reconfigure_grid_weights()
    
    def _reconfigure_grid_weights(self):
        """重新配置grid权重，确保notebook能够完全填充剩余空间"""
        try:
            # 确定notebook应该在哪一行
            notebook_row = 3  # 默认在第3行
            
            # 根据面板的显示状态调整notebook的位置
            if not self.filter_toggle_var.get() and not self.analysis_toggle_var.get():
                # 两个面板都隐藏，notebook在第1行（顶部控制栏之后）
                notebook_row = 1
            elif not self.filter_toggle_var.get() and self.analysis_toggle_var.get():
                # 只有筛选面板隐藏，notebook在第3行（分析面板之后）
                notebook_row = 3
            elif self.filter_toggle_var.get() and not self.analysis_toggle_var.get():
                # 只有分析面板隐藏，notebook在第2行（筛选面板之后）
                notebook_row = 2
            else:
                # 两个面板都显示，notebook在第3行
                notebook_row = 3
            
            # 重新配置notebook容器的位置
            self.notebook_container.grid(row=notebook_row, column=0, sticky="nsew", padx=0, pady=0)
            
            # 重置所有行的权重
            for i in range(4):
                self.main_frame.grid_rowconfigure(i, weight=0)
            
            # 设置notebook行的权重为1，使其能够扩展
            self.main_frame.grid_rowconfigure(notebook_row, weight=1)
            
            self.log_message(f"✓ Grid权重已重新配置，notebook在第{notebook_row}行")
            
        except Exception as e:
            self.log_message(f"✗ 重新配置grid权重时出错: {e}")
    
    def _reposition_notebook_after_hide(self):
        """隐藏分析面板后重新定位notebook（已废弃，使用_reconfigure_grid_weights）"""
        # 直接调用新的grid权重配置方法
        self._reconfigure_grid_weights()
    
    def _force_notebook_fill(self):
        """强制notebook填充剩余空间"""
        try:
            if hasattr(self, 'notebook_container') and hasattr(self, 'notebook'):
                # 获取主框架的尺寸
                main_frame_height = self.main_frame.winfo_height()
                
                # 计算其他组件占用的高度
                other_height = 0
                for child in self.main_frame.winfo_children():
                    if child != self.notebook_container:
                        try:
                            child_height = child.winfo_reqheight()
                            other_height += child_height
                        except:
                            pass
                
                # 计算notebook应该占用的高度，不留边距
                available_height = main_frame_height - other_height
                
                if available_height > 50:  # 确保有足够的高度
                    # 强制设置notebook容器的高度
                    self.notebook_container.configure(height=available_height)
                    self.notebook_container.pack_configure(fill="both", expand=True, padx=0, pady=0)
                    self.notebook.pack_configure(fill="both", expand=True, padx=0, pady=0)
                    
                    self.log_message(f"✓ Notebook高度已设置为: {available_height} (主框架高度: {main_frame_height})")
                
                # 多次强制更新，确保布局生效
                self.root.update_idletasks()
                self.root.update()
                self.root.update_idletasks()
                
        except Exception as e:
            self.log_message(f"✗ 强制填充notebook时出错: {e}")
            # 备用方案：使用最简单的方法
            try:
                self.notebook_container.pack_configure(fill="both", expand=True, padx=0, pady=0)
                self.notebook.pack_configure(fill="both", expand=True, padx=0, pady=0)
            except:
                pass
    
    def _final_notebook_adjustment(self):
        """最终调整notebook，确保完全填充"""
        try:
            if hasattr(self, 'notebook_container') and hasattr(self, 'notebook'):
                # 获取主框架的实际高度
                self.root.update_idletasks()
                main_frame_height = self.main_frame.winfo_height()
                
                # 强制设置notebook容器填充整个主框架
                self.notebook_container.pack_configure(fill="both", expand=True, padx=0, pady=0)
                self.notebook.pack_configure(fill="both", expand=True, padx=0, pady=0)
                
                # 如果还有问题，尝试直接设置高度
                if main_frame_height > 100:
                    self.notebook_container.configure(height=main_frame_height)
                
                self.log_message(f"✓ 最终调整完成，主框架高度: {main_frame_height}")
                
                # 最后一次强制更新
                self.root.update_idletasks()
                self.root.update()
                
        except Exception as e:
            self.log_message(f"✗ 最终调整失败: {e}")
    
    def _reposition_notebook_after_show(self):
        """显示分析面板后重新定位notebook（已废弃，使用_reconfigure_grid_weights）"""
        # 直接调用新的grid权重配置方法
        self._reconfigure_grid_weights()
    
    def _delayed_notebook_show(self):
        """延迟显示notebook（已废弃，使用grid布局）"""
        # 直接调用新的grid权重配置方法
        self._reconfigure_grid_weights()
    
    def _simple_notebook_layout(self):
        """简化的notebook布局管理（使用grid布局）"""
        if not hasattr(self, 'notebook') or not hasattr(self, 'notebook_container'):
            return
            
        # 使用grid重新配置notebook容器
        try:
            # 确定notebook应该在哪一行
            notebook_row = 3  # 默认在第3行
            
            # 根据面板的显示状态调整notebook的位置
            if not self.filter_toggle_var.get() and not self.analysis_toggle_var.get():
                # 两个面板都隐藏，notebook在第1行（顶部控制栏之后）
                notebook_row = 1
            elif not self.filter_toggle_var.get() and self.analysis_toggle_var.get():
                # 只有筛选面板隐藏，notebook在第3行（分析面板之后）
                notebook_row = 3
            elif self.filter_toggle_var.get() and not self.analysis_toggle_var.get():
                # 只有分析面板隐藏，notebook在第2行（筛选面板之后）
                notebook_row = 2
            else:
                # 两个面板都显示，notebook在第3行
                notebook_row = 3
            
        # 重新配置notebook容器
            self.notebook_container.grid(row=notebook_row, column=0, sticky="nsew", padx=0, pady=0)
            
            # 重置所有行的权重
            for i in range(4):
                self.main_frame.grid_rowconfigure(i, weight=0)
            
            # 设置notebook行的权重为1，使其能够扩展
            self.main_frame.grid_rowconfigure(notebook_row, weight=1)
            
            # 确保notebook填充容器（notebook内部使用pack是允许的）
            self.notebook.pack(fill="both", expand=True, padx=0, pady=0)
            
            self.log_message(f"✓ Notebook布局已更新，在第{notebook_row}行")
            
            # 强制更新布局
            self.root.update_idletasks()
            self.root.update()
            
        except Exception as e:
            self.log_message(f"✗ 更新notebook布局时出错: {e}")
    
    def _reconfigure_notebook_layout(self):
        """重新配置notebook布局"""
        if not hasattr(self, 'notebook'):
            return
            
        # 先移除notebook
        self.notebook.pack_forget()
        
        # 立即更新布局，确保pack_forget生效
        self.root.update_idletasks()
        
        # 根据分析面板状态重新配置
        if hasattr(self, 'function_frame') and self.analysis_toggle_var.get():
            # 分析面板显示时，notebook在function_frame之后
            # 使用更稳定的布局方法
            self.notebook.pack(fill="both", expand=True, padx=0, pady=0)
            self.log_message("✓ Notebook布局：显示分析面板模式")
        else:
            # 分析面板隐藏时，notebook填充整个剩余空间
            self.notebook.pack(fill="both", expand=True, padx=0, pady=0)
            self.log_message("✓ Notebook布局：隐藏分析面板模式")
        
        # 强制更新布局
        self.root.update_idletasks()
        
        # 验证notebook是否正确显示
        try:
            pack_info = self.notebook.pack_info()
            self.log_message(f"✓ Notebook pack信息: {pack_info}")
        except:
            self.log_message("✗ Notebook显示异常")
    
    def refresh_current_display(self):
        """根据当前活动的标签页重新显示数据"""
        try:
            # 获取当前主标签页
            current_main_tab = self.notebook.index(self.notebook.select())
            
            if current_main_tab == 0:  # Sales标签页
                # 获取当前子标签页
                current_sub_tab = self.sales_notebook.index(self.sales_notebook.select())
                
                if current_sub_tab == 0:  # 销售数据
                    if hasattr(self, 'sales_data') and self.sales_data:
                        self.display_sales_data()
                        self.log_message("✓ 已刷新销售数据显示")
                    else:
                        self.log_message("ℹ 没有销售数据可显示")
                        
                elif current_sub_tab == 1:  # 支付方式分析
                    if hasattr(self, 'payment_data') and self.payment_data:
                        self.display_payment_analysis()
                        self.log_message("✓ 已刷新支付方式分析显示")
                    else:
                        self.log_message("ℹ 没有支付方式分析数据可显示")
                        
                elif current_sub_tab == 2:  # 折扣分析
                    if hasattr(self, 'discount_data') and self.discount_data:
                        self.display_discount_analysis()
                        self.log_message("✓ 已刷新折扣分析显示")
                    else:
                        self.log_message("ℹ 没有折扣分析数据可显示")
                        
                elif current_sub_tab == 3:  # 月度汇总
                    if hasattr(self, 'monthly_data') and self.monthly_data:
                        self.display_monthly_summary()
                        self.log_message("✓ 已刷新月度汇总显示")
                    else:
                        self.log_message("ℹ 没有月度汇总数据可显示")
                        
            elif current_main_tab == 1:  # Product标签页
                # 获取当前子标签页
                current_sub_tab = self.product_notebook.index(self.product_notebook.select())
                
                if current_sub_tab == 0:  # 日-产品数据
                    if hasattr(self, 'product_overview_data') and self.product_overview_data:
                        self.display_product_overview()
                        self.log_message("✓ 已刷新日-产品数据显示")
                    else:
                        self.log_message("ℹ 没有日-产品数据可显示")
                        
                elif current_sub_tab == 1:  # 周-产品数据
                    if hasattr(self, 'weekly_product_data') and self.weekly_product_data:
                        self.display_weekly_product_data()
                        self.log_message("✓ 已刷新周-产品数据显示")
                    else:
                        self.log_message("ℹ 没有周-产品数据可显示")
                        
                elif current_sub_tab == 2:  # 期间-产品数据
                    if hasattr(self, 'period_product_overview_data') and self.period_product_overview_data:
                        # 重新显示期间产品数据，这会响应日均切换
                        self.display_period_product_overview()
                        self.log_message("✓ 已刷新期间-产品数据显示")
                    else:
                        # 如果没有期间产品数据，自动获取数据
                        self.log_message("ℹ 期间-产品数据不存在，自动获取数据...")
                        self.get_period_product_overview()
                    
                    # 确保在期间产品数据标签页保持不跳转
                    return
                        
                elif current_sub_tab == 3:  # 日-产品分析
                    if hasattr(self, 'sales_tc_analysis_data') and self.sales_tc_analysis_data:
                        self.display_sales_tc_analysis()
                        self.log_message("✓ 已刷新日-产品分析显示")
                    else:
                        self.log_message("ℹ 没有日-产品分析数据可显示")
                        
                elif current_sub_tab == 4:  # 月-产品分析
                    if hasattr(self, 'sales_tc_monthly_data') and self.sales_tc_monthly_data:
                        self.display_sales_tc_monthly()
                        self.log_message("✓ 已刷新月-产品分析显示")
                    else:
                        self.log_message("ℹ 没有月-产品分析数据可显示")
                        
                elif current_sub_tab == 5:  # 产品关联分析
                    if hasattr(self, 'product_association_data') and self.product_association_data:
                        # 需要重新获取选中的产品名称
                        selected_product = getattr(self, 'last_selected_product', '')
                        if selected_product:
                            self.display_product_association_analysis(self.product_association_data, selected_product)
                            self.log_message("✓ 已刷新产品关联分析显示")
                        else:
                            self.log_message("ℹ 没有产品关联分析数据可显示")
                    else:
                        self.log_message("ℹ 没有产品关联分析数据可显示")
                        
                elif current_sub_tab == 6:  # 类别分析
                    if hasattr(self, 'category_analysis_data') and self.category_analysis_data:
                        self.display_category_analysis()
                        self.log_message("✓ 已刷新类别分析显示")
                    else:
                        self.log_message("ℹ 没有类别分析数据可显示")
                        
            elif current_main_tab == 2:  # Brand标签页
                # 获取当前子标签页
                current_sub_tab = self.brand_notebook.index(self.brand_notebook.select())
                
                if current_sub_tab == 0:  # 每日细项
                    if hasattr(self, 'brand_daily_data') and self.brand_daily_data:
                        self.display_brand_daily_breakdown()
                        self.log_message("✓ 已刷新每日细项显示")
                    else:
                        self.log_message("ℹ 没有每日细项数据可显示")
                        
                elif current_sub_tab == 1:  # 期间汇总
                    if hasattr(self, 'brand_period_data') and self.brand_period_data:
                        self.display_brand_period_summary()
                        self.log_message("✓ 已刷新期间汇总显示")
                    else:
                        self.log_message("ℹ 没有期间汇总数据可显示")
                        
            else:
                self.log_message("ℹ 当前标签页不支持显示开关功能")
                
        except Exception as e:
            self.log_message(f"✗ 刷新显示时出错: {e}")
    
    def validate_date_range(self):
        """验证日期范围"""
        try:
            from datetime import datetime
            
            # 如果未启用日期筛选，直接返回True
            if not self.use_date_filter.get():
                self.log_message("ℹ 未启用日期筛选，将使用月份筛选")
                return True
                
            date_from = self.date_from.get_date()
            date_to = self.date_to.get_date()
            current_date = datetime.now().date()
            
            # 添加调试信息
            self.log_message(f"🔍 日期验证调试信息:")
            self.log_message(f"   当前系统日期: {current_date.strftime('%Y-%m-%d')}")
            self.log_message(f"   选择的开始日期: {date_from.strftime('%Y-%m-%d') if date_from else 'None'}")
            self.log_message(f"   选择的结束日期: {date_to.strftime('%Y-%m-%d') if date_to else 'None'}")
            
            if date_from and date_to:
                if date_from > date_to:
                    self.log_message("⚠ 开始日期不能晚于结束日期")
                    return False
                elif date_from > current_date:
                    self.log_message(f"⚠ 开始日期不能是未来日期 (当前日期: {current_date.strftime('%Y-%m-%d')})")
                    return False
                elif date_to > current_date:
                    self.log_message(f"⚠ 结束日期不能是未来日期 (当前日期: {current_date.strftime('%Y-%m-%d')})")
                    return False
                else:
                    self.log_message(f"✓ 日期范围有效: {date_from.strftime('%Y-%m-%d')} 到 {date_to.strftime('%Y-%m-%d')}")
                    return True
            else:
                self.log_message("ℹ 未选择日期范围，将查询所有数据")
                return True
        except Exception as e:
            self.log_message(f"✗ 日期验证失败: {e}")
            import traceback
            self.log_message(f"错误详情: {traceback.format_exc()}")
            return False
    
    def set_current_month_dates(self):
        """设置当前月份的日期范围"""
        try:
            from datetime import datetime, timedelta
            
            now = datetime.now()
            # 设置为本月第一天
            first_day = now.replace(day=1)
            # 设置为今天
            today = now.date()
            
            # 更新日期输入框
            self.date_from.set_date(first_day.date())
            self.date_to.set_date(today)
            
            self.log_message(f"✓ 已设置日期范围: {first_day.strftime('%Y-%m-%d')} 到 {today.strftime('%Y-%m-%d')}")
            
        except Exception as e:
            self.log_message(f"✗ 设置当前月份日期失败: {e}")
    
    def test_database_connection(self):
        """测试数据库连接和数据可用性"""
        try:
            self.log_message("🔍 开始数据库连接测试...")
            
            # 测试连接
            db = self.selected_db.get()
            self.log_message(f"正在测试连接到 {db}...")
            
            if not self.db_manager.connect(db):
                self.log_message(f"✗ 无法连接到 {db}")
                return False
            
            self.log_message(f"✓ 数据库连接成功", include_db_info=True)
            
            # 显示数据库详细信息
            self.log_database_info()
            
            # 测试基本查询
            cursor = self.db_manager.connection.cursor()
            
            # 检查表是否存在
            tables_to_check = ["pos_sales_dtls", "pos_sales_payment_dtls", "pos_cancel_sales_item_dtls", "item_master"]
            for table in tables_to_check:
                try:
                    cursor.execute(f"SELECT COUNT(*) FROM {table}")
                    count = cursor.fetchone()[0]
                    self.log_message(f"✓ 表 {table}: {count} 条记录")
                except Exception as e:
                    self.log_message(f"✗ 表 {table} 查询失败: {e}")
            
            # 检查日期范围内的数据
            if self.use_date_filter.get():
                date_from = self.date_from.get_date().strftime('%Y-%m-%d') if self.date_from.get_date() else None
                date_to = self.date_to.get_date().strftime('%Y-%m-%d') if self.date_to.get_date() else None
                
                if date_from and date_to:
                    try:
                        test_query = f"SELECT COUNT(*) FROM pos_sales_dtls WHERE c_date >= '{date_from} 00:00:00' AND c_date <= '{date_to} 23:59:59'"
                        cursor.execute(test_query)
                        count = cursor.fetchone()[0]
                        self.log_message(f"✓ 日期范围 {date_from} 到 {date_to} 的数据: {count} 条记录")
                        
                        if count == 0:
                            self.log_message("⚠ 该日期范围内没有数据，请检查日期范围或数据库中的数据")
                    except Exception as e:
                        self.log_message(f"✗ 日期范围查询失败: {e}")
            
            cursor.close()
            self.log_message("✓ 数据库连接测试完成")
            return True
            
        except Exception as e:
            self.log_message(f"✗ 数据库连接测试失败: {e}")
            import traceback
            self.log_message(f"错误详情: {traceback.format_exc()}")
            return False
    
    def clear_cache(self):
        """清理所有缓存"""
        try:
            # 清理数据库管理器的缓存
            if hasattr(self.db_manager, '_weekly_cache'):
                self.db_manager._weekly_cache.clear()
            if hasattr(self.db_manager, '_sales_tc_cache'):
                self.db_manager._sales_tc_cache.clear()
            if hasattr(self.db_manager, '_sales_cache'):
                self.db_manager._sales_cache.clear()
            if hasattr(self.db_manager, '_category_cache'):
                self.db_manager._category_cache.clear()
            if hasattr(self.db_manager, '_product_cache'):
                self.db_manager._product_cache.clear()
            if hasattr(self.db_manager, '_period_product_cache'):
                self.db_manager._period_product_cache.clear()
            if hasattr(self.db_manager, '_payment_cache'):
                self.db_manager._payment_cache.clear()
            if hasattr(self.db_manager, '_sales_tc_monthly_cache'):
                self.db_manager._sales_tc_monthly_cache.clear()
            
            self.log_message("✓ 已清理所有缓存")
            return True
            
        except Exception as e:
            self.log_message(f"✗ 清理缓存失败: {e}")
            return False
    
    def check_database_dates(self):
        """检查数据库中的日期格式和范围"""
        try:
            if not self.db_manager.connection:
                self.log_message("ℹ 请先连接数据库")
                return
            
            cursor = self.db_manager.connection.cursor()
            
            # 检查c_date字段的格式和范围
            query = """
                SELECT TOP 5 
                    c_date,
                    FORMAT(c_date, 'yyyy-MM-dd') as date_only,
                    FORMAT(c_date, 'yyyy-MM-dd HH:mm:ss') as date_time
                FROM pos_sales_dtls 
                ORDER BY c_date DESC
            """
            
            try:
                cursor.execute(query)
                results = cursor.fetchall()
            except Exception as query_error:
                print(f"查询执行失败: {query_error}")
                print(f"查询语句: {query[:200]}...")
                cursor.close()
                return []
            finally:
                cursor.close()
            
            self.log_message("ℹ 数据库中的日期格式示例:")
            for row in results:
                self.log_message(f"  - 原始: {row[0]}, 日期: {row[1]}, 日期时间: {row[2]}")
                
        except Exception as e:
            self.log_message(f"✗ 检查数据库日期失败: {e}")
    
    def verify_data_accuracy(self):
        """验证数据准确性"""
        try:
            # 先连接数据库
            db = self.selected_db.get()
            self.log_message(f"正在连接到 {db}...")
            
            if not self.db_manager.connect(db):
                self.log_message(f"✗ 无法连接到 {db}")
                return
            
            self.log_message(f"✓ 连接成功", include_db_info=True)
            
            # 获取当前筛选条件
            # 根据日期筛选开关决定是否使用日期筛选
            if self.use_date_filter.get():
                date_from = self.date_from.get_date().strftime('%Y-%m-%d') if self.date_from.get_date() else None
                date_to = self.date_to.get_date().strftime('%Y-%m-%d') if self.date_to.get_date() else None
                
                # 使用纯日期格式，不添加时间部分
                if date_from and date_to and date_from == date_to:
                    self.log_message(f"ℹ 单日查询: {date_from}")
                elif date_to:
                    self.log_message(f"ℹ 日期范围查询: {date_from} 到 {date_to}")
            else:
                # 不使用日期筛选，只使用月份筛选
                date_from = None
                date_to = None
            
            outlet_filters = self.outlet_combo.get_selected()
            product_filters = self.product_combo.get_selected()
            month_filters = self.month_combo.get_selected()
            weekday_filters = self.weekday_combo.get_selected()
            print(f"GUI获取的星期筛选: {weekday_filters}")
            category_filters = self.category_combo.get_selected()
            payment_filters = self.payment_combo.get_selected_for_filter()
            
            self.log_message("=" * 50)
            self.log_message("🔍 开始验证数据准确性...")
            self.log_message(f"📅 查询日期: {date_from} 到 {date_to}")
            self.log_message(f"🏪 门市筛选: {outlet_filters if outlet_filters else '全部'}")
            self.log_message(f"📦 产品筛选: {product_filters if product_filters else '全部'}")
            self.log_message(f"📆 月份筛选: {month_filters if month_filters else '全部'}")
            self.log_message(f"📅 星期筛选: {weekday_filters if weekday_filters else '全部'}")
            self.log_message(f"📂 类别筛选: {category_filters if category_filters else '全部'}")
            self.log_message(f"💳 支付筛选: {payment_filters if payment_filters else '全部'}")
            self.log_message("=" * 50)
            
            # 1. 验证销售数据
            self.log_message("1️⃣ 验证销售数据...")
            sales_data = self.db_manager.get_sales_data(
                date_from, date_to, outlet_filters, product_filters, None, month_filters, weekday_filters, category_filters, payment_filters
            )
            
            if sales_data:
                self.log_message(f"✅ 销售数据: 共 {len(sales_data)} 条记录")
                
                # 计算总金额
                total_amount = sum(float(row[8]) for row in sales_data if row[8])  # 金额列
                self.log_message(f"💰 销售总金额: ${total_amount:,.2f}")
                
                # 按门市统计
                store_stats = {}
                for row in sales_data:
                    store = row[0]  # 门市列
                    amount = float(row[8]) if row[8] else 0
                    if store not in store_stats:
                        store_stats[store] = {'count': 0, 'amount': 0}
                    store_stats[store]['count'] += 1
                    store_stats[store]['amount'] += amount
                
                self.log_message("🏪 各门市销售统计:")
                for store, stats in sorted(store_stats.items()):
                    self.log_message(f"   {store}: {stats['count']} 笔, ${stats['amount']:,.2f}")
            else:
                self.log_message("❌ 销售数据: 无数据")
            
            # 2. 验证月度汇总数据
            self.log_message("\n2️⃣ 验证月度汇总数据...")
            monthly_data = self.db_manager.get_monthly_summary_optimized(
                date_from, date_to, outlet_filters, product_filters, month_filters, category_filters, payment_filters
            )
            
            if monthly_data:
                self.log_message(f"✅ 月度汇总: 共 {len(monthly_data)} 条记录")
                
                # 计算月度汇总总金额
                monthly_total = sum(float(row[5]) for row in monthly_data if row[5])  # 金额列
                self.log_message(f"💰 月度汇总总金额: ${monthly_total:,.2f}")
                
                # 按月份统计
                month_stats = {}
                for row in monthly_data:
                    month = row[0]  # 月份列
                    amount = float(row[5]) if row[5] else 0
                    if month not in month_stats:
                        month_stats[month] = {'count': 0, 'amount': 0}
                    month_stats[month]['count'] += 1
                    month_stats[month]['amount'] += amount
                
                self.log_message("📅 各月份统计:")
                for month, stats in sorted(month_stats.items()):
                    self.log_message(f"   {month}: {stats['count']} 条, ${stats['amount']:,.2f}")
            else:
                self.log_message("❌ 月度汇总: 无数据")
            
            # 3. 验证支付方式分析数据
            self.log_message("\n3️⃣ 验证支付方式分析数据...")
            payment_data = self.db_manager.get_payment_summary(
                date_from, date_to, outlet_filters, month_filters, category_filters, payment_filters
            )
            
            if payment_data:
                self.log_message(f"✅ 支付方式分析: 共 {len(payment_data)} 条记录")
                
                # 计算支付方式总金额
                payment_total = sum(float(row[4]) for row in payment_data if row[4])  # 金额列
                self.log_message(f"💰 支付方式总金额: ${payment_total:,.2f}")
                
                # 按支付方式统计
                payment_stats = {}
                for row in payment_data:
                    payment = row[0]  # 支付方式列
                    amount = float(row[4]) if row[4] else 0
                    if payment not in payment_stats:
                        payment_stats[payment] = {'count': 0, 'amount': 0}
                    payment_stats[payment]['count'] += 1
                    payment_stats[payment]['amount'] += amount
                
                self.log_message("💳 各支付方式统计:")
                for payment, stats in sorted(payment_stats.items()):
                    self.log_message(f"   {payment}: {stats['count']} 笔, ${stats['amount']:,.2f}")
            else:
                self.log_message("❌ 支付方式分析: 无数据")
            
            # 4. 数据一致性检查
            self.log_message("\n4️⃣ 数据一致性检查...")
            if sales_data and monthly_data:
                sales_total = sum(float(row[8]) for row in sales_data if row[8])
                monthly_total = sum(float(row[5]) for row in monthly_data if row[5])
                difference = abs(sales_total - monthly_total)
                
                if difference < 0.01:  # 允许0.01的误差
                    self.log_message("✅ 销售数据与月度汇总数据一致")
                else:
                    self.log_message(f"⚠️ 数据不一致! 销售数据: ${sales_total:,.2f}, 月度汇总: ${monthly_total:,.2f}, 差异: ${difference:,.2f}")
            
            self.log_message("=" * 50)
            self.log_message("✅ 数据验证完成")
            
        except Exception as e:
            self.log_message(f"✗ 数据验证失败: {e}")
        finally:
            # 断开数据库连接
            self.db_manager.disconnect()
        
        # 存储数据
        self.sales_data = []
        self.payment_data = []
        self.discount_data = []
        self.monthly_data = []
        
        # 活动记录存储
        self.activity_records = []
    
    def setup_global_themes(self):
        """設置基於SEAutomation.py風格的現代主題和樣式"""
        try:
            # 使用clam主題，對自定義樣式支持更好
            style = ttk.Style()
            style.theme_use('clam')
            
            # 🎨 現代清新配色方案 - 完全無灰色
            # 主背景 - 純白 (#FFFFFF) 
            # 面板背景 - 純白 (#FFFFFF)
            # 主要藍色 - 專業藍 (#2196F3)
            # 成功綠色 - 清新綠 (#4CAF50)
            # 警告橙色 - 溫暖橙 (#FF9800)
            # 錯誤紅色 - 柔和紅 (#F44336)
            # 次到紫色 - 優雅紫 (#9C27B0)
            # 輸入框背景 - 純白 (#FFFFFF)
            # 文字顏色 - 純黑 (#000000)
            
            # 現代化Treeview樣式 - 完全純白主題
            style.configure("Treeview", 
                           background="#FFFFFF",  # 純白背景
                           foreground="#000000",  # 純黑文字
                           fieldbackground="#FFFFFF",
                           rowheight=36,  # 增加行高
                           font=('Segoe UI', 10),
                           relief="flat",
                           borderwidth=1)
            
            # 現代化表格表頭 - 專業藍色
            style.configure("Treeview.Heading", 
                           font=('Segoe UI', 11, 'bold'),
                           background="#2196F3",  # 專業藍
                           foreground="#FFFFFF",
                           relief="flat",
                           borderwidth=0,
                           padding=(16, 14))
            
            # 表頭狀態映射
            style.map("Treeview.Heading",
                     background=[('active', '#1976D2'),
                                ('!active', '#2196F3')],
                     foreground=[('active', '#FFFFFF'),
                                ('!active', '#FFFFFF')])
            
            # 現代化LabelFrame樣式 - 清新主題
            style.configure("LabelFrame",
                           background="#FFFFFF",  # 純白背景
                           foreground="#2196F3",  # 專業藍
                           font=('Segoe UI', 11, 'bold'),
                           relief="flat",
                           borderwidth=2)
            
            style.configure("LabelFrame.Label",
                           background="#FFFFFF",
                           foreground="#2196F3",
                           font=('Segoe UI', 11, 'bold'))
            
            # 現代化主按鈕樣式 - 清新專業主題
            style.configure("Modern.TButton",
                           font=('Segoe UI', 11, 'bold'),
                           background="#2196F3",  # 專業藍
                           foreground="#FFFFFF",
                           relief="flat",
                           borderwidth=0,
                           padding=(18, 14))
            
            style.map("Modern.TButton",
                     background=[('active', '#1976D2'),
                                ('!active', '#2196F3'),
                                ('pressed', '#1565C0')])
            
            # 現代化次要按鈕樣式 - 純白主題
            style.configure("Secondary.TButton",
                           font=('Segoe UI', 10),
                           background="#FFFFFF",  # 純白
                           foreground="#2196F3",  # 藍色文字
                           relief="solid",
                           borderwidth=2,
                           padding=(14, 10))
            
            style.map("Secondary.TButton",
                     background=[('active', '#E3F2FD'),
                                ('!active', '#FFFFFF')])
            
            # 現代化標籤頁樣式 - 純白主題
            style.configure("Modern.TNotebook",
                           background="#FFFFFF",  # 純白
                           tabposition="n",
                           borderwidth=0)
            
            style.configure("Modern.TNotebook.Tab",
                           background="#E3F2FD",  # 非常淺的藍色
                           foreground="#1976D2",  # 深藍色
                           padding=(22, 14),
                           font=('Segoe UI', 11, 'bold'))
            
            style.map("Modern.TNotebook.Tab",
                     background=[('selected', '#2196F3'),  # 專業藍
                                ('active', '#FFFFFF')],  # 純白
                     foreground=[('selected', '#FFFFFF'),
                                ('active', '#000000')])
            
            # 現代化輸入框樣式 - 純白主題
            style.configure("Modern.TCombobox",
                           font=('Segoe UI', 10),
                           background="#FFFFFF",  # 純白
                           foreground="#000000",  # 純黑
                           borderwidth=2,
                           relief="solid",
                           lightcolor="#2196F3",  # 專業藍
                           darkcolor="#2196F3")
            
            style.configure("Modern.TEntry",
                           font=('Segoe UI', 10),
                           background="#FFFFFF",
                           foreground="#000000",
                           borderwidth=2,
                           relief="solid",
                           lightcolor="#2196F3",
                           darkcolor="#2196F3")

            
            # 現代化滑動條樣式 - 純白主題
            style.configure("Modern.TScrollbar",
                           background="#E3F2FD",  # 淺藍色
                           troughcolor="#FFFFFF",  # 純白
                           borderwidth=0,
                           lightcolor="#2196F3",  # 專業藍
                           darkcolor="#2196F3")
            
            # 現代化核取方塊和單選按鈕 - 純白主題
            style.configure("Modern.TCheckbutton",
                           font=('Segoe UI', 10),
                           focuscolor="#2196F3",  # 專業藍
                           background="#FFFFFF",  # 純白
                           foreground="#000000")  # 純黑
            
            style.configure("Modern.TRadiobutton",
                           font=('Segoe UI', 10),
                           focuscolor="#2196F3",
                           background="#FFFFFF",
                           foreground="#000000")
            
            print("✅ 活動記錄管理中心風格主題和樣式已應用")
            
        except Exception as e:
            print(f"設置現代化主題失敗: {e}")
    
    def startup_database_update(self):
        """啟動時自動更新單據明細數據庫 - 後台靜默更新"""
        try:
            print("🚀 啟動時自動更新單據明細數據庫...")
            
            # 延遲導入避免循環導入
            from receipt_database_manager import ReceiptDatabaseManager
            self.receipt_db_manager = ReceiptDatabaseManager()
            
            # 簡化的進度回調函數 - 只輸出到控制台
            def silent_progress_callback(message, current, total):
                if total > 0:
                    percentage = int((current / total) * 100)
                    print(f"📊 {message} - {percentage}% ({current}/{total})")
                else:
                    print(f"📊 {message}")
            
            # 延遲啟動更新，確保GUI完全初始化
            def delayed_update():
                # 等待GUI完全初始化
                self.root.after(1000, lambda: self.start_silent_database_update(silent_progress_callback))
            
            # 延遲啟動
            delayed_update()
            
            # 啟動自動更新
            self.receipt_db_manager.start_auto_update()
            
        except Exception as e:
            print(f"❌ 啟動時數據庫更新失敗: {e}")
    
    def start_silent_database_update(self, progress_callback):
        """啟動靜默數據庫更新線程"""
        def update_database():
            try:
                success = self.receipt_db_manager.full_update(progress_callback)
                
                print(f"✅ 數據庫更新完成，結果: {success}")
                
                if success:
                    print("✅ 數據庫更新成功！")
                else:
                    print("❌ 數據庫更新失敗！")
                        
            except Exception as e:
                print(f"❌ 數據庫更新錯誤: {e}")
                print("❌ 數據庫更新失敗！")
        
        # 啟動更新線程
        update_thread = threading.Thread(target=update_database, daemon=True)
        update_thread.start()
    
    
    def setup_ui(self):
        """設置用戶界面 - 穩定三欄布局"""
        print("🏗️ 開始設置全新的穩定UI布局...")
        
        # 啟動時自動更新單據明細數據庫
        self.startup_database_update()
        
        # 設置全局主題和樣式
        self.setup_global_themes()
        
        # === 標題欄 ===
        header_frame = tk.Frame(self.root, bg='#2c3e50', height=60)
        header_frame.pack(fill="x", padx=0, pady=0)
        header_frame.pack_propagate(False)
        
        title_container = tk.Frame(header_frame, bg='#2c3e50')
        title_container.pack(expand=True, fill="both")
        
        title_label = tk.Label(title_container, 
                              text="📊 POS數據分析工具 - 增強版", 
                              font=('Microsoft YaHei UI', 18, 'bold'),
                              fg='white', bg='#2c3e50')
        title_label.pack(side="left", padx=20, pady=15)
        
        subtitle_label = tk.Label(title_container, 
                                text="POS Data Analysis Tool - Enhanced", 
                                font=('Arial', 11),
                                fg='#bdc3c7', bg='#2c3e50')
        subtitle_label.pack(side="right", padx=20, pady=15)
        
        # === 主要佈局容器 ===
        self.layout_container = tk.Frame(self.root, bg='#FFFFFF')
        self.layout_container.pack(fill="both", expand=True, padx=0, pady=0)
        
        # === 左側面板 (固定寬度) ===
        self.left_panel = tk.Frame(self.layout_container, bg='#ffffff', relief='solid', bd=1)
        self.left_panel.pack(side="left", fill="y", expand=False, padx=(15, 8), pady=15)
        self.left_panel.configure(width=190)
        self.left_panel.pack_propagate(False)
        
        # 強制鎖定左側面板 - 永不改變
        self.left_panel.bind('<Configure>', lambda e: self.left_panel.configure(width=190, height=e.height))
        
        # 左側標題
        left_header = tk.Frame(self.left_panel, bg='#3498db', height=40)
        left_header.pack(fill="x")
        left_header.pack_propagate(False)
        
        left_title = tk.Label(left_header, 
                             text="📊 分析功能", 
                             font=('Microsoft YaHei UI', 12, 'bold'),
                             fg='white', bg='#3498db')
        left_title.pack(pady=10)
        
        left_subtitle = tk.Label(left_header, 
                               text="Analysis Functions", 
                               font=('Arial', 9),
                               fg='#ecf0f1', bg='#3498db')
        left_subtitle.pack()
        
        # === 中間內容區域 (彈性寬度) ===
        self.main_frame = tk.Frame(self.layout_container, bg='#ffffff', relief='solid', bd=1)
        self.main_frame.pack(side="left", fill="both", expand=True, padx=(8, 8), pady=15)
        
        # 配置grid权重
        self.main_frame.grid_rowconfigure(1, weight=1)
        self.main_frame.grid_columnconfigure(0, weight=1)
        
        # === 右側面板 (固定寬度) ===
        self.right_panel = tk.Frame(self.layout_container, bg='#ffffff', relief='solid', bd=1)
        self.right_panel.pack(side="right", fill="y", expand=False, padx=(8, 15), pady=15)
        self.right_panel.configure(width=270)
        self.right_panel.pack_propagate(False)
        
        # 強制鎖定右側面板 - 永不改變，防止消失
        self.right_panel.bind('<Configure>', lambda e: self.right_panel.configure(width=270, height=e.height))
        
        # 確保右側面板始終在右側
        self.right_panel.pack_configure(side="right")
        
        # 右側標題
        right_header = tk.Frame(self.right_panel, bg='#e74c3c', height=45)
        right_header.pack(fill="x")
        right_header.pack_propagate(False)
        
        right_title = tk.Label(right_header, 
                              text="📊 活动提醒", 
                              font=('Microsoft YaHei UI', 13, 'bold'),
                              fg='white', bg='#e74c3c')
        right_title.pack(pady=12)
        
        right_subtitle = tk.Label(right_header, 
                                text="Activity Alerts Panel", 
                                font=('Arial', 9),
                                fg='#ecf0f1', bg='#e74c3c')
        right_subtitle.pack()
        
        # 右側內容區域
        right_content_frame = tk.Frame(self.right_panel, bg='#ffffff')
        right_content_frame.pack(fill="both", expand=True, padx=5, pady=5)
        
        # 活動提醒文本框
        self.activity_alert_text = tk.Text(right_content_frame, 
                                          height=15, width=28,
                                          font=('Segoe UI', 10), wrap=tk.WORD, bg='#FFFFFF',
                                          fg='#2c3e50', state='disabled', relief='flat', borderwidth=2)
        self.activity_alert_scrollbar = ttk.Scrollbar(right_content_frame, 
                                                   orient="vertical", 
                                               command=self.activity_alert_text.yview)
        self.activity_alert_text.configure(yscrollcommand=self.activity_alert_scrollbar.set)
        
        # 使用grid布局確保穩定性
        self.activity_alert_text.grid(row=0, column=0, sticky="nsew", padx=(0, 5))
        self.activity_alert_scrollbar.grid(row=0, column=1, sticky="ns")
        
        # 配置grid權重
        right_content_frame.grid_rowconfigure(0, weight=1)
        right_content_frame.grid_columnconfigure(0, weight=1)
        
        print("✅ 三欄布局架構創建完成:")
        print(f"   - 左側面板: 190px")
        print(f"   - 中間內容: 彈性寬度") 
        print(f"   - 右側面板: 270px")
        
        # 初始化活動提醒內容
        self.activity_alert_text.config(state='normal')
        welcome_text = """📊 活动提醒

✅ 三欄布局已穩定！

系統狀態: 正常運行
布局模式: 穩定三欄
面板狀態: 已激活

🎯 功能區域:
• 左側: 分析功能導航
• 中間: 數據展示區域  
• 右側: 活動提醒面板

💡 使用提示:
• 點擊左側按鈕開始分析
• 選擇日期範圍進行篩選
• 查看右側活動提醒信息

🛡️ 穩定性保證:
• 面板尺寸已鎖定
• 布局結構穩定
• 不受操作影響"""
        
        self.activity_alert_text.insert(1.0, welcome_text)
        self.activity_alert_text.config(state='disabled')
        
        # 強制UI更新以確保顯示
        self.layout_container.update_idletasks()
        self.root.update_idletasks()
        
        # 确保活动记录已正确初始化
        if not hasattr(self, 'activity_records'):
            self.activity_records = {
                'GOGO': [],
                'Express': [],
                'PLUS': []
            }
        
        # 尝试更新活动提醒内容（避免空数据错误）
        try:
            self.update_activity_alerts()
        except Exception as e:
            print(f"⚠️ 活动提醒更新失败: {e}")
            # 设置基础内容避免错误显示
            self.activity_alert_text.config(state='normal')
            self.activity_alert_text.delete(1.0, tk.END)
            basic_text = "📊 活动提醒\n\n系统正常运行，活动提醒功能准备就绪。"
            self.activity_alert_text.insert(1.0, basic_text)
            self.activity_alert_text.config(state='disabled')
        
        # 调试输出
        print(f"✅ UI更改已应用:")
        print(f"   - 左侧面板宽度: {self.left_panel['width']}")
        print(f"   - 右侧面板宽度: {self.right_panel['width']}")
        print(f"   - 活动提醒文本长度: {len(welcome_text)}")
        print(f"   - 活动提醒面板已初始化")
        
        # 强制刷新界面
        self.root.update()
        self.root.update_idletasks()
        
        # 强制锁定面板大小，防止自动调整
        self.root.after(100, self.lock_panel_sizes)
        
        # 🛡️ 額外保護：確保右側面板永不被破壞
        self.root.after(200, self.final_right_panel_protection)
        
        # 初始化活动提醒显示
        self.update_activity_alerts()
        
        # 筛选条件框架（包含数据库选择和筛选条件）
        # 美化頂部篩選框架
        # 使用純白色 tkFrame 替代 tk.LabelFrame，完全去除灰色邊框
        self.filter_frame = tk.Frame(self.main_frame, bg='#FFFFFF', relief='solid', bd=2)
        self.filter_frame.grid(row=0, column=0, sticky="ew", padx=8, pady=(0, 8))
        
        # 標題標籤 - 減少上邊距
        filter_title = tk.Label(self.filter_frame, 
                               text="🔍 筛选条件 / Filter Conditions", 
                               font=('Microsoft JhengHei', 10, 'bold'),
                               fg='#2c3e50', bg='#FFFFFF')
        filter_title.pack(pady=(5, 8))
        
        # 設置清新主題篩選框架背景
        filter_canv = tk.Canvas(self.filter_frame, highlightthickness=0, bg='#FFFFFF', height=5)
        filter_canv.place(x=0, y=0, relwidth=1, relheight=1)
        
        # 数据库选择行 - 新的大按鍵設計
        db_row = tk.Frame(self.filter_frame, bg='#FFFFFF')
        db_row.pack(fill="x", pady=(8, 12))
        
        # 数据庫標籤 - 雙語顯示
        db_label = tk.Label(db_row, 
                           text="🗄️ 数据库选择\nDatabase Selection", 
                           font=('Microsoft YaHei UI', 9, 'bold'), bg='#FFFFFF')
        db_label.pack(side="left", padx=(0, 15), pady=6)
        
        # 创建大的数据庫選擇按鍵 - 4個選項
        self.selected_db = tk.StringVar(value="GOGO")
        
        # 創建數據庫選項按鍵 - 使用類實例變量
        self.db_options = {}
        
        for i, (key, info) in enumerate(self.DATABASE_OPTIONS.items()):
            btn = tk.Button(db_row,
                          text=f"{info['icon']} {info['cn']}\n{info['en']}",
                          font=('Microsoft YaHei UI', 9, 'bold'),
                          bg=info['color'], fg='white',
                          relief='solid', bd=2,
                          width=14, height=3,
                          command=lambda k=key: self.select_database_option(k))
            btn.pack(side="left", padx=6, fill="y")
            self.db_options[key] = btn
        
        # 更新初始按鍵狀態
        self.update_database_button_style()
        
        # 活动记录超大按鍵 - 移除连接数据库
        activity_btn = tk.Button(db_row, 
                               text="📝 活动记录\nActivity Log", 
                               font=('Microsoft YaHei UI', 9, 'bold'),
                               bg='#e74c3c', fg='white', 
                               relief='solid', bd=2,
                               width=16, height=3,
                               command=self.open_activity_window)
        activity_btn.pack(side="right", padx=(15, 0), fill="y")
        
        # 第一行：日期范围
        filter_row1 = tk.Frame(self.filter_frame)
        filter_row1.pack(fill="x", pady=2)
        
        # 日期筛选开关
        self.use_date_filter = tk.BooleanVar(value=True)
        date_filter_cb = tk.Checkbutton(filter_row1, text="📅 使用日期筛选 / Use Date Filter", 
                                        variable=self.use_date_filter,
                                        command=self.toggle_date_filter)
        date_filter_cb.pack(side="left", padx=5)
        
        tk.Label(filter_row1, text="📅 日期从 / Date From:", font=('Arial', 9, 'bold')).pack(side="left", padx=5)
        self.date_from = DateEntry(filter_row1, width=12, background='darkblue',
                                  foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy')
        self.date_from.pack(side="left", padx=2)
        
        tk.Label(filter_row1, text="到 / To:", font=('Arial', 9, 'bold')).pack(side="left", padx=5)
        self.date_to = DateEntry(filter_row1, width=12, background='darkblue',
                                foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy')
        self.date_to.pack(side="left", padx=2)
        
        # 绑定日期变化事件，实时更新活动提醒
        self.date_from.bind('<<DateEntrySelected>>', lambda e: self.update_activity_alerts())
        self.date_to.bind('<<DateEntrySelected>>', lambda e: self.update_activity_alerts())
        
        # 添加日期格式说明和快速设置按钮
        date_help_frame = tk.Frame(filter_row1)
        date_help_frame.pack(side="left", padx=10)
        
        date_help_label = tk.Label(date_help_frame, text="(点击日历图标选择日期)\n(Click calendar icon to select date)", 
                                   foreground="gray")
        date_help_label.pack()
        
        # 第二行：筛选条件
        filter_row2 = tk.Frame(self.filter_frame)
        filter_row2.pack(fill="x", pady=2)
        
        # 门市筛选
        tk.Label(filter_row2, text="🏪 门市 / Outlet:", font=('Arial', 9, 'bold')).pack(side="left", padx=5)
        self.outlet_all_btn = ttk.Button(filter_row2, text="全部 / All", command=self.toggle_all_outlets, width=8)
        self.outlet_all_btn.pack(side="left", padx=2)
        self.outlet_combo = MultiSelectCombobox(filter_row2, width=25, title="选择门市 / Select Outlet", on_change_callback=self.on_outlet_changed, delay_ms=1000)
        self.outlet_combo.pack(side="left", padx=2)
        
        # 月份筛选
        tk.Label(filter_row2, text="📆 月份 / Month:", font=('Arial', 9, 'bold')).pack(side="left", padx=5)
        self.month_all_btn = ttk.Button(filter_row2, text="全部 / All", command=self.toggle_all_months, width=8)
        self.month_all_btn.pack(side="left", padx=2)
        self.month_combo = MultiSelectCombobox(filter_row2, width=20, title="选择月份 / Select Month", on_change_callback=self.on_month_changed, delay_ms=1000)
        self.month_combo.pack(side="left", padx=2)
        
        # 星期筛选
        tk.Label(filter_row2, text="📅 星期 / Weekday:", font=('Arial', 9, 'bold')).pack(side="left", padx=5)
        self.weekday_all_btn = ttk.Button(filter_row2, text="全部 / All", command=self.toggle_all_weekdays, width=8)
        self.weekday_all_btn.pack(side="left", padx=2)
        self.weekday_combo = MultiSelectCombobox(filter_row2, width=20, title="选择星期 / Select Weekday", on_change_callback=self.on_weekday_changed, delay_ms=1000)
        self.weekday_combo.pack(side="left", padx=2)
        
        # 支付方式筛选
        tk.Label(filter_row2, text="支付方式:\nPayment Method:").pack(side="left", padx=5)
        self.payment_all_btn = ttk.Button(filter_row2, text="全部\nAll", command=self.toggle_all_payments, width=6)
        self.payment_all_btn.pack(side="left", padx=2)
        self.payment_combo = MultiSelectCombobox(filter_row2, width=25, title="选择支付方式\nSelect Payment Method", on_change_callback=self.on_payment_changed, delay_ms=3000)
        self.payment_combo.pack(side="left", padx=2)
        
        # 第三行：类别、产品和搜索
        filter_row3 = tk.Frame(self.filter_frame)
        filter_row3.pack(fill="x", pady=2)
        
        # 类别筛选
        tk.Label(filter_row3, text="类别:\nCategory:").pack(side="left", padx=5)
        self.category_all_btn = ttk.Button(filter_row3, text="全部\nAll", command=self.toggle_all_categories, width=6)
        self.category_all_btn.pack(side="left", padx=2)
        self.category_combo = MultiSelectCombobox(filter_row3, width=25, title="选择类别\nSelect Category", on_change_callback=self.on_category_changed, delay_ms=1000)
        self.category_combo.pack(side="left", padx=2)
        
        # 产品筛选
        tk.Label(filter_row3, text="产品:\nProduct:").pack(side="left", padx=5)
        self.product_all_btn = ttk.Button(filter_row3, text="全部\nAll", command=self.toggle_all_products, width=6)
        self.product_all_btn.pack(side="left", padx=2)
        self.product_combo = MultiSelectCombobox(filter_row3, width=30, title="选择产品\nSelect Product", on_change_callback=self.on_product_changed, delay_ms=1000)
        self.product_combo.pack(side="left", padx=2)
        
        # 产品显示开关
        self.show_product_details = tk.BooleanVar(value=True)
        product_toggle_cb = tk.Checkbutton(filter_row3, text="显示详细\nShow Details", 
                                          variable=self.show_product_details,
                                          command=self.toggle_product_display)
        product_toggle_cb.pack(side="left", padx=10)
        
        # 日均显示开关
        self.show_daily_average = tk.BooleanVar(value=False)
        daily_avg_cb = tk.Checkbutton(filter_row3, text="显示日均\nShow Daily Average", 
                                     variable=self.show_daily_average,
                                     command=self.toggle_daily_average)
        daily_avg_cb.pack(side="left", padx=10)
        
        # 单店平均开关
        self.show_store_average = tk.BooleanVar(value=False)
        store_avg_cb = tk.Checkbutton(filter_row3, text="单店平均\nPer Store Average", 
                                     variable=self.show_store_average,
                                     command=self.toggle_store_average)
        store_avg_cb.pack(side="left", padx=10)
        
        # 销售数据支付方式开关
        self.include_payment_sales = tk.BooleanVar(value=False)
        payment_sales_cb = tk.Checkbutton(filter_row3, text="包含支付方式\nInclude Payment", 
                                         variable=self.include_payment_sales,
                                         command=self.on_sales_payment_toggle)
        payment_sales_cb.pack(side="left", padx=10)
        
        # 搜索功能已集成到各个筛选框中
        
        # 设置左侧分析功能按钮面板
        self.setup_left_panel()
        
        # 設置右側活動面板 - 重新設計穩定架構
        self.setup_right_panel()
        
        # 创建notebook容器，用于更好的布局管理
        # 使用grid布局，确保完全填充剩余空间
        self.notebook_container = tk.Frame(self.main_frame)
        self.notebook_container.grid(row=1, column=0, sticky="nsew", padx=5, pady=(0, 0))
        
        # 创建主Notebook用于Sales和Product分类
        self.notebook = ttk.Notebook(self.notebook_container)
        self.notebook.pack(fill="both", expand=True, padx=0, pady=0)
        
        # 配置現代化標籤頁樣式
        style = ttk.Style()
        
        # 現代清新標籤頁樣式
        style.configure("Sales.TNotebook.Tab", 
                       background="#E3F2FD", 
                       foreground="#1976D2",
                       padding=(22, 14),
                       font=('Segoe UI', 11, 'bold'))
        
        style.configure("Product.TNotebook.Tab", 
                       background="#E8F5E8", 
                       foreground="#2E7D32",
                       padding=(22, 14),
                       font=('Segoe UI', 11, 'bold'))
        
        style.configure("Brand.TNotebook.Tab", 
                       background="#F3E5F5", 
                       foreground="#6A1B9A",
                       padding=(22, 14),
                       font=('Segoe UI', 11, 'bold'))
        
        style.configure("Log.TNotebook.Tab", 
                       background="#FFF3E0", 
                       foreground="#E65100",
                       padding=(22, 14),
                       font=('Segoe UI', 11, 'bold'))
        
        # 標籤頁狀態映射 - 純白活動狀態
        style.map("Sales.TNotebook.Tab",
                 background=[('selected', '#2196F3'), ('active', '#FFFFFF')],
                 foreground=[('selected', '#FFFFFF'), ('active', '#000000')])
        
        style.map("Product.TNotebook.Tab",
                 background=[('selected', '#4CAF50'), ('active', '#FFFFFF')],
                 foreground=[('selected', '#FFFFFF'), ('active', '#000000')])
        
        style.map("Brand.TNotebook.Tab",
                 background=[('selected', '#9C27B0'), ('active', '#FFFFFF')],
                 foreground=[('selected', '#FFFFFF'), ('active', '#000000')])
        
        style.map("Log.TNotebook.Tab",
                 background=[('selected', '#FF9800'), ('active', '#FFFFFF')],
                 foreground=[('selected', '#FFFFFF'), ('active', '#000000')])
        
        # Sales标签页
        self.sales_notebook = ttk.Notebook(self.notebook)
        self.notebook.add(self.sales_notebook, text="Sales\n销售分析")
        
        # Product标签页
        self.product_notebook = ttk.Notebook(self.notebook)
        self.notebook.add(self.product_notebook, text="Product\n产品分析")
        
        # Brand标签页
        self.brand_notebook = ttk.Notebook(self.notebook)
        self.notebook.add(self.brand_notebook, text="Brand\n品牌分析")
        
        # 每日细项子标签页
        self.brand_daily_frame = tk.Frame(self.brand_notebook)
        self.brand_notebook.add(self.brand_daily_frame, text="每日细项\nDaily Breakdown")
        
        # 期间汇总子标签页
        self.brand_period_frame = tk.Frame(self.brand_notebook)
        self.brand_notebook.add(self.brand_period_frame, text="期间汇总\nPeriod Summary")
        
        # 业绩对比标签页
        self.performance_comparison_frame = tk.Frame(self.brand_notebook)
        self.brand_notebook.add(self.performance_comparison_frame, text="业绩对比\nPerformance Comparison")
        
        # 类别分析标签页
        self.category_analysis_frame = tk.Frame(self.brand_notebook)
        self.brand_notebook.add(self.category_analysis_frame, text="类别分析\nCategory Analysis")
        
        # 业绩对比控制面板
        comparison_control_frame = tk.Frame(self.performance_comparison_frame)
        comparison_control_frame.pack(fill="x", padx=5, pady=5)
        
        # 对比方式选择
        tk.Label(comparison_control_frame, text="对比方式\nComparison Method:").pack(side="left", padx=5)
        self.comparison_method = tk.StringVar(value="date")
        ttk.Radiobutton(comparison_control_frame, text="对比日期\nCompare Date", variable=self.comparison_method, value="date").pack(side="left", padx=5)
        ttk.Radiobutton(comparison_control_frame, text="对比周期\nCompare Week", variable=self.comparison_method, value="week").pack(side="left", padx=5)
        
        # 对比日期范围选择
        tk.Label(comparison_control_frame, text="对比日期范围\nCompare Date Range:").pack(side="left", padx=(20, 5))
        self.comparison_date_from = DateEntry(comparison_control_frame, width=12, background='darkblue',
                                            foreground='white', borderwidth=2, date_pattern='dd/MM/yyyy')
        self.comparison_date_from.pack(side="left", padx=5)
        
        tk.Label(comparison_control_frame, text="到\nTo:").pack(side="left", padx=5)
        self.comparison_date_to = DateEntry(comparison_control_frame, width=12, background='darkblue',
                                          foreground='white', borderwidth=2, date_pattern='dd/MM/yyyy')
        self.comparison_date_to.pack(side="left", padx=5)
        
        # 对比周期选择 - 改为多选
        tk.Label(comparison_control_frame, text="对比周期\nCompare Week:").pack(side="left", padx=(20, 5))
        
        # 创建对比周期多选框
        self.comparison_week_combo = MultiSelectCombobox(comparison_control_frame, width=20, 
                                                        title="选择对比周期\nSelect Comparison Weeks")
        self.comparison_week_combo.pack(side="left", padx=5)
        
        # 设置对比周期选项
        comparison_week_options = ["当前周期", "上一周期", "上上周期", "上个月同期", "上个月上一周期", "上个月上上周期"]
        self.comparison_week_combo.set_values(comparison_week_options)
        # 设置默认选择
        self.comparison_week_combo.selected_values = ["上一周期"]
        self.comparison_week_combo.update_display()
        
        # 显示详细开关
        self.show_performance_details = tk.BooleanVar(value=True)
        tk.Checkbutton(comparison_control_frame, text="显示详细\nShow Details", 
                       variable=self.show_performance_details,
                       command=self.toggle_performance_details).pack(side="left", padx=(20, 5))
        
        # 执行按钮
        ttk.Button(comparison_control_frame, text="执行对比\nExecute Comparison", 
                  command=self.get_performance_comparison, style="Action.TButton").pack(side="left", padx=(20, 5))
        
        # 业绩对比表格
        comparison_tree_frame = tk.Frame(self.performance_comparison_frame)
        comparison_tree_frame.pack(fill="both", expand=True, pady=5)
        
        # 创建业绩对比表格
        comparison_columns = ("产品名称", "期间", "总业绩", "总单据", "平均单据", "产品业绩", "产品单据", "报废数量", "业绩占比%", "单据占比%")
        self.performance_comparison_tree = ttk.Treeview(comparison_tree_frame, columns=comparison_columns, show="headings", height=20)
        
        # 设置列标题
        for col in comparison_columns:
            self.performance_comparison_tree.heading(col, text=col, command=lambda c=col: self._sort_treeview_column(self.performance_comparison_tree, c))
            self.performance_comparison_tree.column(col, width=120, anchor="center")
        
        # 添加滚动条
        comparison_scrollbar = ttk.Scrollbar(comparison_tree_frame, orient="vertical", command=self.performance_comparison_tree.yview)
        self.performance_comparison_tree.configure(yscrollcommand=comparison_scrollbar.set)
        
        # 布局
        self.performance_comparison_tree.pack(side="left", fill="both", expand=True)
        comparison_scrollbar.pack(side="right", fill="y")
        
        
        # 每日细项表格
        daily_tree_frame = tk.Frame(self.brand_daily_frame)
        daily_tree_frame.pack(fill="both", expand=True, pady=5)
        
        self.brand_daily_tree = ttk.Treeview(daily_tree_frame, show="headings")
        daily_scrollbar_y = ttk.Scrollbar(daily_tree_frame, orient="vertical", command=self.brand_daily_tree.yview)
        daily_scrollbar_x = ttk.Scrollbar(daily_tree_frame, orient="horizontal", command=self.brand_daily_tree.xview)
        self.brand_daily_tree.configure(yscrollcommand=daily_scrollbar_y.set, xscrollcommand=daily_scrollbar_x.set)
        
        self.brand_daily_tree.pack(side="left", fill="both", expand=True)
        daily_scrollbar_y.pack(side="right", fill="y")
        daily_scrollbar_x.pack(side="bottom", fill="x")
        
        # 期间汇总表格和控制面板
        period_control_frame = tk.Frame(self.brand_period_frame)
        period_control_frame.pack(fill="x", padx=5, pady=5)
        
        # 显示日均开关 - 品牌期间汇总专用
        self.show_brand_daily_average = tk.BooleanVar(value=False)
        daily_avg_cb = tk.Checkbutton(period_control_frame, text="显示日均\nShow Daily Average", 
                                      variable=self.show_brand_daily_average,
                                      command=self.toggle_brand_daily_average)
        daily_avg_cb.pack(side="left", padx=10)
        
        period_tree_frame = tk.Frame(self.brand_period_frame)
        period_tree_frame.pack(fill="both", expand=True, pady=5)
        
        self.brand_period_tree = ttk.Treeview(period_tree_frame, show="headings")
        period_scrollbar_y = ttk.Scrollbar(period_tree_frame, orient="vertical", command=self.brand_period_tree.yview)
        period_scrollbar_x = ttk.Scrollbar(period_tree_frame, orient="horizontal", command=self.brand_period_tree.xview)
        self.brand_period_tree.configure(yscrollcommand=period_scrollbar_y.set, xscrollcommand=period_scrollbar_x.set)
        
        self.brand_period_tree.pack(side="left", fill="both", expand=True)
        period_scrollbar_y.pack(side="right", fill="y")
        period_scrollbar_x.pack(side="bottom", fill="x")
        
        # 日志信息标签页
        self.log_frame = tk.Frame(self.notebook)
        self.notebook.add(self.log_frame, text="日志信息\nLog Information")
        
        # 日志信息控制面板
        log_control_frame = tk.Frame(self.log_frame)
        log_control_frame.pack(fill="x", padx=5, pady=5)
        
        # 搜索功能
        log_search_frame = tk.Frame(log_control_frame)
        log_search_frame.pack(side="left", padx=5)
        
        tk.Label(log_search_frame, text="🔍 搜索:", font=('Microsoft YaHei UI', 9)).pack(side="left", padx=2)
        self.log_search_entry = ttk.Entry(log_search_frame, width=20, font=('Microsoft YaHei UI', 9))
        self.log_search_entry.pack(side="left", padx=2)
        self.log_search_entry.bind('<KeyRelease>', lambda e: self.realtime_search_log())
        
        # 搜索结果状态标签
        self.log_search_status = tk.Label(log_search_frame, text="", font=('Microsoft YaHei UI', 8), fg='blue')
        self.log_search_status.pack(side="left", padx=10)
        
        # 清空日志按钮
        clear_log_btn = ttk.Button(log_control_frame, text="清空日志", command=self.clear_output)
        clear_log_btn.pack(side="right", padx=5)
        
        # 应用颜色样式
        self.sales_notebook.configure(style="Sales.TNotebook")
        self.product_notebook.configure(style="Product.TNotebook")
        self.brand_notebook.configure(style="Brand.TNotebook")
        
        # 日志信息标签页内容
        self.info_text = tk.Text(self.log_frame, height=15, width=100)
        self.info_text.pack(fill="both", expand=True, pady=5)
        
        # 日志滚动条
        log_scrollbar = ttk.Scrollbar(self.log_frame, orient="vertical", command=self.info_text.yview)
        log_scrollbar.pack(side="right", fill="y")
        self.info_text.configure(yscrollcommand=log_scrollbar.set)
        
        # Sales子标签页
        # 销售数据标签页
        self.sales_frame = tk.Frame(self.sales_notebook)
        self.sales_notebook.add(self.sales_frame, text="销售数据\nSales Raw Data")
        
        # 销售数据控制面板
        sales_control_frame = tk.Frame(self.sales_frame)
        sales_control_frame.pack(fill="x", padx=5, pady=5)
        
        # 搜索功能
        sales_search_frame = tk.Frame(sales_control_frame)
        sales_search_frame.pack(side="left", padx=5)
        
        tk.Label(sales_search_frame, text="🔍 搜索:", font=('Microsoft YaHei UI', 9)).pack(side="left", padx=2)
        self.sales_search_entry = ttk.Entry(sales_search_frame, width=20, font=('Microsoft YaHei UI', 9))
        self.sales_search_entry.pack(side="left", padx=2)
        self.sales_search_entry.bind('<KeyRelease>', lambda e: self.realtime_search_sales())
        
        # 搜索结果状态标签
        self.sales_search_status = tk.Label(sales_search_frame, text="", font=('Microsoft YaHei UI', 8), fg='blue')
        self.sales_search_status.pack(side="left", padx=10)
        
        # 刷新按钮
        refresh_sales_btn = ttk.Button(sales_control_frame, text="🔄 刷新数据 / Refresh Data", 
                                     command=self.refresh_sales_data)
        refresh_sales_btn.pack(side="right", padx=5)
        
        # 销售数据Treeview
        self.sales_tree = ttk.Treeview(self.sales_frame, show="headings")
        self.sales_tree.pack(side="left", fill="both", expand=True)
        
        sales_scrollbar = ttk.Scrollbar(self.sales_frame, orient="vertical", command=self.sales_tree.yview)
        sales_scrollbar.pack(side="right", fill="y")
        self.sales_tree.configure(yscrollcommand=sales_scrollbar.set)
        
        # 支付分析标签页
        self.payment_frame = tk.Frame(self.sales_notebook)
        self.sales_notebook.add(self.payment_frame, text="支付方式分析\nPayment Analysis")
        
        # 支付分析控制面板
        payment_control_frame = tk.Frame(self.payment_frame)
        payment_control_frame.pack(fill="x", padx=5, pady=5)
        
        # 搜索功能
        payment_search_frame = tk.Frame(payment_control_frame)
        payment_search_frame.pack(side="left", padx=5)
        
        tk.Label(payment_search_frame, text="🔍 搜索:", font=('Microsoft YaHei UI', 9)).pack(side="left", padx=2)
        self.payment_search_entry = ttk.Entry(payment_search_frame, width=20, font=('Microsoft YaHei UI', 9))
        self.payment_search_entry.pack(side="left", padx=2)
        self.payment_search_entry.bind('<KeyRelease>', lambda e: self.realtime_search_payment())
        
        # 搜索结果状态标签
        self.payment_search_status = tk.Label(payment_search_frame, text="", font=('Microsoft YaHei UI', 8), fg='blue')
        self.payment_search_status.pack(side="left", padx=10)
        
        # 区间筛选控制
        tk.Label(payment_control_frame, text="单据金额区间筛选:").pack(side="left", padx=5)
        
        self.payment_min_amount = ttk.Entry(payment_control_frame, width=10)
        self.payment_min_amount.pack(side="left", padx=2)
        tk.Label(payment_control_frame, text="到").pack(side="left", padx=2)
        self.payment_max_amount = ttk.Entry(payment_control_frame, width=10)
        self.payment_max_amount.pack(side="left", padx=2)
        
        ttk.Button(payment_control_frame, text="应用筛选", command=self.apply_payment_amount_filter).pack(side="left", padx=10)
        ttk.Button(payment_control_frame, text="清除筛选", command=self.clear_payment_amount_filter).pack(side="left", padx=5)
        
        # 提示信息
        tk.Label(payment_control_frame, text="(留空表示无限制，例如：30 表示30以上，10-15 表示10到15之间)", 
                 font=("Arial", 8), foreground="gray").pack(side="left", padx=10)
        
        self.payment_tree = ttk.Treeview(self.payment_frame, show="headings")
        self.payment_tree.pack(side="left", fill="both", expand=True)
        
        payment_scrollbar = ttk.Scrollbar(self.payment_frame, orient="vertical", command=self.payment_tree.yview)
        payment_scrollbar.pack(side="right", fill="y")
        self.payment_tree.configure(yscrollcommand=payment_scrollbar.set)
        
        # 折扣分析标签页
        self.discount_frame = tk.Frame(self.sales_notebook)
        self.sales_notebook.add(self.discount_frame, text="折扣分析\nDiscount Analysis")
        
        # 折扣分析控制面板
        discount_control_frame = tk.Frame(self.discount_frame)
        discount_control_frame.pack(fill="x", padx=5, pady=5)
        
        # 搜索功能
        discount_search_frame = tk.Frame(discount_control_frame)
        discount_search_frame.pack(side="left", padx=5)
        
        tk.Label(discount_search_frame, text="🔍 搜索:", font=('Microsoft YaHei UI', 9)).pack(side="left", padx=2)
        self.discount_search_entry = ttk.Entry(discount_search_frame, width=20, font=('Microsoft YaHei UI', 9))
        self.discount_search_entry.pack(side="left", padx=2)
        self.discount_search_entry.bind('<KeyRelease>', lambda e: self.realtime_search_discount())
        
        # 搜索结果状态标签
        self.discount_search_status = tk.Label(discount_search_frame, text="", font=('Microsoft YaHei UI', 8), fg='blue')
        self.discount_search_status.pack(side="left", padx=10)
        
        self.discount_tree = ttk.Treeview(self.discount_frame, show="headings")
        self.discount_tree.pack(side="left", fill="both", expand=True)
        
        discount_scrollbar = ttk.Scrollbar(self.discount_frame, orient="vertical", command=self.discount_tree.yview)
        discount_scrollbar.pack(side="right", fill="y")
        self.discount_tree.configure(yscrollcommand=discount_scrollbar.set)
        
        # 月度汇总标签页
        self.monthly_frame = tk.Frame(self.sales_notebook)
        self.sales_notebook.add(self.monthly_frame, text="月 - 销售数据\nMonthly - Product Data")
        
        # 月度汇总控制面板
        monthly_control_frame = tk.Frame(self.monthly_frame)
        monthly_control_frame.pack(fill="x", padx=5, pady=5)
        
        # 搜索功能
        monthly_search_frame = tk.Frame(monthly_control_frame)
        monthly_search_frame.pack(side="left", padx=5)
        
        tk.Label(monthly_search_frame, text="🔍 搜索:", font=('Microsoft YaHei UI', 9)).pack(side="left", padx=2)
        self.monthly_search_entry = ttk.Entry(monthly_search_frame, width=20, font=('Microsoft YaHei UI', 9))
        self.monthly_search_entry.pack(side="left", padx=2)
        self.monthly_search_entry.bind('<KeyRelease>', lambda e: self.realtime_search_monthly())
        
        # 搜索结果状态标签
        self.monthly_search_status = tk.Label(monthly_search_frame, text="", font=('Microsoft YaHei UI', 8), fg='blue')
        self.monthly_search_status.pack(side="left", padx=10)
        
        self.monthly_tree = ttk.Treeview(self.monthly_frame, show="headings", selectmode="extended")
        self.monthly_tree.pack(side="left", fill="both", expand=True)
        
        monthly_scrollbar = ttk.Scrollbar(self.monthly_frame, orient="vertical", command=self.monthly_tree.yview)
        monthly_scrollbar.pack(side="right", fill="y")
        self.monthly_tree.configure(yscrollcommand=monthly_scrollbar.set)
        
        # 綁定選擇事件來更新選中產品的總計
        self.monthly_tree.bind("<<TreeviewSelect>>", self.on_monthly_product_selection_change)
        
        # 初始化選中產品列表
        self.selected_monthly_products = []
        
        # Product子标签页
        # 产品数据分析标签页
        self.product_overview_frame = tk.Frame(self.product_notebook)
        self.product_notebook.add(self.product_overview_frame, text="日 - 产品数据\nDaily Product Data")
        
        # 周期产品数据标签页
        self.weekly_product_frame = tk.Frame(self.product_notebook)
        self.product_notebook.add(self.weekly_product_frame, text="周 - 产品数据\nWeekly Product Data")
        
        # 期间产品数据标签页
        self.period_product_overview_frame = tk.Frame(self.product_notebook)
        self.product_notebook.add(self.period_product_overview_frame, text="期间 - 产品数据\nPeriod Product Data")
        
        # 期间产品数据控制面板
        period_control_frame = tk.Frame(self.period_product_overview_frame)
        period_control_frame.pack(fill="x", padx=5, pady=5)
        
        # 搜索功能
        period_search_frame = tk.Frame(period_control_frame)
        period_search_frame.pack(side="left", padx=5)
        
        tk.Label(period_search_frame, text="🔍 搜索:", font=('Microsoft YaHei UI', 9)).pack(side="left", padx=2)
        self.period_product_search_entry = ttk.Entry(period_search_frame, width=20, font=('Microsoft YaHei UI', 9))
        self.period_product_search_entry.pack(side="left", padx=2)
        self.period_product_search_entry.bind('<KeyRelease>', lambda e: self.realtime_search_period_product())
        
        # 搜索结果状态标签
        self.period_product_search_status = tk.Label(period_search_frame, text="", font=('Microsoft YaHei UI', 8), fg='blue')
        self.period_product_search_status.pack(side="left", padx=10)
        
        # 期间产品数据表格
        period_tree_frame = tk.Frame(self.period_product_overview_frame)
        period_tree_frame.pack(fill="both", expand=True, pady=5)
        
        self.period_product_tree = ttk.Treeview(period_tree_frame, show="headings", selectmode="extended")
        self.period_product_tree.pack(side="left", fill="both", expand=True)
        
        period_scrollbar = ttk.Scrollbar(period_tree_frame, orient="vertical", command=self.period_product_tree.yview)
        period_scrollbar.pack(side="right", fill="y")
        self.period_product_tree.configure(yscrollcommand=period_scrollbar.set)
        
        # 綁定選擇事件來更新選中產品的總計
        self.period_product_tree.bind("<<TreeviewSelect>>", self.on_period_product_selection_change)
        
        # 初始化選中產品列表
        self.selected_period_products = []
        
        # 日-产品分析标签页
        self.sales_tc_analysis_frame = tk.Frame(self.product_notebook)
        self.product_notebook.add(self.sales_tc_analysis_frame, text="日 - 产品分析\nDaily - Product Analysis")
        
        # 日-产品分析控制面板
        daily_analysis_control_frame = tk.Frame(self.sales_tc_analysis_frame)
        daily_analysis_control_frame.pack(fill="x", padx=5, pady=5)
        
        # 搜索功能
        daily_analysis_search_frame = tk.Frame(daily_analysis_control_frame)
        daily_analysis_search_frame.pack(side="left", padx=5)
        
        tk.Label(daily_analysis_search_frame, text="🔍 搜索:", font=('Microsoft YaHei UI', 9)).pack(side="left", padx=2)
        self.daily_analysis_search_entry = ttk.Entry(daily_analysis_search_frame, width=20, font=('Microsoft YaHei UI', 9))
        self.daily_analysis_search_entry.pack(side="left", padx=2)
        self.daily_analysis_search_entry.bind('<KeyRelease>', lambda e: self.realtime_search_daily_analysis())
        
        # 搜索结果状态标签
        self.daily_analysis_search_status = tk.Label(daily_analysis_search_frame, text="", font=('Microsoft YaHei UI', 8), fg='blue')
        self.daily_analysis_search_status.pack(side="left", padx=10)
        
        self.sales_tc_analysis_tree = ttk.Treeview(self.sales_tc_analysis_frame, show="headings")
        self.sales_tc_analysis_tree.pack(side="left", fill="both", expand=True)
        
        sales_tc_analysis_scrollbar = ttk.Scrollbar(self.sales_tc_analysis_frame, orient="vertical", command=self.sales_tc_analysis_tree.yview)
        sales_tc_analysis_scrollbar.pack(side="right", fill="y")
        self.sales_tc_analysis_tree.configure(yscrollcommand=sales_tc_analysis_scrollbar.set)
        
        # 月-产品分析标签页
        self.sales_tc_monthly_frame = tk.Frame(self.product_notebook)
        self.product_notebook.add(self.sales_tc_monthly_frame, text="月 - 产品分析\nMonthly - Product Analysis")
        
        # 月-产品分析控制面板
        monthly_analysis_control_frame = tk.Frame(self.sales_tc_monthly_frame)
        monthly_analysis_control_frame.pack(fill="x", padx=5, pady=5)
        
        # 搜索功能
        monthly_analysis_search_frame = tk.Frame(monthly_analysis_control_frame)
        monthly_analysis_search_frame.pack(side="left", padx=5)
        
        tk.Label(monthly_analysis_search_frame, text="🔍 搜索:", font=('Microsoft YaHei UI', 9)).pack(side="left", padx=2)
        self.monthly_analysis_search_entry = ttk.Entry(monthly_analysis_search_frame, width=20, font=('Microsoft YaHei UI', 9))
        self.monthly_analysis_search_entry.pack(side="left", padx=2)
        self.monthly_analysis_search_entry.bind('<KeyRelease>', lambda e: self.realtime_search_monthly_analysis())
        
        # 搜索结果状态标签
        self.monthly_analysis_search_status = tk.Label(monthly_analysis_search_frame, text="", font=('Microsoft YaHei UI', 8), fg='blue')
        self.monthly_analysis_search_status.pack(side="left", padx=10)
        
        self.sales_tc_monthly_tree = ttk.Treeview(self.sales_tc_monthly_frame, show="headings", selectmode="extended")
        self.sales_tc_monthly_tree.pack(side="left", fill="both", expand=True)
        
        sales_tc_monthly_scrollbar = ttk.Scrollbar(self.sales_tc_monthly_frame, orient="vertical", command=self.sales_tc_monthly_tree.yview)
        sales_tc_monthly_scrollbar.pack(side="right", fill="y")
        self.sales_tc_monthly_tree.configure(yscrollcommand=sales_tc_monthly_scrollbar.set)
        
        # 綁定選擇事件來更新選中產品的總計
        self.sales_tc_monthly_tree.bind("<<TreeviewSelect>>", self.on_monthly_analysis_selection_change)
        
        # 初始化選中產品列表
        self.selected_monthly_analysis_products = []
        
        # 产品关联分析标签页
        self.product_association_frame = tk.Frame(self.product_notebook)
        self.product_notebook.add(self.product_association_frame, text="产品关联分析\nProduct Association Analysis")
        
        # 产品关联分析控制面板
        association_control_frame = tk.Frame(self.product_association_frame)
        association_control_frame.pack(fill="x", padx=5, pady=5)
        
        # 搜索功能
        association_search_frame = tk.Frame(association_control_frame)
        association_search_frame.pack(side="left", padx=5)
        
        tk.Label(association_search_frame, text="🔍 搜索:", font=('Microsoft YaHei UI', 9)).pack(side="left", padx=2)
        self.association_search_entry = ttk.Entry(association_search_frame, width=20, font=('Microsoft YaHei UI', 9))
        self.association_search_entry.pack(side="left", padx=2)
        self.association_search_entry.bind('<KeyRelease>', lambda e: self.realtime_search_association())
        
        # 搜索结果状态标签
        self.association_search_status = tk.Label(association_search_frame, text="", font=('Microsoft YaHei UI', 8), fg='blue')
        self.association_search_status.pack(side="left", padx=10)
        
        # 产品关联分析表格
        association_tree_frame = tk.Frame(self.product_association_frame)
        association_tree_frame.pack(fill="both", expand=True, pady=5)
        
        # 创建产品关联分析表格
        columns = ("产品1", "产品2", "关联度", "共同销售次数", "产品1销售次数", "产品2销售次数")
        self.product_association_tree = ttk.Treeview(association_tree_frame, columns=columns, show="headings", height=20)
        
        # 周期产品数据控制面板
        weekly_control_frame = tk.Frame(self.weekly_product_frame)
        weekly_control_frame.pack(fill="x", padx=5, pady=5)
        
        # 搜索功能
        weekly_search_frame = tk.Frame(weekly_control_frame)
        weekly_search_frame.pack(side="left", padx=5)
        
        tk.Label(weekly_search_frame, text="🔍 搜索:", font=('Microsoft YaHei UI', 9)).pack(side="left", padx=2)
        self.weekly_product_search_entry = ttk.Entry(weekly_search_frame, width=20, font=('Microsoft YaHei UI', 9))
        self.weekly_product_search_entry.pack(side="left", padx=2)
        self.weekly_product_search_entry.bind('<KeyRelease>', lambda e: self.realtime_search_weekly_product())
        
        # 搜索结果状态标签
        self.weekly_product_search_status = tk.Label(weekly_search_frame, text="", font=('Microsoft YaHei UI', 8), fg='blue')
        self.weekly_product_search_status.pack(side="left", padx=10)
        
        # 周期产品数据表格
        weekly_tree_frame = tk.Frame(self.weekly_product_frame)
        weekly_tree_frame.pack(fill="both", expand=True, pady=5)
        
        # 创建周期产品数据表格
        columns = ("产品名称", "周数", "期间", "业绩", "产品单据数", "销售数量")
        self.weekly_product_tree = ttk.Treeview(weekly_tree_frame, columns=columns, show="headings", height=20, selectmode="extended")
        
        # 设置列标题
        for col in columns:
            self.weekly_product_tree.heading(col, text=col, command=lambda c=col: self._sort_treeview_column(self.weekly_product_tree, c))
            self.weekly_product_tree.column(col, width=120, anchor="center")
        
        # 綁定選擇事件來更新選中產品的總計
        self.weekly_product_tree.bind("<<TreeviewSelect>>", self.on_weekly_product_selection_change)
        
        # 初始化選中產品列表
        self.selected_weekly_products = []
        
        # 添加滚动条
        weekly_scrollbar = ttk.Scrollbar(weekly_tree_frame, orient="vertical", command=self.weekly_product_tree.yview)
        self.weekly_product_tree.configure(yscrollcommand=weekly_scrollbar.set)
        
        # 布局
        self.weekly_product_tree.pack(side="left", fill="both", expand=True)
        weekly_scrollbar.pack(side="right", fill="y")
        
        # 产品总览控制面板
        overview_control_frame = tk.Frame(self.product_overview_frame)
        overview_control_frame.pack(fill="x", padx=5, pady=5)
        
        # 显示日均开关
        self.show_product_daily_average = self.show_daily_average
        product_daily_avg_cb = tk.Checkbutton(overview_control_frame, text="显示日均\nShow Daily Average", 
                                              variable=self.show_product_daily_average,
                                              command=self.toggle_product_daily_average)
        product_daily_avg_cb.pack(side="left", padx=10)
        
        # 产品总览表格
        overview_tree_frame = tk.Frame(self.product_overview_frame)
        overview_tree_frame.pack(fill="both", expand=True, pady=5)
        
        self.product_overview_tree = ttk.Treeview(overview_tree_frame, show="headings", selectmode="extended")
        overview_scrollbar_y = ttk.Scrollbar(overview_tree_frame, orient="vertical", command=self.product_overview_tree.yview)
        overview_scrollbar_x = ttk.Scrollbar(overview_tree_frame, orient="horizontal", command=self.product_overview_tree.xview)
        self.product_overview_tree.configure(yscrollcommand=overview_scrollbar_y.set, xscrollcommand=overview_scrollbar_x.set)
        
        self.product_overview_tree.pack(side="left", fill="both", expand=True)
        
        # 綁定選擇事件來更新選中產品的總計
        self.product_overview_tree.bind("<<TreeviewSelect>>", self.on_daily_product_selection_change)
        
        # 初始化選中產品列表
        self.selected_daily_products = []
        overview_scrollbar_y.pack(side="right", fill="y")
        overview_scrollbar_x.pack(side="bottom", fill="x")
        
        self.product_association_tree = ttk.Treeview(self.product_association_frame, show="headings", selectmode="extended")
        self.product_association_tree.pack(side="left", fill="both", expand=True)
        
        # 綁定選擇事件來更新選中產品的總計
        self.product_association_tree.bind("<<TreeviewSelect>>", self.on_association_selection_change)
        
        # 初始化選中產品列表
        self.selected_association_products = []
        
        product_association_scrollbar = ttk.Scrollbar(self.product_association_frame, orient="vertical", command=self.product_association_tree.yview)
        product_association_scrollbar.pack(side="right", fill="y")
        self.product_association_tree.configure(yscrollcommand=product_association_scrollbar.set)
        
        # 类别分析控制面板
        category_analysis_control_frame = tk.Frame(self.category_analysis_frame)
        category_analysis_control_frame.pack(fill="x", padx=5, pady=5)
        
        # 搜索功能
        category_analysis_search_frame = tk.Frame(category_analysis_control_frame)
        category_analysis_search_frame.pack(side="left", padx=5)
        
        tk.Label(category_analysis_search_frame, text="🔍 搜索:", font=('Microsoft YaHei UI', 9)).pack(side="left", padx=2)
        self.category_analysis_search_entry = ttk.Entry(category_analysis_search_frame, width=20, font=('Microsoft YaHei UI', 9))
        self.category_analysis_search_entry.pack(side="left", padx=2)
        self.category_analysis_search_entry.bind('<KeyRelease>', lambda e: self.realtime_search_category_analysis())
        
        # 搜索结果状态标签
        self.category_analysis_search_status = tk.Label(category_analysis_search_frame, text="", font=('Microsoft YaHei UI', 8), fg='blue')
        self.category_analysis_search_status.pack(side="left", padx=10)
        
        # 类别分析表格
        self.category_analysis_tree = ttk.Treeview(self.category_analysis_frame, show="headings")
        self.category_analysis_tree.pack(side="left", fill="both", expand=True)
        
        category_analysis_scrollbar = ttk.Scrollbar(self.category_analysis_frame, orient="vertical", command=self.category_analysis_tree.yview)
        category_analysis_scrollbar.pack(side="right", fill="y")
        self.category_analysis_tree.configure(yscrollcommand=category_analysis_scrollbar.set)
        
        # 初始显示
        self.log_message("POS数据分析工具 - 增强版")
        self.log_message("请先点击'连接数据库'开始...")
    
    def log_message(self, message, include_db_info=False):
        """记录消息"""
        from datetime import datetime
        timestamp = datetime.now().strftime('%H:%M:%S')
        
        # 如果需要包含数据库信息且数据库已连接
        if include_db_info and hasattr(self, 'db_manager') and self.db_manager.connection:
            try:
                min_date, max_date, total_days = self.db_manager.get_database_date_range()
                if min_date and max_date:
                    # 格式化日期显示
                    min_date_str = min_date.strftime('%Y-%m-%d') if hasattr(min_date, 'strftime') else str(min_date)
                    max_date_str = max_date.strftime('%Y-%m-%d') if hasattr(max_date, 'strftime') else str(max_date)
                    db_info = f" | 数据库: {self.db_manager.current_database} | 数据范围: {min_date_str} 至 {max_date_str} | 共{total_days}天"
                    message = f"{message}{db_info}"
            except Exception as e:
                # 如果获取数据库信息失败，只显示基本消息
                pass
        
        self.info_text.insert(tk.END, f"[{timestamp}] {message}\n")
        self.info_text.see(tk.END)
        self.root.update()
    
    def clear_output(self):
        """清空输出"""
        self.info_text.delete(1.0, tk.END)
    
    def log_database_info(self):
        """显示数据库信息"""
        if hasattr(self, 'db_manager') and self.db_manager.connection:
            try:
                min_date, max_date, total_days = self.db_manager.get_database_date_range()
                if min_date and max_date:
                    # 格式化日期显示
                    min_date_str = min_date.strftime('%Y-%m-%d') if hasattr(min_date, 'strftime') else str(min_date)
                    max_date_str = max_date.strftime('%Y-%m-%d') if hasattr(max_date, 'strftime') else str(max_date)
                    self.log_message(f"📊 数据库信息: {self.db_manager.current_database} | 数据范围: {min_date_str} 至 {max_date_str} | 共{total_days}天")
                else:
                    self.log_message("📊 数据库信息: 无法获取数据日期范围")
            except Exception as e:
                self.log_message(f"📊 数据库信息获取失败: {e}")
        else:
            self.log_message("📊 数据库信息: 未连接到数据库")
    
    def show_performance_tips(self):
        """显示性能优化建议"""
        self.log_message("=== 数据库性能优化建议 ===")
        for tip in self.db_manager.performance_tips:
            self.log_message(tip)
        self.log_message("")
        self.log_message("=== 查询优化说明 ===")
        self.log_message("✓ 已添加 NOLOCK 提示减少锁等待")
        self.log_message("✓ 已添加 OPTION (RECOMPILE) 优化查询计划")
        self.log_message("✓ 已优化产品关联分析使用 CTE 和 INNER JOIN")
        self.log_message("✓ 已实现批量查询减少数据库往返次数")
        self.log_message("✓ 建议在数据库服务器上创建上述索引以进一步提升性能")
    
    def sort_treeview(self, tree, col, reverse=False):
        """对TreeView进行排序"""
        data = [(tree.set(child, col), child) for child in tree.get_children('')]
        
        # 尝试转换为数字进行排序
        try:
            data.sort(key=lambda x: float(x[0]) if x[0] else 0, reverse=reverse)
        except ValueError:
            # 如果无法转换为数字，则按字符串排序
            data.sort(key=lambda x: x[0], reverse=reverse)
        
        # 重新排列项目
        for index, (val, child) in enumerate(data):
            tree.move(child, '', index)
        
        # 切换排序方向
        tree.heading(col, command=lambda: self.sort_treeview(tree, col, not reverse))
    
    def toggle_all_outlets(self):
        """切换全部门市选择"""
        self.outlet_combo.toggle_all()
        self.outlet_combo.execute_callback_immediately()  # 立即执行回调
        self.log_message("切换门市选择状态")
    
    def toggle_all_months(self):
        """切换全部月份选择"""
        self.month_combo.toggle_all()
        self.month_combo.execute_callback_immediately()  # 立即执行回调
        self.log_message("切换月份选择状态")
    
    def toggle_all_weekdays(self):
        """切换全部星期选择"""
        self.weekday_combo.toggle_all()
        self.weekday_combo.execute_callback_immediately()  # 立即执行回调
        self.log_message("切换星期选择状态")
    
    def toggle_all_payments(self):
        """切换全部支付方式选择"""
        self.payment_combo.toggle_all()
        self.payment_combo.execute_callback_immediately()  # 立即执行回调
        self.log_message("切换支付方式选择状态")
    
    def toggle_all_categories(self):
        """切换全部类别选择"""
        self.category_combo.toggle_all()
        self.category_combo.execute_callback_immediately()  # 立即执行回调
        self.log_message("切换类别选择状态")
        # 更新产品列表
        self.update_products_by_category()
    
    def toggle_all_products(self):
        """切换全部产品选择"""
        self.product_combo.toggle_all()
        self.product_combo.execute_callback_immediately()  # 立即执行回调
        self.log_message("切换产品选择状态")
    
    def on_outlet_changed(self, selected_values):
        """门市选择改变时触发"""
        self.log_message(f"选择了 {len(selected_values)} 个门市")
        self.update_cascade_filters()
    
    def on_month_changed(self, selected_values):
        """月份选择改变时触发"""
        self.log_message(f"选择了 {len(selected_values)} 个月份")
        self.update_cascade_filters()
    
    def on_weekday_changed(self, selected_values):
        """星期选择改变时触发"""
        self.log_message(f"选择了 {len(selected_values)} 个星期")
        self.update_cascade_filters()
    
    def on_payment_changed(self, selected_values):
        """支付方式选择改变时触发"""
        self.log_message(f"选择了 {len(selected_values)} 种支付方式")
        self.update_cascade_filters()
    
    def on_category_changed(self, selected_values):
        """类别选择改变时触发"""
        self.log_message(f"选择了 {len(selected_values)} 个类别")
        self.update_products_by_category()
    
    def on_product_changed(self, selected_values):
        """产品选择改变时触发"""
        self.log_message(f"选择了 {len(selected_values)} 个产品")
    
    def update_cascade_filters(self):
        """更新级联筛选"""
        # 获取当前选择的筛选条件
        selected_outlets = self.outlet_combo.get_selected()
        selected_months = self.month_combo.get_selected()
        selected_payments = self.payment_combo.get_selected()
        
        # 根据支付方式更新类别列表
        self.update_categories_by_payment(selected_payments)
        
        # 根据门市、月份、支付方式更新产品列表
        self.update_products_by_filters(selected_outlets, selected_months, selected_payments)
    
    def update_categories_by_payment(self, payment_filters):
        """根据支付方式更新类别列表"""
        if not payment_filters or len(payment_filters) == 0:
            # 如果没有选择支付方式，加载所有类别
            self.load_all_categories()
        else:
            # 根据支付方式筛选类别
            db = self.selected_db.get()
            if not self.db_manager.connect(db):
                return
            
            try:
                categories = self.db_manager.get_categories_by_payment(payment_filters)
                self.category_combo.set_values(categories)
                self.log_message(f"根据支付方式筛选出 {len(categories)} 个类别")
            except Exception as e:
                self.log_message(f"✗ 筛选类别失败: {e}")
            finally:
                self.db_manager.disconnect()
    
    def update_products_by_filters(self, outlet_filters, month_filters, payment_filters):
        """根据筛选条件更新产品列表"""
        # 检查是否所有筛选条件都是空的（即选择"全部"）
        if (not outlet_filters or len(outlet_filters) == 0) and \
           (not month_filters or len(month_filters) == 0) and \
           (not payment_filters or len(payment_filters) == 0):
            # 如果没有筛选条件，加载所有产品
            self.load_all_products()
        else:
            # 根据筛选条件筛选产品
            db = self.selected_db.get()
            if not self.db_manager.connect(db):
                return
            
            try:
                products = self.db_manager.get_products_by_filters(outlet_filters, month_filters, payment_filters)
                # 保存当前选中的产品
                current_selected = self.product_combo.get_selected()
                self.product_combo.set_values(products)
                
                # 如果之前有选中的产品，尝试保持选择
                if current_selected:
                    # 过滤出仍然可用的产品
                    available_selected = [p for p in current_selected if p in products]
                    if available_selected:
                        self.product_combo.set_selected(available_selected)
                        self.log_message(f"根据筛选条件筛选出 {len(products)} 个产品，保持 {len(available_selected)} 个已选择的产品")
                    else:
                        self.log_message(f"根据筛选条件筛选出 {len(products)} 个产品，之前选择的产品不在筛选范围内")
                else:
                    self.log_message(f"根据筛选条件筛选出 {len(products)} 个产品")
            except Exception as e:
                self.log_message(f"✗ 筛选产品失败: {e}")
            finally:
                self.db_manager.disconnect()
    
    
    def on_outlet_changed_old(self, event=None):
        """当门市选择改变时自动应用筛选"""
        selected_outlets = self.outlet_combo.get_selected()
        if selected_outlets:
            self.log_message(f"自动筛选门市: {', '.join(selected_outlets)}")
            # 自动获取当前标签页的数据
            current_tab = self.notebook.index(self.notebook.select())
            if current_tab == 1:  # 销售数据
                self.get_sales_data()
            elif current_tab == 2:  # 支付分析
                self.get_payment_analysis()
            elif current_tab == 3:  # 折扣分析
                self.get_discount_analysis()
            elif current_tab == 4:  # 月度汇总
                self.get_monthly_summary()
    
    def update_products_by_category(self):
        """根据选中的类别更新产品列表"""
        selected_categories = self.category_combo.get_selected()
        if selected_categories and len(selected_categories) < len(self.category_combo.values):
            self.log_message(f"筛选类别: {', '.join(selected_categories)}")
            # 获取该类别下的产品
            self.load_products_by_category(selected_categories)
        else:
            # 如果选择全部，加载所有产品
            self.load_all_products()
    
    def load_products_by_category(self, categories):
        """根据类别加载产品列表"""
        if not categories:
            self.load_all_products()
            return
            
        db = self.selected_db.get()
        if not self.db_manager.connect(db):
            return
        
        try:
            cursor = self.db_manager.connection.cursor()
            # 构建IN条件
            placeholders = ','.join(['?' for _ in categories])
            cursor.execute(f"""
                SELECT DISTINCT s.item_name 
                FROM pos_sales_dtls s
                INNER JOIN (
                    SELECT item_name, category_code
                    FROM item_master im1
                    WHERE im1.m_date = (
                        SELECT MAX(m_date) 
                        FROM item_master im2 
                        WHERE im2.item_name = im1.item_name
                    )
                ) im ON s.item_name = im.item_name
                WHERE im.category_code IN ({placeholders})
                ORDER BY s.item_name
            """, categories)
            results = cursor.fetchall()
            products = [row[0] for row in results if row[0]]
            cursor.close()
            
            self.product_combo.set_values(products)
            self.log_message(f"✓ 加载了 {len(products)} 个{', '.join(categories)}类别的产品")
        except Exception as e:
            self.log_message(f"✗ 加载产品失败: {e}")
        finally:
            self.db_manager.disconnect()
    
    def load_all_products(self):
        """加载所有产品"""
        db = self.selected_db.get()
        if not self.db_manager.connect(db):
            return
        
        try:
            products = self.db_manager.get_products()
            if products:
                self.product_combo.set_values(products)
                # 清空选择，显示"全部"
                self.product_combo.set_selected([])
                self.log_message(f"✓ 加载了 {len(products)} 个产品，设置为全部选择")
        except Exception as e:
            self.log_message(f"✗ 加载产品失败: {e}")
        finally:
            self.db_manager.disconnect()
    
    def load_all_categories(self):
        """加载所有类别"""
        try:
            categories = self.db_manager.get_categories()
            self.category_combo.set_values(categories)
            self.log_message(f"✓ 加载了 {len(categories)} 个类别")
        except Exception as e:
            self.log_message(f"✗ 加载类别失败: {e}")
    
    
    def apply_filter(self):
        """应用筛选条件到当前标签页"""
        current_tab = self.notebook.index(self.notebook.select())
        self.log_message("应用筛选条件...")
        
        if current_tab == 1:  # 销售数据
            self.get_sales_data()
        elif current_tab == 2:  # 支付分析
            self.get_payment_analysis()
        elif current_tab == 3:  # 折扣分析
            self.get_discount_analysis()
        elif current_tab == 4:  # 月度汇总
            self.get_monthly_summary()
        elif current_tab == 5:  # 日-产品分析
            self.get_sales_tc_analysis()
        else:
            self.log_message("请先选择一个数据标签页")
    
    def setup_initial_layout(self):
        """设置初始布局"""
        # 初始化时不需要调用布局方法，notebook已经在setup_ui中正确设置了
        pass
    
    def connect_database(self):
        """连接数据库并加载选项"""
        # 獲取選中的選項鍵
        option_key = self.selected_db.get()
        print(f"DEBUG: connect_database() - option_key = '{option_key}'")
        
        # 獲取實際的數據庫名稱
        option_info = self.DATABASE_OPTIONS.get(option_key, {})
        actual_db_name = option_info.get('db', option_key)
        cn_name = option_info.get('cn', option_key)
        
        print(f"DEBUG: option_info = {option_info}")
        print(f"DEBUG: actual_db_name = '{actual_db_name}'")
        print(f"DEBUG: cn_name = '{cn_name}'")
        
        self.log_message(f"正在连接到 {cn_name}...")
        
        if not self.db_manager.connect(actual_db_name):
            self.log_message(f"✗ 无法连接到 {cn_name}")
            return
        
        self.log_message(f"✓ 连接成功", include_db_info=True)
        
        # 显示数据库详细信息
        self.log_database_info()
        
        # 加载门市列表
        self.log_message("正在加载门市列表...")
        outlets = self.db_manager.get_outlets()
        if outlets:
            self.outlet_combo.set_values(outlets)
            # 保存门市列表供活动记录窗口使用
            self.available_outlets = outlets
            self.log_message(f"✓ 加载了 {len(outlets)} 个门市")
            self.log_message(f"门市列表: {outlets[:5]}{'...' if len(outlets) > 5 else ''}")  # 显示前5个门市
        else:
            self.log_message("✗ 没有获取到门市数据")
        
        # 加载产品列表
        self.log_message("正在加载产品列表...")
        products = self.db_manager.get_products()
        if products:
            self.product_combo.set_values(products)
            self.log_message(f"✓ 加载了 {len(products)} 个产品")
        
        # 更新活動提醒
        try:
            self.update_activity_alerts()
        except Exception as e:
            print(f"更新活動提醒失敗: {e}")
        
        # 加载月份列表
        self.log_message("正在加载月份列表...")
        months = self.db_manager.get_months()
        if months:
            self.month_combo.set_values(months)
            self.log_message(f"✓ 加载了 {len(months)} 个月份")
        
        # 加载星期列表
        self.log_message("正在加载星期列表...")
        weekdays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
        self.weekday_combo.set_values(weekdays)
        self.log_message(f"✓ 加载了 {len(weekdays)} 个星期")
        
        # 加载类别列表
        self.log_message("正在加载类别列表...")
        categories = self.db_manager.get_categories()
        if categories:
            self.category_combo.set_values(categories)
            self.log_message(f"✓ 加载了 {len(categories)} 个类别")
        
        # 加载支付方式列表
        self.log_message("正在加载支付方式列表...")
        payment_names = self.db_manager.get_payment_names()
        if payment_names:
            self.payment_combo.set_values(payment_names)
            self.log_message(f"✓ 加载了 {len(payment_names)} 种支付方式")
        
        self.db_manager.disconnect()
    
    def get_sales_data(self):
        """获取销售数据 - 智能缓存版本"""
        # 验证日期范围
        if not self.validate_date_range():
            return
            
        # 優先本地：如果本地有按日或按月導出文件/SQLite，直接用（上方已有月度/單日導出優先邏輯）
        # 若走到這裡還需要SQL，才連線
        db = self.selected_db.get()
        self.log_message(f"當前選擇: {db}")
        
        # 获取筛选条件
        # 根据日期筛选开关决定是否使用日期筛选
        if self.use_date_filter.get():
            # DateEntry返回datetime对象，需要转换为字符串
            date_from = self.date_from.get_date().strftime('%Y-%m-%d') if self.date_from.get_date() else None
            date_to = self.date_to.get_date().strftime('%Y-%m-%d') if self.date_to.get_date() else None
            
            # 使用纯日期格式，不添加时间部分
            if date_from and date_to and date_from == date_to:
                self.log_message(f"ℹ 单日查询: {date_from}")
            elif date_to:
                self.log_message(f"ℹ 日期范围查询: {date_from} 到 {date_to}")
        else:
            # 不使用日期筛选，只使用月份筛选
            date_from = None
            date_to = None
            self.log_message("ℹ 未启用日期筛选，将使用月份筛选")
            
        # 优先检查已导出的数据文件
        current_database = self.db_manager.current_database
        current_include_payment = False
        
        # 将完整数据库名称转换为简化名称（用于文件查找）
        db_name_mapping = {
            'sushi_gogo_pos_live': 'GOGO',
            'sushi_express_pos_live': 'Express', 
            'sushi_plus_pos_live': 'PLUS'
        }
        simplified_db_name = db_name_mapping.get(current_database, current_database)
        
        export_dir = "new_staged_export_specific_data"
        exported_data_found = False
        
        # 检查是否有已导出的月度数据文件
        from datetime import datetime
        start_date = datetime.strptime(date_from, '%Y-%m-%d')
        end_date = datetime.strptime(date_to, '%Y-%m-%d')
        
        # 检查跨月查询或单月查询
        if start_date.month == end_date.month and start_date.year == end_date.year:
            # 单月查询
            self.log_message("📅 单月查询 - 使用已导出月度数据")
            month_str_dash = start_date.strftime('%Y-%m')  # 2025-09
            month_str_underscore = start_date.strftime('%Y_%m')  # 2025_09
            
            exported_monthly_file_dash = f"{export_dir}/{simplified_db_name}_sales_raw_{month_str_dash}.pkl.gz"
            exported_monthly_file_underscore = f"{export_dir}/{simplified_db_name}_sales_raw_{month_str_underscore}.pkl.gz"
            
            # 优先使用连字符格式（与您的导出文件匹配）
            exported_monthly_file = exported_monthly_file_dash if os.path.exists(exported_monthly_file_dash) else exported_monthly_file_underscore
            
            # 调试信息
            self.log_message(f"🔍 检查已导出月度文件:")
            self.log_message(f"   连字符格式: {exported_monthly_file_dash} - {'存在' if os.path.exists(exported_monthly_file_dash) else '不存在'}")
            self.log_message(f"   下划线格式: {exported_monthly_file_underscore} - {'存在' if os.path.exists(exported_monthly_file_underscore) else '不存在'}")
            self.log_message(f"   最终选择: {exported_monthly_file}")
            
            if os.path.exists(exported_monthly_file):
                self.log_message(f"📁 发现已导出月度数据: {exported_monthly_file}")
                try:
                    import gzip
                    import pickle
                    with gzip.open(exported_monthly_file, 'rb') as f:
                        monthly_data = pickle.load(f)
                    
                    # 从月度数据中筛选指定日期范围的数据
                    filtered_data = []
                    for record in monthly_data:
                        record_date = record.get('c_date', '')
                        if isinstance(record_date, str) and date_from <= record_date <= date_to:
                            filtered_data.append(record)
                        elif hasattr(record_date, 'date') and date_from <= str(record_date.date()) <= date_to:
                            filtered_data.append(record)
                    
                    if filtered_data:
                        self.log_message(f"✓ 从已导出月度数据获取 {len(filtered_data)} 条记录")
                        self.cached_sales_data = filtered_data
                        exported_data_found = True
                    else:
                        self.log_message(f"⚠️ 已导出月度数据中未找到 {date_from} 到 {date_to} 的数据")
                except Exception as e:
                    self.log_message(f"✗ 读取已导出月度数据失败: {e}")
        else:
            # 跨月查询 - 尝试合并多个月的已导出数据
            self.log_message(f"📅 跨月查询 ({start_date.strftime('%Y-%m')} 到 {end_date.strftime('%Y-%m')}) - 尝试合并已导出月度数据")
            
            all_filtered_data = []
            current_date = start_date
            
            while current_date <= end_date:
                month_str_dash = current_date.strftime('%Y-%m')  # 2025-09
                month_str_underscore = current_date.strftime('%Y_%m')  # 2025_09
                
                exported_monthly_file_dash = f"{export_dir}/{simplified_db_name}_sales_raw_{month_str_dash}.pkl.gz"
                exported_monthly_file_underscore = f"{export_dir}/{simplified_db_name}_sales_raw_{month_str_underscore}.pkl.gz"
                
                # 优先使用连字符格式
                exported_monthly_file = exported_monthly_file_dash if os.path.exists(exported_monthly_file_dash) else exported_monthly_file_underscore
                
                if os.path.exists(exported_monthly_file):
                    self.log_message(f"📁 读取 {current_date.strftime('%Y-%m')} 的已导出数据: {exported_monthly_file}")
                    try:
                        import gzip
                        import pickle
                        with gzip.open(exported_monthly_file, 'rb') as f:
                            monthly_data = pickle.load(f)
                        
                        # 从月度数据中筛选指定日期范围的数据
                        for record in monthly_data:
                            record_date = record.get('c_date', '')
                            if isinstance(record_date, str) and date_from <= record_date <= date_to:
                                all_filtered_data.append(record)
                            elif hasattr(record_date, 'date') and date_from <= str(record_date.date()) <= date_to:
                                all_filtered_data.append(record)
                        
                        self.log_message(f"✓ 从 {current_date.strftime('%Y-%m')} 获取 {len([r for r in monthly_data if date_from <= r.get('c_date', '') <= date_to])} 条记录")
                        
                    except Exception as e:
                        self.log_message(f"✗ 读取 {current_date.strftime('%Y-%m')} 数据失败: {e}")
                else:
                    self.log_message(f"⚠️ {current_date.strftime('%Y-%m')} 的已导出数据不存在")
                
                # 移动到下个月
                if current_date.month == 12:
                    current_date = current_date.replace(year=current_date.year + 1, month=1)
                else:
                    current_date = current_date.replace(month=current_date.month + 1)
            
            if all_filtered_data:
                self.log_message(f"✓ 跨月查询完成，总共获取 {len(all_filtered_data)} 条记录")
                self.cached_sales_data = all_filtered_data
                exported_data_found = True
            else:
                self.log_message("⚠️ 跨月查询未找到任何已导出数据")
        
        # 如果没有找到已导出数据，检查是否需要重新查询数据库
        if not exported_data_found:
            need_refresh = (
                len(self.cached_sales_data) == 0 or  # 没有缓存数据
                self.cache_date_range != (date_from, date_to) or  # 日期范围改变
                self.cache_database != current_database or  # 数据库改变
                False
            )
            
            if need_refresh:
                # 優先本地SQLite彙總
                local_sales = self.db_manager.get_local_sales_analysis(
                    date_from=date_from,
                    date_to=date_to,
                    outlet_filters=outlet_filters,
                    product_filters=product_filters,
                    month_filters=month_filters,
                    weekday_filters=weekday_filters,
                    category_filters=category_filters,
                    payment_filters=payment_filters,
                )
                if local_sales:
                    self.log_message("📦 使用本地SQLite銷售分析數據")
                    self.cached_sales_data = local_sales
                else:
                    self.log_message("ℹ 本地無銷售分析數據，回退到SQL Server")
                    # 連線並從SQL查
                    if not self.db_manager.connection:
                        self.db_manager.connect(db)
                    self.cached_sales_data = self.db_manager.get_sales_data(
                        date_from, date_to, [], [], None, [], [], [], []
                    )
            
            if self.cached_sales_data:
                self.log_message(f"✓ 数据库查询成功，共 {len(self.cached_sales_data)} 条记录")
                # 更新缓存信息
                self.cache_date_range = (date_from, date_to)
                self.cache_database = current_database
            else:
                self.log_message("✗ 数据库查询失败或没有数据")
                self.db_manager.disconnect()
                return
        else:
            self.log_message("⚡ 使用缓存数据，无需重新查询数据库")
        
        # 应用筛选条件
        self.log_message("🔍 正在应用筛选条件...")
        filtered_data = self.apply_filters_to_cached_data()
        
        if filtered_data:
            self.log_message(f"✓ 筛选完成，共 {len(filtered_data)} 条记录")
            self.sales_data = filtered_data
            self.display_sales_data()
        else:
            self.log_message("ℹ 筛选后没有符合条件的数据")
            self.sales_data = []
        
        self.db_manager.disconnect()
    
    def apply_filters_to_cached_data(self):
        """对缓存数据应用筛选条件"""
        if not self.cached_sales_data:
            return []
        
        filtered_data = self.cached_sales_data.copy()
        
        # 获取当前筛选条件
        outlet_filters = self.outlet_combo.get_selected()
        product_filters = self.product_combo.get_selected()
        month_filters = self.month_combo.get_selected()
        weekday_filters = self.weekday_combo.get_selected()
        category_filters = self.category_combo.get_selected()
        payment_filters = self.payment_combo.get_selected()

        # 保存门市筛选
        self.period_product_outlet_filters = [o for o in outlet_filters if o]

        # 保存门市筛选
        self.product_overview_outlet_filters = [o for o in outlet_filters if o]

        # 保存门店筛选用于单店平均计算
        self.period_product_outlet_filters = [o for o in outlet_filters if o]

        # 保存门店筛选用于单店平均计算
        self.product_overview_outlet_filters = [o for o in outlet_filters if o]
        
        self.log_message(f"ℹ 筛选条件 - 门市: {outlet_filters if outlet_filters else '全部'}")
        self.log_message(f"ℹ 筛选条件 - 产品: {product_filters if product_filters else '全部'}")
        self.log_message(f"ℹ 筛选条件 - 月份: {month_filters if month_filters else '全部'}")
        self.log_message(f"ℹ 筛选条件 - 星期: {weekday_filters if weekday_filters else '全部'}")
        self.log_message(f"ℹ 筛选条件 - 类别: {category_filters if category_filters else '全部'}")
        self.log_message(f"ℹ 筛选条件 - 支付方式: {payment_filters if payment_filters else '全部'}")
        
        # 应用门市筛选
        if outlet_filters:
            filtered_data = [record for record in filtered_data if record.get('store_name') in outlet_filters]
            self.log_message(f"✓ 门市筛选后: {len(filtered_data)} 条记录")
        
        # 应用产品筛选
        if product_filters:
            filtered_data = [record for record in filtered_data if record.get('item_name') in product_filters]
            self.log_message(f"✓ 产品筛选后: {len(filtered_data)} 条记录")
        
        # 应用月份筛选
        if month_filters:
            filtered_data = [record for record in filtered_data if record.get('month') in month_filters]
            self.log_message(f"✓ 月份筛选后: {len(filtered_data)} 条记录")
        
        # 应用星期筛选
        if weekday_filters:
            filtered_data = [record for record in filtered_data if record.get('weekday') in weekday_filters]
            self.log_message(f"✓ 星期筛选后: {len(filtered_data)} 条记录")
        
        # 应用类别筛选
        if category_filters:
            filtered_data = [record for record in filtered_data if record.get('category_code') in category_filters]
            self.log_message(f"✓ 类别筛选后: {len(filtered_data)} 条记录")
        
        # 应用支付方式筛选
        if payment_filters:
            filtered_data = [record for record in filtered_data if record.get('payment_method') in payment_filters]
            self.log_message(f"✓ 支付方式筛选后: {len(filtered_data)} 条记录")
        
        return filtered_data
    
    def clear_memory_cache(self):
        """清除内存缓存数据"""
        self.cached_sales_data = []
        self.cache_date_range = None
        self.cache_database = None
        self.log_message("🗑️ 内存缓存已清除，下次查询将重新获取数据")
    
    def on_sales_payment_toggle(self):
        """处理销售数据支付方式切换"""
        try:
            include_payment = self.include_payment_sales.get()
            self.log_message(f"🔄 销售数据支付方式切换: {'包含' if include_payment else '不包含'}")
            
            # 如果有现有数据，重新获取
            if hasattr(self, 'sales_data') and self.sales_data:
                self.log_message("📊 重新获取销售数据...")
                self.display_sales_data()
            else:
                self.log_message("ℹ 暂无销售数据，请先获取数据")
                
        except Exception as e:
            self.log_message(f"❌ 销售数据支付方式切换失败: {e}")
    
    def refresh_sales_data(self):
        """刷新销售数据"""
        try:
            self.log_message("🔄 刷新销售数据...")
            self.display_sales_data()
        except Exception as e:
            self.log_message(f"❌ 刷新销售数据失败: {e}")
    
    def display_sales_data(self):
        """显示销售数据"""
        # 清空TreeView
        for item in self.sales_tree.get_children():
            self.sales_tree.delete(item)
        
        # 设置列 - 根据支付方式选择动态调整
        include_payment = self.include_payment_sales.get()
        if include_payment:
            columns = ['门市\nOutlet', '单据号\nReceipt No', '产品名称\nProduct Name', '支付方式\nPayment Method', '类别\nCategory', '数量\nQuantity', '折扣金额\nDiscount Amount', '折扣名称\nDiscount Name', '促销折扣\nPromo Discount', '金额\nAmount', '服务费\nService Fee', '税费\nTax', '日期\nDate', '总金额\nTotal Amount']
        else:
            columns = ['门市\nOutlet', '单据号\nReceipt No', '产品名称\nProduct Name', '类别\nCategory', '数量\nQuantity', '折扣金额\nDiscount Amount', '折扣名称\nDiscount Name', '促销折扣\nPromo Discount', '金额\nAmount', '服务费\nService Fee', '税费\nTax', '日期\nDate', '总金额\nTotal Amount']
        
        self.sales_tree["columns"] = columns
        
        for col in columns:
            self.sales_tree.heading(col, text=col, command=lambda c=col: self.sort_treeview(self.sales_tree, c))
            self.sales_tree.column(col, width=100, anchor="center")
        
        # 確保表頭可見 - 強制顯示表頭
        self.sales_tree.configure(show='headings')
        
        # 设置行高以显示中英文标题
        style = ttk.Style()
        style.configure("Treeview", rowheight=25)  # 进一步缩小数据行高度到25像素
        style.configure("Treeview.Heading", font=('Arial', 9, 'bold'), height=80, background="#34495e", foreground="white", padding=(10, 8))  # 缩小字体但增加标题高度到80像素
        
        # 准备显示数据
        display_data = self.sales_data
        if self.show_daily_average.get() and self.sales_data:
            display_data = self.calculate_daily_average(self.sales_data)
        
        # 插入数据
        for data in display_data:
            # 根据开关状态决定是否显示详细数据
            if self.show_product_details.get():
                if include_payment:
                    # 包含支付方式的数据行
                    self.sales_tree.insert("", "end", values=(
                    data['store_name'],
                    data['sales_no'],
                    data['item_name'],
                    data['payment_methods'],
                    data['category_code'],
                    f"{data['qty']:.2f}",
                    format_currency(data['disc_amt']),
                    data['disc_name'],
                    format_currency(data['pro_disc_amt']),
                    format_currency(data['sub_total']),
                    format_currency(data['svc_amt']),
                    format_currency(data['tax_amt']),
                    str(data['c_date']),
                    format_currency(data['total_amt'])
                ))
                else:
                    # 不包含支付方式的数据行
                    self.sales_tree.insert("", "end", values=(
                        data['store_name'],
                        data['sales_no'],
                        data['item_name'],
                        data['category_code'],
                        f"{data['qty']:.2f}",
                        format_currency(data['disc_amt']),
                        data['disc_name'],
                        format_currency(data['pro_disc_amt']),
                        format_currency(data['sub_total']),
                        format_currency(data['svc_amt']),
                        format_currency(data['tax_amt']),
                        str(data['c_date']),
                        format_currency(data['total_amt'])
                    ))
        
        # 添加总计行
        if self.sales_data:
            # 计算各店总计
            store_totals = {}
            month_totals = {}
            grand_total_qty = 0.0
            grand_total_disc_amt = 0.0
            grand_total_pro_disc_amt = 0.0
            grand_total_sub_total = 0.0
            grand_total_svc_amt = 0.0
            grand_total_tax_amt = 0.0
            grand_total_amount = 0.0
            
            for data in self.sales_data:
                store = data['store_name']
                month = data['month']
                qty = data['qty']
                disc_amt = data['disc_amt']
                pro_disc_amt = data['pro_disc_amt']
                sub_total = data['sub_total']
                svc_amt = data['svc_amt']
                tax_amt = data['tax_amt']
                total_amt = data['total_amt']
                
                # 各店总计
                if store not in store_totals:
                    store_totals[store] = {
                        'qty': 0.0, 'disc_amt': 0.0, 'pro_disc_amt': 0.0, 
                        'sub_total': 0.0, 'svc_amt': 0.0, 'tax_amt': 0.0, 'total_amt': 0.0
                    }
                store_totals[store]['qty'] += qty
                store_totals[store]['disc_amt'] += disc_amt
                store_totals[store]['pro_disc_amt'] += pro_disc_amt
                store_totals[store]['sub_total'] += sub_total
                store_totals[store]['svc_amt'] += svc_amt
                store_totals[store]['tax_amt'] += tax_amt
                store_totals[store]['total_amt'] += total_amt
                
                # 月份总计
                if month not in month_totals:
                    month_totals[month] = {
                        'qty': 0.0, 'disc_amt': 0.0, 'pro_disc_amt': 0.0, 
                        'sub_total': 0.0, 'svc_amt': 0.0, 'tax_amt': 0.0, 'total_amt': 0.0
                    }
                month_totals[month]['qty'] += qty
                month_totals[month]['disc_amt'] += disc_amt
                month_totals[month]['pro_disc_amt'] += pro_disc_amt
                month_totals[month]['sub_total'] += sub_total
                month_totals[month]['svc_amt'] += svc_amt
                month_totals[month]['tax_amt'] += tax_amt
                month_totals[month]['total_amt'] += total_amt
                
                # 全总计
                grand_total_qty += qty
                grand_total_disc_amt += disc_amt
                grand_total_pro_disc_amt += pro_disc_amt
                grand_total_sub_total += sub_total
                grand_total_svc_amt += svc_amt
                grand_total_tax_amt += tax_amt
                grand_total_amount += total_amt
            
            # 添加各店总计
            for store, totals in store_totals.items():
                self.sales_tree.insert("", "end", values=(
                    f'【{store} 总计】',
                    '',
                    '',
                    '',
                    '',
                    f"{totals['qty']:.2f}",
                    format_currency(totals['disc_amt']),
                    '',
                    format_currency(totals['pro_disc_amt']),
                    format_currency(totals['sub_total']),
                    format_currency(totals['svc_amt']),
                    format_currency(totals['tax_amt']),
                    '',
                    format_currency(totals['total_amt'])
                ))
            
            # 添加月份总计
            for month, totals in month_totals.items():
                self.sales_tree.insert("", "end", values=(
                    f'【{month} 月份总计】',
                    '',
                    '',
                    '',
                    '',
                    f"{totals['qty']:.2f}",
                    format_currency(totals['disc_amt']),
                    '',
                    format_currency(totals['pro_disc_amt']),
                    format_currency(totals['sub_total']),
                    format_currency(totals['svc_amt']),
                    format_currency(totals['tax_amt']),
                    '',
                    format_currency(totals['total_amt'])
                ))
            
            # 添加全总计
            self.sales_tree.insert("", "end", values=(
                '【全总计】',
                '',
                '',
                '',
                '',
                f"{grand_total_qty:.2f}",
                format_currency(grand_total_disc_amt),
                '',
                format_currency(grand_total_pro_disc_amt),
                format_currency(grand_total_sub_total),
                format_currency(grand_total_svc_amt),
                format_currency(grand_total_tax_amt),
                '',
                format_currency(grand_total_amount)
            ))
        
        # 確保表頭可見 - 滾動到頂部
        self.sales_tree.update()
        self.sales_tree.yview_moveto(0)
        
        # 切换到销售数据标签页（如果活动记录窗口没有打开）
        if not (hasattr(self, 'activity_window') and self.activity_window.winfo_exists()):
            self.notebook.select(0)  # 选择Sales标签页
            self.sales_notebook.select(0)  # 选择销售数据子标签页
    
    def get_payment_analysis(self):
        """获取支付方式分析"""
        # 验证日期范围
        if not self.validate_date_range():
            return
            
        # 先连接数据库
        db = self.selected_db.get()
        self.log_message(f"正在连接到 {db}...")
        
        if not self.db_manager.connect(db):
            self.log_message(f"✗ 无法连接到 {db}")
            return
        
        self.log_message(f"✓ 连接成功", include_db_info=True)
        
        # 获取筛选条件
        # 根据日期筛选开关决定是否使用日期筛选
        if self.use_date_filter.get():
            # DateEntry返回datetime对象，需要转换为字符串
            date_from = self.date_from.get_date().strftime('%Y-%m-%d') if self.date_from.get_date() else None
            date_to = self.date_to.get_date().strftime('%Y-%m-%d') if self.date_to.get_date() else None
        else:
            # 不使用日期筛选，只使用月份筛选
            date_from = None
            date_to = None
            self.log_message("ℹ 未启用日期筛选，将使用月份筛选")
        
        # 使用纯日期格式，不添加时间部分
        if date_from and date_to and date_from == date_to:
            self.log_message(f"ℹ 单日查询: {date_from}")
        elif date_to:
            self.log_message(f"ℹ 日期范围查询: {date_from} 到 {date_to}")
        outlet_filters = self.outlet_combo.get_selected()
        month_filters = self.month_combo.get_selected()
        weekday_filters = self.weekday_combo.get_selected()
        print(f"GUI获取的星期筛选: {weekday_filters}")
        category_filters = self.category_combo.get_selected()
        payment_filters = self.payment_combo.get_selected()
        
        self.log_message("正在获取支付方式分析...")
        self.log_message(f"筛选条件 - 月份: {month_filters}, 支付方式: {payment_filters}, 门市: {outlet_filters}")
        self.payment_data = self.db_manager.get_payment_summary(
            date_from, date_to, outlet_filters, month_filters, category_filters, payment_filters
        )
        
        if self.payment_data:
            self.log_message(f"✓ 获取支付分析成功，共 {len(self.payment_data)} 条记录")
            self.display_payment_analysis()
        else:
            self.log_message("✗ 获取支付分析失败或没有数据")
        
        self.db_manager.disconnect()
    
    def get_payment_summary_filtered_by_amount(self, min_amount=None, max_amount=None):
        """获取按单据金额筛选的支付方式分析数据"""
        if not self.db_manager.connection:
            print("DEBUG: 在get_payment_summary_filtered_by_amount中数据库连接已断开，尝试重新连接")
            # 使用当前选择的数据库
            current_db = self.selected_db.get()
            print(f"DEBUG: 当前选择的数据库: {current_db}")
            self.db_manager.connect(current_db)
        
        if not self.db_manager.connection:
            print("DEBUG: 无法重新连接数据库")
            return []
        
        try:
            cursor = self.db_manager.connection.cursor()
            
            # 获取业绩计算SQL
            performance_sql = self.db_manager.get_performance_calculation_sql()
            
            # 先测试一下数据库中实际的单据金额分布
            test_query = f"""
                SELECT TOP 10 
                    s.sales_no,
                    s.store_name,
                    SUM({performance_sql}) as receipt_amount
                FROM {TABLE_SALES} s WITH (NOLOCK)
                LEFT JOIN item_master im WITH (NOLOCK) ON s.item_name = im.item_name
                WHERE s.item_name NOT LIKE '%WASTAGE%'
                    AND s.item_name NOT LIKE '%Waste%'
                    AND s.item_name NOT LIKE '%waste%'
                    AND s.item_name NOT LIKE '%WASTE%'
                GROUP BY s.sales_no, s.store_name
                ORDER BY receipt_amount DESC
            """
            
            print(f"DEBUG: 测试查询 - 查看实际单据金额:")
            print(f"DEBUG: 测试SQL: {test_query}")
            cursor.execute(test_query)
            test_results = cursor.fetchall()
            print(f"DEBUG: 测试结果数量: {len(test_results)}")
            for i, row in enumerate(test_results):
                print(f"DEBUG: 单据 {i+1}: {row[0]} - {row[1]} - 金额: {row[2]}")
            
            # 构建金额筛选条件
            amount_conditions = []
            if min_amount is not None:
                amount_conditions.append(f"SUM({performance_sql}) >= {min_amount}")
            if max_amount is not None:
                amount_conditions.append(f"SUM({performance_sql}) <= {max_amount}")
            
            amount_filter = ""
            if amount_conditions:
                amount_filter = " AND " + " AND ".join(amount_conditions)
            
            # 获取当前筛选的日期范围
            date_from = self.date_from.get_date().strftime('%Y-%m-%d')
            date_to = self.date_to.get_date().strftime('%Y-%m-%d')
            
            # 构建日期筛选条件
            date_conditions = []
            if date_from:
                date_conditions.append(f"s.c_date >= '{date_from} 00:00:00'")
            if date_to:
                date_conditions.append(f"s.c_date <= '{date_to} 23:59:59'")
            
            date_filter = ""
            if date_conditions:
                date_filter = " AND " + " AND ".join(date_conditions)
            
            # 查询符合单据金额条件的支付方式数据 - 简化版本
            query = f"""
                WITH ReceiptAmounts AS (
                    SELECT 
                        s.sales_no,
                        s.store_name,
                        FORMAT(s.c_date, 'yyyy-MM') as month_key,
                        SUM({performance_sql}) as receipt_amount
                    FROM {TABLE_SALES} s WITH (NOLOCK)
                    LEFT JOIN item_master im WITH (NOLOCK) ON s.item_name = im.item_name
                    WHERE s.item_name NOT LIKE '%WASTAGE%'
                        AND s.item_name NOT LIKE '%Waste%'
                        AND s.item_name NOT LIKE '%waste%'
                        AND s.item_name NOT LIKE '%WASTE%'
                        {date_filter}
                    GROUP BY s.sales_no, s.store_name, FORMAT(s.c_date, 'yyyy-MM')
                    HAVING 1=1 {amount_filter}
                )
                SELECT 
                    ra.store_name as 门市,
                    ra.month_key as 月份,
                    p.payment_name as 支付方式,
                    SUM(ra.receipt_amount) as 总金额,
                    COUNT(DISTINCT CONCAT(ra.store_name, '-', ra.sales_no)) as 使用次数,
                    AVG(ra.receipt_amount) as 平均金额
                FROM ReceiptAmounts ra
                INNER JOIN {TABLE_PAYMENT} p WITH (NOLOCK) ON ra.sales_no = p.sales_no AND ra.store_name = p.store_name
                GROUP BY ra.store_name, ra.month_key, p.payment_name
                ORDER BY ra.store_name, ra.month_key, p.payment_name
                OPTION (RECOMPILE, MAXDOP 4)
            """
            
            # 添加调试信息
            print(f"DEBUG: 支付筛选SQL查询:")
            print(f"DEBUG: 最小金额: {min_amount}, 最大金额: {max_amount}")
            print(f"DEBUG: 金额筛选条件: {amount_filter}")
            print(f"DEBUG: SQL查询: {query}")
            
            cursor.execute(query)
            results = cursor.fetchall()
            
            print(f"DEBUG: 查询结果数量: {len(results)}")
            if len(results) > 0:
                print(f"DEBUG: 第一条结果: {results[0]}")
            
            # 转换数据格式
            data = []
            store_totals = {}
            grand_totals = {}
            
            for row in results:
                try:
                    store_name = str(row[0]) if row[0] else ''
                    month = str(row[1]) if row[1] else ''
                    payment_method = str(row[2]) if row[2] else ''
                    total_amount = float(row[3]) if row[3] else 0.0
                    usage_count = int(row[4]) if row[4] else 0
                    avg_amount = float(row[5]) if row[5] else 0.0
                    
                    # 计算占比
                    store_month_key = f"{store_name}_{month}"
                    if store_month_key not in store_totals:
                        store_totals[store_month_key] = {'total_amount': 0.0, 'total_count': 0}
                    
                    store_totals[store_month_key]['total_amount'] += total_amount
                    store_totals[store_month_key]['total_count'] += usage_count
                    
                    # 累计全总计
                    if month not in grand_totals:
                        grand_totals[month] = {'total_amount': 0.0, 'total_count': 0}
                    grand_totals[month]['total_amount'] += total_amount
                    grand_totals[month]['total_count'] += usage_count
                    
                    data.append({
                        '门市': store_name,
                        '月份': month,
                        '支付方式': payment_method,
                        '总金额': total_amount,
                        '使用次数': usage_count,
                        '平均金额': avg_amount,
                        '该店次数占比(%)': 0.0,  # 稍后计算
                        '该店金额占比(%)': 0.0   # 稍后计算
                    })
                    
                except Exception as e:
                    continue
            
            # 计算占比并添加门店总计和全总计
            final_data = []
            
            # 按门店和月份分组处理数据
            from collections import defaultdict
            grouped_data = defaultdict(list)
            
            for row in data:
                store_month_key = f"{row['门市']}_{row['月份']}"
                store_total = store_totals.get(store_month_key, {'total_amount': 0.0, 'total_count': 0})
                
                row['该店次数占比(%)'] = (row['使用次数'] / store_total['total_count'] * 100) if store_total['total_count'] > 0 else 0.0
                row['该店金额占比(%)'] = (row['总金额'] / store_total['total_amount'] * 100) if store_total['total_amount'] > 0 else 0.0
                
                grouped_data[store_month_key].append(row)
            
            # 按门店和月份排序，并在每个门市组后添加总计
            for store_month_key in sorted(grouped_data.keys()):
                store_name, month = store_month_key.split('_', 1)
                store_data = grouped_data[store_month_key]
                
                # 添加该门市的详细数据
                final_data.extend(store_data)
                
                # 添加该门市的总计
                totals = store_totals.get(store_month_key, {'total_amount': 0.0, 'total_count': 0})
                final_data.append({
                    '门市': f'【{store_name} 总计】',
                    '月份': month,
                    '支付方式': 'ALL',
                    '总金额': totals['total_amount'],
                    '使用次数': totals['total_count'],
                    '平均金额': totals['total_amount'] / totals['total_count'] if totals['total_count'] > 0 else 0.0,
                    '该店次数占比(%)': 100.0,
                    '该店金额占比(%)': 100.0
                })
            
            # 最后添加全总计和付款方式汇总
            for month in sorted(grand_totals.keys()):
                totals = grand_totals[month]
                final_data.append({
                    '门市': '【全总计】',
                    '月份': month,
                    '支付方式': 'ALL',
                    '总金额': totals['total_amount'],
                    '使用次数': totals['total_count'],
                    '平均金额': totals['total_amount'] / totals['total_count'] if totals['total_count'] > 0 else 0.0,
                    '该店次数占比(%)': 100.0,
                    '该店金额占比(%)': 100.0
                })
            
            # 添加付款方式汇总 - 按付款方式分组汇总所有门市
            payment_method_totals = {}
            for row in data:
                payment_method = row['支付方式']
                if payment_method not in payment_method_totals:
                    payment_method_totals[payment_method] = {
                        '总金额': 0.0,
                        '使用次数': 0,
                        '门市数': set()
                    }
                
                payment_method_totals[payment_method]['总金额'] += row['总金额']
                payment_method_totals[payment_method]['使用次数'] += row['使用次数']
                payment_method_totals[payment_method]['门市数'].add(row['门市'])
            
            # 添加付款方式汇总行
            for payment_method in sorted(payment_method_totals.keys()):
                totals = payment_method_totals[payment_method]
                final_data.append({
                    '门市': '【付款方式汇总】',
                    '月份': '',
                    '支付方式': payment_method,
                    '总金额': totals['总金额'],
                    '使用次数': totals['使用次数'],
                    '平均金额': totals['总金额'] / totals['使用次数'] if totals['使用次数'] > 0 else 0.0,
                    '该店次数占比(%)': (totals['使用次数'] / sum(pm['使用次数'] for pm in payment_method_totals.values()) * 100) if sum(pm['使用次数'] for pm in payment_method_totals.values()) > 0 else 0.0,
                    '该店金额占比(%)': (totals['总金额'] / sum(pm['总金额'] for pm in payment_method_totals.values()) * 100) if sum(pm['总金额'] for pm in payment_method_totals.values()) > 0 else 0.0
                })
            
            cursor.close()
            return final_data
            
        except Exception as e:
            return []
    
    def apply_payment_amount_filter(self):
        """应用支付方式分析的金额区间筛选 - 筛选单据金额而不是总金额"""
        print(f"DEBUG: 开始应用支付筛选")
        print(f"DEBUG: 是否有payment_data属性: {hasattr(self, 'payment_data')}")
        if hasattr(self, 'payment_data'):
            print(f"DEBUG: payment_data是否为空: {not self.payment_data}")
        
        if not hasattr(self, 'payment_data') or not self.payment_data:
            self.log_message("✗ 请先获取支付方式分析数据")
            return
        
        # 确保有原始数据备份
        if not hasattr(self, 'original_payment_data'):
            self.original_payment_data = self.payment_data.copy()
            self.log_message("✓ 已备份原始支付分析数据")
        
        try:
            min_amount = None
            max_amount = None
            
            # 解析最小金额
            min_text = self.payment_min_amount.get().strip()
            if min_text:
                min_amount = float(min_text)
            
            # 解析最大金额
            max_text = self.payment_max_amount.get().strip()
            if max_text:
                max_amount = float(max_text)
            
            if min_amount is None and max_amount is None:
                # 没有筛选条件，显示原始数据
                self.display_payment_analysis_data(self.payment_data)
                self.log_message("✓ 已清除金额区间筛选")
                return
            
            # 先测试一下简单的金额查询
            print(f"DEBUG: 开始测试简单金额查询 - 最小: {min_amount}, 最大: {max_amount}")
            
            # 获取当前筛选的日期范围
            date_from = self.date_from.get_date().strftime('%Y-%m-%d')
            date_to = self.date_to.get_date().strftime('%Y-%m-%d')
            print(f"DEBUG: 当前日期范围: {date_from} 到 {date_to}")
            
            # 构建日期筛选条件
            date_conditions = []
            if date_from:
                date_conditions.append(f"s.c_date >= '{date_from} 00:00:00'")
            if date_to:
                date_conditions.append(f"s.c_date <= '{date_to} 23:59:59'")
            
            date_filter = ""
            if date_conditions:
                date_filter = " AND " + " AND ".join(date_conditions)
            
            test_simple_query = f"""
                SELECT TOP 5 
                    s.sales_no,
                    s.store_name,
                    SUM(CAST(s.sub_total as FLOAT) - CAST(ISNULL(s.pro_disc_amt, 0) as FLOAT) + CAST(ISNULL(s.svc_amt, 0) as FLOAT) - CAST(ISNULL(s.tax_amt, 0) as FLOAT)) as receipt_amount
                FROM pos_sales_dtls s WITH (NOLOCK)
                WHERE s.item_name NOT LIKE '%WASTAGE%'
                    {date_filter}
                GROUP BY s.sales_no, s.store_name
                HAVING SUM(CAST(s.sub_total as FLOAT) - CAST(ISNULL(s.pro_disc_amt, 0) as FLOAT) + CAST(ISNULL(s.svc_amt, 0) as FLOAT) - CAST(ISNULL(s.tax_amt, 0) as FLOAT)) BETWEEN {min_amount} AND {max_amount}
                ORDER BY receipt_amount DESC
            """
            print(f"DEBUG: 简单测试SQL: {test_simple_query}")
            
            # 检查数据库连接
            if not self.db_manager.connection:
                print("DEBUG: 数据库连接已断开，尝试重新连接")
                # 使用当前选择的数据库
                current_db = self.selected_db.get()
                print(f"DEBUG: 当前选择的数据库: {current_db}")
                self.db_manager.connect(current_db)
            
            if not self.db_manager.connection:
                print("DEBUG: 无法重新连接数据库")
                self.log_message("✗ 数据库连接失败")
                return
            
            cursor = self.db_manager.connection.cursor()
            cursor.execute(test_simple_query)
            simple_results = cursor.fetchall()
            print(f"DEBUG: 简单测试结果数量: {len(simple_results)}")
            for i, row in enumerate(simple_results):
                print(f"DEBUG: 简单测试单据 {i+1}: {row[0]} - {row[1]} - 金额: {row[2]}")
            cursor.close()
            
            # 重新查询符合单据金额条件的数据
            filtered_data = self.get_payment_summary_filtered_by_amount(min_amount, max_amount)
            
            # 显示筛选结果
            self.display_payment_analysis_data(filtered_data)
            
            self.log_message(f"✓ 应用单据金额区间筛选成功，显示 {len(filtered_data)} 条记录")
            
        except ValueError as e:
            self.log_message(f"✗ 金额输入格式错误: {e}")
        except Exception as e:
            self.log_message(f"✗ 应用筛选失败: {e}")
    
    def clear_payment_amount_filter(self):
        """清除支付方式分析的金额区间筛选"""
        self.payment_min_amount.delete(0, tk.END)
        self.payment_max_amount.delete(0, tk.END)
        
        # 恢复原始数据
        if hasattr(self, 'original_payment_data') and self.original_payment_data:
            self.payment_data = self.original_payment_data.copy()
            self.display_payment_analysis_data(self.payment_data)
            self.log_message("✓ 已清除金额区间筛选，恢复原始数据")
        elif hasattr(self, 'payment_data') and self.payment_data:
            self.display_payment_analysis_data(self.payment_data)
            self.log_message("✓ 已清除金额区间筛选")
    
    def display_payment_analysis(self):
        """显示支付方式分析"""
        self.display_payment_analysis_data(self.payment_data)
    
    def display_payment_analysis_data(self, data):
        """显示支付方式分析数据"""
        # 保存当前显示的数据，用于导出
        self.filtered_payment_data = data.copy() if data else []
        
        # 清空TreeView
        for item in self.payment_tree.get_children():
            self.payment_tree.delete(item)
        
        # 设置列
        columns = ['门市\nOutlet', '月份\nMonth', '支付方式\nPayment Method', '总金额\nTotal Amount', '单据数\nReceipt Count', '平均金额\nAverage Amount', '该店次数占比(%)\nStore Count Ratio(%)', '该店金额占比(%)\nStore Amount Ratio(%)']
        self.payment_tree["columns"] = columns
        
        for col in columns:
            self.payment_tree.heading(col, text=col, command=lambda c=col: self.sort_treeview(self.payment_tree, c))
            self.payment_tree.column(col, width=100, anchor="center")
        
        # 確保表頭可見 - 強制顯示表頭
        self.payment_tree.configure(show='headings')
        
        # 设置行高以显示中英文标题
        style = ttk.Style()
        style.configure("Treeview", rowheight=25)  # 进一步缩小数据行高度到25像素
        style.configure("Treeview.Heading", font=('Arial', 9, 'bold'), height=80, background="#34495e", foreground="white", padding=(10, 8))  # 缩小字体但增加标题高度到80像素
        
        # 配置颜色标签
        self.payment_tree.tag_configure("store_total", background="#E6F3FF", foreground="#000000")  # 门店总计 - 浅蓝色
        self.payment_tree.tag_configure("grand_total", background="#FFE6E6", foreground="#000000")  # 全总计 - 浅红色
        
        # 准备显示数据
        display_data = data
        if self.show_daily_average.get() and data:
            display_data = self.calculate_daily_average(data)
        
        # 插入数据
        for row_data in display_data:
            # 根据开关状态决定是否显示详细数据
            if self.show_product_details.get():
                # 判断行类型并设置标签
                if row_data['门市'].startswith('【') and '总计】' in row_data['门市'] and row_data['门市'] != '【全总计】':
                    tag = "store_total"  # 门店总计
                elif row_data['门市'] == '【全总计】':
                    tag = "grand_total"  # 全总计
                else:
                    tag = ""  # 普通数据行
                
                self.payment_tree.insert("", "end", values=(
                        row_data['门市'],
                        row_data['月份'],
                        row_data['支付方式'],
                        format_currency(row_data['总金额']),
                        format_number(row_data['使用次数']),
                        format_currency(row_data['平均金额']),
                        f"{row_data['该店次数占比(%)']:.2f}",
                        f"{row_data['该店金额占比(%)']:.2f}"
                    ), tags=(tag,))
            else:
                # 只显示总计行（门店总计和全总计）
                    if (row_data['门市'].startswith('【') and '总计】' in row_data['门市']) or row_data['门市'] == '【全总计】':
                        if row_data['门市'] == '【全总计】':
                            tag = "grand_total"  # 全总计
                        else:
                            tag = "store_total"  # 门店总计
                        
                        self.payment_tree.insert("", "end", values=(
                            row_data['门市'],
                            row_data['月份'],
                            row_data['支付方式'],
                            format_currency(row_data['总金额']),
                            format_number(row_data['使用次数']),
                            format_currency(row_data['平均金额']),
                            f"{row_data['该店次数占比(%)']:.2f}",
                            f"{row_data['该店金额占比(%)']:.2f}"
            ), tags=(tag,))
        
        # 確保表頭可見 - 滾動到頂部
        self.payment_tree.update()
        self.payment_tree.yview_moveto(0)
        
        # 切换到支付分析标签页（如果活动记录窗口没有打开）
        if not (hasattr(self, 'activity_window') and self.activity_window.winfo_exists()):
            self.notebook.select(0)  # 选择Sales标签页
            self.sales_notebook.select(1)  # 选择支付方式分析子标签页
    
    def get_discount_analysis(self):
        """获取折扣分析"""
        # 验证日期范围
        if not self.validate_date_range():
            return
            
        # 先连接数据库
        db = self.selected_db.get()
        self.log_message(f"正在连接到 {db}...")
        
        if not self.db_manager.connect(db):
            self.log_message(f"✗ 无法连接到 {db}")
            return
        
        self.log_message(f"✓ 连接成功", include_db_info=True)
        
        # 获取筛选条件
        # 根据日期筛选开关决定是否使用日期筛选
        if self.use_date_filter.get():
            # DateEntry返回datetime对象，需要转换为字符串
            date_from = self.date_from.get_date().strftime('%Y-%m-%d') if self.date_from.get_date() else None
            date_to = self.date_to.get_date().strftime('%Y-%m-%d') if self.date_to.get_date() else None
        else:
            # 不使用日期筛选，只使用月份筛选
            date_from = None
            date_to = None
            self.log_message("ℹ 未启用日期筛选，将使用月份筛选")
        
        # 使用纯日期格式，不添加时间部分
        if date_from and date_to and date_from == date_to:
            self.log_message(f"ℹ 单日查询: {date_from}")
        elif date_to:
            self.log_message(f"ℹ 日期范围查询: {date_from} 到 {date_to}")
        outlet_filters = self.outlet_combo.get_selected()
        month_filters = self.month_combo.get_selected()
        weekday_filters = self.weekday_combo.get_selected()
        print(f"GUI获取的星期筛选: {weekday_filters}")
        category_filters = self.category_combo.get_selected()
        payment_filters = self.payment_combo.get_selected()
        
        self.log_message("正在获取折扣分析...")
        self.discount_data = self.db_manager.get_discount_analysis(
            date_from, date_to, outlet_filters, month_filters, weekday_filters, category_filters, payment_filters
        )
        
        if self.discount_data:
            self.log_message(f"✓ 获取折扣分析成功，共 {len(self.discount_data)} 条记录")
            self.display_discount_analysis()
        else:
            self.log_message("✗ 获取折扣分析失败或没有数据")
        
        self.db_manager.disconnect()
    
    def display_discount_analysis(self):
        """显示折扣分析"""
        # 清空TreeView
        for item in self.discount_tree.get_children():
            self.discount_tree.delete(item)
        
        # 设置列
        columns = ['门市\nOutlet', '月份\nMonth', '折扣名称\nDiscount Name', '折扣金额\nDiscount Amount', '折扣占比(%)\nDiscount Ratio(%)', '折扣次数\nDiscount Count', '折扣次数占比(%)\nDiscount Count Ratio(%)', '全門市折扣總次數\nTotal Discount Count All Stores']
        self.discount_tree["columns"] = columns
        
        for col in columns:
            self.discount_tree.heading(col, text=col, command=lambda c=col: self.sort_treeview(self.discount_tree, c))
            self.discount_tree.column(col, width=100, anchor="center")
        
        # 设置行高以显示中英文标题
        style = ttk.Style()
        style.configure("Treeview", rowheight=25)  # 进一步缩小数据行高度到25像素
        style.configure("Treeview.Heading", font=('Arial', 9, 'bold'), height=80, background="#34495e", foreground="white", padding=(10, 8))  # 缩小字体但增加标题高度到80像素
        
        # 准备显示数据
        display_data = self.discount_data
        if self.show_daily_average.get() and self.discount_data:
            display_data = self.calculate_daily_average(self.discount_data)
        
        # 插入数据
        for data in display_data:
            # 根据开关状态决定是否显示详细数据
            if self.show_product_details.get():
                self.discount_tree.insert("", "end", values=(
                    data['门市'],
                    data['月份'],
                    data['折扣名称'],
                    format_currency(data['折扣金额']),
                    f"{data['折扣占比(%)']:.2f}",
                    format_number(data['折扣次数']),
                    f"{data['折扣次数占比(%)']:.2f}",
                    format_number(data.get('全門市折扣總次數', 0))
                ))
            else:
                # 只显示总计行（门店总计和全总计）
                if (data['门市'].startswith('【') and '总计】' in data['门市']) or data['门市'] == '【全总计】':
                    self.discount_tree.insert("", "end", values=(
                        data['门市'],
                        data['月份'],
                        data['折扣名称'],
                        format_currency(data['折扣金额']),
                        f"{data['折扣占比(%)']:.2f}",
                        format_number(data['折扣次数']),
                        f"{data['折扣次数占比(%)']:.2f}",
                        format_number(data.get('全門市折扣總次數', 0))
                    ))
        
        # 切换到折扣分析标签页（如果活动记录窗口没有打开）
        if not (hasattr(self, 'activity_window') and self.activity_window.winfo_exists()):
            self.notebook.select(0)  # 选择Sales标签页
            self.sales_notebook.select(2)  # 选择折扣分析子标签页
    
    def get_monthly_summary(self):
        """获取月度汇总"""
        # 验证日期范围
        if not self.validate_date_range():
            return
            
        # 先连接数据库
        db = self.selected_db.get()
        self.log_message(f"正在连接到 {db}...")
        
        if not self.db_manager.connect(db):
            self.log_message(f"✗ 无法连接到 {db}")
            return
        
        self.log_message(f"✓ 连接成功", include_db_info=True)
        
        # 获取筛选条件
        # 根据日期筛选开关决定是否使用日期筛选
        if self.use_date_filter.get():
            # DateEntry返回datetime对象，需要转换为字符串
            date_from = self.date_from.get_date().strftime('%Y-%m-%d') if self.date_from.get_date() else None
            date_to = self.date_to.get_date().strftime('%Y-%m-%d') if self.date_to.get_date() else None
        else:
            # 不使用日期筛选，只使用月份筛选
            date_from = None
            date_to = None
            self.log_message("ℹ 未启用日期筛选，将使用月份筛选")
        
        # 使用纯日期格式，不添加时间部分
        if date_from and date_to and date_from == date_to:
            self.log_message(f"ℹ 单日查询: {date_from}")
        elif date_to:
            self.log_message(f"ℹ 日期范围查询: {date_from} 到 {date_to}")
        outlet_filters = self.outlet_combo.get_selected()
        product_filters = self.product_combo.get_selected()
        month_filters = self.month_combo.get_selected()
        category_filters = self.category_combo.get_selected()
        payment_filters = self.payment_combo.get_selected()
        weekday_filters = self.weekday_combo.get_selected()
        
        self.log_message("正在获取月度汇总...")
        # 先用本地
        local_monthly = self.db_manager.get_monthly_summary_from_local(
            date_from=date_from, date_to=date_to, outlet_filters=outlet_filters
        )
        if local_monthly:
            self.log_message("📦 使用本地SQLite月度匯總數據")
            self.monthly_data = local_monthly
        else:
            self.log_message("ℹ 本地無月度匯總數據，回退到SQL Server")
            self.monthly_data = self.db_manager.get_monthly_summary_optimized(
                date_from, date_to, outlet_filters, product_filters, month_filters, category_filters, payment_filters
            )
        self.monthly_store_count = self.db_manager.get_unique_store_count(
            date_from=date_from,
            date_to=date_to,
            outlet_filters=outlet_filters,
            month_filters=month_filters,
            weekday_filters=weekday_filters,
            category_filters=category_filters,
            product_filters=product_filters,
            payment_filters=payment_filters
        ) or 1
        
        if self.monthly_data:
            self.log_message(f"✓ 获取月度汇总成功，共 {len(self.monthly_data)} 条记录")
            self.display_monthly_summary()
            
            # 切换到月度汇总标签页
            if not (hasattr(self, 'activity_window') and self.activity_window.winfo_exists()):
                self.notebook.select(0)  # 选择Sales标签页
                self.sales_notebook.select(3)  # 选择月度汇总子标签页
        else:
            self.log_message("✗ 获取月度汇总失败或没有数据")
        
        self.db_manager.disconnect()
    
    def display_monthly_summary(self):
        """显示月度汇总"""
        # 清空TreeView
        for item in self.monthly_tree.get_children():
            self.monthly_tree.delete(item)
        
        # 设置列
        columns = ['月份\nMonth', '门市\nOutlet', '类别\nCategory', '产品\nProduct', '卖出量\nQuantity Sold', '金额\nAmount', '总金额\nTotal Amount', '单据数\nReceipt Count', '产品单据业绩\nProduct Receipt Performance', '金额占比(%)\nAmount Ratio(%)', '单据占比(%)\nReceipt Ratio(%)', '产品单据业绩占比(%)\nProduct Receipt Performance Ratio(%)']
        self.monthly_tree["columns"] = columns
        
        for col in columns:
            self.monthly_tree.heading(col, text=col, command=lambda c=col: self.sort_treeview(self.monthly_tree, c))
            self.monthly_tree.column(col, width=120, anchor="center")
        
        # 设置行高以显示中英文标题
        style = ttk.Style()
        style.configure("Treeview", rowheight=25)  # 进一步缩小数据行高度到25像素
        style.configure("Treeview.Heading", font=('Arial', 9, 'bold'), height=80, background="#34495e", foreground="white", padding=(10, 8))  # 缩小字体但增加标题高度到80像素
        
        # 配置颜色标签
        self.monthly_tree.tag_configure("store_total", background="#E6F3FF", foreground="#000000")  # 门店总计 - 浅蓝色
        self.monthly_tree.tag_configure("month_total", background="#E6FFE6", foreground="#000000")  # 月份总计 - 浅绿色
        self.monthly_tree.tag_configure("grand_total", background="#FFE6E6", foreground="#000000")  # 全总计 - 浅红色
        
        # 准备显示数据
        display_data = self.monthly_data
        if self.show_daily_average.get() and self.monthly_data:
            display_data = self.calculate_daily_average(self.monthly_data)
        
        # 重新组织数据，按月份和门店分组
        monthly_grouped = {}
        month_totals = {}  # 存储每个月份的总计
        grand_total = {'qty': 0.0, 'amount': 0.0, 'total_amount': 0.0, 'receipt_count': 0}
        
        for data in display_data:
            # 跳过已经是总计行的数据
            if data['月份'].startswith('【') and ('总计】' in data['月份'] or '月份总计】' in data['月份']):
                continue

            month = data['月份']
            store = data['门市']

            if month not in monthly_grouped:
                monthly_grouped[month] = {}
            if store not in monthly_grouped[month]:
                monthly_grouped[month][store] = []

            monthly_grouped[month][store].append(data)

            # 计算月份总计（始终使用原始数据，即 self.monthly_data）
            if month not in month_totals:
                month_totals[month] = {'qty': 0.0, 'amount': 0.0, 'total_amount': 0.0, 'receipt_count': 0}
            month_totals[month]['qty'] += data['卖出量']
            month_totals[month]['amount'] += data['金额']
            month_totals[month]['total_amount'] += data['总金额']
            month_totals[month]['receipt_count'] += data['单据数']

            # 计算全总计（同样使用原始数据）
            grand_total['qty'] += data['卖出量']
            grand_total['amount'] += data['金额']
            grand_total['total_amount'] += data['总金额']
            grand_total['receipt_count'] += data['单据数']
        
        # 按月份和门店顺序插入数据
        for month in sorted(monthly_grouped.keys()):
            for store in sorted(monthly_grouped[month].keys()):
                # 插入该门店的详细数据
                for data in monthly_grouped[month][store]:
                    if self.show_product_details.get():
                        self.monthly_tree.insert("", "end", values=(
                            data['月份'],
                            data['门市'],
                            data['类别'],
                            data['产品'],
                            f"{data['卖出量']:.2f}",
                            format_currency(data['金额']),
                            format_currency(data['总金额']),
                            format_number(data['单据数']),
                            format_currency(data.get('产品单据业绩', 0)),
                            f"{data['金额占比(%)']:.2f}",
                            f"{data['单据占比(%)']:.2f}",
                            f"{data.get('产品单据业绩占比(%)', 0):.2f}"
                        ))
                
                # 计算该门店当月的总计（只计算当月，不是累计）
                store_month_total = {'qty': 0.0, 'amount': 0.0, 'total_amount': 0.0, 'receipt_count': 0}
                for data in monthly_grouped[month][store]:
                    store_month_total['qty'] += data['卖出量']
                    store_month_total['amount'] += data['金额']
                    store_month_total['total_amount'] += data['总金额']
                    store_month_total['receipt_count'] += data['单据数']
                
                # 插入该门店当月的总计
                self.monthly_tree.insert("", "end", values=(
                    month,
                    f'【{store} 总计】',
                    '',
                    '',
                    f"{store_month_total['qty']:.2f}",
                    format_currency(store_month_total['amount']),
                    format_currency(store_month_total['total_amount']),
                    format_number(store_month_total['receipt_count']),
                    '',
                    '',
                    '',
                    ''
                ), tags=("store_total",))
            
            # 插入该月份的总计
            month_total = month_totals[month]
            self.monthly_tree.insert("", "end", values=(
                f'【{month} 月份总计】',
                '',
                '',
                '',
                f"{month_total['qty']:.2f}",
                format_currency(month_total['amount']),
                format_currency(month_total['total_amount']),
                format_number(month_total['receipt_count']),
                '',
                '',
                '',
                ''
            ), tags=("month_total",))
        
        # 插入全总计
            self.monthly_tree.insert("", "end", values=(
                '【全总计】',
                '',
                '',
                '',
                f"{grand_total['qty']:.2f}",
                format_currency(grand_total['amount']),
                format_currency(grand_total['total_amount']),
                format_number(grand_total['receipt_count']),
                '',
                '',
                '',
                ''
            ), tags=("grand_total",))
            
            # 添加選中產品總計行（初始為空）
            self.update_monthly_selected_products_summary()
        
        # 切换到月度汇总标签页（如果活动记录窗口没有打开）
        if not (hasattr(self, 'activity_window') and self.activity_window.winfo_exists()):
            self.notebook.select(0)  # 选择Sales标签页
            self.sales_notebook.select(3)  # 选择月度汇总子标签页
    
    def get_sales_analysis(self):
        """获取Sales分析"""
        # 验证日期范围
        if not self.validate_date_range():
            return
            
        # 先连接数据库
        db = self.selected_db.get()
        if not self.db_manager.connect(db):
            self.log_message("✗ 数据库连接失败")
            return
        
        # 获取筛选条件
        if self.use_date_filter.get():
            # DateEntry返回datetime对象，需要转换为字符串
            date_from = self.date_from.get_date().strftime('%Y-%m-%d') if self.date_from.get_date() else None
            date_to = self.date_to.get_date().strftime('%Y-%m-%d') if self.date_to.get_date() else None
            
            # 使用纯日期格式，不添加时间部分
            if date_from and date_to and date_from == date_to:
                self.log_message(f"ℹ 单日查询: {date_from}")
            elif date_to:
                self.log_message(f"ℹ 日期范围查询: {date_from} 到 {date_to}")
        else:
            # 不使用日期筛选，只使用月份筛选
            date_from = None
            date_to = None
            self.log_message("ℹ 未启用日期筛选，将使用月份筛选")
            
        outlet_filters = self.outlet_combo.get_selected()
        month_filters = self.month_combo.get_selected()
        weekday_filters = self.weekday_combo.get_selected()
        print(f"GUI获取的星期筛选: {weekday_filters}")
        category_filters = self.category_combo.get_selected()
        payment_filters = self.payment_combo.get_selected()
        
        self.log_message("正在获取Sales分析...")
        self.sales_analysis_data = self.db_manager.get_sales_analysis(
            date_from, date_to, outlet_filters, month_filters, weekday_filters, category_filters, payment_filters
        )
        
        if self.sales_analysis_data:
            self.log_message(f"✓ 获取Sales分析成功，共 {len(self.sales_analysis_data)} 条记录")
            self.display_sales_analysis()
        else:
            self.log_message("✗ 获取Sales分析失败或没有数据")
        
        self.db_manager.disconnect()
    
    def display_sales_analysis(self):
        """显示Sales分析"""
        # 清空TreeView
        for item in self.sales_analysis_tree.get_children():
            self.sales_analysis_tree.delete(item)
        
        # 设置列
        columns = ("日期", "门市", "总业绩", "单据数")
        self.sales_analysis_tree["columns"] = columns
        self.sales_analysis_tree["show"] = "headings"
        
        # 设置列标题
        for col in columns:
            self.sales_analysis_tree.heading(col, text=col)
            self.sales_analysis_tree.column(col, width=120, anchor="center")
        
        # 插入数据
        for data in self.sales_analysis_data:
            self.sales_analysis_tree.insert("", "end", values=(
                data['日期'],
                data['门市'],
                f"${data['总业绩']:,.2f}",
                data['单据数']
            ))
        
        # 计算总计
        total_amount = sum(data['总业绩'] for data in self.sales_analysis_data)
        
        # 修復總單據數計算：重新查詢唯一單據數而不是加總各行
        total_receipts = 0
        if self.sales_analysis_data:
            # 重新查詢正確的唯一單據數
            try:
                if hasattr(self, 'db_manager') and self.db_manager.connection:
                    cursor = self.db_manager.connection.cursor()
                    
                    # 使用相同的條件但只計算唯一單據數
                    date_from = self.date_from.get_date().strftime('%Y-%m-%d') if self.date_from.get_date() else None
                    date_to = self.date_to.get_date().strftime('%Y-%m-%d') if self.date_to.get_date() else None
                    outlet_filters = self.outlet_combo.get_selected()
                    month_filters = self.month_combo.get_selected()
                    weekday_filters = self.weekday_combo.get_selected()
                    category_filters = self.category_combo.get_selected()
                    payment_filters = self.payment_combo.get_selected()
                    
                    # 簡化的唯一單據數查詢（不用支付方式篩選來避免重複計算）
                    conditions = []
                    if date_from:
                        conditions.append(f"CAST(s.c_date AS DATE) >= '{date_from}'")
                    if date_to:
                        conditions.append(f"CAST(s.c_date AS DATE) <= '{date_to}'")
                    if outlet_filters and len(outlet_filters) > 0:
                        outlet_conditions = " OR ".join([f"s.store_name = '{outlet}'" for outlet in outlet_filters])
                        conditions.append(f"({outlet_conditions})")
                    if month_filters and len(month_filters) > 0:
                        month_conditions = " OR ".join([f"FORMAT(CAST(s.c_date AS DATE), 'yyyy-MM') = '{month}'" for month in month_filters])
                        conditions.append(f"({month_conditions})")
                    if category_filters and len(category_filters) > 0:
                        category_conditions = " OR ".join([f"s.item_category = '{category}'" for category in category_filters])
                        conditions.append(f"({category_conditions})")
                    
                    conditions.append("s.item_name NOT IN ('WASTAGE', 'Waste', 'waste', 'WASTE')")
                    
                    where_clause = ""
                    if conditions:
                        where_clause = " WHERE " + " AND ".join(conditions)
                    
                    unique_query = f"""
                        SELECT COUNT(DISTINCT CONCAT(s.store_name, '-', s.sales_no)) as unique_receipt_count
                        FROM pos_sales_dtls s
                        {where_clause}
                        AND s.item_name != 'WASTAGE'
                    """
                    
                    cursor.execute(unique_query)
                    result = cursor.fetchone()
                    total_receipts = result[0] if result else 0
                    cursor.close()
                else:
                    # 如果無法重新查詢，就加總各行（儘管不準確）
                    total_receipts = sum(data['单据数'] for data in self.sales_analysis_data)
            except:
                # 如果失敗，就加總各行各用的單據數
                total_receipts = sum(data['单据数'] for data in self.sales_analysis_data)
        
        # 插入总计行
        self.sales_analysis_tree.insert("", "end", values=(
            "【总计】",
            "",
            f"${total_amount:,.2f}",
            total_receipts
        ), tags=("total",))
        
        # 设置总计行样式
        self.sales_analysis_tree.tag_configure("total", background="lightblue", font=("Arial", 10, "bold"))
        
        # 切换到Sales分析标签页（如果活动记录窗口没有打开）
        # 注释掉自动跳转，避免搜索时意外跳转
        # if not (hasattr(self, 'activity_window') and self.activity_window.winfo_exists()):
        #     # # self.notebook.select(1)  # 选择Product标签页 - 已禁用，避免跳转 - 已禁用，避免跳转
        #     self.product_notebook.select(0)  # 选择日-产品分析子标签页
    
    def get_tc_analysis(self):
        """获取TC分析"""
        # 验证日期范围
        if not self.validate_date_range():
            return
            
        # 先连接数据库
        db = self.selected_db.get()
        if not self.db_manager.connect(db):
            self.log_message("✗ 数据库连接失败")
            return
        
        # 获取筛选条件
        if self.use_date_filter.get():
            # DateEntry返回datetime对象，需要转换为字符串
            date_from = self.date_from.get_date().strftime('%Y-%m-%d') if self.date_from.get_date() else None
            date_to = self.date_to.get_date().strftime('%Y-%m-%d') if self.date_to.get_date() else None
            
            # 使用纯日期格式，不添加时间部分
            if date_from and date_to and date_from == date_to:
                self.log_message(f"ℹ 单日查询: {date_from}")
            elif date_to:
                self.log_message(f"ℹ 日期范围查询: {date_from} 到 {date_to}")
        else:
            # 不使用日期筛选，只使用月份筛选
            date_from = None
            date_to = None
            self.log_message("ℹ 未启用日期筛选，将使用月份筛选")
            
        outlet_filters = self.outlet_combo.get_selected()
        product_filters = self.product_combo.get_selected()
        month_filters = self.month_combo.get_selected()
        weekday_filters = self.weekday_combo.get_selected()
        category_filters = self.category_combo.get_selected()
        payment_filters = self.payment_combo.get_selected()
        
        self.log_message("正在获取TC分析...")
        self.tc_analysis_data = self.db_manager.get_tc_analysis(
            date_from, date_to, outlet_filters, product_filters, month_filters, weekday_filters, category_filters, payment_filters
        )
        
        if self.tc_analysis_data:
            self.log_message(f"✓ 获取TC分析成功，共 {len(self.tc_analysis_data)} 条记录")
            self.display_tc_analysis()
        else:
            self.log_message("✗ 获取TC分析失败或没有数据")
        
        self.db_manager.disconnect()
    
    def display_tc_analysis(self):
        """显示TC分析"""
        # 清空TreeView
        for item in self.tc_analysis_tree.get_children():
            self.tc_analysis_tree.delete(item)
        
        # 设置列
        columns = ("门市", "总业绩", "总单据数", "产品业绩", "产品单据数", "业绩占比(%)", "单据数占比(%)")
        self.tc_analysis_tree["columns"] = columns
        self.tc_analysis_tree["show"] = "headings"
        
        # 设置列标题
        for col in columns:
            self.tc_analysis_tree.heading(col, text=col)
            self.tc_analysis_tree.column(col, width=120, anchor="center")
        
        # 插入数据
        for data in self.tc_analysis_data:
            self.tc_analysis_tree.insert("", "end", values=(
                data['门市'],
                f"${data['总业绩']:,.2f}",
                data['总单据数'],
                f"${data['产品业绩']:,.2f}",
                data['产品单据数'],
                f"{data['业绩占比(%)']:.2f}",
                f"{data['单据数占比(%)']:.2f}"
            ))
        
        # 计算总计
        total_amount = sum(data['总业绩'] for data in self.tc_analysis_data)
        total_product_amount = sum(data['产品业绩'] for data in self.tc_analysis_data)
        total_product_receipts = sum(data['产品单据数'] for data in self.tc_analysis_data)
        
        # 修復總單據數計算：重新查詢而不是加總各行
        total_receipts = 0
        if self.tc_analysis_data:
            try:
                # 重新計算正確的唯一單據數（使用與TC分析相同的條件）
                if hasattr(self, 'db_manager') and self.db_manager.connection:
                    cursor = self.db_manager.connection.cursor()
                    
                    # 使用與TC分析相同的條件
                    date_from = self.date_from.get_date().strftime('%Y-%m-%d') if self.date_from.get_date() else None
                    date_to = self.date_to.get_date().strftime('%Y-%m-%d') if self.date_to.get_date() else None
                    outlet_filters = self.outlet_combo.get_selected()
                    product_filters = self.product_combo.get_selected()
                    month_filters = self.month_combo.get_selected()
                    weekday_filters = self.weekday_combo.get_selected()
                    category_filters = self.category_combo.get_selected()
                    payment_filters = self.payment_combo.get_selected()
                    
                    conditions = []
                    if date_from:
                        conditions.append(f"CAST(s.c_date AS DATE) >= '{date_from}'")
                    if date_to:
                        conditions.append(f"CAST(s.c_date AS DATE) <= '{date_to}'")
                    if outlet_filters and len(outlet_filters) > 0:
                        outlet_conditions = " OR ".join([f"s.store_name = '{outlet}'" for outlet in outlet_filters])
                        conditions.append(f"({outlet_conditions})")
                    if product_filters and len(product_filters) > 0:
                        product_conditions = " OR ".join([f"s.item_name = '{product}'" for product in product_filters])
                        conditions.append(f"({product_conditions})")
                    if month_filters and len(month_filters) > 0:
                        month_conditions = " OR ".join([f"FORMAT(CAST(s.c_date AS DATE), 'yyyy-MM') = '{month}'" for month in month_filters])
                        conditions.append(f"({month_conditions})")
                    if category_filters and len(category_filters) > 0:
                        category_conditions = " OR ".join([f"s.item_category = '{category}'" for category in category_filters])
                        conditions.append(f"({category_conditions})")
                    
                    conditions.append("s.item_name NOT IN ('WASTAGE', 'Waste', 'waste', 'WASTE')")
                    
                    where_clause = ""
                    if conditions:
                        where_clause = " WHERE " + " AND ".join(conditions)
                    
                    unique_query = f"""
                        SELECT COUNT(DISTINCT CONCAT(s.store_name, '-', s.sales_no)) as unique_receipt_count
                        FROM pos_sales_dtls s
                        {where_clause}
                        AND s.item_name != 'WASTAGE'
                    """
                    
                    cursor.execute(unique_query)
                    result = cursor.fetchone()
                    total_receipts = result[0] if result else 0
                    cursor.close()
                else:
                    total_receipts = sum(data['总单据数'] for data in self.tc_analysis_data)
            except:
                total_receipts = sum(data['总单据数'] for data in self.tc_analysis_data)
        
        # 计算总占比
        total_amount_percentage = (total_product_amount / total_amount * 100) if total_amount > 0 else 0.0
        total_receipt_percentage = (total_product_receipts / total_receipts * 100) if total_receipts > 0 else 0.0
        
        # 插入总计行
        self.tc_analysis_tree.insert("", "end", values=(
            "【总计】",
            f"${total_amount:,.2f}",
            total_receipts,
            f"${total_product_amount:,.2f}",
            total_product_receipts,
            f"{total_amount_percentage:.2f}",
            f"{total_receipt_percentage:.2f}"
        ), tags=("total",))
        
        # 设置总计行样式
        self.tc_analysis_tree.tag_configure("total", background="lightblue", font=("Arial", 10, "bold"))
        
        # 切换到日-产品分析标签页（如果活动记录窗口没有打开）
        # 注释掉自动跳转，避免搜索时意外跳转
        # if not (hasattr(self, 'activity_window') and self.activity_window.winfo_exists()):
        #     # # self.notebook.select(1)  # 选择Product标签页 - 已禁用，避免跳转 - 已禁用，避免跳转
        #     self.product_notebook.select(0)  # 选择日-产品分析子标签页
    
    def get_sales_tc_analysis(self):
        """获取日-产品分析 - 合并Sales和TC分析"""
        try:
            # 验证日期范围
            if not self.validate_date_range():
                return
                
            # 先连接数据库
            db = self.selected_db.get()
            print(f"🔍 尝试连接数据库: {db}")
            if not self.db_manager.connect(db):
                self.log_message("✗ 数据库连接失败")
                print(f"❌ 数据库连接失败: {db}")
                return
            
            # 测试数据库连接
            try:
                cursor = self.db_manager.connection.cursor()
                cursor.execute("SELECT COUNT(*) FROM pos_sales_dtls")
                result = cursor.fetchone()
                print(f"✅ 数据库连接成功，pos_sales_dtls表记录数: {result[0] if result else 0}")
                cursor.close()
            except Exception as e:
                print(f"❌ 数据库连接测试失败: {e}")
                self.log_message(f"✗ 数据库连接测试失败: {e}")
                return
            
            # 获取筛选条件
            if self.use_date_filter.get():
                # DateEntry返回datetime对象，需要转换为字符串
                date_from = self.date_from.get_date().strftime('%Y-%m-%d') if self.date_from.get_date() else None
                date_to = self.date_to.get_date().strftime('%Y-%m-%d') if self.date_to.get_date() else None
                
                # 使用纯日期格式，不添加时间部分
                if date_from and date_to and date_from == date_to:
                    self.log_message(f"ℹ 单日查询: {date_from}")
                elif date_to:
                    self.log_message(f"ℹ 日期范围查询: {date_from} 到 {date_to}")
            else:
                # 不使用日期筛选，使用当前月份
                from datetime import datetime, timedelta
                now = datetime.now()
                current_month = now.strftime('%Y-%m')
                date_from = f"{current_month}-01"
                # 计算当前月的最后一天
                if now.month == 12:
                    next_month = datetime(now.year + 1, 1, 1)
                else:
                    next_month = datetime(now.year, now.month + 1, 1)
                last_day = next_month - timedelta(days=1)
                date_to = last_day.strftime('%Y-%m-%d')
                self.log_message(f"ℹ 未启用日期筛选，使用当前月份: {date_from} 到 {date_to}")
            
            outlet_filters = self.outlet_combo.get_selected()
            product_filters = self.product_combo.get_selected()
            month_filters = self.month_combo.get_selected()
            weekday_filters = self.weekday_combo.get_selected()
            category_filters = self.category_combo.get_selected()
            payment_filters = self.payment_combo.get_selected()
            
            self.log_message("正在获取日-产品分析...")
            print(f"DEBUG: 调用 get_sales_tc_analysis，参数: date_from={date_from}, date_to={date_to}")
            print(f"DEBUG: 筛选条件: outlet_filters={outlet_filters}, product_filters={product_filters}, month_filters={month_filters}, weekday_filters={weekday_filters}, category_filters={category_filters}, payment_filters={payment_filters}")
            
            # 清理缓存以确保获取最新数据
            if hasattr(self.db_manager, '_sales_tc_cache'):
                self.db_manager._sales_tc_cache.clear()
                print("DEBUG: 已清理日-产品分析缓存")
            
            # 对于销售TC分析，总业绩和总单据数应该包含所有产品，产品业绩和产品单据数只包含选中的产品
            # 所以我们需要传递空的产品筛选给总业绩计算，但保留产品筛选给产品业绩计算
            self.sales_tc_analysis_data = self.db_manager.get_sales_tc_analysis(
                date_from, date_to, outlet_filters, product_filters, month_filters, weekday_filters, category_filters, payment_filters
            )
            print(f"DEBUG: get_sales_tc_analysis 返回结果: {len(self.sales_tc_analysis_data) if self.sales_tc_analysis_data else 0} 条记录")
            
            if self.sales_tc_analysis_data:
                self.log_message(f"✓ 获取日-产品分析成功，共 {len(self.sales_tc_analysis_data)} 条记录")
                self.display_sales_tc_analysis()
            else:
                self.log_message("✗ 获取日-产品分析失败或没有数据")
            
            self.db_manager.disconnect()
            
        except Exception as e:
            import traceback
            error_details = traceback.format_exc()
            self.log_message(f"✗ 获取日-产品分析失败: {e}")
            self.log_message(f"错误详情: {error_details}")
            print(f"GUI日-产品分析异常: {e}")
            print(f"错误详情: {error_details}")
    
    def display_sales_tc_analysis(self):
        """显示日-产品分析"""
        # 清空TreeView
        for item in self.sales_tc_analysis_tree.get_children():
            self.sales_tc_analysis_tree.delete(item)
        
        # 设置列
        columns = ("日期\nDate", "门市\nOutlet", "总业绩\nTotal Performance", "总单据数\nTotal Receipt Count", "总销售数量\nTotal Quantity", "产品业绩\nProduct Performance", "产品单据数\nProduct Receipt Count", "产品销售数量\nProduct Quantity", "产品单据业绩\nProduct Receipt Performance", "业绩占比(%)\nPerformance Ratio(%)", "单据数占比(%)\nReceipt Count Ratio(%)", "销售数量占比(%)\nQuantity Ratio(%)", "产品单据业绩占比(%)\nProduct Receipt Performance Ratio(%)")
        self.sales_tc_analysis_tree["columns"] = columns
        self.sales_tc_analysis_tree["show"] = "headings"
        
        # 设置列标题
        for col in columns:
            self.sales_tc_analysis_tree.heading(col, text=col)
            self.sales_tc_analysis_tree.column(col, width=120, anchor="center")
        
        # 设置行高以显示中英文标题
        style = ttk.Style()
        style.configure("Treeview", rowheight=25)  # 进一步缩小数据行高度到25像素
        style.configure("Treeview.Heading", font=('Arial', 9, 'bold'), height=80, background="#34495e", foreground="white", padding=(10, 8))  # 缩小字体但增加标题高度到80像素
        
        # 配置每日加总行的颜色
        self.sales_tc_analysis_tree.tag_configure("daily_total", background="#E6F3FF", foreground="#000000")  # 浅蓝色
        
        # 按日期分组数据并添加每日加总
        daily_data = {}
        for data in self.sales_tc_analysis_data:
            date = data['日期']
            if date not in daily_data:
                daily_data[date] = []
            daily_data[date].append(data)
        
        # 插入数据，按日期分组并添加每日加总
        for date in sorted(daily_data.keys()):
            date_data = daily_data[date]
            
            # 根据开关状态决定是否显示详细数据
            if self.show_product_details.get():
                # 插入该日期的所有门店数据
                for data in date_data:
                    self.sales_tc_analysis_tree.insert("", "end", values=(
                        data['日期'],
                        data['门市'],
                        format_currency(data['总业绩']),
                        format_number(data['总单据数']),
                        format_number(data['总销售数量']),
                        format_currency(data['产品业绩']),
                        format_number(data['产品单据数']),
                        format_number(data['产品销售数量']),
                        format_currency(data.get('产品单据业绩', 0)),
                        f"{data['业绩占比(%)']:.2f}",
                        f"{data['单据数占比(%)']:.2f}",
                        f"{data['销售数量占比(%)']:.2f}",
                        f"{data.get('产品单据业绩占比(%)', 0):.2f}"
                    ))
            
            # 计算该日期的加总
            daily_total_amount = sum(data['总业绩'] for data in date_data)
            daily_total_receipts = sum(data['总单据数'] for data in date_data)
            daily_total_quantity = sum(data['总销售数量'] for data in date_data)
            daily_product_amount = sum(data['产品业绩'] for data in date_data)
            daily_product_receipts = sum(data['产品单据数'] for data in date_data)
            daily_product_quantity = sum(data['产品销售数量'] for data in date_data)
            daily_product_receipt_performance = sum(data.get('产品单据业绩', 0) for data in date_data)
            daily_amount_percentage = (daily_product_amount / daily_total_amount * 100) if daily_total_amount > 0 else 0.0
            daily_receipt_percentage = (daily_product_receipts / daily_total_receipts * 100) if daily_total_receipts > 0 else 0.0
            daily_quantity_percentage = (daily_product_quantity / daily_total_quantity * 100) if daily_total_quantity > 0 else 0.0
            daily_product_receipt_performance_percentage = (daily_product_receipt_performance / daily_total_amount * 100) if daily_total_amount > 0 else 0.0
            
            # 插入该日期的加总行
            self.sales_tc_analysis_tree.insert("", "end", values=(
                f"【{date} 总计】",
                "",
                format_currency(daily_total_amount),
                format_number(daily_total_receipts),
                format_number(daily_total_quantity),
                format_currency(daily_product_amount),
                format_number(daily_product_receipts),
                format_number(daily_product_quantity),
                format_currency(daily_product_receipt_performance),
                f"{daily_amount_percentage:.2f}",
                f"{daily_receipt_percentage:.2f}",
                f"{daily_quantity_percentage:.2f}",
                f"{daily_product_receipt_performance_percentage:.2f}"
            ), tags=("daily_total",))
        
        # 计算总计
        total_amount = sum(data['总业绩'] for data in self.sales_tc_analysis_data)
        total_quantity = sum(data['总销售数量'] for data in self.sales_tc_analysis_data)
        total_product_amount = sum(data['产品业绩'] for data in self.sales_tc_analysis_data)
        total_product_receipts = sum(data['产品单据数'] for data in self.sales_tc_analysis_data)
        total_product_quantity = sum(data['产品销售数量'] for data in self.sales_tc_analysis_data)
        total_product_receipt_performance = sum(data.get('产品单据业绩', 0) for data in self.sales_tc_analysis_data)
        
        # 修復總單據數計算：重新查詢而不是加總各行
        total_receipts = 0
        if self.sales_tc_analysis_data:
            try:
                # 重新計算正確的唯一單據數（使用與銷售TC分析相同的條件）
                if hasattr(self, 'db_manager') and self.db_manager.connection:
                    cursor = self.db_manager.connection.cursor()
                    
                    # 使用與銷售TC分析相同的條件
                    date_from = self.date_from.get_date().strftime('%Y-%m-%d') if self.date_from.get_date() else None
                    date_to = self.date_to.get_date().strftime('%Y-%m-%d') if self.date_to.get_date() else None
                    outlet_filters = self.outlet_combo.get_selected()
                    product_filters = self.product_combo.get_selected()
                    month_filters = self.month_combo.get_selected()
                    weekday_filters = self.weekday_combo.get_selected()
                    category_filters = self.category_combo.get_selected()
                    payment_filters = self.payment_combo.get_selected()
                    
                    conditions = []
                    if date_from:
                        conditions.append(f"CAST(s.c_date AS DATE) >= '{date_from}'")
                    if date_to:
                        conditions.append(f"CAST(s.c_date AS DATE) <= '{date_to}'")
                    if outlet_filters and len(outlet_filters) > 0:
                        outlet_conditions = " OR ".join([f"s.store_name = '{outlet}'" for outlet in outlet_filters])
                        conditions.append(f"({outlet_conditions})")
                    if product_filters and len(product_filters) > 0:
                        product_conditions = " OR ".join([f"s.item_name = '{product}'" for product in product_filters])
                        conditions.append(f"({product_conditions})")
                    if month_filters and len(month_filters) > 0:
                        month_conditions = " OR ".join([f"FORMAT(CAST(s.c_date AS DATE), 'yyyy-MM') = '{month}'" for month in month_filters])
                        conditions.append(f"({month_conditions})")
                    if category_filters and len(category_filters) > 0:
                        category_conditions = " OR ".join([f"s.item_category = '{category}'" for category in category_filters])
                        conditions.append(f"({category_conditions})")
                    
                    conditions.append("s.item_name NOT IN ('WASTAGE', 'Waste', 'waste', 'WASTE')")
                    
                    where_clause = ""
                    if conditions:
                        where_clause = " WHERE " + " AND ".join(conditions)
                    
                    unique_query = f"""
                        SELECT COUNT(DISTINCT CONCAT(s.store_name, '-', s.sales_no)) as unique_receipt_count
                        FROM pos_sales_dtls s
                        {where_clause}
                        AND s.item_name != 'WASTAGE'
                    """
                    
                    cursor.execute(unique_query)
                    result = cursor.fetchone()
                    total_receipts = result[0] if result else 0
                    cursor.close()
                else:
                    total_receipts = sum(data['总单据数'] for data in self.sales_tc_analysis_data)
            except:
                total_receipts = sum(data['总单据数'] for data in self.sales_tc_analysis_data)
        
        # 计算总占比
        total_amount_percentage = (total_product_amount / total_amount * 100) if total_amount > 0 else 0.0
        total_receipt_percentage = (total_product_receipts / total_receipts * 100) if total_receipts > 0 else 0.0
        total_quantity_percentage = (total_product_quantity / total_quantity * 100) if total_quantity > 0 else 0.0
        total_product_receipt_performance_percentage = (total_product_receipt_performance / total_amount * 100) if total_amount > 0 else 0.0
        
        # 插入总计行
        self.sales_tc_analysis_tree.insert("", "end", values=(
            "【总计】",
            "",
            f"${total_amount:,.2f}",
            total_receipts,
            total_quantity,
            f"${total_product_amount:,.2f}",
            total_product_receipts,
            total_product_quantity,
            f"${total_product_receipt_performance:,.2f}",
            f"{total_amount_percentage:.2f}",
            f"{total_receipt_percentage:.2f}",
            f"{total_quantity_percentage:.2f}",
            f"{total_product_receipt_performance_percentage:.2f}"
        ), tags=("total",))
        
        # 设置总计行样式
        self.sales_tc_analysis_tree.tag_configure("total", background="lightblue", font=("Arial", 10, "bold"))
        
        # 切换到日-产品分析标签页（如果活动记录窗口没有打开）
        if not (hasattr(self, 'activity_window') and self.activity_window.winfo_exists()):
            self.notebook.select(1)  # 选择Product标签页
            self.product_notebook.select(3)  # 选择日-产品分析子标签页
    
    def get_sales_tc_monthly(self):
        """获取月-产品分析"""
        # 验证日期范围
        if not self.validate_date_range():
            return
            
        # 先连接数据库
        db = self.selected_db.get()
        print(f"🔍 尝试连接数据库: {db}")
        if not self.db_manager.connect(db):
            self.log_message("✗ 数据库连接失败")
            print(f"❌ 数据库连接失败: {db}")
            return
        
        # 测试数据库连接
        try:
            cursor = self.db_manager.connection.cursor()
            cursor.execute("SELECT COUNT(*) FROM pos_sales_dtls")
            result = cursor.fetchone()
            print(f"✅ 数据库连接成功，pos_sales_dtls表记录数: {result[0] if result else 0}")
            cursor.close()
        except Exception as e:
            print(f"❌ 数据库连接测试失败: {e}")
            self.log_message(f"✗ 数据库连接测试失败: {e}")
            return
        
        # 获取筛选条件
        if self.use_date_filter.get():
            # DateEntry返回datetime对象，需要转换为字符串
            date_from = self.date_from.get_date().strftime('%Y-%m-%d') if self.date_from.get_date() else None
            date_to = self.date_to.get_date().strftime('%Y-%m-%d') if self.date_to.get_date() else None
            
            # 使用纯日期格式，不添加时间部分
            if date_from and date_to and date_from == date_to:
                self.log_message(f"ℹ 单日查询: {date_from}")
            elif date_to:
                self.log_message(f"ℹ 日期范围查询: {date_from} 到 {date_to}")
        else:
            # 不使用日期筛选，只使用月份筛选
            # 但是数据库查询需要日期范围，所以我们需要设置一个合理的默认范围
            # 如果没有选择月份，使用当前月份
            month_filters = self.month_combo.get_selected()
            if month_filters and len(month_filters) > 0:
                # 使用选中的第一个月份作为日期范围
                selected_month = month_filters[0]
                date_from = f"{selected_month}-01"
                # 计算该月的最后一天
                from datetime import datetime, timedelta
                year, month = map(int, selected_month.split('-'))
                if month == 12:
                    next_month = datetime(year + 1, 1, 1)
                else:
                    next_month = datetime(year, month + 1, 1)
                last_day = next_month - timedelta(days=1)
                date_to = last_day.strftime('%Y-%m-%d')
                self.log_message(f"ℹ 未启用日期筛选，使用月份筛选: {date_from} 到 {date_to}")
            else:
                # 如果没有选择月份，使用当前月份
                from datetime import datetime, timedelta
                now = datetime.now()
                current_month = now.strftime('%Y-%m')
                date_from = f"{current_month}-01"
                # 计算当前月的最后一天
                if now.month == 12:
                    next_month = datetime(now.year + 1, 1, 1)
                else:
                    next_month = datetime(now.year, now.month + 1, 1)
                last_day = next_month - timedelta(days=1)
                date_to = last_day.strftime('%Y-%m-%d')
                self.log_message(f"ℹ 未启用日期筛选，使用当前月份: {date_from} 到 {date_to}")
            
        outlet_filters = self.outlet_combo.get_selected()
        product_filters = self.product_combo.get_selected()
        month_filters = self.month_combo.get_selected()
        weekday_filters = self.weekday_combo.get_selected()
        print(f"GUI获取的星期筛选: {weekday_filters}")
        category_filters = self.category_combo.get_selected()
        payment_filters = self.payment_combo.get_selected()
        
        self.log_message("正在获取月-产品分析...")
        self.sales_tc_monthly_data = self.db_manager.get_sales_tc_monthly_analysis(
            date_from, date_to, outlet_filters, product_filters, month_filters, weekday_filters, category_filters, payment_filters
        )
        self.sales_tc_monthly_store_count = self.db_manager.get_unique_store_count(
            date_from=date_from,
            date_to=date_to,
            outlet_filters=outlet_filters,
            month_filters=month_filters,
            weekday_filters=weekday_filters,
            category_filters=category_filters,
            product_filters=product_filters,
            payment_filters=payment_filters
        ) or 1
        
        if self.sales_tc_monthly_data:
            self.log_message(f"✓ 获取月-产品分析成功，共 {len(self.sales_tc_monthly_data)} 条记录")
            self.display_sales_tc_monthly()
        else:
            self.log_message("✗ 获取月-产品分析失败或没有数据")
        
        self.db_manager.disconnect()
    
    def display_sales_tc_monthly(self):
        """显示月-产品分析"""
        # 清空TreeView
        for item in self.sales_tc_monthly_tree.get_children():
            self.sales_tc_monthly_tree.delete(item)
        
        # 设置列
        columns = ['月份\nMonth', '门市\nOutlet', '总业绩\nTotal Performance', '总单据数\nTotal Receipt Count', '总销售数量\nTotal Quantity', '产品业绩\nProduct Performance', '产品单据数\nProduct Receipt Count', '产品销售数量\nProduct Quantity', '产品单据业绩\nProduct Receipt Performance', '业绩占比(%)\nPerformance Ratio(%)', '单据数占比(%)\nReceipt Count Ratio(%)', '销售数量占比(%)\nQuantity Ratio(%)', '产品单据业绩占比(%)\nProduct Receipt Performance Ratio(%)']
        self.sales_tc_monthly_tree["columns"] = columns
        
        for col in columns:
            self.sales_tc_monthly_tree.heading(col, text=col, command=lambda c=col: self.sort_treeview(self.sales_tc_monthly_tree, c))
            self.sales_tc_monthly_tree.column(col, width=120, anchor="center")
        
        # 设置行高以显示中英文标题
        style = ttk.Style()
        style.configure("Treeview", rowheight=25)  # 进一步缩小数据行高度到25像素
        style.configure("Treeview.Heading", font=('Arial', 9, 'bold'), height=80, background="#34495e", foreground="white", padding=(10, 8))  # 缩小字体但增加标题高度到80像素
        
        # 插入数据
        # 确定门店数量用于单店平均
        store_count = getattr(self, 'sales_tc_monthly_store_count', None)
        if not store_count or store_count <= 0:
            unique_stores = {data['门市'] for data in self.sales_tc_monthly_data if data['门市'] and not str(data['门市']).startswith('【')}
            store_count = len(unique_stores) or 1

        for data in self.sales_tc_monthly_data:
            total_perf = data['总业绩']
            total_receipts = data['总单据数']
            total_qty = data['总销售数量']
            prod_perf = data['产品业绩']
            prod_receipts = data['产品单据数']
            prod_qty = data['产品销售数量']
            prod_receipt_perf = data.get('产品单据业绩', 0)

            if self.show_store_average.get() and store_count > 0:
                total_perf /= store_count
                total_receipts /= store_count
                total_qty /= store_count
                prod_perf /= store_count
                prod_receipts /= store_count
                prod_qty /= store_count
                prod_receipt_perf /= store_count

            # 根据开关状态决定是否显示详细数据
            if self.show_product_details.get():
                self.sales_tc_monthly_tree.insert("", "end", values=(
                    data['月份'],
                    data['门市'],
                    f"{total_perf:.2f}",
                    format_number(total_receipts),
                    f"{total_qty:.2f}",
                    f"{prod_perf:.2f}",
                    format_number(prod_receipts),
                    f"{prod_qty:.2f}",
                    f"{prod_receipt_perf:.2f}",
                    f"{data['业绩占比(%)']:.2f}",
                    f"{data['单据数占比(%)']:.2f}",
                    f"{data['销售数量占比(%)']:.2f}",
                    f"{data.get('产品单据业绩占比(%)', 0):.2f}"
                ))
        
        # 计算并添加总计行 - 修正计算逻辑（基于月份门市去重后将业绩求和，避免重复计算）
        if self.sales_tc_monthly_data:
            monthly_totals = {}
            product_totals = {'product_sales': 0.0, 'product_receipts': 0.0, 'product_quantity': 0.0, 'product_receipt_performance': 0.0}

            for data in self.sales_tc_monthly_data:
                month_key = data['月份']
                store_key = data['门市']
                key = f"{month_key}_{store_key}"

                if key not in monthly_totals:
                    monthly_totals[key] = {
                        'month': data['月份'],
                        'store': data['门市'],
                        'total_sales': data['总业绩'],
                        'total_receipts': data['总单据数'],
                        'total_quantity': data['总销售数量']
                    }

                product_totals['product_sales'] += data['产品业绩']
                product_totals['product_receipts'] += data['产品单据数']
                product_totals['product_quantity'] += data['产品销售数量']
                product_totals['product_receipt_performance'] += data.get('产品单据业绩', 0)

            store_count = getattr(self, 'sales_tc_monthly_store_count', None)
            if not store_count or store_count <= 0:
                store_count = len({entry['store'] for entry in monthly_totals.values() if entry['store'] and not str(entry['store']).startswith('【')}) or 1

            total_sales = sum(item['total_sales'] for item in monthly_totals.values())
            total_receipts = sum(item['total_receipts'] for item in monthly_totals.values())
            total_quantity = sum(item['total_quantity'] for item in monthly_totals.values())

            if self.show_store_average.get() and store_count > 0:
                total_sales /= store_count
                total_receipts /= store_count
                total_quantity /= store_count
                product_totals['product_sales'] /= store_count
                product_totals['product_receipts'] /= store_count
                product_totals['product_quantity'] /= store_count
                product_totals['product_receipt_performance'] /= store_count

            total_sales_ratio = (product_totals['product_sales'] / total_sales * 100) if total_sales > 0 else 0
            total_receipt_ratio = (product_totals['product_receipts'] / total_receipts * 100) if total_receipts > 0 else 0
            total_quantity_ratio = (product_totals['product_quantity'] / total_quantity * 100) if total_quantity > 0 else 0
            total_product_receipt_performance_ratio = (product_totals['product_receipt_performance'] / total_sales * 100) if total_sales > 0 else 0

            self.sales_tc_monthly_tree.insert("", "end", values=(
                "【总计】",
                "",
                f"{total_sales:.2f}",
                format_number(total_receipts),
                f"{total_quantity:.2f}",
                f"{product_totals['product_sales']:.2f}",
                format_number(product_totals['product_receipts']),
                f"{product_totals['product_quantity']:.2f}",
                f"{product_totals['product_receipt_performance']:.2f}",
                f"{total_sales_ratio:.2f}",
                f"{total_receipt_ratio:.2f}",
                f"{total_quantity_ratio:.2f}",
                f"{total_product_receipt_performance_ratio:.2f}"
            ), tags=("total",))
            
            # 添加選中產品總計行（初始為空）
            self.update_monthly_analysis_selected_products_summary()
        
        # 设置总计行样式
        self.sales_tc_monthly_tree.tag_configure("total", background="lightblue", font=("Arial", 10, "bold"))
        
        # 切换到月-产品分析标签页（如果活动记录窗口没有打开）
        if not (hasattr(self, 'activity_window') and self.activity_window.winfo_exists()):
            self.notebook.select(1)  # 选择Product标签页
            self.product_notebook.select(4)  # 选择月-产品分析子标签页
    
    def setup_left_panel(self):
        """设置左侧分析功能按钮面板"""
        # 创建滚动区域 - 活動記錄管理中心風格
        canvas = tk.Canvas(self.left_panel, bg='#ffffff', highlightthickness=0)
        scrollbar = ttk.Scrollbar(self.left_panel, orient="vertical", command=canvas.yview)
        scrollable_frame = tk.Frame(canvas, bg='#ffffff')
        
        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        # 绑定鼠标滚轮事件
        def _on_mousewheel(event):
            canvas.yview_scroll(int(-1*(event.delta/120)), "units")
        
        def _bind_to_mousewheel(event):
            canvas.bind_all("<MouseWheel>", _on_mousewheel)
        
        def _unbind_from_mousewheel(event):
            canvas.unbind_all("<MouseWheel>")
        
        canvas.bind('<Enter>', _bind_to_mousewheel)
        canvas.bind('<Leave>', _unbind_from_mousewheel)
        
        canvas.pack(side="left", fill="both", expand=True, padx=(0, 0))
        scrollbar.pack(side="right", fill="y", padx=(0, 0))
        
        # 創建現代化樣式
        style = ttk.Style()
        
        # 🌟 現代化左側面板樣式
        
        # 現代清新多色彩按鈕設計 - 柔和而專業
        # 銷售分析按鈕 - 專業藍色系
        style.configure("Sales.TButton", 
                       font=('Segoe UI', 9, 'bold'),
                       background="#2196F3",  # 專業藍
                       foreground="#FFFFFF",
                       padding=(14, 12),
                       relief="flat",
                       borderwidth=0)
        
        style.map("Sales.TButton",
                 background=[('active', '#1976D2'),
                            ('!active', '#2196F3')])
        
        # 產品分析按鈕 - 清新綠色系
        style.configure("Product.TButton", 
                       font=('Segoe UI', 9, 'bold'),
                       background="#4CAF50",  # 清新綠
                       foreground="#FFFFFF",
                       padding=(14, 12),
                       relief="flat",
                       borderwidth=0)
        
        style.map("Product.TButton",
                 background=[('active', '#388E3C'),
                            ('!active', '#4CAF50')])
        
        # 品牌分析按鈕 - 優雅紫色系
        style.configure("Brand.TButton", 
                       font=('Segoe UI', 9, 'bold'),
                       background="#9C27B0",  # 優雅紫
                       foreground="#FFFFFF",
                       padding=(14, 12),
                       relief="flat",
                       borderwidth=0)
        
        style.map("Brand.TButton",
                 background=[('active', '#7B1FA2'),
                            ('!active', '#9C27B0')])
        
        # 導出按鈕 - 溫暖橙色系
        style.configure("Export.TButton", 
                       font=('Segoe UI', 9, 'bold'),
                       background="#FF9800",  # 溫暖橙
                       foreground="#FFFFFF",
                       padding=(14, 12),
                       relief="flat",
                       borderwidth=0)
        
        style.map("Export.TButton",
                 background=[('active', '#F57C00'),
                            ('!active', '#FF9800')])
        
        # 工具按鈕 - 純白系
        style.configure("Tools.TButton", 
                       font=('Segoe UI', 9),
                       background="#FFFFFF",  # 純白
                       foreground="#2196F3",  # 藍色文字
                       padding=(12, 10),
                       relief="solid",
                       borderwidth=2)
        
        style.map("Tools.TButton",
                 background=[('active', '#E3F2FD'),
                            ('!active', '#FFFFFF')])
        
        # 連接按鈕 - 成功綠色
        style.configure("Connect.TButton", 
                       font=('Segoe UI', 10, 'bold'),
                       background="#4CAF50",  # 成功綠色
                       foreground="#FFFFFF",
                       padding=(16, 14),
                       relief="flat",
                       borderwidth=0)
        
        style.map("Connect.TButton",
                 background=[('active', '#388E3C'),
                            ('!active', '#4CAF50')])
        
        # 活動記錄按鈕 - 柔和紅色
        style.configure("Activity.TButton", 
                       font=('Segoe UI', 9, 'bold'),
                       background="#F44336",  # 柔和紅
                       foreground="#FFFFFF",
                       padding=(14, 12),
                       relief="flat",
                       borderwidth=0)
        
        style.map("Activity.TButton",
                 background=[('active', '#D32F2F'),
                            ('!active', '#F44336')])
        
        # Sales Analysis 销售分析 - 圖二深色主題風格
        sales_frame = tk.LabelFrame(scrollable_frame, text="📊 Sales Analysis\n销售分析", bg='#2c3e50', fg='white', relief='flat', bd=1)
        sales_frame.pack(fill="x", pady=(0, 8), padx=(0, 0))
        
        # 深灰背景 + 彩色邊框設計
        sales_buttons = [
            ("销售数据\nSales Raw Data", self.get_sales_data, "#2563eb"),
            ("支付方式分析\nPayment Analysis", self.get_payment_analysis, "#059669"),
            ("折扣分析\nDiscount Analysis", self.get_discount_analysis, "#dc2626"),
            ("月 - 销售数据\nMonthly - Product Data", self.get_monthly_summary, "#ea580c")
        ]
        
        for text, command, border_color in sales_buttons:
            # 創建深灰背景 + 彩色邊框按鈕
            btn = tk.Button(sales_frame, 
                           text=text, 
                           command=lambda cmd=command: self.safe_command_execute(cmd),
                           bg='#34495e',  # 深灰背景
                           fg='white',
                           font=('Microsoft JhengHei UI', 10, 'bold'),
                           relief='solid',
                           bd=3,  # 邊框厚度
                           highlightthickness=0,
                           cursor='hand2')
            
            # 設置彩色邊框
            btn.configure(highlightbackground=border_color, highlightcolor=border_color)
            
            btn.pack(fill="x", pady=3, padx=8)
            
            # 添加懸停效果 - 邊框顏色填充
            def on_enter(event, btn=btn, border_color=border_color):
                btn.config(bg=border_color, fg='white')
            
            def on_leave(event, btn=btn):
                btn.config(bg='#34495e', fg='white')
                
            btn.bind('<Enter>', on_enter)
            btn.bind('<Leave>', on_leave)
        
        # Product Analysis 产品分析 - 圖二深色主題風格
        product_frame = tk.LabelFrame(scrollable_frame, text="📦 Product Analysis\n产品分析", bg='#2c3e50', fg='white', relief='flat', bd=1)
        product_frame.pack(fill="x", pady=(0, 8), padx=(0, 0))
        
        # 深灰背景 + 彩色邊框產品分析按鈕組
        product_buttons = [
            ("日 - 产品数据\nDaily Product Data", self.get_product_overview, "#059669"),
            ("周 - 产品数据\nWeekly Product Data", self.get_weekly_product_data, "#0891b2"),
            ("期间 - 产品数据\nPeriod Product Data", self.get_period_product_overview, "#0d9488"),
            ("日 - 产品分析\nDaily - Product Analysis", self.get_sales_tc_analysis, "#65a30d"),
            ("月 - 产品分析\nMonthly - Product Analysis", self.get_sales_tc_monthly, "#16a34a"),
            ("产品关联分析\nProduct Association Analysis", self.get_product_association_analysis, "#7c2d12"),
            ("类别分析\nCategory Analysis", self.get_category_analysis, "#ea580c")
        ]
        
        for text, command, border_color in product_buttons:
            # 創建深灰背景 + 彩色邊框按鈕
            btn = tk.Button(product_frame, 
                           text=text, 
                           command=lambda cmd=command: self.safe_command_execute(cmd),
                           bg='#34495e',  # 深灰背景
                           fg='white',
                           font=('Microsoft JhengHei UI', 10, 'bold'),
                           relief='solid',
                           bd=3,  # 邊框厚度
                           highlightthickness=0,
                           cursor='hand2')
            
            # 設置彩色邊框
            btn.configure(highlightbackground=border_color, highlightcolor=border_color)
            
            btn.pack(fill="x", pady=3, padx=8)
            
            # 添加懸停效果 - 邊框顏色填充
            def on_enter(event, btn=btn, border_color=border_color):
                btn.config(bg=border_color, fg='white')
            
            def on_leave(event, btn=btn):
                btn.config(bg='#34495e', fg='white')
                
            btn.bind('<Enter>', on_enter)
            btn.bind('<Leave>', on_leave)
        
        # Brand Analysis 品牌分析 - 圖二深色主題風格
        brand_frame = tk.LabelFrame(scrollable_frame, text="🏢 Brand Analysis\n品牌分析", bg='#2c3e50', fg='white', relief='flat', bd=1)
        brand_frame.pack(fill="x", pady=(0, 8), padx=(0, 0))
        
        # 深灰背景 + 彩色邊框品牌分析按鈕組
        brand_buttons = [
            ("每日细项\nDaily Breakdown", self.get_brand_daily_breakdown, "#7c3aed"),
            ("期间汇总\nPeriod Summary", self.get_brand_period_summary, "#8b5cf6"),
            ("业绩对比\nPerformance Comparison", self.get_brand_analysis, "#a855f7")
        ]
        
        for text, command, border_color in brand_buttons:
            # 創建深灰背景 + 彩色邊框按鈕
            btn = tk.Button(brand_frame, 
                           text=text, 
                           command=lambda cmd=command: self.safe_command_execute(cmd),
                           bg='#34495e',  # 深灰背景
                           fg='white',
                           font=('Microsoft JhengHei UI', 10, 'bold'),
                           relief='solid',
                           bd=3,  # 邊框厚度
                           highlightthickness=0,
                           cursor='hand2')
            
            # 設置彩色邊框
            btn.configure(highlightbackground=border_color, highlightcolor=border_color)
            
            btn.pack(fill="x", pady=3, padx=8)
            
            # 添加懸停效果 - 邊框顏色填充
            def on_enter(event, btn=btn, border_color=border_color):
                btn.config(bg=border_color, fg='white')
            
            def on_leave(event, btn=btn):
                btn.config(bg='#34495e', fg='white')
                
            btn.bind('<Enter>', on_enter)
            btn.bind('<Leave>', on_leave)
        
        # Export Functions 导出功能 - 統一橙色主題
        export_frame = tk.LabelFrame(scrollable_frame, text="📤 Export Functions\n导出功能", bg='#2c3e50', fg='white', relief='flat', bd=1)
        export_frame.pack(fill="x", pady=(0, 8), padx=(0, 0))
        
        # 深灰背景 + 彩色邊框導出按鈕組
        export_buttons = [
            ("导出当前数据\nExport Current Data", self.export_data, "#ea580c"),
            ("导出所有分析\nExport All Analysis", self.export_all_data, "#f59e0b"),
            ("生成报告\nGenerate Report", self.generate_report, "#ef4444")
        ]
        
        for text, command, border_color in export_buttons:
            # 創建深灰背景 + 彩色邊框按鈕
            btn = tk.Button(export_frame, 
                           text=text, 
                           command=lambda cmd=command: self.safe_command_execute(cmd),
                           bg='#34495e',  # 深灰背景
                           fg='white',
                           font=('Microsoft JhengHei UI', 10, 'bold'),
                           relief='solid',
                           bd=3,  # 邊框厚度
                           highlightthickness=0,
                           cursor='hand2')
            
            # 設置彩色邊框
            btn.configure(highlightbackground=border_color, highlightcolor=border_color)
            
            btn.pack(fill="x", pady=3, padx=8)
            
            # 添加懸停效果 - 邊框顏色填充
            def on_enter(event, btn=btn, border_color=border_color):
                btn.config(bg=border_color, fg='white')
            
            def on_leave(event, btn=btn):
                btn.config(bg='#34495e', fg='white')
                
            btn.bind('<Enter>', on_enter)
            btn.bind('<Leave>', on_leave)
        
        # 添加工具功能区域
        tools_frame = tk.LabelFrame(scrollable_frame, text="🔧 Tools\n工具")
        tools_frame.pack(fill="x", pady=(0, 3), padx=(0, 0))
        
        # 工具按钮组
        tools_buttons = [
            ("刷新数据\nRefresh Data", self.refresh_all_data),
            ("超快速导出\nUltra Fast Export", self.ultra_fast_export),
            ("🚀 6个月快速导出\n6 Months Fast Export", self.super_fast_export_6months),
            ("📋 分段式导出\nStaged Export", self.new_staged_export),
            ("快速导出历史数据\nFast Export Historical Data", lambda: self.export_all_historical_data(background_mode=True)),
            ("完整导出历史数据\nFull Export Historical Data", lambda: self.export_all_historical_data(background_mode=False)),
            ("缓存统计\nCache Stats", self.show_cache_statistics),
            ("清除缓存\nClear Cache", self.clear_memory_cache),
            ("系统设置\nSystem Settings", self.open_settings),
            ("帮助文档\nHelp Documentation", self.open_help)
        ]
        
        for text, command in tools_buttons:
            btn = ttk.Button(tools_frame, text=text, command=command, width=20, style="Tools.TButton")
            btn.pack(fill="x", pady=2)
        
        # 绑定鼠标滚轮事件
        def _on_mousewheel(event):
            canvas.yview_scroll(int(-1*(event.delta/120)), "units")
        
        canvas.bind_all("<MouseWheel>", _on_mousewheel)
        
        # 当窗口失去焦点时解绑鼠标滚轮事件
        def _unbind_mousewheel(event):
            canvas.unbind_all("<MouseWheel>")
        
        self.root.bind("<FocusOut>", _unbind_mousewheel)
        
        # 註釋：停止在左側面板設置時重新創建右側面板
        # self.setup_right_panel()  # 已移除以保護現有右側面板
    
    def adjust_color(self, color, amount):
        """調整顏色亮度 - SEAutomation 風格"""
        if isinstance(color, str) and color.startswith('#'):
            # 移除 # 號
            color = color[1:]
            
            # 轉換為 RGB
            r = int(color[0:2], 16)
            g = int(color[2:4], 16)
            b = int(color[4:6], 16)
            
            # 調整亮度
            r = min(255, max(0, r + amount))
            g = min(255, max(0, g + amount))
            b = min(255, max(0, b + amount))
            
            # 轉換回 HEX
            return f"#{r:02x}{g:02x}{b:02x}"
        return color
    
    def safe_command_execute(self, command):
        """安全執行命令，確保右側面板徹底受到保護"""
        try:
            # 檢查保護狀態
            protected = hasattr(self, '_right_panel_protected') and self._right_panel_protected
            print(f"🛡️ 執行命令 - 右側面板保護狀態: {protected}")
            
            # 記錄執行前的面板狀態
            if hasattr(self, 'right_panel'):
                panel_exists = self.right_panel.winfo_exists()
                child_count = len(self.right_panel.winfo_children()) if panel_exists else 0
                print(f"🔍 執行前右側面板狀態: 存在={panel_exists}, 子組件={child_count}")
            
            # 執行命令
            command()
            
            # 執行後全面檢查並保護
            if hasattr(self, 'right_panel'):
                try:
                    # 強制確保可視性
                    self.right_panel.lift()
                    self.right_panel.tkraise()
                    
                    # 檢查狀態
                    panel_exists = self.right_panel.winfo_exists()
                    panel_visible = self.right_panel.winfo_viewable()
                    child_count = len(self.right_panel.winfo_children()) if panel_exists else 0
                    
                    print(f"🔍 執行後右側面板狀態: 存在={panel_exists}, 可見={panel_visible}, 子組件={child_count}")
                    
                    # 如果需要，強制重新pack以確保顯示
                    if panel_exists and not panel_visible:
                        print("🔧 強制重新pack右側面板以確保可見性")
                        self.force_show_right_panel_now()
                    else:
                        # 即使面板可見，也要檢查布局穩定性
                        self.enforce_stable_layout()
                        
                except tk.TclError as panel_error:
                    print(f"❌ 右側面板檢查失敗: {panel_error}")
                    # 嘗試恢復
                    if hasattr(self, '_right_panel_protected'):
                        print("🔄 嘗試重新設置保護標記")
                
        except Exception as e:
            print(f"執行命令時出錯: {e}")
            # 最後的保護措施
            if hasattr(self, '_right_panel_protected'):
                self._right_panel_protected = True
                print("🛡️ 已重新啟用右側面板保護機制")
    
    def force_show_right_panel_now(self):
        """強制顯示右側面板 - 解決可見性問題"""
        try:
            print("🛡️ 強制顯示右側面板")
            
            if hasattr(self, 'right_panel') and hasattr(self, 'layout_container'):
                # 使用保存的layout_container引用
                print("🔄 重新pack右側面板到layout_container")
                
                # 強制重新pack右側面板
                self.right_panel.pack_forget()
                self.right_panel.pack(side="right", fill="y", expand=False, padx=(8, 15), pady=15)
                self.right_panel.configure(width=270)
                self.right_panel.pack_propagate(False)
                
                # 強制顯示和置頂
                self.right_panel.lift()
                self.right_panel.tkraise()
                
                # 保存保護標記
                self._right_panel_protected = True
                
                # 強制更新
                self.root.update_idletasks()
                self.root.update()
                
                print("✅ 右側面板強制顯示完成")
                print(f"✅ 右側面板寬度: {self.right_panel.cget('width')}px")
                
                # 強制重新排列整個布局
                self.enforce_stable_layout()
            else:
                print("❌ 缺少右側面板或主容器引用")
        except Exception as e:
            print(f"❌ 強制顯示右側面板失敗: {e}")
    
    def enforce_stable_layout(self):
        """強制執行穩定三欄布局 - 確保右側面板永不消失"""
        try:
            print("🛡️ 強制執行穩定布局...")
            
            if hasattr(self, 'layout_container'):
                # 重新排列所有三個面板的順序
                
                # 1. 先pack_left_left
                self.left_panel.pack_forget()
                self.left_panel.pack(side="left", fill="y", expand=False, padx=(15, 8), pady=15)
                self.left_panel.configure(width=190)
                self.left_panel.pack_propagate(False)
                
                # 2. 再pack_right (重要：右側必須在中間之後)
                self.right_panel.pack_forget()
                self.right_panel.pack(side="right", fill="y", expand=False, padx=(8, 15), pady=15)
                self.right_panel.configure(width=270)
                self.right_panel.pack_propagate(False)
                
                # 3. 最後pack中間 (填滿剩餘空間)
                self.main_frame.pack_forget()
                self.main_frame.pack(side="left", fill="both", expand=True, padx=(8, 8), pady=15)
                
                # 強制更新
                self.layout_container.update_idletasks()
                self.root.update_idletasks()
                
                print("✅ 三欄布局強制穩定完成")
                print(f"   - 左側: {self.left_panel.cget('width')}px, 位置: {self.left_panel.pack_info()}")
                print(f"   - 右側: {self.right_panel.cget('width')}px, 位置: {self.right_panel.pack_info()}")
                print(f"   - 中間: 彈性, 位置: {self.main_frame.pack_info()}")
                
        except Exception as e:
            print(f"❌ 強制穩定布局失敗: {e}")
    
    def setup_right_panel(self):
        """設置右側活動提醒面板 - 全面保護機制"""
        try:
            print("🔧 檢查右側面板保護狀態...")
            
            # 檢查是否有保護標記
            if hasattr(self, '_right_panel_protected') and self._right_panel_protected:
                print("✅ 右側面板受保護，禁止任何修改")
                return
                
            # 檢查右側面板是否已經正確設置
            if hasattr(self, 'right_panel') and hasattr(self.right_panel, 'winfo_children'):
                child_count = len(self.right_panel.winfo_children())
                if child_count > 0:
                    print(f"✅ 右側面板已存在 ({child_count}個子組件)，完全保護")
                    return
            
            # 只有在右側面板為空時才重新創建
            print("🔧 右側面板為空，初始化內容...")
            
            # 創建右側面板標題區域
            right_header = tk.Frame(self.right_panel, bg='#e74c3c', height=40)
            right_header.pack(fill="x")
            right_header.pack_propagate(False)
            
            right_title = tk.Label(right_header, 
                              text="📊 活动提醒", 
                              font=('Microsoft YaHei UI', 12, 'bold'),
                              fg='white', bg='#e74c3c')
            right_title.pack(pady=10)
            
            right_subtitle = tk.Label(right_header, 
                                text="Activity Alerts", 
                                font=('Arial', 9),
                                fg='#ecf0f1', bg='#e74c3c')
            right_subtitle.pack()
            
            # 創建活動提醒显示區域
            self.activity_alert_text = tk.Text(self.right_panel, height=15, width=30, 
                                          font=('Segoe UI', 10), wrap=tk.WORD, bg='#FFFFFF',
                                          state='disabled', relief='flat', borderwidth=2)
            
            activity_alert_scrollbar = ttk.Scrollbar(self.right_panel, orient="vertical", 
                                                   command=self.activity_alert_text.yview)
            self.activity_alert_text.configure(yscrollcommand=activity_alert_scrollbar.set)
            
            self.activity_alert_text.pack(side="left", fill="both", expand=True, padx=5, pady=5)
            activity_alert_scrollbar.pack(side="right", fill="y", padx=(0,5), pady=5)
            
            # 初始化基础内容
            self.activity_alert_text.config(state='normal')
            self.activity_alert_text.delete(1.0, tk.END)
            basic_text = """📊 活动提醒

系统正常运行！
选择分析功能开始使用。

💡 提示:
• 选择日期范围进行分析
• 使用筛选条件精确定位数据  
• 查看日志信息了解操作状态"""
            self.activity_alert_text.insert(1.0, basic_text)
            self.activity_alert_text.config(state='disabled')
            
            print("✅ 右側面板初始化完成")
            
        except Exception as e:
            print(f"❌ 右側面板設置失敗: {e}")
            # 備用方案：創建簡單的面板
            try:
                if not hasattr(self, 'activity_alert_text'):
                    self.activity_alert_text = tk.Text(self.right_panel, height=15, width=30, 
                                                  font=('Segoe UI', 10), wrap=tk.WORD, bg='#FFFFFF',
                                                  state='disabled', relief='flat', borderwidth=2)
                    self.activity_alert_text.pack(fill="both", expand=True, padx=5, pady=5)
                    
                    # 設置基礎內容
                    self.activity_alert_text.config(state='normal')
                    self.activity_alert_text.delete(1.0, tk.END)
                    self.activity_alert_text.insert('1.0', "📊 右側面板正常運行")
                    self.activity_alert_text.config(state='disabled')
                print("✅ 備用右側面板設置完成")
            except:
                print("❌ 備用面板設置也失敗")
    
    def lock_panel_sizes(self):
        """锁定面板大小，防止自动调整"""
        try:
            # 强制设置并锁定左侧面板大小
            self.left_panel.configure(width=190, height=600)
            self.left_panel.pack_propagate(False)  # 防止子组件改变父组件大小
            
            # 强制设置并锁定右侧面板大小
            self.right_panel.configure(width=270)
            self.right_panel.pack_propagate(False)  # 防止子组件改变父组件大小
            
            print("🔒 面板大小已锁定:")
            print(f"   - 左侧面板: 190px (锁定)")
            print(f"   - 右侧面板: 270px (锁定)")
            
            # 强制刷新界面
            self.root.update_idletasks()
            
        except Exception as e:
            print(f"锁定面板大小时出错: {e}")
    
    def setup_ui_complete(self):
        """完成UI设置"""
        # 初始化完成，设置默认日期范围
        try:
            # 设置默认日期为当前月份
            self.set_current_month_dates()
            self.log_message("✓ 已自动设置日期范围为当前月份")
        except Exception as e:
            self.log_message(f"⚠ 设置默认日期失败: {e}")
            # 如果设置失败，至少确保日期筛选是启用的
            self.use_date_filter.set(True)
    
    def export_all_data(self):
        """导出所有分析数据"""
        self.log_message("正在导出所有分析数据...")
        try:
            # 创建导出目录
            export_dir = "exports"
            if not os.path.exists(export_dir):
                os.makedirs(export_dir)
            
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            exported_files = []
            
            # 导出各种数据
            data_types = [
                (self.sales_data, "sales_data", "销售数据"),
                (self.payment_data, "payment_analysis", "支付分析"),
                (self.discount_data, "discount_analysis", "折扣分析"),
                (self.monthly_data, "monthly_summary", "月度汇总"),
                (self.sales_tc_analysis_data, "sales_tc_analysis", "销售TC分析"),
                (self.sales_tc_monthly_data, "sales_tc_monthly", "销售TC月度"),
                (self.product_association_data, "product_association", "产品关联分析")
            ]
            
            for data, filename, description in data_types:
                if data:
                    filepath = os.path.join(export_dir, f"{filename}_{timestamp}.csv")
                    self.save_data_to_csv(data, filepath)
                    exported_files.append(f"{description}: {filepath}")
            
            if exported_files:
                self.log_message(f"✓ 成功导出 {len(exported_files)} 个文件")
                for file_info in exported_files:
                    self.log_message(f"  - {file_info}")
            else:
                self.log_message("ℹ 没有数据可导出")
                
        except Exception as e:
            self.log_message(f"✗ 导出失败: {e}")
    
    def generate_report(self):
        """生成报告"""
        self.log_message("正在生成报告...")
        try:
            # 创建报告目录
            report_dir = "reports"
            if not os.path.exists(report_dir):
                os.makedirs(report_dir)
            
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            report_file = os.path.join(report_dir, f"pos_analysis_report_{timestamp}.txt")
            
            with open(report_file, 'w', encoding='utf-8') as f:
                f.write("POS数据分析报告\n")
                f.write("=" * 50 + "\n")
                f.write(f"生成时间: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                f.write(f"数据库: {self.db_manager.current_database}\n\n")
                
                # 添加数据统计
                f.write("数据统计:\n")
                f.write("-" * 30 + "\n")
                f.write(f"销售数据记录数: {len(self.sales_data) if self.sales_data else 0}\n")
                f.write(f"支付分析记录数: {len(self.payment_data) if self.payment_data else 0}\n")
                f.write(f"折扣分析记录数: {len(self.discount_data) if self.discount_data else 0}\n")
                f.write(f"月度汇总记录数: {len(self.monthly_data) if self.monthly_data else 0}\n")
                f.write(f"销售TC分析记录数: {len(self.sales_tc_analysis_data) if self.sales_tc_analysis_data else 0}\n")
                f.write(f"产品关联分析记录数: {len(self.product_association_data) if self.product_association_data else 0}\n")
            
            self.log_message(f"✓ 报告生成成功: {report_file}")
            
        except Exception as e:
            self.log_message(f"✗ 生成报告失败: {e}")
    
    def refresh_all_data(self):
        """刷新所有数据"""
        self.log_message("正在刷新所有数据...")
        try:
            # 重新连接数据库
            database_name = self.selected_db.get()
            if database_name:
                self.log_message(f"重新连接到数据库: {database_name}")
                self.connect_database()
            
            # 清除现有数据
            self.sales_data = None
            self.payment_data = None
            self.discount_data = None
            self.monthly_data = None
            self.sales_tc_analysis_data = None
            self.sales_tc_monthly_data = None
            self.product_association_data = None
            
            self.log_message("✓ 数据刷新完成")
            # 显示当前数据库信息
            self.log_database_info()
            
        except Exception as e:
            self.log_message(f"✗ 刷新数据失败: {e}")
    
    def show_cache_statistics(self):
        """显示缓存统计信息"""
        try:
            self.log_message("📊 正在获取缓存统计信息...")
            self.db_manager.get_cache_statistics()
        except Exception as e:
            self.log_message(f"✗ 获取缓存统计失败: {e}")
    
    def export_all_historical_data(self, background_mode=True):
        """导出所有历史数据（支持多数据库）"""
        if background_mode:
            # 后台模式：使用线程处理
            import threading
            self.log_message("🚀 开始后台导出所有历史数据...")
            self.log_message("ℹ️ 导出将在后台进行，您可以继续使用其他功能")
            
            # 创建进度窗口
            self.create_export_progress_window()
            
            # 启动后台线程
            export_thread = threading.Thread(target=self._background_export_worker, daemon=True)
            export_thread.start()
            
            # 立即返回，不等待线程完成
            return
        else:
            # 前台模式：创建进度窗口后直接处理
            self.create_export_progress_window()
            # 确保UI组件创建完成
            self.root.update()
            self._background_export_worker()
    
    def create_export_progress_window(self):
        """创建导出进度窗口"""
        try:
            # 创建进度窗口
            self.export_progress_window = tk.Toplevel(self.root)
            self.export_progress_window.title("导出进度 - Export Progress")
            self.export_progress_window.geometry("500x300")
            self.export_progress_window.resizable(False, False)
            
            # 设置窗口居中，但不阻塞主窗口
            self.export_progress_window.transient(self.root)
            # 不设置 grab_set()，这样用户仍然可以操作主窗口
            
            # 进度信息框架
            progress_frame = tk.Frame(self.export_progress_window, padding="10")
            progress_frame.pack(fill="both", expand=True)
            
            # 标题
            title_label = tk.Label(progress_frame, text="📊 正在导出历史数据...", 
                                   font=("Arial", 12, "bold"))
            title_label.pack(pady=(0, 10))
            
            # 当前状态
            self.export_status_label = tk.Label(progress_frame, text="准备开始导出...", 
                                                font=("Arial", 10))
            self.export_status_label.pack(pady=(0, 10))
            
            # 进度条
            self.export_progress_bar = ttk.Progressbar(progress_frame, length=400, mode='indeterminate')
            self.export_progress_bar.pack(pady=(0, 10))
            self.export_progress_bar.start()
            
            # 详细信息文本框
            self.export_detail_text = tk.Text(progress_frame, height=10, width=60, wrap="word")
            export_scrollbar = ttk.Scrollbar(progress_frame, orient="vertical", command=self.export_detail_text.yview)
            self.export_detail_text.configure(yscrollcommand=export_scrollbar.set)
            
            self.export_detail_text.pack(side="left", fill="both", expand=True, pady=(0, 10))
            export_scrollbar.pack(side="right", fill="y")
            
            # 按钮框架
            button_frame = tk.Frame(progress_frame)
            button_frame.pack(fill="x", pady=(10, 0))
            
            # 关闭按钮
            self.export_close_button = ttk.Button(button_frame, text="关闭\nClose", 
                                                 command=self.close_export_progress, state="disabled")
            self.export_close_button.pack(side="right", padx=(5, 0))
            
            # 取消按钮
            self.export_cancel_button = ttk.Button(button_frame, text="取消导出\nCancel Export", 
                                                  command=self.cancel_export)
            self.export_cancel_button.pack(side="right", padx=(5, 0))
            
            # 初始化导出状态
            self.export_cancelled = False
            self.export_completed = False
            
        except Exception as e:
            self.log_message(f"✗ 创建进度窗口失败: {e}")
    
    def close_export_progress(self):
        """关闭导出进度窗口"""
        try:
            if hasattr(self, 'export_progress_window') and self.export_progress_window:
                self.export_progress_window.destroy()
                self.export_progress_window = None
        except Exception as e:
            print(f"关闭进度窗口失败: {e}")
    
    def cancel_export(self):
        """取消导出"""
        try:
            self.export_cancelled = True
            self.export_status_label.config(text="正在取消导出...")
            self.export_cancel_button.config(state="disabled")
            self.log_message("⚠️ 用户取消了导出操作")
        except Exception as e:
            print(f"取消导出失败: {e}")
    
    def update_export_progress(self, message):
        """更新导出进度"""
        try:
            if hasattr(self, 'export_detail_text') and self.export_detail_text:
                self.export_detail_text.insert(tk.END, message + "\n")
                self.export_detail_text.see(tk.END)
                self.export_status_label.config(text=message)
                # 强制更新界面
                self.root.update()
        except Exception as e:
            print(f"更新进度失败: {e}")
    
    def _background_export_worker(self):
        """后台导出工作线程"""
        try:
            # 创建导出目录
            import os
            from datetime import datetime, timedelta
            
            export_dir = "historical_data_export"
            os.makedirs(export_dir, exist_ok=True)
            
            # 定义支持的数据库
            databases = [
                {"name": "GOGO", "display": "GOGO", "db_name": "sushi_gogo_pos_live"},
                {"name": "Express", "display": "Express", "db_name": "sushi_express_pos_live"},
                {"name": "PLUS", "display": "PLUS", "db_name": "sushi_plus_pos_live"}  # 预留PLUS数据库
            ]
            
            all_exported_data = {}
            
            # 更新进度：开始处理
            self.update_export_progress("🚀 开始导出所有历史数据...")
            
            # 遍历每个数据库
            for i, db_info in enumerate(databases):
                if self.export_cancelled:
                    self.update_export_progress("⚠️ 导出已被用户取消")
                    break
                
                db_name = db_info["name"]
                db_display = db_info["display"]
                db_connection = db_info["db_name"]
                
                self.update_export_progress(f"🗄️ 正在处理 {db_display} 数据库... ({i+1}/{len(databases)})")
                
                # 尝试连接到数据库
                try:
                    # 保存当前数据库设置
                    original_db = self.db_manager.current_database
                    
                    # 切换到目标数据库
                    self.db_manager.connect(db_connection)
                    
                    if not self.db_manager.connection:
                        self.update_export_progress(f"⚠️ 无法连接到 {db_display} 数据库，跳过")
                        continue
                    
                    # 获取数据日期范围
                    date_range = self.get_available_date_range()
                    if not date_range:
                        self.update_export_progress(f"⚠️ {db_display} 数据库无数据，跳过")
                        continue
                    
                    start_date, end_date = date_range
                    self.update_export_progress(f"📅 {db_display} 数据日期范围: {start_date} 到 {end_date}")
                    
                    # 为每个数据库创建子目录
                    db_export_dir = f"{export_dir}/{db_display}"
                    os.makedirs(db_export_dir, exist_ok=True)
                    
                    # 导出该数据库的所有数据
                    db_data = {
                        "database": db_display,
                        "date_range": (start_date, end_date),
                        "sales_data": [],
                        "monthly_summary": [],
                        "product_analysis": [],
                        "discount_analysis": [],
                        "payment_analysis": [],
                        "brand_analysis": []
                    }
                    
                    # 超快速导出：只导出最近6个月数据，包含支付方式
                    from datetime import datetime, timedelta
                    end_datetime = datetime.strptime(end_date, '%Y-%m-%d')
                    start_datetime = end_datetime - timedelta(days=180)  # 最近6个月
                    fast_start_date = start_datetime.strftime('%Y-%m-%d')
                    
                    self.update_export_progress(f"⚡ 超快速模式：导出 {db_display} 最近6个月数据 ({fast_start_date} 到 {end_date})")
                    
                    # 使用新的快速导出函数
                    self.export_sales_data_fast_mode(fast_start_date, end_date, db_export_dir, db_display, db_data)
                    
                    # 导出月度汇总
                    self.update_export_progress(f"📈 正在导出 {db_display} 月度汇总...")
                    self.export_monthly_summary_data(start_date, end_date, db_export_dir, db_display, db_data)
                    
                    # 导出产品分析
                    self.update_export_progress(f"🛍️ 正在导出 {db_display} 产品分析...")
                    self.export_product_analysis_data(start_date, end_date, db_export_dir, db_display, db_data)
                    
                    # 导出折扣分析
                    self.update_export_progress(f"💰 正在导出 {db_display} 折扣分析...")
                    self.export_discount_analysis_data(start_date, end_date, db_export_dir, db_display, db_data)
                    
                    # 导出支付分析（单独处理支付方式数据）
                    self.update_export_progress(f"💳 正在导出 {db_display} 支付分析...")
                    self.export_payment_analysis_data(start_date, end_date, db_export_dir, db_display, db_data)
                    
                    # 导出品牌分析
                    self.update_export_progress(f"🏷️ 正在导出 {db_display} 品牌分析...")
                    self.export_brand_analysis_data(start_date, end_date, db_export_dir, db_display, db_data)
                    
                    all_exported_data[db_display] = db_data
                    self.update_export_progress(f"✅ {db_display} 数据库导出完成")
                    
                    # 恢复原始数据库设置
                    self.db_manager.current_database = original_db
                    
                except Exception as e:
                    self.update_export_progress(f"✗ {db_display} 数据库导出失败: {e}")
                    continue
            
            # 生成汇总报告
            if not self.export_cancelled:
                self.update_export_progress("📋 正在生成汇总报告...")
                self.generate_export_summary(export_dir, all_exported_data)
                
                # 完成导出
                self.update_export_progress(f"✅ 所有历史数据导出完成！保存位置: {export_dir}")
                self.export_progress_bar.stop()
                self.export_progress_bar.config(mode='determinate', value=100)
                self.export_close_button.config(state="normal")
                self.export_cancel_button.config(state="disabled")
                self.export_completed = True
            else:
                self.update_export_progress("⚠️ 导出已被用户取消")
                self.export_progress_bar.stop()
                self.export_close_button.config(state="normal")
                self.export_cancel_button.config(state="disabled")
            
        except Exception as e:
            self.update_export_progress(f"✗ 导出历史数据失败: {e}")
            self.export_progress_bar.stop()
            self.export_close_button.config(state="normal")
            self.export_cancel_button.config(state="disabled")
            import traceback
            traceback.print_exc()
    
    def export_sales_data_fast_mode(self, start_date, end_date, export_dir, db_display, db_data):
        """超快速导出模式：只导出最近数据，大幅提升速度"""
        try:
            import pandas as pd
            from datetime import datetime, timedelta
            import gzip
            import pickle
            import os
            
            self.update_export_progress(f"⚡ 超快速模式：导出 {db_display} 销售数据...")
            
            # 直接查询整个日期范围，不分月
            sales_data = self.db_manager.get_sales_data(
                date_from=start_date,
                date_to=end_date,
                use_excel_cache=True
            )
            
            if sales_data:
                # 为每条记录添加数据库标识
                for record in sales_data:
                    record['数据库来源'] = db_display
                    record['数据库来源\nDatabase Source'] = db_display
                
                # 保存到Excel和压缩文件
                df = pd.DataFrame(sales_data)
                excel_file = f"{export_dir}/{db_display}_sales_data_{start_date}_to_{end_date}.xlsx"
                compressed_file = f"{export_dir}/{db_display}_sales_data_{start_date}_to_{end_date}.pkl.gz"
                
                # 保存Excel文件
                df.to_excel(excel_file, index=False)
                
                # 保存压缩文件
                with gzip.open(compressed_file, 'wb') as f:
                    pickle.dump(sales_data, f, protocol=pickle.HIGHEST_PROTOCOL)
                
                # 计算压缩率
                excel_size = os.path.getsize(excel_file) / (1024 * 1024)  # MB
                compressed_size = os.path.getsize(compressed_file) / (1024 * 1024)  # MB
                compression_ratio = (1 - compressed_size / excel_size) * 100 if excel_size > 0 else 0
                
                db_data["sales_data"] = sales_data
                self.update_export_progress(f"✅ {db_display} 销售数据导出完成！")
                self.update_export_progress(f"   📊 记录数: {len(sales_data)}")
                self.update_export_progress(f"   📁 Excel: {excel_size:.2f}MB")
                self.update_export_progress(f"   🗜️ 压缩: {compressed_size:.2f}MB (压缩率: {compression_ratio:.1f}%)")
            else:
                self.update_export_progress(f"⚠️ {db_display} 没有销售数据")
                
        except Exception as e:
            self.update_export_progress(f"✗ {db_display} 快速导出失败: {e}")
    
    def export_analysis_data_fast_mode(self, start_date, end_date, export_dir, db_display, db_data):
        """快速导出分析数据"""
        try:
            self.update_export_progress(f"📈 正在导出 {db_display} 分析数据...")
            
            # 获取月度汇总
            monthly_summary = self.get_monthly_summary_data()
            if monthly_summary:
                db_data["monthly_summary"] = monthly_summary
                self.update_export_progress(f"   ✓ 月度汇总: {len(monthly_summary)} 条")
            
            # 获取产品分析
            product_analysis = self.get_product_analysis_data()
            if product_analysis:
                db_data["product_analysis"] = product_analysis
                self.update_export_progress(f"   ✓ 产品分析: {len(product_analysis)} 条")
            
            # 获取折扣分析
            discount_analysis = self.get_discount_analysis_data()
            if discount_analysis:
                db_data["discount_analysis"] = discount_analysis
                self.update_export_progress(f"   ✓ 折扣分析: {len(discount_analysis)} 条")
            
            self.update_export_progress(f"✅ {db_display} 分析数据导出完成")
            
        except Exception as e:
            self.update_export_progress(f"✗ {db_display} 分析数据导出失败: {e}")

    def export_sales_data_by_period_fast(self, start_date, end_date, export_dir, db_display, db_data):
        """快速导出销售数据（不包含支付方式）"""
        try:
            import pandas as pd
            from datetime import datetime, timedelta
            
            # 按月份导出
            current_date = datetime.strptime(start_date, '%Y-%m-%d')
            end_datetime = datetime.strptime(end_date, '%Y-%m-%d')
            
            all_sales_data = []
            
            while current_date <= end_datetime:
                if self.export_cancelled:
                    break
                    
                month_start = current_date.replace(day=1)
                if current_date.month == 12:
                    month_end = current_date.replace(year=current_date.year + 1, month=1, day=1) - timedelta(days=1)
                else:
                    month_end = current_date.replace(month=current_date.month + 1, day=1) - timedelta(days=1)
                
                # 确保不超过结束日期
                if month_end > end_datetime:
                    month_end = end_datetime
                
                month_str = month_start.strftime('%Y-%m')
                self.update_export_progress(f"  正在导出 {db_display} {month_str} 销售数据...")
                
                # 获取该月数据（包含支付方式）
                sales_data = self.db_manager.get_sales_data(
                    date_from=month_start.strftime('%Y-%m-%d'),
                    date_to=month_end.strftime('%Y-%m-%d'),
                    use_excel_cache=True
                )
                
                # 让线程释放控制权，允许界面更新
                import time
                time.sleep(0.01)
                
                if sales_data:
                    # 为每条记录添加数据库标识
                    for record in sales_data:
                        record['数据库来源'] = db_display
                        record['数据库来源\nDatabase Source'] = db_display
                        # 支付方式已在查询中获取
                    
                    all_sales_data.extend(sales_data)
                    # 保存月度文件
                    df = pd.DataFrame(sales_data)
                    excel_file = f"{export_dir}/sales_data_{month_str}.xlsx"
                    df.to_excel(excel_file, index=False)
                    
                    # 压缩文件
                    import gzip
                    import pickle
                    compressed_file = f"{export_dir}/sales_data_{month_str}.pkl.gz"
                    with gzip.open(compressed_file, 'wb') as f:
                        pickle.dump(sales_data, f, protocol=pickle.HIGHEST_PROTOCOL)
                    
                    # 计算压缩率
                    import os
                    excel_size = os.path.getsize(excel_file) / (1024 * 1024)  # MB
                    compressed_size = os.path.getsize(compressed_file) / (1024 * 1024)  # MB
                    compression_ratio = (1 - compressed_size / excel_size) * 100 if excel_size > 0 else 0
                    
                    self.update_export_progress(f"    ✓ {db_display} {month_str}: {len(sales_data)} 条记录")
                    self.update_export_progress(f"    📊 压缩率: {compression_ratio:.1f}% (Excel: {excel_size:.2f}MB → 压缩: {compressed_size:.2f}MB)")
                
                # 移动到下个月
                if current_date.month == 12:
                    current_date = current_date.replace(year=current_date.year + 1, month=1)
                else:
                    current_date = current_date.replace(month=current_date.month + 1)
            
            # 保存完整文件
            if all_sales_data and not self.export_cancelled:
                df_all = pd.DataFrame(all_sales_data)
                excel_file = f"{export_dir}/all_sales_data_{start_date}_to_{end_date}.xlsx"
                df_all.to_excel(excel_file, index=False)
                
                # 压缩完整文件
                import gzip
                import pickle
                compressed_file = f"{export_dir}/all_sales_data_{start_date}_to_{end_date}.pkl.gz"
                with gzip.open(compressed_file, 'wb') as f:
                    pickle.dump(all_sales_data, f, protocol=pickle.HIGHEST_PROTOCOL)
                
                # 计算压缩率
                import os
                excel_size = os.path.getsize(excel_file) / (1024 * 1024)  # MB
                compressed_size = os.path.getsize(compressed_file) / (1024 * 1024)  # MB
                compression_ratio = (1 - compressed_size / excel_size) * 100 if excel_size > 0 else 0
                
                db_data["sales_data"] = all_sales_data
                self.update_export_progress(f"✓ {db_display} 销售数据导出完成，总计 {len(all_sales_data)} 条记录")
                self.update_export_progress(f"📊 完整文件压缩率: {compression_ratio:.1f}% (Excel: {excel_size:.2f}MB → 压缩: {compressed_size:.2f}MB)")
            
        except Exception as e:
            self.update_export_progress(f"✗ {db_display} 导出销售数据失败: {e}")
    
    def ultra_fast_export(self):
        """超快速导出 - 只导出当前数据库的基本数据"""
        try:
            import threading
            self.log_message("⚡ 开始超快速导出...")
            self.log_message("ℹ️ 只导出当前数据库的基本数据，速度极快")
            
            # 创建简单的进度窗口
            self.create_simple_progress_window("超快速导出中...")
            
            # 启动后台线程
            export_thread = threading.Thread(target=self._ultra_fast_export_worker, daemon=True)
            export_thread.start()
            
        except Exception as e:
            self.log_message(f"✗ 超快速导出失败: {e}")
    
    def super_fast_export_6months(self):
        """6个月超快速导出（包含支付方式）"""
        try:
            import threading
            self.log_message("🚀 开始6个月超快速导出...")
            self.log_message("ℹ️ 导出最近6个月数据，包含支付方式，预计耗时2-5分钟")
            
            # 创建进度窗口
            self.create_simple_progress_window("🚀 6个月快速导出")
            
            # 启动后台线程
            export_thread = threading.Thread(target=self._super_fast_export_6months_worker, daemon=True)
            export_thread.start()
            
        except Exception as e:
            self.log_message(f"✗ 6个月快速导出失败: {e}")
    
    def staged_export_all_data(self):
        """分阶段导出所有数据：先导出其他数据，最后导出销售数据"""
        try:
            import threading
            self.log_message("📋 开始分段式导出指定数据...")
            self.log_message("ℹ️ 导出顺序：Payment Analysis → Discount Analysis → Monthly Product Data → Daily Product Data → Weekly Product Data → Daily Product Analysis → Category Analysis → Sales Raw Data")
            self.log_message("ℹ️ 预计总耗时：20-30分钟")
            
            # 创建进度窗口
            self.create_simple_progress_window("📋 分段式导出")
            
            # 启动后台线程
            export_thread = threading.Thread(target=self._staged_export_worker, daemon=True)
            export_thread.start()
            
        except Exception as e:
            self.log_message(f"✗ 分段式导出失败: {e}")
    
    def _staged_export_worker(self):
        """分阶段导出工作线程"""
        try:
            import os
            import pandas as pd
            import gzip
            import pickle
            from datetime import datetime, timedelta
            
            export_dir = "staged_export_specific_data"
            os.makedirs(export_dir, exist_ok=True)
            
            # 获取当前数据库的基本信息
            current_db = self.db_manager.current_database
            if current_db is None:
                current_db = self.selected_db.get()  # 使用UI选择的数据库
            
            if current_db is None or current_db == "":
                self.update_simple_progress("⚠️ 未选择数据库")
                return
                
            db_display = "GOGO" if "gogo" in current_db.lower() else "Express"
            
            self.update_simple_progress(f"📊 开始分阶段导出 {db_display} 数据库...")
            
            # 先连接到数据库
            self.update_simple_progress("🔗 正在连接到数据库...")
            if not self.db_manager.connect(current_db):
                self.update_simple_progress("⚠️ 无法连接到数据库")
                return
            
            # 获取日期范围
            self.update_simple_progress("📅 正在获取数据日期范围...")
            date_range = self.get_available_date_range()
            if not date_range:
                self.update_simple_progress("⚠️ 数据库无数据")
                self.db_manager.disconnect()
                return
            
            start_date, end_date = date_range
            self.update_simple_progress(f"📅 数据范围: {start_date} 到 {end_date}")
            
            # 阶段1：Payment Analysis
            self.update_simple_progress("💳 阶段1：导出Payment Analysis...")
            try:
                payment_data = self.db_manager.get_payment_analysis(
                    date_from=start_date,
                    date_to=end_date,
                    outlet_filters=None,
                    product_filters=None,
                    month_filters=None,
                    category_filters=None,
                    payment_filters=None
                )
                
                if payment_data:
                    df_payment = pd.DataFrame(payment_data)
                    payment_file = f"{export_dir}/{db_display}_payment_analysis.xlsx"
                    df_payment.to_excel(payment_file, index=False)
                    self.update_simple_progress(f"   ✅ Payment Analysis: {len(payment_data)} 条记录")
                    self.log_message(f"✅ Payment Analysis导出完成: {payment_file}")
                else:
                    self.update_simple_progress("   ⚠️ Payment Analysis数据为空")
            except Exception as e:
                self.update_simple_progress(f"   ✗ Payment Analysis导出失败: {e}")
            
            # 阶段2：Discount Analysis
            self.update_simple_progress("💰 阶段2：导出Discount Analysis...")
            try:
                discount_data = self.db_manager.get_discount_analysis(
                    date_from=start_date,
                    date_to=end_date,
                    outlet_filters=None,
                    product_filters=None,
                    month_filters=None,
                    category_filters=None,
                    payment_filters=None
                )
                
                if discount_data:
                    df_discount = pd.DataFrame(discount_data)
                    discount_file = f"{export_dir}/{db_display}_discount_analysis.xlsx"
                    df_discount.to_excel(discount_file, index=False)
                    self.update_simple_progress(f"   ✅ Discount Analysis: {len(discount_data)} 条记录")
                    self.log_message(f"✅ Discount Analysis导出完成: {discount_file}")
                else:
                    self.update_simple_progress("   ⚠️ Discount Analysis数据为空")
            except Exception as e:
                self.update_simple_progress(f"   ✗ Discount Analysis导出失败: {e}")
            
            # 阶段3：Monthly Product Data (月-销售数据)
            self.update_simple_progress("📊 阶段3：导出Monthly Product Data...")
            try:
                monthly_data = self.db_manager.get_monthly_summary_optimized(
                    date_from=start_date,
                    date_to=end_date,
                    outlet_filters=None,
                    product_filters=None,
                    month_filters=None,
                    category_filters=None,
                    payment_filters=None
                )
                
                if monthly_data:
                    df_monthly = pd.DataFrame(monthly_data)
                    monthly_file = f"{export_dir}/{db_display}_monthly_product_data.xlsx"
                    df_monthly.to_excel(monthly_file, index=False)
                    self.update_simple_progress(f"   ✅ Monthly Product Data: {len(monthly_data)} 条记录")
                    self.log_message(f"✅ Monthly Product Data导出完成: {monthly_file}")
                else:
                    self.update_simple_progress("   ⚠️ Monthly Product Data数据为空")
            except Exception as e:
                self.update_simple_progress(f"   ✗ Monthly Product Data导出失败: {e}")
            
            # 阶段4：Daily Product Data (日-产品数据)
            self.update_simple_progress("📅 阶段4：导出Daily Product Data...")
            try:
                daily_product_data = self.db_manager.get_product_overview(
                    date_from=start_date,
                    date_to=end_date,
                    outlet_filters=None,
                    month_filters=None,
                    weekday_filters=None,
                    category_filters=None,
                    payment_filters=None
                )
                
                if daily_product_data:
                    df_daily = pd.DataFrame(daily_product_data)
                    daily_file = f"{export_dir}/{db_display}_daily_product_data.xlsx"
                    df_daily.to_excel(daily_file, index=False)
                    self.update_simple_progress(f"   ✅ Daily Product Data: {len(daily_product_data)} 条记录")
                    self.log_message(f"✅ Daily Product Data导出完成: {daily_file}")
                else:
                    self.update_simple_progress("   ⚠️ Daily Product Data数据为空")
            except Exception as e:
                self.update_simple_progress(f"   ✗ Daily Product Data导出失败: {e}")
            
            # 阶段5：Weekly Product Data (周-产品数据)
            self.update_simple_progress("📈 阶段5：导出Weekly Product Data...")
            try:
                weekly_product_data = self.db_manager.get_weekly_product_data(
                    date_from=start_date,
                    date_to=end_date,
                    outlet_filters=None,
                    product_filters=None,
                    month_filters=None,
                    category_filters=None,
                    payment_filters=None
                )
                
                if weekly_product_data:
                    df_weekly = pd.DataFrame(weekly_product_data)
                    weekly_file = f"{export_dir}/{db_display}_weekly_product_data.xlsx"
                    df_weekly.to_excel(weekly_file, index=False)
                    self.update_simple_progress(f"   ✅ Weekly Product Data: {len(weekly_product_data)} 条记录")
                    self.log_message(f"✅ Weekly Product Data导出完成: {weekly_file}")
                else:
                    self.update_simple_progress("   ⚠️ Weekly Product Data数据为空")
            except Exception as e:
                self.update_simple_progress(f"   ✗ Weekly Product Data导出失败: {e}")
            
            # 阶段6：Daily Product Analysis (日-产品分析)
            self.update_simple_progress("🔍 阶段6：导出Daily Product Analysis...")
            try:
                daily_analysis_data = self.db_manager.get_sales_tc_analysis(
                    date_from=start_date,
                    date_to=end_date,
                    outlet_filters=None,
                    product_filters=None,
                    month_filters=None,
                    weekday_filters=None,
                    category_filters=None,
                    payment_filters=None
                )
                
                if daily_analysis_data:
                    df_daily_analysis = pd.DataFrame(daily_analysis_data)
                    daily_analysis_file = f"{export_dir}/{db_display}_daily_product_analysis.xlsx"
                    df_daily_analysis.to_excel(daily_analysis_file, index=False)
                    self.update_simple_progress(f"   ✅ Daily Product Analysis: {len(daily_analysis_data)} 条记录")
                    self.log_message(f"✅ Daily Product Analysis导出完成: {daily_analysis_file}")
                else:
                    self.update_simple_progress("   ⚠️ Daily Product Analysis数据为空")
            except Exception as e:
                self.update_simple_progress(f"   ✗ Daily Product Analysis导出失败: {e}")
            
            # 阶段7：Category Analysis (类别分析)
            self.update_simple_progress("📂 阶段7：导出Category Analysis...")
            try:
                category_data = self.db_manager.get_category_analysis(
                    date_from=start_date,
                    date_to=end_date,
                    outlet_filters=None,
                    product_filters=None,
                    month_filters=None,
                    weekday_filters=None,
                    category_filters=None,
                    payment_filters=None
                )
                
                if category_data:
                    df_category = pd.DataFrame(category_data)
                    category_file = f"{export_dir}/{db_display}_category_analysis.xlsx"
                    df_category.to_excel(category_file, index=False)
                    self.update_simple_progress(f"   ✅ Category Analysis: {len(category_data)} 条记录")
                    self.log_message(f"✅ Category Analysis导出完成: {category_file}")
                else:
                    self.update_simple_progress("   ⚠️ Category Analysis数据为空")
            except Exception as e:
                self.update_simple_progress(f"   ✗ Category Analysis导出失败: {e}")
            
            # 阶段8：Sales Raw Data (最后导出，包含支付方式)
            self.update_simple_progress("🛒 阶段8：导出Sales Raw Data（包含支付方式，最耗时）...")
            self.update_simple_progress("   ⏰ 预计需要10-15分钟，请耐心等待...")
            
            # 按月导出销售数据
            current_date = datetime.strptime(start_date, '%Y-%m-%d')
            end_datetime = datetime.strptime(end_date, '%Y-%m-%d')
            
            all_sales_data = []
            month_count = 0
            
            while current_date <= end_datetime:
                month_start = current_date.replace(day=1)
                if current_date.month == 12:
                    month_end = current_date.replace(year=current_date.year + 1, month=1, day=1) - timedelta(days=1)
                else:
                    month_end = current_date.replace(month=current_date.month + 1, day=1) - timedelta(days=1)
                
                # 确保不超过结束日期
                if month_end > end_datetime:
                    month_end = end_datetime
                
                month_str = month_start.strftime('%Y-%m')
                month_count += 1
                self.update_simple_progress(f"   📅 正在导出 {month_str} 销售数据... ({month_count})")
                
                # 获取该月数据
                sales_data = self.db_manager.get_sales_data(
                    date_from=month_start.strftime('%Y-%m-%d'),
                    date_to=month_end.strftime('%Y-%m-%d'),
                    use_excel_cache=True
                )
                
                if sales_data:
                    # 为每条记录添加数据库标识
                    for record in sales_data:
                        record['数据库来源'] = db_display
                        record['数据库来源\nDatabase Source'] = db_display
                    
                    all_sales_data.extend(sales_data)
                    
                    # 保存月度文件
                    df_month = pd.DataFrame(sales_data)
                    month_file = f"{export_dir}/{db_display}_sales_raw_{month_str}.xlsx"
                    df_month.to_excel(month_file, index=False)
                    
                    # 压缩月度文件
                    compressed_file = f"{export_dir}/{db_display}_sales_raw_{month_str}.pkl.gz"
                    with gzip.open(compressed_file, 'wb') as f:
                        pickle.dump(sales_data, f, protocol=pickle.HIGHEST_PROTOCOL)
                    
                    self.update_simple_progress(f"   ✅ {month_str}: {len(sales_data)} 条记录")
                
                # 移动到下个月
                if current_date.month == 12:
                    current_date = current_date.replace(year=current_date.year + 1, month=1)
                else:
                    current_date = current_date.replace(month=current_date.month + 1)
            
            # 保存完整销售数据文件
            if all_sales_data:
                self.update_simple_progress("💾 正在保存完整销售数据文件...")
                
                df_all = pd.DataFrame(all_sales_data)
                all_file = f"{export_dir}/{db_display}_all_sales_raw_data.xlsx"
                df_all.to_excel(all_file, index=False)
                
                # 压缩完整文件
                compressed_all_file = f"{export_dir}/{db_display}_all_sales_raw_data.pkl.gz"
                with gzip.open(compressed_all_file, 'wb') as f:
                    pickle.dump(all_sales_data, f, protocol=pickle.HIGHEST_PROTOCOL)
                
                # 计算压缩率
                excel_size = os.path.getsize(all_file) / (1024 * 1024)  # MB
                compressed_size = os.path.getsize(compressed_all_file) / (1024 * 1024)  # MB
                compression_ratio = (1 - compressed_size / excel_size) * 100 if excel_size > 0 else 0
                
                self.update_simple_progress(f"✅ 完整Sales Raw Data: {len(all_sales_data)} 条记录")
                self.update_simple_progress(f"📁 Excel: {excel_size:.2f}MB")
                self.update_simple_progress(f"🗜️ 压缩: {compressed_size:.2f}MB (压缩率: {compression_ratio:.1f}%)")
                
                self.log_message(f"✅ 完整Sales Raw Data导出完成:")
                self.log_message(f"   - Excel文件: {all_file} ({excel_size:.2f} MB)")
                self.log_message(f"   - 压缩文件: {compressed_all_file} ({compressed_size:.2f} MB)")
                self.log_message(f"   - 压缩率: {compression_ratio:.1f}%")
                self.log_message(f"   - 总记录数: {len(all_sales_data)}")
                self.log_message(f"   - 包含支付方式: ✅")
            
            # 完成
            self.update_simple_progress("🎉 分段式导出完成！")
            self.simple_progress_bar.stop()
            self.simple_progress_bar.config(mode='determinate', value=100)
            self.simple_close_button.config(state="normal")
            
            # 断开数据库连接
            self.db_manager.disconnect()
            
            self.log_message(f"🎉 分段式导出完成！所有数据已保存到: {export_dir}/")
            
        except Exception as e:
            self.update_simple_progress(f"✗ 导出失败: {e}")
            self.simple_progress_bar.stop()
            self.simple_close_button.config(state="normal")
            self.log_message(f"✗ 分段式导出失败: {e}")
    
    def new_staged_export(self):
        """新的分段式导出：先导出所有数据库的前7个报告，最后导出Sales Raw Data"""
        try:
            import threading
            self.log_message("📋 开始新的分段式导出...")
            self.log_message("ℹ️ 策略：先导出所有数据库的前7个报告，最后导出Sales Raw Data")
            self.log_message("ℹ️ 预计总耗时：20-30分钟")
            
            # 创建进度窗口
            self.create_simple_progress_window("📋 新分段式导出")
            
            # 启动后台线程
            export_thread = threading.Thread(target=self._new_staged_export_worker, daemon=True)
            export_thread.start()
            
        except Exception as e:
            self.log_message(f"✗ 新分段式导出失败: {e}")
    
    def _new_staged_export_worker(self):
        """新的分段式导出工作线程"""
        try:
            import os
            import pandas as pd
            import gzip
            import pickle
            from datetime import datetime, timedelta
            
            export_dir = "new_staged_export_specific_data"
            os.makedirs(export_dir, exist_ok=True)
            
            # 定义要处理的数据库列表
            databases = [
                {"name": "GOGO", "db": "sushi_gogo_pos_live"},
                {"name": "Express", "db": "sushi_express_pos_live"},
                {"name": "PLUS", "db": "sushi_plus_pos_live"}  # 未来的数据库
            ]
            
            self.update_simple_progress("🚀 开始新的分段式导出...")
            self.update_simple_progress("📋 策略：先导出所有数据库的前7个报告，最后导出Sales Raw Data")
            
            # 获取日期范围（使用当前选择的数据库）
            current_db = self.selected_db.get()
            if not current_db:
                self.update_simple_progress("⚠️ 未选择数据库")
                return
                
            # 先连接到当前数据库获取日期范围
            if not self.db_manager.connect(current_db):
                self.update_simple_progress("⚠️ 无法连接到数据库")
                return
            
            self.update_simple_progress("📅 正在获取数据日期范围...")
            date_range = self.get_available_date_range()
            if not date_range:
                self.update_simple_progress("⚠️ 数据库无数据")
                self.db_manager.disconnect()
                return
            
            start_date, end_date = date_range
            self.update_simple_progress(f"📅 数据范围: {start_date} 到 {end_date}")
            
            # 阶段1-7：导出所有数据库的分析报告（不包含Sales Raw Data）
            for db_info in databases:
                db_name = db_info["name"]
                db_connection = db_info["db"]
                
                self.update_simple_progress(f"🗄️ 正在处理 {db_name} 数据库...")
                
                # 连接到当前数据库
                self.update_simple_progress(f"🔗 正在连接到 {db_name} 数据库...")
                if not self.db_manager.connect(db_connection):
                    self.update_simple_progress(f"⚠️ 无法连接到 {db_name} 数据库，跳过")
                    continue
                self.update_simple_progress(f"✅ {db_name} 数据库连接成功")
                
                # 阶段1：Payment Analysis
                self.update_simple_progress(f"💳 {db_name} - 阶段1：导出Payment Analysis...")
                try:
                    payment_data = self.db_manager.get_payment_summary(
                        date_from=start_date, date_to=end_date,
                        outlet_filters=None, month_filters=None,
                        category_filters=None, payment_filters=None
                    )
                    if payment_data:
                        df_payment = pd.DataFrame(payment_data)
                        payment_file = f"{export_dir}/{db_name}_payment_analysis.xlsx"
                        df_payment.to_excel(payment_file, index=False)
                        self.update_simple_progress(f"   ✅ {db_name} Payment Analysis: {len(payment_data)} 条记录")
                    else:
                        self.update_simple_progress(f"   ⚠️ {db_name} Payment Analysis数据为空")
                except Exception as e:
                    self.update_simple_progress(f"   ✗ {db_name} Payment Analysis导出失败: {e}")
                    self.log_message(f"✗ {db_name} Payment Analysis导出失败: {e}")
                
                # 阶段2：Discount Analysis
                self.update_simple_progress(f"💰 {db_name} - 阶段2：导出Discount Analysis...")
                try:
                    discount_data = self.db_manager.get_discount_analysis(
                        date_from=start_date, date_to=end_date,
                        outlet_filters=None, month_filters=None,
                        weekday_filters=None, category_filters=None, payment_filters=None
                    )
                    if discount_data:
                        df_discount = pd.DataFrame(discount_data)
                        discount_file = f"{export_dir}/{db_name}_discount_analysis.xlsx"
                        df_discount.to_excel(discount_file, index=False)
                        self.update_simple_progress(f"   ✅ {db_name} Discount Analysis: {len(discount_data)} 条记录")
                    else:
                        self.update_simple_progress(f"   ⚠️ {db_name} Discount Analysis数据为空")
                except Exception as e:
                    self.update_simple_progress(f"   ✗ {db_name} Discount Analysis导出失败: {e}")
                    self.log_message(f"✗ {db_name} Discount Analysis导出失败: {e}")
                
                # 阶段3：Monthly Product Data
                self.update_simple_progress(f"📊 {db_name} - 阶段3：导出Monthly Product Data...")
                try:
                    monthly_data = self.db_manager.get_monthly_summary_optimized(
                        date_from=start_date, date_to=end_date,
                        outlet_filters=None, product_filters=None, month_filters=None,
                        category_filters=None, payment_filters=None
                    )
                    if monthly_data:
                        df_monthly = pd.DataFrame(monthly_data)
                        monthly_file = f"{export_dir}/{db_name}_monthly_product_data.xlsx"
                        df_monthly.to_excel(monthly_file, index=False)
                        self.update_simple_progress(f"   ✅ {db_name} Monthly Product Data: {len(monthly_data)} 条记录")
                    else:
                        self.update_simple_progress(f"   ⚠️ {db_name} Monthly Product Data数据为空")
                except Exception as e:
                    self.update_simple_progress(f"   ✗ {db_name} Monthly Product Data导出失败: {e}")
                
                # 阶段4：Daily Product Data
                self.update_simple_progress(f"📅 {db_name} - 阶段4：导出Daily Product Data...")
                try:
                    daily_product_data = self.db_manager.get_product_overview(
                        date_from=start_date, date_to=end_date,
                        outlet_filters=None, month_filters=None, weekday_filters=None,
                        category_filters=None, payment_filters=None
                    )
                    if daily_product_data:
                        df_daily = pd.DataFrame(daily_product_data)
                        daily_file = f"{export_dir}/{db_name}_daily_product_data.xlsx"
                        df_daily.to_excel(daily_file, index=False)
                        self.update_simple_progress(f"   ✅ {db_name} Daily Product Data: {len(daily_product_data)} 条记录")
                    else:
                        self.update_simple_progress(f"   ⚠️ {db_name} Daily Product Data数据为空")
                except Exception as e:
                    self.update_simple_progress(f"   ✗ {db_name} Daily Product Data导出失败: {e}")
                
                # 阶段5：Weekly Product Data
                self.update_simple_progress(f"📈 {db_name} - 阶段5：导出Weekly Product Data...")
                try:
                    weekly_product_data = self.db_manager.get_weekly_product_data(
                        date_from=start_date, date_to=end_date,
                        outlet_filters=None, month_filters=None,
                        weekday_filters=None, category_filters=None, payment_filters=None
                    )
                    if weekly_product_data:
                        df_weekly = pd.DataFrame(weekly_product_data)
                        weekly_file = f"{export_dir}/{db_name}_weekly_product_data.xlsx"
                        df_weekly.to_excel(weekly_file, index=False)
                        self.update_simple_progress(f"   ✅ {db_name} Weekly Product Data: {len(weekly_product_data)} 条记录")
                    else:
                        self.update_simple_progress(f"   ⚠️ {db_name} Weekly Product Data数据为空")
                except Exception as e:
                    self.update_simple_progress(f"   ✗ {db_name} Weekly Product Data导出失败: {e}")
                
                # 阶段6：Daily Product Analysis
                self.update_simple_progress(f"🔍 {db_name} - 阶段6：导出Daily Product Analysis...")
                try:
                    daily_analysis_data = self.db_manager.get_sales_tc_analysis(
                        date_from=start_date, date_to=end_date,
                        outlet_filters=None, product_filters=None, month_filters=None,
                        weekday_filters=None, category_filters=None, payment_filters=None
                    )
                    if daily_analysis_data:
                        df_daily_analysis = pd.DataFrame(daily_analysis_data)
                        daily_analysis_file = f"{export_dir}/{db_name}_daily_product_analysis.xlsx"
                        df_daily_analysis.to_excel(daily_analysis_file, index=False)
                        self.update_simple_progress(f"   ✅ {db_name} Daily Product Analysis: {len(daily_analysis_data)} 条记录")
                    else:
                        self.update_simple_progress(f"   ⚠️ {db_name} Daily Product Analysis数据为空")
                except Exception as e:
                    self.update_simple_progress(f"   ✗ {db_name} Daily Product Analysis导出失败: {e}")
                
                # 阶段7：Category Analysis
                self.update_simple_progress(f"📂 {db_name} - 阶段7：导出Category Analysis...")
                try:
                    category_data = self.db_manager.get_category_analysis(
                        date_from=start_date, date_to=end_date,
                        outlet_filters=None, month_filters=None,
                        weekday_filters=None, category_filters=None, payment_filters=None
                    )
                    if category_data:
                        df_category = pd.DataFrame(category_data)
                        category_file = f"{export_dir}/{db_name}_category_analysis.xlsx"
                        df_category.to_excel(category_file, index=False)
                        self.update_simple_progress(f"   ✅ {db_name} Category Analysis: {len(category_data)} 条记录")
                    else:
                        self.update_simple_progress(f"   ⚠️ {db_name} Category Analysis数据为空")
                except Exception as e:
                    self.update_simple_progress(f"   ✗ {db_name} Category Analysis导出失败: {e}")
                
                self.update_simple_progress(f"✅ {db_name} 数据库前7个报告导出完成")
            
            # 阶段8：最后导出所有数据库的Sales Raw Data
            self.update_simple_progress("🛒 阶段8：导出所有数据库的Sales Raw Data（包含支付方式，最耗时）...")
            self.update_simple_progress("   ⏰ 预计需要15-25分钟，请耐心等待...")
            
            for db_info in databases:
                db_name = db_info["name"]
                db_connection = db_info["db"]
                
                self.update_simple_progress(f"🛒 正在导出 {db_name} 的Sales Raw Data...")
                
                # 连接到当前数据库
                self.update_simple_progress(f"🔗 正在连接到 {db_name} 数据库...")
                if not self.db_manager.connect(db_connection):
                    self.update_simple_progress(f"⚠️ 无法连接到 {db_name} 数据库，跳过Sales Raw Data")
                    continue
                self.update_simple_progress(f"✅ {db_name} 数据库连接成功")
                
                # 按月导出销售数据
                current_date = datetime.strptime(start_date, '%Y-%m-%d')
                end_datetime = datetime.strptime(end_date, '%Y-%m-%d')
                
                all_sales_data = []
                month_count = 0
                
                while current_date <= end_datetime:
                    month_start = current_date.replace(day=1)
                    if current_date.month == 12:
                        month_end = current_date.replace(year=current_date.year + 1, month=1, day=1) - timedelta(days=1)
                    else:
                        month_end = current_date.replace(month=current_date.month + 1, day=1) - timedelta(days=1)
                    
                    # 确保不超过结束日期
                    if month_end > end_datetime:
                        month_end = end_datetime
                    
                    month_str = month_start.strftime('%Y-%m')
                    month_count += 1
                    self.update_simple_progress(f"   📅 {db_name} - 正在导出 {month_str} 销售数据... ({month_count})")
                    
                    # 获取该月数据（包含支付方式）
                    sales_data = self.db_manager.get_sales_data(
                        date_from=month_start.strftime('%Y-%m-%d'),
                        date_to=month_end.strftime('%Y-%m-%d'),
                    
                        use_excel_cache=True
                    )
                    
                    if sales_data:
                        # 为每条记录添加数据库标识
                        for record in sales_data:
                            record['数据库来源'] = db_name
                            record['数据库来源\nDatabase Source'] = db_name
                        
                        all_sales_data.extend(sales_data)
                        
                        # 保存月度文件
                        df_month = pd.DataFrame(sales_data)
                        month_file = f"{export_dir}/{db_name}_sales_raw_{month_str}.xlsx"
                        df_month.to_excel(month_file, index=False)
                        
                        # 压缩月度文件
                        compressed_file = f"{export_dir}/{db_name}_sales_raw_{month_str}.pkl.gz"
                        with gzip.open(compressed_file, 'wb') as f:
                            pickle.dump(sales_data, f, protocol=pickle.HIGHEST_PROTOCOL)
                        
                        self.update_simple_progress(f"   ✅ {db_name} {month_str}: {len(sales_data)} 条记录")
                    
                    # 移动到下个月
                    if current_date.month == 12:
                        current_date = current_date.replace(year=current_date.year + 1, month=1)
                    else:
                        current_date = current_date.replace(month=current_date.month + 1)
                
                # 保存完整销售数据文件
                if all_sales_data:
                    self.update_simple_progress(f"💾 正在保存 {db_name} 完整Sales Raw Data文件...")
                    
                    # 检查数据量是否超过Excel限制
                    max_excel_rows = 1048576  # Excel最大行数
                    
                    if len(all_sales_data) > max_excel_rows:
                        self.update_simple_progress(f"⚠️ {db_name} 数据量过大 ({len(all_sales_data):,} 行)，超过Excel限制 ({max_excel_rows:,} 行)")
                        self.update_simple_progress(f"📁 仅保存压缩文件...")
                        
                        # 只保存压缩文件
                        compressed_all_file = f"{export_dir}/{db_name}_all_sales_raw_data.pkl.gz"
                        with gzip.open(compressed_all_file, 'wb') as f:
                            pickle.dump(all_sales_data, f, protocol=pickle.HIGHEST_PROTOCOL)
                        
                        compressed_size = os.path.getsize(compressed_all_file) / (1024 * 1024)  # MB
                        self.update_simple_progress(f"✅ {db_name} 压缩文件保存成功: {compressed_size:.2f} MB")
                        
                        # 尝试分批保存Excel文件
                        try:
                            self.update_simple_progress(f"📋 尝试分批保存 {db_name} Excel文件...")
                            batch_size = max_excel_rows - 1000  # 留一些余量
                            total_batches = (len(all_sales_data) + batch_size - 1) // batch_size
                            
                            for batch_num in range(total_batches):
                                start_idx = batch_num * batch_size
                                end_idx = min(start_idx + batch_size, len(all_sales_data))
                                batch_data = all_sales_data[start_idx:end_idx]
                                
                                batch_file = f"{export_dir}/{db_name}_sales_raw_data_batch_{batch_num + 1}_of_{total_batches}.xlsx"
                                df_batch = pd.DataFrame(batch_data)
                                df_batch.to_excel(batch_file, index=False)
                                
                                batch_size_mb = os.path.getsize(batch_file) / (1024 * 1024)
                                self.update_simple_progress(f"✓ 批次 {batch_num + 1}/{total_batches}: {batch_size_mb:.2f} MB")
                            
                            self.update_simple_progress(f"✅ {db_name} 成功分批保存 {total_batches} 个Excel文件")
                            
                        except Exception as e:
                            self.update_simple_progress(f"⚠️ {db_name} 分批保存Excel失败: {e}")
                            self.update_simple_progress(f"💡 建议使用压缩文件进行数据分析")
                        
                        excel_size = 0  # 没有单个Excel文件
                        compression_ratio = 0  # 无法计算压缩率
                        
                    else:
                        # 数据量在Excel限制范围内，正常保存
                        df_all = pd.DataFrame(all_sales_data)
                        all_file = f"{export_dir}/{db_name}_all_sales_raw_data.xlsx"
                        df_all.to_excel(all_file, index=False)
                        
                        # 压缩完整文件
                        compressed_all_file = f"{export_dir}/{db_name}_all_sales_raw_data.pkl.gz"
                        with gzip.open(compressed_all_file, 'wb') as f:
                            pickle.dump(all_sales_data, f, protocol=pickle.HIGHEST_PROTOCOL)
                        
                        # 计算压缩率
                        excel_size = os.path.getsize(all_file) / (1024 * 1024)  # MB
                        compressed_size = os.path.getsize(compressed_all_file) / (1024 * 1024)  # MB
                        compression_ratio = (1 - compressed_size / excel_size) * 100 if excel_size > 0 else 0
                    
                    self.update_simple_progress(f"✅ {db_name} 完整Sales Raw Data: {len(all_sales_data)} 条记录")
                    self.update_simple_progress(f"📁 Excel: {excel_size:.2f}MB")
                    self.update_simple_progress(f"🗜️ 压缩: {compressed_size:.2f}MB (压缩率: {compression_ratio:.1f}%)")
                    
                    self.log_message(f"✅ {db_name} 完整Sales Raw Data导出完成:")
                    self.log_message(f"   - Excel文件: {all_file} ({excel_size:.2f} MB)")
                    self.log_message(f"   - 压缩文件: {compressed_all_file} ({compressed_size:.2f} MB)")
                    self.log_message(f"   - 压缩率: {compression_ratio:.1f}%")
                    self.log_message(f"   - 总记录数: {len(all_sales_data)}")
                    self.log_message(f"   - 包含支付方式: ✅")
                
                self.update_simple_progress(f"✅ {db_name} Sales Raw Data导出完成")
            
            # 完成
            self.update_simple_progress("🎉 新的分段式导出完成！")
            self.simple_progress_bar.stop()
            self.simple_progress_bar.config(mode='determinate', value=100)
            self.simple_close_button.config(state="normal")
            
            # 断开数据库连接
            self.db_manager.disconnect()
            
            self.log_message(f"🎉 新的分段式导出完成！所有数据已保存到: {export_dir}/")
            self.log_message("📋 导出顺序：所有数据库的前7个报告 → 所有数据库的Sales Raw Data")
            
        except Exception as e:
            self.update_simple_progress(f"✗ 导出失败: {e}")
            self.simple_progress_bar.stop()
            self.simple_close_button.config(state="normal")
            self.log_message(f"✗ 新的分段式导出失败: {e}")
            if self.db_manager.connection:
                self.db_manager.disconnect()
    
    def create_simple_progress_window(self, title):
        """创建简单的进度窗口"""
        try:
            self.simple_progress_window = tk.Toplevel(self.root)
            self.simple_progress_window.title(title)
            self.simple_progress_window.geometry("500x200")
            self.simple_progress_window.resizable(False, False)
            
            # 居中显示
            self.simple_progress_window.transient(self.root)
            
            # 进度信息
            progress_frame = tk.Frame(self.simple_progress_window, padding="20")
            progress_frame.pack(fill="both", expand=True)
            
            # 标题
            title_label = tk.Label(progress_frame, text=title, font=("Arial", 12, "bold"))
            title_label.pack(pady=(0, 10))
            
            # 状态标签
            self.simple_status_label = tk.Label(progress_frame, text="准备开始...", font=("Arial", 10))
            self.simple_status_label.pack(pady=(0, 10))
            
            # 进度条
            self.simple_progress_bar = ttk.Progressbar(progress_frame, length=300, mode='indeterminate')
            self.simple_progress_bar.pack(pady=(0, 10))
            self.simple_progress_bar.start()
            
            # 关闭按钮
            self.simple_close_button = ttk.Button(progress_frame, text="关闭\nClose", 
                                                 command=self.close_simple_progress, state="disabled")
            self.simple_close_button.pack()
            
        except Exception as e:
            self.log_message(f"✗ 创建简单进度窗口失败: {e}")
    
    def close_simple_progress(self):
        """关闭简单进度窗口"""
        try:
            if hasattr(self, 'simple_progress_window') and self.simple_progress_window:
                self.simple_progress_window.destroy()
                self.simple_progress_window = None
        except Exception as e:
            print(f"关闭简单进度窗口失败: {e}")
    
    def update_simple_progress(self, message):
        """更新简单进度"""
        try:
            if hasattr(self, 'simple_status_label') and self.simple_status_label:
                self.simple_status_label.config(text=message)
                self.root.update()
        except Exception as e:
            print(f"更新简单进度失败: {e}")
    
    def _ultra_fast_export_worker(self):
        """超快速导出工作线程"""
        try:
            import os
            import pandas as pd
            
            export_dir = "ultra_fast_export"
            os.makedirs(export_dir, exist_ok=True)
            
            # 获取当前数据库的基本信息
            current_db = self.db_manager.current_database
            if current_db is None:
                current_db = self.selected_db.get()  # 使用UI选择的数据库
            
            if current_db is None or current_db == "":
                self.update_simple_progress("⚠️ 未选择数据库")
                return
                
            db_display = "GOGO" if "gogo" in current_db.lower() else "Express"
            
            self.update_simple_progress(f"正在导出 {db_display} 数据库...")
            
            # 先连接到数据库
            self.update_simple_progress("🔗 正在连接到数据库...")
            if not self.db_manager.connect(current_db):
                self.update_simple_progress("⚠️ 无法连接到数据库")
                return
            
            # 获取日期范围
            self.update_simple_progress("📅 正在获取数据日期范围...")
            date_range = self.get_available_date_range()
            if not date_range:
                self.update_simple_progress("⚠️ 数据库无数据")
                self.db_manager.disconnect()
                return
            
            start_date, end_date = date_range
            self.update_simple_progress(f"数据范围: {start_date} 到 {end_date}")
            
            # 只导出最近3个月的数据
            from datetime import datetime, timedelta
            end_datetime = datetime.strptime(end_date, '%Y-%m-%d')
            start_datetime = end_datetime - timedelta(days=90)  # 最近3个月
            
            self.update_simple_progress("正在获取销售数据...")
            
            # 获取数据（不包含支付方式）
            sales_data = self.db_manager.get_sales_data(
                date_from=start_datetime.strftime('%Y-%m-%d'),
                date_to=end_date,
                use_excel_cache=True
            )
            
            if sales_data:
                self.update_simple_progress(f"正在保存 {len(sales_data)} 条记录...")
                
                # 为每条记录添加数据库标识
                for record in sales_data:
                    record['数据库来源'] = db_display
                    record['数据库来源\nDatabase Source'] = db_display
                
                # 保存到Excel和压缩文件
                df = pd.DataFrame(sales_data)
                excel_file = f"{export_dir}/{db_display}_recent_3months.xlsx"
                compressed_file = f"{export_dir}/{db_display}_recent_3months.pkl.gz"
                
                # 保存Excel文件
                df.to_excel(excel_file, index=False)
                
                # 保存压缩文件
                import gzip
                import pickle
                with gzip.open(compressed_file, 'wb') as f:
                    pickle.dump(sales_data, f, protocol=pickle.HIGHEST_PROTOCOL)
                
                # 计算压缩率
                excel_size = os.path.getsize(excel_file) / (1024 * 1024)  # MB
                compressed_size = os.path.getsize(compressed_file) / (1024 * 1024)  # MB
                compression_ratio = (1 - compressed_size / excel_size) * 100 if excel_size > 0 else 0
                
                # 完成
                self.update_simple_progress(f"✅ 导出完成！")
                self.simple_progress_bar.stop()
                self.simple_progress_bar.config(mode='determinate', value=100)
                self.simple_close_button.config(state="normal")
                
                self.log_message(f"⚡ 超快速导出完成！")
                self.log_message(f"   - Excel文件: {excel_file} ({excel_size:.2f} MB)")
                self.log_message(f"   - 压缩文件: {compressed_file} ({compressed_size:.2f} MB)")
                self.log_message(f"   - 压缩率: {compression_ratio:.1f}%")
                self.log_message(f"   - 记录数: {len(sales_data)}")
            else:
                self.update_simple_progress("⚠️ 没有数据可导出")
                self.simple_progress_bar.stop()
                self.simple_close_button.config(state="normal")
            
        except Exception as e:
            self.update_simple_progress(f"✗ 导出失败: {e}")
            self.simple_progress_bar.stop()
            self.simple_close_button.config(state="normal")
            self.log_message(f"✗ 超快速导出失败: {e}")
    
    def get_available_date_range(self):
        """获取数据库中可用的日期范围"""
        try:
            cursor = self.db_manager.connection.cursor()
            
            # 获取最早和最晚的日期
            query = """
                SELECT 
                    MIN(CAST(c_date AS DATE)) as min_date,
                    MAX(CAST(c_date AS DATE)) as max_date
                FROM pos_sales_dtls 
                WHERE item_name NOT IN ('WASTAGE', 'Waste', 'waste', 'WASTE')
            """
            
            cursor.execute(query)
            result = cursor.fetchone()
            
            if result and result[0] and result[1]:
                return str(result[0]), str(result[1])
            else:
                return None
                
        except Exception as e:
            self.log_message(f"✗ 获取日期范围失败: {e}")
            return None
    
    def export_sales_data_by_period(self, start_date, end_date, export_dir, db_display, db_data):
        """按期间导出销售数据"""
        try:
            import pandas as pd
            from datetime import datetime, timedelta
            
            # 按月份导出
            current_date = datetime.strptime(start_date, '%Y-%m-%d')
            end_datetime = datetime.strptime(end_date, '%Y-%m-%d')
            
            all_sales_data = []
            
            while current_date <= end_datetime:
                month_start = current_date.replace(day=1)
                if current_date.month == 12:
                    month_end = current_date.replace(year=current_date.year + 1, month=1, day=1) - timedelta(days=1)
                else:
                    month_end = current_date.replace(month=current_date.month + 1, day=1) - timedelta(days=1)
                
                # 确保不超过结束日期
                if month_end > end_datetime:
                    month_end = end_datetime
                
                month_str = month_start.strftime('%Y-%m')
                self.log_message(f"  正在导出 {db_display} {month_str} 销售数据...")
                
                # 获取该月数据
                sales_data = self.db_manager.get_sales_data(
                    date_from=month_start.strftime('%Y-%m-%d'),
                    date_to=month_end.strftime('%Y-%m-%d')
                )
                
                if sales_data:
                    # 为每条记录添加数据库标识
                    for record in sales_data:
                        record['数据库来源'] = db_display
                        record['数据库来源\nDatabase Source'] = db_display
                    
                    all_sales_data.extend(sales_data)
                    # 保存月度文件
                    df = pd.DataFrame(sales_data)
                    df.to_excel(f"{export_dir}/sales_data_{month_str}.xlsx", index=False)
                    self.log_message(f"    ✓ {db_display} {month_str}: {len(sales_data)} 条记录")
                
                # 移动到下个月
                if current_date.month == 12:
                    current_date = current_date.replace(year=current_date.year + 1, month=1)
                else:
                    current_date = current_date.replace(month=current_date.month + 1)
            
            # 保存完整文件
            if all_sales_data:
                df_all = pd.DataFrame(all_sales_data)
                df_all.to_excel(f"{export_dir}/all_sales_data_{start_date}_to_{end_date}.xlsx", index=False)
                db_data["sales_data"] = all_sales_data
                self.log_message(f"✓ {db_display} 销售数据导出完成，总计 {len(all_sales_data)} 条记录")
            
        except Exception as e:
            self.log_message(f"✗ {db_display} 导出销售数据失败: {e}")
    
    def export_monthly_summary_data(self, start_date, end_date, export_dir, db_display, db_data):
        """导出月度汇总数据"""
        try:
            import pandas as pd
            
            monthly_data = self.db_manager.get_monthly_summary(start_date, end_date)
            if monthly_data:
                # 为每条记录添加数据库标识
                for record in monthly_data:
                    record['数据库来源'] = db_display
                    record['数据库来源\nDatabase Source'] = db_display
                
                df = pd.DataFrame(monthly_data)
                df.to_excel(f"{export_dir}/monthly_summary_{start_date}_to_{end_date}.xlsx", index=False)
                db_data["monthly_summary"] = monthly_data
                self.log_message(f"✓ {db_display} 月度汇总导出完成，共 {len(monthly_data)} 条记录")
            
        except Exception as e:
            self.log_message(f"✗ {db_display} 导出月度汇总失败: {e}")
    
    def export_product_analysis_data(self, start_date, end_date, export_dir, db_display, db_data):
        """导出产品分析数据"""
        try:
            import pandas as pd
            
            # 日-产品分析
            daily_product_data = self.db_manager.get_sales_tc_analysis(start_date, end_date)
            if daily_product_data:
                # 为每条记录添加数据库标识
                for record in daily_product_data:
                    record['数据库来源'] = db_display
                    record['数据库来源\nDatabase Source'] = db_display
                
                df = pd.DataFrame(daily_product_data)
                df.to_excel(f"{export_dir}/daily_product_analysis_{start_date}_to_{end_date}.xlsx", index=False)
                db_data["product_analysis"].extend(daily_product_data)
                self.log_message(f"✓ {db_display} 日-产品分析导出完成，共 {len(daily_product_data)} 条记录")
            
            # 月-产品分析
            monthly_product_data = self.db_manager.get_sales_tc_monthly(start_date, end_date)
            if monthly_product_data:
                # 为每条记录添加数据库标识
                for record in monthly_product_data:
                    record['数据库来源'] = db_display
                    record['数据库来源\nDatabase Source'] = db_display
                
                df = pd.DataFrame(monthly_product_data)
                df.to_excel(f"{export_dir}/monthly_product_analysis_{start_date}_to_{end_date}.xlsx", index=False)
                db_data["product_analysis"].extend(monthly_product_data)
                self.log_message(f"✓ {db_display} 月-产品分析导出完成，共 {len(monthly_product_data)} 条记录")
            
        except Exception as e:
            self.log_message(f"✗ {db_display} 导出产品分析失败: {e}")
    
    def export_discount_analysis_data(self, start_date, end_date, export_dir, db_display, db_data):
        """导出折扣分析数据"""
        try:
            import pandas as pd
            
            discount_data = self.db_manager.get_discount_analysis(start_date, end_date)
            if discount_data:
                # 为每条记录添加数据库标识
                for record in discount_data:
                    record['数据库来源'] = db_display
                    record['数据库来源\nDatabase Source'] = db_display
                
                df = pd.DataFrame(discount_data)
                df.to_excel(f"{export_dir}/discount_analysis_{start_date}_to_{end_date}.xlsx", index=False)
                db_data["discount_analysis"] = discount_data
                self.log_message(f"✓ {db_display} 折扣分析导出完成，共 {len(discount_data)} 条记录")
            
        except Exception as e:
            self.log_message(f"✗ {db_display} 导出折扣分析失败: {e}")
    
    def export_payment_analysis_data(self, start_date, end_date, export_dir, db_display, db_data):
        """导出支付分析数据"""
        try:
            import pandas as pd
            
            payment_data = self.db_manager.get_payment_analysis(start_date, end_date)
            if payment_data:
                # 为每条记录添加数据库标识
                for record in payment_data:
                    record['数据库来源'] = db_display
                    record['数据库来源\nDatabase Source'] = db_display
                
                df = pd.DataFrame(payment_data)
                df.to_excel(f"{export_dir}/payment_analysis_{start_date}_to_{end_date}.xlsx", index=False)
                db_data["payment_analysis"] = payment_data
                self.log_message(f"✓ {db_display} 支付分析导出完成，共 {len(payment_data)} 条记录")
            
        except Exception as e:
            self.log_message(f"✗ {db_display} 导出支付分析失败: {e}")
    
    def export_brand_analysis_data(self, start_date, end_date, export_dir, db_display, db_data):
        """导出品牌分析数据"""
        try:
            import pandas as pd
            
            # 获取品牌分析数据
            brand_data = self.db_manager.get_brand_analysis(start_date, end_date)
            if brand_data:
                # 为每条记录添加数据库标识
                for record in brand_data:
                    record['数据库来源'] = db_display
                    record['数据库来源\nDatabase Source'] = db_display
                
                df = pd.DataFrame(brand_data)
                df.to_excel(f"{export_dir}/brand_analysis_{start_date}_to_{end_date}.xlsx", index=False)
                db_data["brand_analysis"] = brand_data
                self.log_message(f"✓ {db_display} 品牌分析导出完成，共 {len(brand_data)} 条记录")
            
        except Exception as e:
            self.log_message(f"✗ {db_display} 导出品牌分析失败: {e}")
    
    def generate_export_summary(self, export_dir, all_exported_data):
        """生成导出汇总报告"""
        try:
            import pandas as pd
            from datetime import datetime
            
            # 创建汇总数据
            summary_data = []
            total_records = 0
            
            for db_name, db_data in all_exported_data.items():
                summary_row = {
                    '数据库\nDatabase': db_name,
                    '日期范围\nDate Range': f"{db_data['date_range'][0]} 到 {db_data['date_range'][1]}",
                    '销售数据记录数\nSales Records': len(db_data.get('sales_data', [])),
                    '月度汇总记录数\nMonthly Summary': len(db_data.get('monthly_summary', [])),
                    '产品分析记录数\nProduct Analysis': len(db_data.get('product_analysis', [])),
                    '折扣分析记录数\nDiscount Analysis': len(db_data.get('discount_analysis', [])),
                    '支付分析记录数\nPayment Analysis': len(db_data.get('payment_analysis', [])),
                    '品牌分析记录数\nBrand Analysis': len(db_data.get('brand_analysis', []))
                }
                
                db_total = (summary_row['销售数据记录数\nSales Records'] + 
                           summary_row['月度汇总记录数\nMonthly Summary'] + 
                           summary_row['产品分析记录数\nProduct Analysis'] + 
                           summary_row['折扣分析记录数\nDiscount Analysis'] + 
                           summary_row['支付分析记录数\nPayment Analysis'] + 
                           summary_row['品牌分析记录数\nBrand Analysis'])
                
                summary_row['数据库总记录数\nDatabase Total'] = db_total
                total_records += db_total
                summary_data.append(summary_row)
            
            # 添加总计行
            if summary_data:
                total_row = {
                    '数据库\nDatabase': '总计 Total',
                    '日期范围\nDate Range': '-',
                    '销售数据记录数\nSales Records': sum(row['销售数据记录数\nSales Records'] for row in summary_data),
                    '月度汇总记录数\nMonthly Summary': sum(row['月度汇总记录数\nMonthly Summary'] for row in summary_data),
                    '产品分析记录数\nProduct Analysis': sum(row['产品分析记录数\nProduct Analysis'] for row in summary_data),
                    '折扣分析记录数\nDiscount Analysis': sum(row['折扣分析记录数\nDiscount Analysis'] for row in summary_data),
                    '支付分析记录数\nPayment Analysis': sum(row['支付分析记录数\nPayment Analysis'] for row in summary_data),
                    '品牌分析记录数\nBrand Analysis': sum(row['品牌分析记录数\nBrand Analysis'] for row in summary_data),
                    '数据库总记录数\nDatabase Total': total_records
                }
                summary_data.append(total_row)
            
            # 保存汇总报告
            if summary_data:
                df_summary = pd.DataFrame(summary_data)
                df_summary.to_excel(f"{export_dir}/导出汇总报告_Export_Summary.xlsx", index=False)
                
                # 生成文本报告
                with open(f"{export_dir}/导出报告.txt", 'w', encoding='utf-8') as f:
                    f.write("=" * 60 + "\n")
                    f.write("历史数据导出汇总报告\n")
                    f.write("Historical Data Export Summary Report\n")
                    f.write("=" * 60 + "\n")
                    f.write(f"导出时间 Export Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                    f.write(f"导出目录 Export Directory: {export_dir}\n\n")
                    
                    f.write("数据库导出统计 Database Export Statistics:\n")
                    f.write("-" * 50 + "\n")
                    
                    for row in summary_data:
                        if row['数据库\nDatabase'] != '总计 Total':
                            f.write(f"数据库: {row['数据库\nDatabase']}\n")
                            f.write(f"  日期范围: {row['日期范围\nDate Range']}\n")
                            f.write(f"  销售数据: {row['销售数据记录数\nSales Records']:,} 条记录\n")
                            f.write(f"  月度汇总: {row['月度汇总记录数\nMonthly Summary']:,} 条记录\n")
                            f.write(f"  产品分析: {row['产品分析记录数\nProduct Analysis']:,} 条记录\n")
                            f.write(f"  折扣分析: {row['折扣分析记录数\nDiscount Analysis']:,} 条记录\n")
                            f.write(f"  支付分析: {row['支付分析记录数\nPayment Analysis']:,} 条记录\n")
                            f.write(f"  品牌分析: {row['品牌分析记录数\nBrand Analysis']:,} 条记录\n")
                            f.write(f"  小计: {row['数据库总记录数\nDatabase Total']:,} 条记录\n\n")
                    
                    f.write("=" * 50 + "\n")
                    f.write(f"总计 Total: {total_records:,} 条记录\n")
                    f.write(f"导出数据库数量: {len(all_exported_data)} 个\n")
                    f.write("=" * 50 + "\n")
                
                self.log_message(f"📋 汇总报告已生成: {export_dir}/导出汇总报告_Export_Summary.xlsx")
                self.log_message(f"📋 文本报告已生成: {export_dir}/导出报告.txt")
                self.log_message(f"📊 总计导出: {total_records:,} 条记录，来自 {len(all_exported_data)} 个数据库")
            
        except Exception as e:
            self.log_message(f"✗ 生成汇总报告失败: {e}")
    
    def clear_data_cache(self):
        """清除数据缓存"""
        self.log_message("正在清除数据缓存...")
        try:
            # 清除数据缓存
            self.sales_data = None
            self.payment_data = None
            self.discount_data = None
            self.monthly_data = None
            self.sales_tc_analysis_data = None
            self.sales_tc_monthly_data = None
            self.product_association_data = None
            
            # 清除活动记录
            self.activity_records = []
            
            self.log_message("✓ 缓存清除完成")
            
        except Exception as e:
            self.log_message(f"✗ 清除缓存失败: {e}")
    
    def open_settings(self):
        """打开系统设置"""
        self.log_message("系统设置功能正在开发中...")
        messagebox.showinfo("系统设置", "系统设置功能正在开发中，敬请期待！\n\nSystem Settings is under development, please stay tuned!")
    
    def open_help(self):
        """打开帮助文档"""
        self.log_message("正在打开帮助文档...")
        try:
            help_text = """
POS数据分析工具 - 使用帮助

1. 数据库连接
   - 选择数据库类型
   - 点击"连接数据库"按钮

2. 筛选条件设置
   - 设置日期范围
   - 选择门市、月份、星期等筛选条件
   - 选择产品和类别

3. 分析功能
   - 销售分析：查看销售数据、支付方式、折扣等
   - 产品分析：查看产品表现、关联分析等
   - 品牌分析：查看品牌业绩对比等

4. 数据导出
   - 导出当前数据
   - 导出所有分析结果
   - 生成分析报告

5. 工具功能
   - 刷新数据
   - 清除缓存
   - 系统设置
   - 帮助文档

如有问题，请联系技术支持。
            """
            messagebox.showinfo("帮助文档", help_text)
            
        except Exception as e:
            self.log_message(f"✗ 打开帮助文档失败: {e}")
    
    def save_data_to_csv(self, data, filepath):
        """保存数据到CSV文件"""
        try:
            if not data:
                self.log_message("没有数据可保存")
                return False
            
            # 创建目录（如果不存在）
            os.makedirs(os.path.dirname(filepath), exist_ok=True)
            
            # 写入CSV文件
            with open(filepath, 'w', newline='', encoding='utf-8-sig') as csvfile:
                if data:
                    # 获取字段名
                    fieldnames = data[0].keys()
                    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
                    writer.writeheader()
                    writer.writerows(data)
            
            # 获取文件大小
            file_size = os.path.getsize(filepath) / (1024 * 1024)  # MB
            
            self.log_message(f"✓ 数据已保存到: {filepath}")
            self.log_message(f"文件大小: {file_size:.2f} MB，记录数: {len(data)}")
            
            return True
            
        except Exception as e:
            self.log_message(f"✗ 保存CSV文件失败: {e}")
            return False
    
    def export_data(self):
        """导出数据 - 修复：导出当前显示的筛选后数据"""
        # 确定要导出的数据
        current_tab = self.notebook.index(self.notebook.select())
        self.log_message(f"当前标签页索引: {current_tab}")
        
        if current_tab == 1 and self.sales_data:  # 销售数据
            data = self.sales_data
            filename = f"sales_data_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
        elif current_tab == 2:  # 支付分析
            # 修复：检查是否有筛选后的支付数据
            if hasattr(self, 'filtered_payment_data') and self.filtered_payment_data:
                data = self.filtered_payment_data
                self.log_message("✓ 导出筛选后的支付分析数据")
            elif self.payment_data:
                data = self.payment_data
                self.log_message("ℹ 导出原始支付分析数据（未应用筛选）")
            else:
                self.log_message("✗ 没有支付分析数据可导出")
                return
            filename = f"payment_analysis_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
        elif current_tab == 3 and self.discount_data:  # 折扣分析
            data = self.discount_data
            filename = f"discount_analysis_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
        elif current_tab == 4 and self.monthly_data:  # 月度汇总
            data = self.monthly_data
            filename = f"monthly_summary_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
        elif current_tab == 5 and self.sales_tc_analysis_data:  # 销售TC分析
            data = self.sales_tc_analysis_data
            filename = f"sales_tc_analysis_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
        elif current_tab == 6 and self.sales_tc_monthly_data:  # 销售TC月度汇总
            data = self.sales_tc_monthly_data
            filename = f"sales_tc_monthly_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
        elif current_tab == 7 and self.product_association_data:  # 产品关联分析
            data = self.product_association_data
            filename = f"product_association_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
        elif current_tab == 2:  # 品牌分析
            # 检查品牌分析的子标签页
            if hasattr(self, 'brand_notebook'):
                brand_sub_tab = self.brand_notebook.index(self.brand_notebook.select())
                self.log_message(f"品牌分析子标签页索引: {brand_sub_tab}")
                if brand_sub_tab == 0 and hasattr(self, 'brand_daily_data') and self.brand_daily_data:  # 每日细项
                    data = self.brand_daily_data
                    filename = f"brand_daily_breakdown_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
                elif brand_sub_tab == 1 and hasattr(self, 'brand_period_data') and self.brand_period_data:  # 期间汇总
                    data = self.brand_period_data
                    filename = f"brand_period_summary_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
                elif brand_sub_tab == 2 and hasattr(self, 'brand_analysis_data') and self.brand_analysis_data:  # 业绩对比
                    data = self.brand_analysis_data
                    filename = f"brand_performance_comparison_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
                else:
                    self.log_message("品牌分析子标签页没有数据，尝试导出所有可用数据...")
                    self.export_all_data()
                    return
            else:
                self.log_message("品牌分析标签页没有数据，尝试导出所有可用数据...")
                self.export_all_data()
                return
        else:
            # 如果没有找到当前标签页的数据，尝试导出所有可用数据
            self.log_message("当前标签页没有数据，尝试导出所有可用数据...")
            self.export_all_data()
            return
        
        # 选择保存位置
        filename = filedialog.asksaveasfilename(
            defaultextension=".csv",
            filetypes=[("CSV files", "*.csv")],
            initialfile=filename
        )
        
        if filename:
            try:
                df = pd.DataFrame(data)
                df.to_csv(filename, index=False, encoding='utf-8-sig')
                
                file_size = os.path.getsize(filename) / (1024 * 1024)  # MB
                self.log_message(f"✓ 数据已导出到: {filename}")
                self.log_message(f"文件大小: {file_size:.2f} MB")
                
                messagebox.showinfo("成功", f"已导出 {len(data)} 条记录到:\n{filename}\n\n文件大小: {file_size:.2f} MB")
            except Exception as e:
                self.log_message(f"✗ 导出数据失败: {e}")
                messagebox.showerror("错误", f"导出失败:\n{e}")
    
    def get_product_association_analysis(self):
        """获取产品关联分析"""
        try:
            # 检查是否选择了产品
            selected_products = self.product_combo.get_selected_for_filter()
            if not selected_products or len(selected_products) == 0:
                self.log_message("✗ 请先选择要分析的产品")
                return
            
            if len(selected_products) > 1:
                self.log_message("✗ 产品关联分析一次只能选择一个产品")
                return
            
            selected_product = selected_products[0]
            self.log_message(f"正在获取产品关联分析: {selected_product}")
            
            # 获取筛选条件
            date_from = self.date_from.get_date() if self.use_date_filter.get() else None
            date_to = self.date_to.get_date() if self.use_date_filter.get() else None
            outlet_filters = self.outlet_combo.get_selected_for_filter()
            month_filters = self.month_combo.get_selected_for_filter()
            weekday_filters = self.weekday_combo.get_selected()
            category_filters = self.category_combo.get_selected_for_filter()
            payment_filters = self.payment_combo.get_selected_for_filter()
            
            # 验证日期范围
            if self.use_date_filter.get() and not self.validate_date_range():
                return
            
            # 先连接数据库
            db = self.selected_db.get()
            if not self.db_manager.connect(db):
                self.log_message("✗ 数据库连接失败")
                return
            
            # 获取数据
            self.log_message(f"调用数据库查询: {selected_product}")
            print(f"DEBUG: 调用 get_product_association_analysis，参数: selected_product={selected_product}, date_from={date_from}, date_to={date_to}")
            print(f"DEBUG: 筛选条件: outlet_filters={outlet_filters}, month_filters={month_filters}, weekday_filters={weekday_filters}, category_filters={category_filters}, payment_filters={payment_filters}")
            data = self.db_manager.get_product_association_analysis(
                selected_product, date_from, date_to, outlet_filters, 
                month_filters, weekday_filters, category_filters, payment_filters
            )
            print(f"DEBUG: get_product_association_analysis 返回结果: {len(data) if data else 0} 条记录")
            self.log_message(f"数据库查询返回: {len(data) if data else 0} 条记录")
            
            if data:
                self.product_association_data = data
                self.last_selected_product = selected_product  # 保存选中的产品名称
                self.display_product_association_analysis(data, selected_product)
                self.log_message(f"✓ 产品关联分析完成: {len(data)} 条记录")
            else:
                self.log_message("✗ 获取产品关联分析失败或没有数据")
                
        except Exception as e:
            import traceback
            error_details = traceback.format_exc()
            self.log_message(f"✗ 获取产品关联分析失败: {e}")
            self.log_message(f"错误详情: {error_details}")
            print(f"GUI产品关联分析异常: {e}")
            print(f"错误详情: {error_details}")
    
    def display_product_association_analysis(self, data, selected_product):
        """显示产品关联分析数据"""
        # 清空现有数据
        for item in self.product_association_tree.get_children():
            self.product_association_tree.delete(item)
        
        # 设置列
        columns = ("月份\nMonth", "门市\nOutlet", "产品名称\nProduct Name", "数量\nQuantity", "单据数\nReceipt Count", "单据业绩\nReceipt Performance", "数量占比%\nQuantity Ratio%", "单据占比%\nReceipt Ratio%")
        self.product_association_tree["columns"] = columns
        self.product_association_tree["show"] = "headings"
        
        # 设置列标题和排序功能
        for col in columns:
            self.product_association_tree.heading(col, text=col, command=lambda c=col: self._sort_treeview_column(self.product_association_tree, c))
            self.product_association_tree.column(col, width=120, anchor="center")
        
        # 设置行高以显示中英文标题
        style = ttk.Style()
        style.configure("Treeview", rowheight=25)  # 进一步缩小数据行高度到25像素
        style.configure("Treeview.Heading", font=('Arial', 9, 'bold'), height=80, background="#34495e", foreground="white", padding=(10, 8))  # 缩小字体但增加标题高度到80像素
        
        # 配置标签样式
        self.product_association_tree.tag_configure("selected_product", background="#2196F3", foreground="white")  # 深蓝色 - 搜索产品
        self.product_association_tree.tag_configure("total_other", background="#FF9800", foreground="white")      # 深橙色 - Total Other Item
        self.product_association_tree.tag_configure("other_product", background="#E0E0E0")                        # 深灰色 - 其他产品
        self.product_association_tree.tag_configure("grand_total", background="#4CAF50", foreground="white")      # 绿色 - 全部总数
        
        # 插入数据并设置颜色
        for row in data:
            月份, 门市, 产品名称, 数量, 单据数, 单据业绩, 数量占比, 单据占比 = row
            
            # 根据产品名称确定标签
            if 产品名称 == selected_product:
                tag = "selected_product"
            elif 产品名称 == "Total Other Item":
                tag = "total_other"
            elif 产品名称 == "全部总数\nGrand Total":
                tag = "grand_total"
            else:
                tag = "other_product"
            
            # 根据开关状态决定是否显示详细数据
            if self.show_product_details.get() or tag in ["selected_product", "total_other", "grand_total"]:
                self.product_association_tree.insert("", "end", values=row, tags=(tag,))
        
        # 切换到产品关联分析标签页（如果活动记录窗口没有打开）
        if not (hasattr(self, 'activity_window') and self.activity_window.winfo_exists()):
            self.notebook.select(1)  # 选择Product标签页
            self.product_notebook.select(5)  # 选择产品关联分析子标签页
    
    def get_brand_analysis(self):
        """获取品牌分析"""
        # 验证日期范围
        if not self.validate_date_range():
            return
            
        # 先连接数据库
        db = self.selected_db.get()
        if not self.db_manager.connect(db):
            self.log_message("✗ 数据库连接失败")
            return
        
        # 获取筛选条件
        if self.use_date_filter.get():
            # DateEntry返回datetime对象，需要转换为字符串
            date_from = self.date_from.get_date().strftime('%Y-%m-%d') if self.date_from.get_date() else None
            date_to = self.date_to.get_date().strftime('%Y-%m-%d') if self.date_to.get_date() else None
            
            # 使用纯日期格式，不添加时间部分
            if date_from and date_to and date_from == date_to:
                self.log_message(f"ℹ 单日查询: {date_from}")
            elif date_to:
                self.log_message(f"ℹ 日期范围查询: {date_from} 到 {date_to}")
        else:
            # 不使用日期筛选，只使用月份筛选
            # 但是数据库查询需要日期范围，所以我们需要设置一个合理的默认范围
            # 如果没有选择月份，使用当前月份
            month_filters = self.month_combo.get_selected()
            if month_filters and len(month_filters) > 0:
                # 使用选中的第一个月份作为日期范围
                selected_month = month_filters[0]
                year, month = selected_month.split('-')
                date_from = f"{year}-{month}-01"
                # 计算该月的最后一天
                if month in ['01', '03', '05', '07', '08', '10', '12']:
                    last_day = 31
                elif month in ['04', '06', '09', '11']:
                    last_day = 30
                else:  # 2月
                    if int(year) % 4 == 0 and (int(year) % 100 != 0 or int(year) % 400 == 0):
                        last_day = 29
                    else:
                        last_day = 28
                date_to = f"{year}-{month}-{last_day:02d}"
                self.log_message(f"ℹ 使用月份筛选: {selected_month}")
            else:
                # 如果没有选择月份，使用当前月份
                from datetime import datetime
                now = datetime.now()
                current_month = now.strftime('%Y-%m')
                year, month = current_month.split('-')
                date_from = f"{year}-{month}-01"
                if month in ['01', '03', '05', '07', '08', '10', '12']:
                    last_day = 31
                elif month in ['04', '06', '09', '11']:
                    last_day = 30
                else:  # 2月
                    if int(year) % 4 == 0 and (int(year) % 100 != 0 or int(year) % 400 == 0):
                        last_day = 29
                    else:
                        last_day = 28
                date_to = f"{year}-{month}-{last_day:02d}"
                self.log_message(f"ℹ 未选择月份，使用当前月份: {current_month}")
            
        outlet_filters = self.outlet_combo.get_selected()
        month_filters = self.month_combo.get_selected()
        weekday_filters = self.weekday_combo.get_selected()
        print(f"GUI获取的星期筛选: {weekday_filters}")
        category_filters = self.category_combo.get_selected()
        payment_filters = self.payment_combo.get_selected()
        
        self.log_message("正在获取品牌分析...")
        self.brand_analysis_data = self.db_manager.get_brand_analysis(
            date_from, date_to, outlet_filters, month_filters, weekday_filters, category_filters, payment_filters
        )
        
        if self.brand_analysis_data:
            self.display_brand_analysis()
            self.log_message(f"✓ 获取品牌分析成功，共 {len(self.brand_analysis_data)} 条记录")
        else:
            self.log_message("✗ 获取品牌分析失败或没有数据")
    
    def display_brand_analysis(self):
        """显示品牌分析数据"""
        # 清空现有数据
        for item in self.performance_comparison_tree.get_children():
            self.performance_comparison_tree.delete(item)
        
        # 设置列
        columns = ("月份\nMonth", "门市\nOutlet", "品牌\nBrand", "总数量\nTotal Quantity", "总单据数\nTotal Receipts", "总业绩\nTotal Sales")
        self.performance_comparison_tree["columns"] = columns
        self.performance_comparison_tree["show"] = "headings"
        
        # 设置列标题和排序功能
        for col in columns:
            self.performance_comparison_tree.heading(col, text=col, command=lambda c=col: self._sort_treeview_column(self.performance_comparison_tree, c))
            self.performance_comparison_tree.column(col, width=120, anchor="center")
        
        # 设置行高以显示中英文标题
        style = ttk.Style()
        style.configure("Treeview", rowheight=25)  # 进一步缩小数据行高度到25像素
        style.configure("Treeview.Heading", font=('Arial', 9, 'bold'), height=80, background="#34495e", foreground="white", padding=(10, 8))  # 缩小字体但增加标题高度到80像素
        
        # 配置标签样式
        self.performance_comparison_tree.tag_configure("sushi", background="#FFE6E6", foreground="#000000")      # 浅红色 - SUSHI
        self.performance_comparison_tree.tag_configure("noodles", background="#E6F3FF", foreground="#000000")    # 浅蓝色 - NOODLES
        self.performance_comparison_tree.tag_configure("tempura", background="#FFF0E6", foreground="#000000")    # 浅橙色 - TEMPURA
        self.performance_comparison_tree.tag_configure("donburi", background="#E6FFE6", foreground="#000000")    # 浅绿色 - DONBURI
        self.performance_comparison_tree.tag_configure("salad", background="#F0E6FF", foreground="#000000")      # 浅紫色 - SALAD
        self.performance_comparison_tree.tag_configure("beverage", background="#E6FFFF", foreground="#000000")    # 浅青色 - BEVERAGE
        self.performance_comparison_tree.tag_configure("other", background="#F5F5F5", foreground="#000000")       # 浅灰色 - OTHER
        
        # 插入数据并设置颜色
        for row in self.brand_analysis_data:
            月份, 门市, 品牌, 总数量, 总单据数, 总业绩 = row
            
            # 根据品牌确定标签
            brand_lower = 品牌.lower()
            if 'sushi' in brand_lower or 'sashimi' in brand_lower:
                tag = "sushi"
            elif 'noodles' in brand_lower or 'ramen' in brand_lower or 'udon' in brand_lower:
                tag = "noodles"
            elif 'tempura' in brand_lower:
                tag = "tempura"
            elif 'donburi' in brand_lower or 'don' in brand_lower:
                tag = "donburi"
            elif 'salad' in brand_lower:
                tag = "salad"
            elif 'beverage' in brand_lower or 'drink' in brand_lower:
                tag = "beverage"
            else:
                tag = "other"
            
            # 根据开关状态决定是否显示详细数据
            if self.show_product_details.get():
                # 格式化数值
                formatted_row = (
                    月份, 门市, 品牌,
                    f"{float(总数量):,.2f}",
                    f"{int(总单据数):,}",
                    f"$ {float(总业绩):,.2f}"
                )
                
                self.performance_comparison_tree.insert("", "end", values=formatted_row, tags=(tag,))
        
        # 切换到品牌分析标签页（如果活动记录窗口没有打开）
        if not (hasattr(self, 'activity_window') and self.activity_window.winfo_exists()):
            self.notebook.select(2)  # 选择Brand标签页
            self.brand_notebook.select(0)  # 选择品牌分析子标签页
    
    def get_brand_daily_breakdown(self):
        """获取品牌每日细项分析"""
        # 验证日期范围
        if not self.validate_date_range():
            return
            
        # 先连接数据库
        db = self.selected_db.get()
        if not self.db_manager.connect(db):
            self.log_message("✗ 数据库连接失败")
            return
        
        # 获取筛选条件
        if self.use_date_filter.get():
            date_from = self.date_from.get_date().strftime('%Y-%m-%d') if self.date_from.get_date() else None
            date_to = self.date_to.get_date().strftime('%Y-%m-%d') if self.date_to.get_date() else None
        else:
            selected_months = self.month_combo.get_selected()
            if selected_months:
                from datetime import datetime
                first_month = selected_months[0]
                dt = datetime.strptime(first_month, '%Y-%m')
                date_from = dt.replace(day=1).strftime('%Y-%m-%d')
                if dt.month == 12:
                    next_month = dt.replace(year=dt.year + 1, month=1, day=1)
                else:
                    next_month = dt.replace(month=dt.month + 1, day=1)
                date_to = (next_month - timedelta(days=1)).strftime('%Y-%m-%d')
            else:
                date_from = None
                date_to = None
                self.log_message("ℹ 未启用日期筛选，将使用月份筛选")
        
        outlet_filters = self.outlet_combo.get_selected()
        month_filters = self.month_combo.get_selected()
        weekday_filters = self.weekday_combo.get_selected()
        category_filters = self.category_combo.get_selected()
        payment_filters = self.payment_combo.get_selected()

        # 保存门店筛选用于单店平均
        self.weekly_product_outlet_filters = [o for o in outlet_filters if o]
        
        self.log_message("正在获取品牌每日细项分析...")
        self.brand_daily_data = self.db_manager.get_brand_daily_breakdown(
            date_from, date_to, outlet_filters, month_filters, weekday_filters, category_filters, payment_filters
        )
        
        if self.brand_daily_data:
            self.display_brand_daily_breakdown()
            self.log_message(f"✓ 获取品牌每日细项分析成功，共 {len(self.brand_daily_data)} 条记录")
        else:
            self.log_message("✗ 获取品牌每日细项分析失败或没有数据")
    
    def display_brand_daily_breakdown(self):
        """显示品牌每日细项分析数据"""
        # 清空现有数据
        for item in self.brand_daily_tree.get_children():
            self.brand_daily_tree.delete(item)
        
        # 设置列
        columns = ("日期\nDate", "门市\nOutlet", "总业绩\nTotal Sales", "总单据数\nTotal Receipts", 
                  "总单据大小\nTotal Ticket Size", "DI业绩\nDI Sales", "DI单据数\nDI Receipts", "DI单据大小\nDI Ticket Size",
                  "外带业绩\nTakeaway Sales", "外带单据数\nTakeaway Receipts", "外带单据大小\nTakeaway Ticket Size",
                  "配送业绩\nDelivery Sales", "配送单据数\nDelivery Receipts", "配送单据大小\nDelivery Ticket Size",
                  "FOOD PANDA业绩\nFOOD PANDA Sales", "FOOD PANDA单据数\nFOOD PANDA Receipts", "FOOD PANDA单据大小\nFOOD PANDA Ticket Size",
                  "GRAB FOOD业绩\nGRAB FOOD Sales", "GRAB FOOD单据数\nGRAB FOOD Receipts", "GRAB FOOD单据大小\nGRAB FOOD Ticket Size",
                  "DELIVEROO业绩\nDELIVEROO Sales", "DELIVEROO单据数\nDELIVEROO Receipts", "DELIVEROO单据大小\nDELIVEROO Ticket Size")
        self.brand_daily_tree["columns"] = columns
        self.brand_daily_tree["show"] = "headings"
        
        # 设置列标题和排序功能
        for col in columns:
            self.brand_daily_tree.heading(col, text=col, command=lambda c=col: self._sort_treeview_column(self.brand_daily_tree, c))
            self.brand_daily_tree.column(col, width=120, anchor="center")
        
        # 设置行高以显示中英文标题
        style = ttk.Style()
        style.configure("Treeview", rowheight=25)
        style.configure("Treeview.Heading", font=('Arial', 9, 'bold'), height=80, background="#34495e", foreground="white", padding=(10, 8))
        
        # 配置每日总计行的颜色
        style.configure("Treeview", background="#FFFFFF")
        style.configure("daily_total.Treeview", background="#FFFFFF", foreground="#000000")
        self.brand_daily_tree.tag_configure('daily_total', background='#FFFFFF', foreground='#000000')
        
        # 插入数据
        total_sales = 0
        total_receipts = 0
        total_di_sales = 0
        total_di_receipts = 0
        total_takeaway_sales = 0
        total_takeaway_receipts = 0
        total_delivery_sales = 0
        total_delivery_receipts = 0
        total_foodpanda_sales = 0
        total_foodpanda_receipts = 0
        total_grab_sales = 0
        total_grab_receipts = 0
        total_deliveroo_sales = 0
        total_deliveroo_receipts = 0
        
        for row in self.brand_daily_data:
            formatted_row = (
                row['日期'],
                row['门市'],
                format_currency(row['总业绩']),
                format_number(row['总单据数']),
                format_currency(row['总单据大小']),
                format_currency(row['DI业绩']),
                format_number(row['DI单据数']),
                format_currency(row['DI单据大小']),
                format_currency(row['外带业绩']),
                format_number(row['外带单据数']),
                format_currency(row['外带单据大小']),
                format_currency(row['配送业绩']),
                format_number(row['配送单据数']),
                format_currency(row['配送单据大小']),
                format_currency(row['FOOD_PANDA业绩']),
                format_number(row['FOOD_PANDA单据数']),
                format_currency(row['FOOD_PANDA单据大小']),
                format_currency(row['GRAB_FOOD业绩']),
                format_number(row['GRAB_FOOD单据数']),
                format_currency(row['GRAB_FOOD单据大小']),
                format_currency(row['DELIVEROO业绩']),
                format_number(row['DELIVEROO单据数']),
                format_currency(row['DELIVEROO单据大小'])
            )
            
            # 根据开关状态决定是否显示详细数据
            if self.show_product_details.get():
                # 检查是否为每日总计行，如果是则添加颜色
                if row.get('is_daily_total', False):
                    item = self.brand_daily_tree.insert("", "end", values=formatted_row, tags=('daily_total',))
                else:
                    self.brand_daily_tree.insert("", "end", values=formatted_row)
            
            # 累计总计
            total_sales += row['总业绩']
            total_receipts += row['总单据数']
            total_di_sales += row['DI业绩']
            total_di_receipts += row['DI单据数']
            total_takeaway_sales += row['外带业绩']
            total_takeaway_receipts += row['外带单据数']
            total_delivery_sales += row['配送业绩']
            total_delivery_receipts += row['配送单据数']
            total_foodpanda_sales += row['FOOD_PANDA业绩']
            total_foodpanda_receipts += row['FOOD_PANDA单据数']
            total_grab_sales += row['GRAB_FOOD业绩']
            total_grab_receipts += row['GRAB_FOOD单据数']
            total_deliveroo_sales += row['DELIVEROO业绩']
            total_deliveroo_receipts += row['DELIVEROO单据数']
        
        # 添加总计行
        if self.brand_daily_data:
            total_ticket_size = total_sales / total_receipts if total_receipts > 0 else 0
            total_di_ticket_size = total_di_sales / total_di_receipts if total_di_receipts > 0 else 0
            total_takeaway_ticket_size = total_takeaway_sales / total_takeaway_receipts if total_takeaway_receipts > 0 else 0
            total_delivery_ticket_size = total_delivery_sales / total_delivery_receipts if total_delivery_receipts > 0 else 0
            total_foodpanda_ticket_size = total_foodpanda_sales / total_foodpanda_receipts if total_foodpanda_receipts > 0 else 0
            total_grab_ticket_size = total_grab_sales / total_grab_receipts if total_grab_receipts > 0 else 0
            total_deliveroo_ticket_size = total_deliveroo_sales / total_deliveroo_receipts if total_deliveroo_receipts > 0 else 0
            
            total_row = (
                "总计\nTotal",
                "全部门店\nAll Outlets",
                format_currency(total_sales),
                format_number(total_receipts),
                format_currency(total_ticket_size),
                format_currency(total_di_sales),
                format_number(total_di_receipts),
                format_currency(total_di_ticket_size),
                format_currency(total_takeaway_sales),
                format_number(total_takeaway_receipts),
                format_currency(total_takeaway_ticket_size),
                format_currency(total_delivery_sales),
                format_number(total_delivery_receipts),
                format_currency(total_delivery_ticket_size),
                format_currency(total_foodpanda_sales),
                format_number(total_foodpanda_receipts),
                format_currency(total_foodpanda_ticket_size),
                format_currency(total_grab_sales),
                format_number(total_grab_receipts),
                format_currency(total_grab_ticket_size),
                format_currency(total_deliveroo_sales),
                format_number(total_deliveroo_receipts),
                format_currency(total_deliveroo_ticket_size)
            )
            
            # 插入总计行并设置颜色
            total_item = self.brand_daily_tree.insert("", "end", values=total_row, tags=("total",))
            self.brand_daily_tree.tag_configure("total", background="#E6F3FF", font=('Arial', 9, 'bold'))
        
        # 切换到每日细项标签页
        self.safe_switch_to_tab(2, 0)
    
    def get_performance_comparison(self):
        """获取业绩对比分析"""
        # 验证日期范围
        if not self.validate_date_range():
            return
            
        # 先连接数据库
        db = self.selected_db.get()
        self.log_message(f"正在连接到 {db}...")
        
        if not self.db_manager.connect(db):
            self.log_message(f"✗ 无法连接到 {db}")
            return
        
        self.log_message(f"✓ 连接成功", include_db_info=True)
        
        # 获取筛选条件
        if self.use_date_filter.get():
            date_from = self.date_from.get_date().strftime('%Y-%m-%d') if self.date_from.get_date() else None
            date_to = self.date_to.get_date().strftime('%Y-%m-%d') if self.date_to.get_date() else None
        else:
            selected_months = self.month_combo.get_selected()
            if selected_months:
                first_month = selected_months[0]
                dt = datetime.strptime(first_month, '%Y-%m')
                date_from = dt.strftime('%Y-%m-01')
                if dt.month == 12:
                    next_month = datetime(dt.year + 1, 1, 1)
                else:
                    next_month = datetime(dt.year, dt.month + 1, 1)
                date_to = (next_month - timedelta(days=1)).strftime('%Y-%m-%d')
            else:
                date_from = None
                date_to = None
        
        outlet_filters = self.outlet_combo.get_selected()
        month_filters = self.month_combo.get_selected()
        weekday_filters = self.weekday_combo.get_selected()
        category_filters = self.category_combo.get_selected()
        payment_filters = self.payment_combo.get_selected()
        
        # 获取对比参数
        comparison_method = self.comparison_method.get()
        comparison_date_from = self.comparison_date_from.get_date() if self.comparison_date_from.get_date() else None
        comparison_date_to = self.comparison_date_to.get_date() if self.comparison_date_to.get_date() else None
        comparison_weeks = self.comparison_week_combo.get_selected()
        
        self.log_message("正在获取业绩对比分析...")
        self.performance_comparison_data = self.db_manager.get_performance_comparison(
            date_from, date_to, outlet_filters, month_filters, weekday_filters, category_filters, payment_filters,
            comparison_method, comparison_date_from, comparison_date_to, comparison_weeks
        )
        
        if self.performance_comparison_data:
            self.display_performance_comparison()
            self.log_message(f"✓ 获取业绩对比分析成功，共 {len(self.performance_comparison_data)} 条记录")
        else:
            self.log_message("✗ 获取业绩对比分析失败或没有数据")
    
    def display_performance_comparison(self):
        """显示业绩对比分析数据"""
        # 清空现有数据
        for item in self.performance_comparison_tree.get_children():
            self.performance_comparison_tree.delete(item)
        
        if not self.performance_comparison_data:
            return
        
        # 根据显示详细开关过滤数据
        if not self.show_performance_details.get():
            # 只显示总计行
            filtered_data = [data for data in self.performance_comparison_data if '总计' in data['产品名称']]
        else:
            # 显示所有数据
            filtered_data = self.performance_comparison_data
        
        # 添加数据到表格
        for data in filtered_data:
            values = (
                data['产品名称'],
                data['期间'],
                f"$ {data['总业绩']:,.2f}",
                f"{data['总单据']:,}",
                f"$ {data['平均单据']:,.2f}",
                f"$ {data['产品业绩']:,.2f}",
                f"{data['产品单据']:,}",
                f"{data['报废数量']:,.0f}",
                f"{data['业绩占比']:.2f}%",
                f"{data['单据占比']:.2f}%"
            )
            
            # 根据产品名称设置不同的标签
            if '总计' in data['产品名称']:
                item = self.performance_comparison_tree.insert("", "end", values=values, tags=("total",))
            else:
                item = self.performance_comparison_tree.insert("", "end", values=values)
        
        # 配置总计行的样式
        self.performance_comparison_tree.tag_configure("total", background="#E6F3FF", font=('Arial', 9, 'bold'))
        
        # 切换到业绩对比标签页（如果活动记录窗口没有打开）
        if not (hasattr(self, 'activity_window') and self.activity_window.winfo_exists()):
            self.notebook.select(2)  # 选择Brand标签页
            self.brand_notebook.select(2)  # 选择业绩对比子标签页

    def get_brand_period_summary(self):
        """获取品牌期间汇总分析"""
        # 验证日期范围
        if not self.validate_date_range():
            return
            
        # 先连接数据库
        db = self.selected_db.get()
        if not self.db_manager.connect(db):
            self.log_message("✗ 数据库连接失败")
            return
        
        # 获取筛选条件
        if self.use_date_filter.get():
            date_from = self.date_from.get_date().strftime('%Y-%m-%d') if self.date_from.get_date() else None
            date_to = self.date_to.get_date().strftime('%Y-%m-%d') if self.date_to.get_date() else None
        else:
            date_from = None
            date_to = None
            self.log_message("ℹ 未启用日期筛选，将使用月份筛选")
        
        outlet_filters = self.outlet_combo.get_selected()
        month_filters = self.month_combo.get_selected()
        weekday_filters = self.weekday_combo.get_selected()
        category_filters = self.category_combo.get_selected()
        payment_filters = self.payment_combo.get_selected()
        
        self.log_message("正在获取品牌期间汇总分析...")
        self.brand_period_data = self.db_manager.get_brand_period_summary(
            date_from, date_to, outlet_filters, month_filters, weekday_filters, category_filters, payment_filters
        )
        
        if self.brand_period_data:
            self.display_brand_period_summary()
            self.log_message(f"✓ 获取品牌期间汇总分析成功，共 {len(self.brand_period_data)} 条记录")
        else:
            self.log_message("✗ 获取品牌期间汇总分析失败或没有数据")
    
    def display_brand_period_summary(self):
        """显示品牌期间汇总分析数据"""
        # 清空现有数据
        for item in self.brand_period_tree.get_children():
            self.brand_period_tree.delete(item)
        
        # 设置列
        columns = ("期间\nPeriod", "门市\nOutlet", "总业绩\nTotal Sales", "总单据数\nTotal Receipts", 
                  "总单据大小\nTotal Ticket Size", "DI业绩\nDI Sales", "DI单据数\nDI Receipts", "DI单据大小\nDI Ticket Size",
                  "外带业绩\nTakeaway Sales", "外带单据数\nTakeaway Receipts", "外带单据大小\nTakeaway Ticket Size",
                  "配送业绩\nDelivery Sales", "配送单据数\nDelivery Receipts", "配送单据大小\nDelivery Ticket Size",
                  "FOOD PANDA业绩\nFOOD PANDA Sales", "FOOD PANDA单据数\nFOOD PANDA Receipts", "FOOD PANDA单据大小\nFOOD PANDA Ticket Size",
                  "GRAB FOOD业绩\nGRAB FOOD Sales", "GRAB FOOD单据数\nGRAB FOOD Receipts", "GRAB FOOD单据大小\nGRAB FOOD Ticket Size",
                  "DELIVEROO业绩\nDELIVEROO Sales", "DELIVEROO单据数\nDELIVEROO Receipts", "DELIVEROO单据大小\nDELIVEROO Ticket Size")
        self.brand_period_tree["columns"] = columns
        self.brand_period_tree["show"] = "headings"
        
        # 设置列标题和排序功能
        for col in columns:
            self.brand_period_tree.heading(col, text=col, command=lambda c=col: self._sort_treeview_column(self.brand_period_tree, c))
            self.brand_period_tree.column(col, width=120, anchor="center")
        
        # 设置行高以显示中英文标题
        style = ttk.Style()
        style.configure("Treeview", rowheight=25)
        style.configure("Treeview.Heading", font=('Arial', 9, 'bold'), height=80, background="#34495e", foreground="white", padding=(10, 8))
        
        # 插入数据
        total_sales = 0
        total_receipts = 0
        total_di_sales = 0
        total_di_receipts = 0
        total_takeaway_sales = 0
        total_takeaway_receipts = 0
        total_delivery_sales = 0
        total_delivery_receipts = 0
        total_foodpanda_sales = 0
        total_foodpanda_receipts = 0
        total_grab_sales = 0
        total_grab_receipts = 0
        total_deliveroo_sales = 0
        total_deliveroo_receipts = 0
        
        for row in self.brand_period_data:
            # 根据日均开关决定显示格式
            if self.show_brand_daily_average.get():
                # 显示日均数据
                formatted_row = (
                    row['期间'],
                    row['门市'],
                    format_currency(row['总业绩_日均']),
                    format_number(row['总单据数_日均']),
                    format_currency(row['总单据大小_日均']),
                    format_currency(row['DI业绩_日均']),
                    format_number(row['DI单据数_日均']),
                    format_currency(row['DI单据大小_日均']),
                    format_currency(row['外带业绩_日均']),
                    format_number(row['外带单据数_日均']),
                    format_currency(row['外带单据大小_日均']),
                    format_currency(row['配送业绩_日均']),
                    format_number(row['配送单据数_日均']),
                    format_currency(row['配送单据大小_日均']),
                    format_currency(row['FOOD_PANDA业绩_日均']),
                    format_number(row['FOOD_PANDA单据数_日均']),
                    format_currency(row['FOOD_PANDA单据大小_日均']),
                    format_currency(row['GRAB_FOOD业绩_日均']),
                    format_number(row['GRAB_FOOD单据数_日均']),
                    format_currency(row['GRAB_FOOD单据大小_日均']),
                    format_currency(row['DELIVEROO业绩_日均']),
                    format_number(row['DELIVEROO单据数_日均']),
                    format_currency(row['DELIVEROO单据大小_日均'])
                )
                # 累计总计（使用原始数据）
                total_sales += row['总业绩']
                total_receipts += row['总单据数']
                total_di_sales += row['DI业绩']
                total_di_receipts += row['DI单据数']
                total_takeaway_sales += row['外带业绩']
                total_takeaway_receipts += row['外带单据数']
                total_delivery_sales += row['配送业绩']
                total_delivery_receipts += row['配送单据数']
                total_foodpanda_sales += row['FOOD_PANDA业绩']
                total_foodpanda_receipts += row['FOOD_PANDA单据数']
                total_grab_sales += row['GRAB_FOOD业绩']
                total_grab_receipts += row['GRAB_FOOD单据数']
                total_deliveroo_sales += row['DELIVEROO业绩']
                total_deliveroo_receipts += row['DELIVEROO单据数']
            else:
                # 显示总数据
                formatted_row = (
                    row['期间'],
                    row['门市'],
                    format_currency(row['总业绩']),
                    format_number(row['总单据数']),
                    format_currency(row['总单据大小']),
                    format_currency(row['DI业绩']),
                    format_number(row['DI单据数']),
                    format_currency(row['DI单据大小']),
                    format_currency(row['外带业绩']),
                    format_number(row['外带单据数']),
                    format_currency(row['外带单据大小']),
                    format_currency(row['配送业绩']),
                    format_number(row['配送单据数']),
                    format_currency(row['配送单据大小']),
                    format_currency(row['FOOD_PANDA业绩']),
                    format_number(row['FOOD_PANDA单据数']),
                    format_currency(row['FOOD_PANDA单据大小']),
                    format_currency(row['GRAB_FOOD业绩']),
                    format_number(row['GRAB_FOOD单据数']),
                    format_currency(row['GRAB_FOOD单据大小']),
                    format_currency(row['DELIVEROO业绩']),
                    format_number(row['DELIVEROO单据数']),
                    format_currency(row['DELIVEROO单据大小'])
                )
                # 累计总计
                total_sales += row['总业绩']
                total_receipts += row['总单据数']
                total_di_sales += row['DI业绩']
                total_di_receipts += row['DI单据数']
                total_takeaway_sales += row['外带业绩']
                total_takeaway_receipts += row['外带单据数']
                total_delivery_sales += row['配送业绩']
                total_delivery_receipts += row['配送单据数']
                total_foodpanda_sales += row['FOOD_PANDA业绩']
                total_foodpanda_receipts += row['FOOD_PANDA单据数']
                total_grab_sales += row['GRAB_FOOD业绩']
                total_grab_receipts += row['GRAB_FOOD单据数']
                total_deliveroo_sales += row['DELIVEROO业绩']
                total_deliveroo_receipts += row['DELIVEROO单据数']
            
            # 根据开关状态决定是否显示详细数据
            if self.show_product_details.get():
                self.brand_period_tree.insert("", "end", values=formatted_row)
        
        # 添加总计行
        if self.brand_period_data:
            total_ticket_size = total_sales / total_receipts if total_receipts > 0 else 0
            total_di_ticket_size = total_di_sales / total_di_receipts if total_di_receipts > 0 else 0
            total_takeaway_ticket_size = total_takeaway_sales / total_takeaway_receipts if total_takeaway_receipts > 0 else 0
            total_delivery_ticket_size = total_delivery_sales / total_delivery_receipts if total_delivery_receipts > 0 else 0
            total_foodpanda_ticket_size = total_foodpanda_sales / total_foodpanda_receipts if total_foodpanda_receipts > 0 else 0
            total_grab_ticket_size = total_grab_sales / total_grab_receipts if total_grab_receipts > 0 else 0
            total_deliveroo_ticket_size = total_deliveroo_sales / total_deliveroo_receipts if total_deliveroo_receipts > 0 else 0
            
            if self.show_brand_daily_average.get():
                # 显示日均总计
                total_row = (
                    "总计\nTotal",
                    "全部门店\nAll Outlets",
                    format_currency(total_sales / len(self.brand_period_data) if self.brand_period_data else 0),
                    format_number(total_receipts / len(self.brand_period_data) if self.brand_period_data else 0),
                    format_currency(total_ticket_size),
                    format_currency(total_di_sales / len(self.brand_period_data) if self.brand_period_data else 0),
                    format_number(total_di_receipts / len(self.brand_period_data) if self.brand_period_data else 0),
                    format_currency(total_di_ticket_size),
                    format_currency(total_takeaway_sales / len(self.brand_period_data) if self.brand_period_data else 0),
                    format_number(total_takeaway_receipts / len(self.brand_period_data) if self.brand_period_data else 0),
                    format_currency(total_takeaway_ticket_size),
                    format_currency(total_delivery_sales / len(self.brand_period_data) if self.brand_period_data else 0),
                    format_number(total_delivery_receipts / len(self.brand_period_data) if self.brand_period_data else 0),
                    format_currency(total_delivery_ticket_size),
                    format_currency(total_foodpanda_sales / len(self.brand_period_data) if self.brand_period_data else 0),
                    format_number(total_foodpanda_receipts / len(self.brand_period_data) if self.brand_period_data else 0),
                    format_currency(total_foodpanda_ticket_size),
                    format_currency(total_grab_sales / len(self.brand_period_data) if self.brand_period_data else 0),
                    format_number(total_grab_receipts / len(self.brand_period_data) if self.brand_period_data else 0),
                    format_currency(total_grab_ticket_size),
                    format_currency(total_deliveroo_sales / len(self.brand_period_data) if self.brand_period_data else 0),
                    format_number(total_deliveroo_receipts / len(self.brand_period_data) if self.brand_period_data else 0),
                    format_currency(total_deliveroo_ticket_size)
                )
            else:
                # 显示总数据总计
                total_row = (
                    "总计\nTotal",
                    "全部门店\nAll Outlets",
                    format_currency(total_sales),
                    format_number(total_receipts),
                    format_currency(total_ticket_size),
                    format_currency(total_di_sales),
                    format_number(total_di_receipts),
                    format_currency(total_di_ticket_size),
                    format_currency(total_takeaway_sales),
                    format_number(total_takeaway_receipts),
                    format_currency(total_takeaway_ticket_size),
                    format_currency(total_delivery_sales),
                    format_number(total_delivery_receipts),
                    format_currency(total_delivery_ticket_size),
                    format_currency(total_foodpanda_sales),
                    format_number(total_foodpanda_receipts),
                    format_currency(total_foodpanda_ticket_size),
                    format_currency(total_grab_sales),
                    format_number(total_grab_receipts),
                    format_currency(total_grab_ticket_size),
                    format_currency(total_deliveroo_sales),
                    format_number(total_deliveroo_receipts),
                    format_currency(total_deliveroo_ticket_size)
                )
            
            # 插入总计行并设置颜色
            total_item = self.brand_period_tree.insert("", "end", values=total_row, tags=("total",))
            self.brand_period_tree.tag_configure("total", background="#E6F3FF", font=('Arial', 9, 'bold'))
        
        # 切换到期间汇总标签页（如果活动记录窗口没有打开）
        if not (hasattr(self, 'activity_window') and self.activity_window.winfo_exists()):
            self.notebook.select(2)  # 选择Brand标签页
            self.brand_notebook.select(1)  # 选择期间汇总子标签页
    
    def get_category_analysis(self):
        """获取类别分析"""
        # 验证日期范围
        if not self.validate_date_range():
            return
            
        # 先连接数据库
        db = self.selected_db.get()
        if not self.db_manager.connect(db):
            self.log_message("✗ 数据库连接失败")
            return
        
        # 获取筛选条件
        if self.use_date_filter.get():
            date_from = self.date_from.get_date().strftime('%Y-%m-%d') if self.date_from.get_date() else None
            date_to = self.date_to.get_date().strftime('%Y-%m-%d') if self.date_to.get_date() else None
        else:
            date_from = None
            date_to = None
            self.log_message("ℹ 未启用日期筛选，将使用月份筛选")
        
        outlet_filters = self.outlet_combo.get_selected()
        month_filters = self.month_combo.get_selected()
        weekday_filters = self.weekday_combo.get_selected()
        category_filters = self.category_combo.get_selected()
        payment_filters = self.payment_combo.get_selected()
        
        self.log_message("正在获取类别分析...")
        self.category_analysis_data = self.db_manager.get_category_analysis(
            date_from, date_to, outlet_filters, month_filters, weekday_filters, category_filters, payment_filters
        )
        
        if self.category_analysis_data:
            self.display_category_analysis()
            self.log_message(f"✓ 获取类别分析成功，共 {len(self.category_analysis_data)} 条记录")
        else:
            self.log_message("✗ 获取类别分析失败或没有数据")
    
    def display_category_analysis(self):
        """显示类别分析数据"""
        # 清空现有数据
        for item in self.category_analysis_tree.get_children():
            self.category_analysis_tree.delete(item)
        
        # 设置列
        columns = ("月份\nMonth", "门市\nOutlet", "类别\nCategory", "总业绩\nTotal Sales", "总单据数\nTotal Receipts", 
                  "总单据大小\nTotal Ticket Size", "DI业绩\nDI Sales", "DI单据数\nDI Receipts", "DI单据大小\nDI Ticket Size",
                  "外带业绩\nTakeaway Sales", "外带单据数\nTakeaway Receipts", "外带单据大小\nTakeaway Ticket Size",
                  "配送业绩\nDelivery Sales", "配送单据数\nDelivery Receipts", "配送单据大小\nDelivery Ticket Size",
                  "FOOD PANDA业绩\nFOOD PANDA Sales", "FOOD PANDA单据数\nFOOD PANDA Receipts", "FOOD PANDA单据大小\nFOOD PANDA Ticket Size",
                  "GRAB FOOD业绩\nGRAB FOOD Sales", "GRAB FOOD单据数\nGRAB FOOD Receipts", "GRAB FOOD单据大小\nGRAB FOOD Ticket Size",
                  "DELIVEROO业绩\nDELIVEROO Sales", "DELIVEROO单据数\nDELIVEROO Receipts", "DELIVEROO单据大小\nDELIVEROO Ticket Size")
        self.category_analysis_tree["columns"] = columns
        self.category_analysis_tree["show"] = "headings"
        
        # 设置列标题和排序功能
        for col in columns:
            self.category_analysis_tree.heading(col, text=col, command=lambda c=col: self._sort_treeview_column(self.category_analysis_tree, c))
            self.category_analysis_tree.column(col, width=120, anchor="center")
        
        # 设置行高以显示中英文标题
        style = ttk.Style()
        style.configure("Treeview", rowheight=25)
        style.configure("Treeview.Heading", font=('Arial', 9, 'bold'), height=80, background="#34495e", foreground="white", padding=(10, 8))
        
        # 插入数据
        for row in self.category_analysis_data:
            formatted_row = (
                row['月份'],
                row['门市'],
                row['类别'],
                format_currency(row['总业绩']),
                format_number(row['总单据数']),
                format_currency(row['总单据大小']),
                format_currency(row['DI业绩']),
                format_number(row['DI单据数']),
                format_currency(row['DI单据大小']),
                format_currency(row['外带业绩']),
                format_number(row['外带单据数']),
                format_currency(row['外带单据大小']),
                format_currency(row['配送业绩']),
                format_number(row['配送单据数']),
                format_currency(row['配送单据大小']),
                format_currency(row['FOOD_PANDA业绩']),
                format_number(row['FOOD_PANDA单据数']),
                format_currency(row['FOOD_PANDA单据大小']),
                format_currency(row['GRAB_FOOD业绩']),
                format_number(row['GRAB_FOOD单据数']),
                format_currency(row['GRAB_FOOD单据大小']),
                format_currency(row['DELIVEROO业绩']),
                format_number(row['DELIVEROO单据数']),
                format_currency(row['DELIVEROO单据大小'])
            )
            
            self.category_analysis_tree.insert("", "end", values=formatted_row)
        
        # 切换到类别分析标签页（如果活动记录窗口没有打开）
        if not (hasattr(self, 'activity_window') and self.activity_window.winfo_exists()):
            self.notebook.select(1)  # 选择Product标签页
            self.product_notebook.select(6)  # 选择类别分析子标签页
    
    def get_weekly_product_data(self):
        """获取周期产品数据"""
        # 验证日期范围
        if not self.validate_date_range():
            return
            
        # 先连接数据库
        db = self.selected_db.get()
        self.log_message(f"正在连接到 {db}...")
        
        if not self.db_manager.connect(db):
            self.log_message(f"✗ 无法连接到 {db}")
            return
        
        self.log_message(f"✓ 连接成功", include_db_info=True)
        
        # 获取筛选条件
        if self.use_date_filter.get():
            date_from = self.date_from.get_date().strftime('%Y-%m-%d') if self.date_from.get_date() else None
            date_to = self.date_to.get_date().strftime('%Y-%m-%d') if self.date_to.get_date() else None
        else:
            date_from = None
            date_to = None
        
        outlet_filters = self.outlet_combo.get_selected()
        month_filters = self.month_combo.get_selected()
        weekday_filters = self.weekday_combo.get_selected()
        category_filters = self.category_combo.get_selected()
        payment_filters = self.payment_combo.get_selected()
        
        self.log_message("正在获取周期产品数据...")
        print(f"DEBUG: 调用 get_weekly_product_data，参数: date_from={date_from}, date_to={date_to}")
        print(f"DEBUG: 筛选条件: outlet_filters={outlet_filters}, month_filters={month_filters}, weekday_filters={weekday_filters}, category_filters={category_filters}, payment_filters={payment_filters}")
        
        # 清理缓存以确保获取最新数据
        if hasattr(self.db_manager, '_weekly_cache'):
            self.db_manager._weekly_cache.clear()
            print("DEBUG: 已清理周期产品数据缓存")
        
        # 强制清理所有相关缓存
        if hasattr(self.db_manager, '_product_cache'):
            self.db_manager._product_cache.clear()
        if hasattr(self.db_manager, '_period_product_cache'):
            self.db_manager._period_product_cache.clear()
        
        try:
            self.weekly_product_data = self.db_manager.get_weekly_product_data(
                date_from, date_to, outlet_filters, month_filters, weekday_filters, category_filters, payment_filters
            )
            print(f"DEBUG: get_weekly_product_data 返回结果: {len(self.weekly_product_data) if self.weekly_product_data else 0} 条记录")
            self.weekly_product_store_count = self.db_manager.get_unique_store_count(
                date_from=date_from,
                date_to=date_to,
                outlet_filters=outlet_filters,
                month_filters=month_filters,
                weekday_filters=weekday_filters,
                category_filters=category_filters,
                product_filters=None,
                payment_filters=payment_filters
            ) or 1
            
            if self.weekly_product_data:
                print(f"DEBUG: 准备显示 {len(self.weekly_product_data)} 条周-产品数据")
                self.display_weekly_product_data()
                self.log_message(f"✓ 获取周期产品数据成功，共 {len(self.weekly_product_data)} 条记录")
                # 确保切换到正确的标签页
                if hasattr(self, 'product_notebook'):
                    self.notebook.select(1)  # 选择Product标签页
                    self.product_notebook.select(1)  # 选择周-产品数据子标签页
            else:
                self.log_message("✗ 获取周期产品数据失败或没有数据")
                print("DEBUG: 周-产品数据为空，无法显示")
        except Exception as e:
            self.log_message(f"✗ 获取周期产品数据发生异常: {str(e)}")
            print(f"DEBUG: 获取周期产品数据异常: {e}")
        finally:
            self.db_manager.disconnect()
    
    def display_weekly_product_data(self):
        """显示周期产品数据"""
        # 清空现有数据
        for item in self.weekly_product_tree.get_children():
            self.weekly_product_tree.delete(item)
        
        # 清空選中產品列表
        self.selected_weekly_products = []
        
        if not self.weekly_product_data:
            return
        
        # 添加数据到表格
        # 检查数据格式以确定正确的键名
        if self.weekly_product_data:
            first_data = self.weekly_product_data[0]
            # 判断是合并模式还是单一模式
            if '产品业绩' in first_data:
                # 合并模式
                display_revenue_key = '日均业绩' if self.show_daily_average.get() else '产品业绩'
                receipt_key = '产品单据数'
                quantity_key = '销售数量'
            else:
                # 单一模式
                display_revenue_key = '总业绩_日均' if self.show_daily_average.get() else '总业绩'
                receipt_key = '总单据数'
                quantity_key = '销售总数'
        else:
            # 默认值
            display_revenue_key = '总业绩_日均' if self.show_daily_average.get() else '总业绩'
            receipt_key = '总单据数'
            quantity_key = '销售总数'
        
        revenue_column_label = "日均业绩" if self.show_daily_average.get() else "产品业绩"
        self.weekly_product_tree.heading("业绩", text=revenue_column_label)

        # 根据当前筛选确定门店数量用于单店平均
        store_count = self.weekly_product_store_count if getattr(self, 'weekly_product_store_count', 0) else 1

        for data in self.weekly_product_data:
            revenue_value = data[display_revenue_key]
            receipt_value = data[receipt_key]
            quantity_value = data[quantity_key]

            if self.show_store_average.get() and store_count > 0:
                revenue_value = revenue_value / store_count
                receipt_value = receipt_value / store_count
                quantity_value = quantity_value / store_count

            revenue_display = f"$ {revenue_value:,.2f}"

            values = (
                data['产品名称'],
                data['周数'],
                data['期间'],
                revenue_display,
                format_number(receipt_value),
                format_number(quantity_value)
            )
            
            # 根据类型设置不同的标签
            if data.get('类型') == 'Total':
                item = self.weekly_product_tree.insert("", "end", values=values, tags=("total",))
            else:
                item = self.weekly_product_tree.insert("", "end", values=values)
        
        # 配置总计行的样式
        self.weekly_product_tree.tag_configure("total", background="#E6F3FF", font=('Arial', 9, 'bold'))
        
        # 添加選中產品總計行（初始為空）
        self.update_weekly_selected_products_summary()
        
        # 切换到周期产品数据标签页（如果活动记录窗口没有打开）
        if not (hasattr(self, 'activity_window') and self.activity_window.winfo_exists()):
            self.notebook.select(1)  # 选择Product标签页
            self.product_notebook.select(1)  # 选择周期产品数据子标签页

    def get_product_overview(self):
        """获取产品总览分析"""
        # 验证日期范围
        if not self.validate_date_range():
            return
            
        # 先连接数据库
        db = self.selected_db.get()
        if not self.db_manager.connect(db):
            self.log_message("✗ 数据库连接失败")
            return
        
        # 获取筛选条件
        if self.use_date_filter.get():
            date_from = self.date_from.get_date().strftime('%Y-%m-%d') if self.date_from.get_date() else None
            date_to = self.date_to.get_date().strftime('%Y-%m-%d') if self.date_to.get_date() else None
        else:
            date_from = None
            date_to = None
            self.log_message("ℹ 未启用日期筛选，将使用月份筛选")
        
        outlet_filters = self.outlet_combo.get_selected()
        product_filters = self.product_combo.get_selected()
        month_filters = self.month_combo.get_selected()
        weekday_filters = self.weekday_combo.get_selected()
        category_filters = self.category_combo.get_selected()
        payment_filters = self.payment_combo.get_selected()
        
        # 保存门市筛选条件
        self.product_overview_outlet_filters = [o for o in outlet_filters if o]
        
        self.log_message("正在获取产品总览分析...")
        self.product_overview_data = self.db_manager.get_product_overview(
            date_from, date_to, outlet_filters, product_filters, month_filters, weekday_filters, category_filters, payment_filters
        )
        self.product_overview_store_count = self.db_manager.get_unique_store_count(
            date_from=date_from,
            date_to=date_to,
            outlet_filters=self.product_overview_outlet_filters,
            month_filters=month_filters,
            weekday_filters=weekday_filters,
            category_filters=category_filters,
            product_filters=product_filters,
            payment_filters=payment_filters
        ) or 1
        
        if self.product_overview_data:
            self.display_product_overview()
            self.log_message(f"✓ 获取产品总览分析成功，共 {len(self.product_overview_data)} 条记录")
        else:
            self.log_message("✗ 获取产品总览分析失败或没有数据")
    
    def get_period_product_overview(self):
        """获取期间产品总览分析"""
        # 验证日期范围
        if not self.validate_date_range():
            return
            
        # 先连接数据库
        db = self.selected_db.get()
        print(f"🔍 尝试连接数据库: {db}")
        if not self.db_manager.connect(db):
            self.log_message("✗ 数据库连接失败")
            print(f"❌ 数据库连接失败: {db}")
            return
        
        # 测试数据库连接
        try:
            cursor = self.db_manager.connection.cursor()
            cursor.execute("SELECT COUNT(*) FROM pos_sales_dtls")
            result = cursor.fetchone()
            print(f"✅ 数据库连接成功，pos_sales_dtls表记录数: {result[0] if result else 0}")
            cursor.close()
        except Exception as e:
            print(f"❌ 数据库连接测试失败: {e}")
            self.log_message(f"✗ 数据库连接测试失败: {e}")
            return
        
        # 获取筛选条件
        if self.use_date_filter.get():
            date_from = self.date_from.get_date().strftime('%Y-%m-%d') if self.date_from.get_date() else None
            date_to = self.date_to.get_date().strftime('%Y-%m-%d') if self.date_to.get_date() else None
        else:
            date_from = None
            date_to = None
            self.log_message("ℹ 未启用日期筛选，将使用月份筛选")
        
        outlet_filters = self.outlet_combo.get_selected()
        product_filters = self.product_combo.get_selected()
        month_filters = self.month_combo.get_selected()
        weekday_filters = self.weekday_combo.get_selected()
        category_filters = self.category_combo.get_selected()
        payment_filters = self.payment_combo.get_selected()
        
        self.log_message("正在获取期间产品总览分析...")
        try:
            self.period_product_overview_data = self.db_manager.get_period_product_overview(
                date_from, date_to, outlet_filters, product_filters, month_filters, weekday_filters, category_filters, payment_filters
            )
            self.period_product_store_count = self.db_manager.get_unique_store_count(
                date_from=date_from,
                date_to=date_to,
                outlet_filters=self.period_product_outlet_filters,
                month_filters=month_filters,
                weekday_filters=weekday_filters,
                category_filters=category_filters,
                product_filters=product_filters,
                payment_filters=payment_filters
            ) or 1
            
            if self.period_product_overview_data and len(self.period_product_overview_data) > 0:
                self.display_period_product_overview()
                self.log_message(f"✓ 获取期间产品总览分析成功，共 {len(self.period_product_overview_data)} 条记录")
                # 确保切换到正确的标签页
                if hasattr(self, 'product_notebook'):
                    self.notebook.select(1)  # 选择Product标签页
                    self.product_notebook.select(2)  # 选择期间-产品数据子标签页
            else:
                self.log_message("✗ 获取期间产品总览分析失败或没有数据")
        except Exception as e:
            self.log_message(f"✗ 获取期间产品总览分析发生异常: {str(e)}")
        finally:
            self.db_manager.disconnect()
    
    def display_period_product_overview(self):
        """显示期间产品总览分析数据"""
        if not hasattr(self, 'period_product_overview_data') or not self.period_product_overview_data:
            self.log_message("❌ 期间-产品数据为空，无法显示")
            return
            
        # 使用专门的期间产品treeview
        if not hasattr(self, 'period_product_tree'):
            self.log_message("❌ 期间产品数据显示组件未初始化")
            return
            
        # 清空现有数据
        for item in self.period_product_tree.get_children():
            self.period_product_tree.delete(item)
        
        # 清空選中產品列表
        self.selected_period_products = []
        
        # 设置列（期间汇总版本）
        columns = ("期间\nPeriod", "产品名称\nProduct Name", "类别\nCategory", "天数\nDays", 
                  "总业绩\nTotal Sales", "总单据数\nTotal Receipts", "销售总数\nTotal Quantity", 
                  "报废数量\nWastage Qty", "销售金额\nSales Amount", "产品单据业绩\nProduct Receipt Performance", "业绩占比(%)\nSales Ratio(%)", 
                  "数量占比(%)\nQuantity Ratio(%)", "报废占比(%)\nWastage Ratio(%)", "产品单据业绩占比(%)\nProduct Receipt Performance Ratio(%)")
        self.period_product_tree["columns"] = columns
        self.period_product_tree["show"] = "headings"
        
        # 设置列标题和排序功能
        for col in columns:
            self.period_product_tree.heading(col, text=col, command=lambda c=col: self._sort_treeview_column(self.period_product_tree, c))
            self.period_product_tree.column(col, width=150, anchor="center")
        
        # 樣式已在全局設定中處理，此處無需額外配置
        
        # 插入数据
        total_sales = 0
        total_receipts = 0
        total_quantity = 0
        total_wastage = 0
        total_product_receipt_performance = 0
        
        saved_outlets = getattr(self, 'period_product_outlet_filters', None)
        try:
            outlet_filters = [o for o in self.outlet_combo.get_selected() if o]
        except Exception:
            outlet_filters = []
        if not outlet_filters and saved_outlets is not None:
            outlet_filters = saved_outlets

        if self.show_store_average.get():
            store_count = self.period_product_store_count if hasattr(self, 'period_product_store_count') else len(outlet_filters) or 1
        else:
            store_count = len({row.get('门市') for row in self.period_product_overview_data if row.get('门市')}) or 1

        for row in self.period_product_overview_data:
            # 根据全局日均开关决定显示格式
            if self.show_daily_average.get():
                sales_value = row['总业绩_日均']
                receipts_value = row['总单据数_日均']
                quantity_value = row['销售总数_日均']
                wastage_value = row['报废数量_日均']
                product_receipt_performance_value = row.get('产品单据业绩_日均', 0)
            else:
                sales_value = row['总业绩']
                receipts_value = row['总单据数']
                quantity_value = row['销售总数']
                wastage_value = row['报废数量']
                product_receipt_performance_value = row.get('产品单据业绩', 0)

            if self.show_store_average.get():
                sales_value /= store_count
                receipts_value /= store_count
                quantity_value /= store_count
                wastage_value /= store_count
                product_receipt_performance_value /= store_count

            sales_amount_value = row['销售金额']
            if self.show_store_average.get():
                sales_amount_value /= store_count

            formatted_row = (
                row['期间'],
                row['产品名称'],
                row['类别'],
                row['天数'],
                format_currency(sales_value),
                format_number(receipts_value),
                format_number(quantity_value),
                format_number(wastage_value),
                format_currency(sales_amount_value),
                format_currency(product_receipt_performance_value),
                f"{row['业绩占比']:.2f}%",
                f"{row['数量占比']:.2f}%",
                f"{row['报废占比']:.2f}%",
                f"{row.get('产品单据业绩占比', 0):.2f}%"
            )

            # 累计总计（使用原始数据）
            total_sales += row['总业绩']
            total_receipts += row['总单据数']
            total_quantity += row['销售总数']
            total_wastage += row['报废数量']
            total_product_receipt_performance += row.get('产品单据业绩', 0)
            
            self.period_product_tree.insert("", "end", values=formatted_row)
        
        # 添加总计行
        if self.period_product_overview_data:
            total_quantity_with_wastage = total_wastage + total_quantity
            wastage_ratio_total = (total_wastage / total_quantity_with_wastage * 100) if total_quantity_with_wastage > 0 else 0
            total_product_receipt_performance_ratio = (total_product_receipt_performance / total_sales * 100) if total_sales > 0 else 0
            denom = len(self.period_product_overview_data) if (self.show_daily_average.get() and self.period_product_overview_data) else 1
            if self.show_store_average.get():
                denom *= store_count
            total_row = (
                "总计\nTotal",
                "所有产品\nAll Products",
                "",
                "",
                format_currency(total_sales / denom),
                format_number(total_receipts / denom),
                format_number(total_quantity / denom),
                format_number(total_wastage / denom),
                "",
                format_currency(total_product_receipt_performance / denom),
                "100.00%",
                "100.00%",
                f"{wastage_ratio_total:.2f}%",
                f"{total_product_receipt_performance_ratio:.2f}%"
            )
            
            # 插入总计行并设置颜色
            total_item = self.period_product_tree.insert("", "end", values=total_row, tags=("total",))
            self.period_product_tree.tag_configure("total", background="#E6F3FF", font=('Arial', 9, 'bold'))
            
            # 添加選中產品總計行（初始為空）
            self.update_selected_products_summary()
        
        # 切换到产品分析标签页（如果活动记录窗口没有打开）
        # 注释掉自动跳转，避免搜索时意外跳转
        # if not (hasattr(self, 'activity_window') and self.activity_window.winfo_exists()):
        #     # # self.notebook.select(1)  # 选择Product标签页 - 已禁用，避免跳转 - 已禁用，避免跳转
        #     self.product_notebook.select(0)  # 选择日-产品数据子标签页
    
    def on_period_product_selection_change(self, event):
        """處理期間產品選擇變化事件"""
        try:
            # 獲取選中的項目
            selected_items = self.period_product_tree.selection()
            # 過濾掉總計行和選中產品總計行
            selected_products = []
            for item in selected_items:
                values = self.period_product_tree.item(item, "values")
                if values and len(values) > 1:
                    product_name = values[1]  # 產品名稱在第2列
                    # 排除總計行和選中產品總計行
                    if product_name not in ["所有产品\nAll Products", "選中產品總計\nSelected Products Total"]:
                        selected_products.append(product_name)
            
            # 更新選中產品列表
            self.selected_period_products = selected_products
            
            # 更新選中產品總計行
            self.update_selected_products_summary()
            
        except Exception as e:
            print(f"處理期間產品選擇變化時出錯: {e}")
    
    def update_selected_products_summary(self):
        """更新選中產品的總計行"""
        try:
            # 移除所有現有的選中產品總計行
            items_to_delete = []
            for item in self.period_product_tree.get_children():
                values = self.period_product_tree.item(item, "values")
                if values and len(values) > 0 and ("選中產品總計" in str(values[0]) or "Selected Products Total" in str(values[0])):
                    items_to_delete.append(item)
            
            for item in items_to_delete:
                self.period_product_tree.delete(item)
            
            # 如果沒有選中產品，不顯示總計行
            if not self.selected_period_products:
                return
            
            # 計算選中產品的總計
            selected_total_sales = 0
            selected_total_receipts = 0
            selected_total_quantity = 0
            selected_total_wastage = 0
            selected_total_product_receipt_performance = 0
            selected_count = 0
            
            for row in self.period_product_overview_data:
                if row['产品名称'] in self.selected_period_products:
                    selected_total_sales += row['总业绩']
                    selected_total_receipts += row['总单据数']
                    selected_total_quantity += row['销售总数']
                    selected_total_wastage += row['报废数量']
                    selected_total_product_receipt_performance += row.get('产品单据业绩', 0)
                    selected_count += 1
            
            if selected_count == 0:
                return
            
            # 計算比例
            total_sales = sum(row['总业绩'] for row in self.period_product_overview_data)
            total_quantity_with_wastage = sum(row['销售总数'] + row['报废数量'] for row in self.period_product_overview_data)
            total_wastage = sum(row['报废数量'] for row in self.period_product_overview_data)
            total_product_receipt_performance = sum(row.get('产品单据业绩', 0) for row in self.period_product_overview_data)
            
            # 計算選中產品的占比
            selected_sales_ratio = (selected_total_sales / total_sales * 100) if total_sales > 0 else 0
            selected_quantity_ratio = (selected_total_quantity / sum(row['销售总数'] for row in self.period_product_overview_data) * 100) if sum(row['销售总数'] for row in self.period_product_overview_data) > 0 else 0
            selected_wastage_ratio = (selected_total_wastage / total_wastage * 100) if total_wastage > 0 else 0
            selected_product_receipt_performance_ratio = (selected_total_product_receipt_performance / total_product_receipt_performance * 100) if total_product_receipt_performance > 0 else 0
            
            # 根據顯示模式調整數值
            if self.show_daily_average.get():
                denom = len(self.period_product_overview_data) if self.period_product_overview_data else 1
            else:
                denom = 1
                
            if self.show_store_average.get():
                store_count = self.period_product_store_count if hasattr(self, 'period_product_store_count') else 1
                denom *= store_count
            
            # 創建選中產品總計行
            selected_row = (
                "選中產品總計\nSelected Products Total",
                f"已選中 {selected_count} 個產品\n{selected_count} Products Selected",
                "",
                "",
                format_currency(selected_total_sales / denom),
                format_number(selected_total_receipts / denom),
                format_number(selected_total_quantity / denom),
                format_number(selected_total_wastage / denom),
                "",
                format_currency(selected_total_product_receipt_performance / denom),
                f"{selected_sales_ratio:.2f}%",
                f"{selected_quantity_ratio:.2f}%",
                f"{selected_wastage_ratio:.2f}%",
                f"{selected_product_receipt_performance_ratio:.2f}%"
            )
            
            # 找到總計行的位置
            total_item_index = None
            children = self.period_product_tree.get_children()
            for i, item in enumerate(children):
                values = self.period_product_tree.item(item, "values")
                if values and len(values) > 1 and values[1] == "所有产品\nAll Products":
                    total_item_index = i
                    break
            
            # 在表格最頂部插入選中產品總計行
            selected_item = self.period_product_tree.insert("", 0, values=selected_row, tags=("selected_total",))
            
            self.period_product_tree.tag_configure("selected_total", background="#FFF2CC", font=('Arial', 9, 'bold'))
            
        except Exception as e:
            print(f"更新選中產品總計時出錯: {e}")
    
    def on_daily_product_selection_change(self, event):
        """處理日-產品數據選擇變化事件"""
        try:
            # 獲取選中的項目
            selected_items = self.product_overview_tree.selection()
            
            # 過濾掉總計行和選中產品總計行
            selected_products = []
            for item in selected_items:
                values = self.product_overview_tree.item(item, "values")
                if values and len(values) > 3:
                    product_name = values[3]  # 產品名稱在第4列
                    # 排除總計行和選中產品總計行
                    if product_name not in ["所有产品\nAll Products", "選中產品總計\nSelected Products Total"]:
                        selected_products.append(product_name)
            
            # 更新選中產品列表
            self.selected_daily_products = selected_products
            
            # 更新選中產品總計行
            self.update_daily_selected_products_summary()
            
        except Exception as e:
            print(f"處理日-產品數據選擇變化時出錯: {e}")
    
    def update_daily_selected_products_summary(self):
        """更新日-產品數據選中產品的總計行"""
        try:
            # 移除所有現有的選中產品總計行
            items_to_delete = []
            for item in self.product_overview_tree.get_children():
                values = self.product_overview_tree.item(item, "values")
                if values and len(values) > 3 and ("選中產品總計" in str(values[3]) or "Selected Products Total" in str(values[3])):
                    items_to_delete.append(item)
            
            for item in items_to_delete:
                self.product_overview_tree.delete(item)
            
            # 如果沒有選中產品，不顯示總計行
            if not self.selected_daily_products:
                return
            
            # 計算選中產品的總計
            selected_total_sales = 0
            selected_total_receipts = 0
            selected_total_quantity = 0
            selected_total_product_receipt_performance = 0
            selected_count = len(self.selected_daily_products)  # 直接使用選中產品列表的長度
            
            for row in self.product_overview_data:
                if row['产品名称'] in self.selected_daily_products:
                    selected_total_sales += row['总业绩']
                    selected_total_receipts += row['总单据数']
                    selected_total_quantity += row['销售总数']
                    selected_total_product_receipt_performance += row.get('产品单据业绩', 0)
            
            if selected_count == 0:
                return
            
            # 計算比例
            total_sales = sum(row['总业绩'] for row in self.product_overview_data)
            total_quantity = sum(row['销售总数'] for row in self.product_overview_data)
            total_product_receipt_performance = sum(row.get('产品单据业绩', 0) for row in self.product_overview_data)
            
            # 計算選中產品的占比
            selected_sales_ratio = (selected_total_sales / total_sales * 100) if total_sales > 0 else 0
            selected_quantity_ratio = (selected_total_quantity / total_quantity * 100) if total_quantity > 0 else 0
            selected_product_receipt_performance_ratio = (selected_total_product_receipt_performance / total_product_receipt_performance * 100) if total_product_receipt_performance > 0 else 0
            
            # 創建選中產品總計行
            selected_row = (
                "", "", "", f"選中產品總計 ({selected_count}個產品)\nSelected Products Total ({selected_count} Products)", "", 
                f"{selected_total_sales:.2f}", f"{selected_total_receipts}", f"{selected_total_quantity}", 
                f"{selected_total_sales:.2f}", f"{selected_total_product_receipt_performance:.2f}",
                f"{selected_sales_ratio:.2f}%", f"{selected_quantity_ratio:.2f}%", f"{selected_product_receipt_performance_ratio:.2f}%"
            )
            
            # 找到總計行的位置
            total_item_index = None
            children = self.product_overview_tree.get_children()
            for i, item in enumerate(children):
                values = self.product_overview_tree.item(item, "values")
                if values and len(values) > 3 and values[3] == "所有产品\nAll Products":
                    total_item_index = i
                    break
            
            # 在表格最頂部插入選中產品總計行
            selected_item = self.product_overview_tree.insert("", 0, values=selected_row, tags=("selected_total",))
            
            self.product_overview_tree.tag_configure("selected_total", background="#FFF2CC", font=('Arial', 9, 'bold'))
            
            # 使用sticky選項讓選中產品總計行固定在頂部
            self.product_overview_tree.item(selected_item, tags=("selected_total", "sticky"))
            self.product_overview_tree.tag_configure("sticky", sticky="n")
            
        except Exception as e:
            print(f"更新日-產品數據選中產品總計時出錯: {e}")
    
    def on_weekly_product_selection_change(self, event):
        """處理週-產品數據選擇變化事件"""
        try:
            # 獲取選中的項目
            selected_items = self.weekly_product_tree.selection()
            
            # 過濾掉總計行和選中產品總計行
            selected_products = []
            for item in selected_items:
                values = self.weekly_product_tree.item(item, "values")
                if values and len(values) > 0:
                    product_name = values[0]  # 產品名稱在第1列
                    # 排除總計行和選中產品總計行
                    if product_name not in ["所有产品\nAll Products", "選中產品總計\nSelected Products Total"]:
                        selected_products.append(product_name)
            
            # 更新選中產品列表
            self.selected_weekly_products = selected_products
            
            # 更新選中產品總計行
            self.update_weekly_selected_products_summary()
            
        except Exception as e:
            print(f"處理週-產品數據選擇變化時出錯: {e}")
    
    def update_weekly_selected_products_summary(self):
        """更新週-產品數據選中產品的總計行"""
        try:
            # 移除所有現有的選中產品總計行
            items_to_delete = []
            for item in self.weekly_product_tree.get_children():
                values = self.weekly_product_tree.item(item, "values")
                if values and len(values) > 0 and ("選中產品總計" in str(values[0]) or "Selected Products Total" in str(values[0])):
                    items_to_delete.append(item)
            
            for item in items_to_delete:
                self.weekly_product_tree.delete(item)
            
            # 如果沒有選中產品，不顯示總計行
            if not self.selected_weekly_products:
                return
            
            # 計算選中產品的總計
            selected_total_performance = 0
            selected_total_receipts = 0
            selected_total_quantity = 0
            selected_count = 0
            
            for row in self.weekly_product_data:
                if row['产品名称'] in self.selected_weekly_products:
                    selected_total_performance += row['业绩']
                    selected_total_receipts += row['产品单据数']
                    selected_total_quantity += row['销售数量']
                    selected_count += 1
            
            if selected_count == 0:
                return
            
            # 計算比例
            total_performance = sum(row['业绩'] for row in self.weekly_product_data)
            total_receipts = sum(row['产品单据数'] for row in self.weekly_product_data)
            total_quantity = sum(row['销售数量'] for row in self.weekly_product_data)
            
            # 計算選中產品的占比
            selected_performance_ratio = (selected_total_performance / total_performance * 100) if total_performance > 0 else 0
            selected_receipts_ratio = (selected_total_receipts / total_receipts * 100) if total_receipts > 0 else 0
            selected_quantity_ratio = (selected_total_quantity / total_quantity * 100) if total_quantity > 0 else 0
            
            # 創建選中產品總計行
            selected_row = (
                f"選中產品總計 ({selected_count}個產品)",
                "", "", 
                f"{selected_total_performance:.2f}",
                f"{selected_total_receipts}",
                f"{selected_total_quantity}"
            )
            
            # 找到總計行的位置
            total_item_index = None
            children = self.weekly_product_tree.get_children()
            for i, item in enumerate(children):
                values = self.weekly_product_tree.item(item, "values")
                if values and len(values) > 0 and values[0] == "所有产品\nAll Products":
                    total_item_index = i
                    break
            
            # 在表格最頂部插入選中產品總計行
            selected_item = self.weekly_product_tree.insert("", 0, values=selected_row, tags=("selected_total",))
            
            self.weekly_product_tree.tag_configure("selected_total", background="#FFF2CC", font=('Arial', 9, 'bold'))
            
        except Exception as e:
            print(f"更新週-產品數據選中產品總計時出錯: {e}")
    
    def on_monthly_product_selection_change(self, event):
        """處理月-銷售數據選擇變化事件"""
        try:
            # 獲取選中的項目
            selected_items = self.monthly_tree.selection()
            
            # 過濾掉總計行和選中產品總計行
            selected_products = []
            for item in selected_items:
                values = self.monthly_tree.item(item, "values")
                if values and len(values) > 1:
                    product_name = values[1]  # 產品名稱在第2列
                    # 排除總計行和選中產品總計行
                    if product_name not in ["所有产品\nAll Products", "選中產品總計\nSelected Products Total"]:
                        selected_products.append(product_name)
            
            # 更新選中產品列表
            self.selected_monthly_products = selected_products
            
            # 更新選中產品總計行
            self.update_monthly_selected_products_summary()
            
        except Exception as e:
            print(f"處理月-銷售數據選擇變化時出錯: {e}")
    
    def update_monthly_selected_products_summary(self):
        """更新月-銷售數據選中產品的總計行"""
        try:
            # 移除所有現有的選中產品總計行
            items_to_delete = []
            for item in self.monthly_tree.get_children():
                values = self.monthly_tree.item(item, "values")
                if values and len(values) > 1 and ("選中產品總計" in str(values[1]) or "Selected Products Total" in str(values[1])):
                    items_to_delete.append(item)
            
            for item in items_to_delete:
                self.monthly_tree.delete(item)
            
            # 如果沒有選中產品，不顯示總計行
            if not self.selected_monthly_products:
                return
            
            # 計算選中產品的總計
            selected_total_sales = 0
            selected_total_receipts = 0
            selected_total_quantity = 0
            selected_total_product_receipt_performance = 0
            selected_count = 0
            
            for row in self.monthly_summary_data:
                if row['产品名称'] in self.selected_monthly_products:
                    selected_total_sales += row['总业绩']
                    selected_total_receipts += row['总单据数']
                    selected_total_quantity += row['销售总数']
                    selected_total_product_receipt_performance += row.get('产品单据业绩', 0)
                    selected_count += 1
            
            if selected_count == 0:
                return
            
            # 計算比例
            total_sales = sum(row['总业绩'] for row in self.monthly_summary_data)
            total_quantity = sum(row['销售总数'] for row in self.monthly_summary_data)
            total_product_receipt_performance = sum(row.get('产品单据业绩', 0) for row in self.monthly_summary_data)
            
            # 計算選中產品的占比
            selected_sales_ratio = (selected_total_sales / total_sales * 100) if total_sales > 0 else 0
            selected_quantity_ratio = (selected_total_quantity / total_quantity * 100) if total_quantity > 0 else 0
            selected_product_receipt_performance_ratio = (selected_total_product_receipt_performance / total_product_receipt_performance * 100) if total_product_receipt_performance > 0 else 0
            
            # 創建選中產品總計行
            selected_row = (
                "", f"選中產品總計 ({selected_count}個產品)\nSelected Products Total ({selected_count} Products)", "", 
                f"{selected_total_quantity}", f"{selected_total_sales:.2f}", f"{selected_total_sales:.2f}", 
                f"{selected_total_receipts}", f"{selected_total_product_receipt_performance:.2f}",
                f"{selected_sales_ratio:.2f}%", f"{selected_quantity_ratio:.2f}%", f"{selected_product_receipt_performance_ratio:.2f}%"
            )
            
            # 找到總計行的位置
            total_item_index = None
            children = self.monthly_tree.get_children()
            for i, item in enumerate(children):
                values = self.monthly_tree.item(item, "values")
                if values and len(values) > 1 and values[1] == "所有产品\nAll Products":
                    total_item_index = i
                    break
            
            # 在表格最頂部插入選中產品總計行
            selected_item = self.monthly_tree.insert("", 0, values=selected_row, tags=("selected_total",))
            
            self.monthly_tree.tag_configure("selected_total", background="#FFF2CC", font=('Arial', 9, 'bold'))
            
        except Exception as e:
            print(f"更新月-銷售數據選中產品總計時出錯: {e}")
    
    def on_monthly_analysis_selection_change(self, event):
        """處理月-產品分析選擇變化事件"""
        try:
            # 獲取選中的項目
            selected_items = self.sales_tc_monthly_tree.selection()
            
            # 過濾掉總計行和選中產品總計行
            selected_products = []
            for item in selected_items:
                values = self.sales_tc_monthly_tree.item(item, "values")
                if values and len(values) > 1:
                    product_name = values[1]  # 產品名稱在第2列
                    # 排除總計行和選中產品總計行
                    if product_name not in ["所有产品\nAll Products", "選中產品總計\nSelected Products Total"]:
                        selected_products.append(product_name)
            
            # 更新選中產品列表
            self.selected_monthly_analysis_products = selected_products
            
            # 更新選中產品總計行
            self.update_monthly_analysis_selected_products_summary()
            
        except Exception as e:
            print(f"處理月-產品分析選擇變化時出錯: {e}")
    
    def update_monthly_analysis_selected_products_summary(self):
        """更新月-產品分析選中產品的總計行"""
        try:
            # 移除所有現有的選中產品總計行
            items_to_delete = []
            for item in self.sales_tc_monthly_tree.get_children():
                values = self.sales_tc_monthly_tree.item(item, "values")
                if values and len(values) > 1 and ("選中產品總計" in str(values[1]) or "Selected Products Total" in str(values[1])):
                    items_to_delete.append(item)
            
            for item in items_to_delete:
                self.sales_tc_monthly_tree.delete(item)
            
            # 如果沒有選中產品，不顯示總計行
            if not self.selected_monthly_analysis_products:
                return
            
            # 計算選中產品的總計
            selected_total_sales = 0
            selected_total_receipts = 0
            selected_total_quantity = 0
            selected_total_product_receipt_performance = 0
            selected_count = 0
            
            for row in self.sales_tc_monthly_data:
                if row['产品名称'] in self.selected_monthly_analysis_products:
                    selected_total_sales += row['总业绩']
                    selected_total_receipts += row['总单据数']
                    selected_total_quantity += row['销售总数']
                    selected_total_product_receipt_performance += row.get('产品单据业绩', 0)
                    selected_count += 1
            
            if selected_count == 0:
                return
            
            # 計算比例
            total_sales = sum(row['总业绩'] for row in self.sales_tc_monthly_data)
            total_quantity = sum(row['销售总数'] for row in self.sales_tc_monthly_data)
            total_product_receipt_performance = sum(row.get('产品单据业绩', 0) for row in self.sales_tc_monthly_data)
            
            # 計算選中產品的占比
            selected_sales_ratio = (selected_total_sales / total_sales * 100) if total_sales > 0 else 0
            selected_quantity_ratio = (selected_total_quantity / total_quantity * 100) if total_quantity > 0 else 0
            selected_product_receipt_performance_ratio = (selected_total_product_receipt_performance / total_product_receipt_performance * 100) if total_product_receipt_performance > 0 else 0
            
            # 創建選中產品總計行
            selected_row = (
                "", f"選中產品總計 ({selected_count}個產品)\nSelected Products Total ({selected_count} Products)", 
                f"{selected_total_sales:.2f}", f"{selected_total_receipts}", f"{selected_total_quantity}", 
                f"{selected_total_sales:.2f}", f"{selected_total_receipts}", f"{selected_total_quantity}", 
                f"{selected_total_product_receipt_performance:.2f}",
                f"{selected_sales_ratio:.2f}%", f"{selected_quantity_ratio:.2f}%", f"{selected_product_receipt_performance_ratio:.2f}%"
            )
            
            # 找到總計行的位置
            total_item_index = None
            children = self.sales_tc_monthly_tree.get_children()
            for i, item in enumerate(children):
                values = self.sales_tc_monthly_tree.item(item, "values")
                if values and len(values) > 1 and values[1] == "所有产品\nAll Products":
                    total_item_index = i
                    break
            
            # 在表格最頂部插入選中產品總計行
            selected_item = self.sales_tc_monthly_tree.insert("", 0, values=selected_row, tags=("selected_total",))
            
            self.sales_tc_monthly_tree.tag_configure("selected_total", background="#FFF2CC", font=('Arial', 9, 'bold'))
            
        except Exception as e:
            print(f"更新月-產品分析選中產品總計時出錯: {e}")
    
    def on_association_selection_change(self, event):
        """處理產品關聯分析選擇變化事件"""
        try:
            # 獲取選中的項目
            selected_items = self.product_association_tree.selection()
            
            # 過濾掉總計行和選中產品總計行
            selected_products = []
            for item in selected_items:
                values = self.product_association_tree.item(item, "values")
                if values and len(values) > 0:
                    product_name = values[0]  # 產品名稱在第1列
                    # 排除總計行和選中產品總計行
                    if product_name not in ["所有产品\nAll Products", "選中產品總計\nSelected Products Total"]:
                        selected_products.append(product_name)
            
            # 更新選中產品列表
            self.selected_association_products = selected_products
            
            # 更新選中產品總計行
            self.update_association_selected_products_summary()
            
        except Exception as e:
            print(f"處理產品關聯分析選擇變化時出錯: {e}")
    
    def update_association_selected_products_summary(self):
        """更新產品關聯分析選中產品的總計行"""
        try:
            # 移除所有現有的選中產品總計行
            items_to_delete = []
            for item in self.product_association_tree.get_children():
                values = self.product_association_tree.item(item, "values")
                if values and len(values) > 0 and ("選中產品總計" in str(values[0]) or "Selected Products Total" in str(values[0])):
                    items_to_delete.append(item)
            
            for item in items_to_delete:
                self.product_association_tree.delete(item)
            
            # 如果沒有選中產品，不顯示總計行
            if not self.selected_association_products:
                return
            
            # 計算選中產品的總計
            selected_total_sales = 0
            selected_total_receipts = 0
            selected_total_quantity = 0
            selected_count = 0
            
            for row in self.product_association_data:
                if row['产品名称'] in self.selected_association_products:
                    selected_total_sales += row['总业绩']
                    selected_total_receipts += row['总单据数']
                    selected_total_quantity += row['销售总数']
                    selected_count += 1
            
            if selected_count == 0:
                return
            
            # 計算比例
            total_sales = sum(row['总业绩'] for row in self.product_association_data)
            total_quantity = sum(row['销售总数'] for row in self.product_association_data)
            
            # 計算選中產品的占比
            selected_sales_ratio = (selected_total_sales / total_sales * 100) if total_sales > 0 else 0
            selected_quantity_ratio = (selected_total_quantity / total_quantity * 100) if total_quantity > 0 else 0
            
            # 創建選中產品總計行
            selected_row = (
                f"選中產品總計 ({selected_count}個產品)",
                "", "", "", "", "", "", "", "", "", "",
                f"{selected_sales_ratio:.2f}%", f"{selected_quantity_ratio:.2f}%"
            )
            
            # 找到總計行的位置
            total_item_index = None
            children = self.product_association_tree.get_children()
            for i, item in enumerate(children):
                values = self.product_association_tree.item(item, "values")
                if values and len(values) > 0 and values[0] == "所有产品\nAll Products":
                    total_item_index = i
                    break
            
            # 在表格最頂部插入選中產品總計行
            selected_item = self.product_association_tree.insert("", 0, values=selected_row, tags=("selected_total",))
            
            self.product_association_tree.tag_configure("selected_total", background="#FFF2CC", font=('Arial', 9, 'bold'))
            
        except Exception as e:
            print(f"更新產品關聯分析選中產品總計時出錯: {e}")
    
    def display_product_overview(self):
        """显示产品总览分析数据"""
        # 清空现有数据
        for item in self.product_overview_tree.get_children():
            self.product_overview_tree.delete(item)
        
        # 清空選中產品列表
        self.selected_daily_products = []
        
        # 设置列
        columns = ("日期\nDate", "月份\nMonth", "门市\nOutlet", "产品名称\nProduct Name", "类别\nCategory", 
                  "总业绩\nTotal Sales", "总单据数\nTotal Receipts", "销售总数\nTotal Quantity", 
                  "销售金额\nSales Amount", "产品单据业绩\nProduct Receipt Performance", 
                  "业绩占比(%)\nSales Ratio(%)", "数量占比(%)\nQuantity Ratio(%)", "产品单据业绩占比(%)\nProduct Receipt Performance Ratio(%)")
        self.product_overview_tree["columns"] = columns
        self.product_overview_tree["show"] = "headings"
        
        # 设置列标题和排序功能
        for col in columns:
            self.product_overview_tree.heading(col, text=col, command=lambda c=col: self._sort_treeview_column(self.product_overview_tree, c))
            self.product_overview_tree.column(col, width=150, anchor="center")
        
        # 樣式已在全局設定中處理，此處無需額外配置
        
        # 配置All门市行的样式
        self.product_overview_tree.tag_configure("all_outlet", background="#E6F3FF", font=('Arial', 9, 'bold'))
        
        # 插入数据
        total_sales = 0
        total_receipts = 0
        total_quantity = 0
        
        saved_outlets = getattr(self, 'product_overview_outlet_filters', None)
        try:
            outlet_filters = [o for o in self.outlet_combo.get_selected() if o]
        except Exception:
            outlet_filters = []
        if not outlet_filters and saved_outlets is not None:
            outlet_filters = saved_outlets

        if self.show_store_average.get():
            store_count = self.product_overview_store_count if hasattr(self, 'product_overview_store_count') else len(outlet_filters) or 1
        else:
            store_count = len({row.get('门市') for row in self.product_overview_data if row.get('门市')}) or 1

        # 计算All门市汇总数据
        all_outlet_data = {}
        daily_totals_for_all = {}  # 用于计算All门市的占比
        
        for row in self.product_overview_data:
            # 包含日期在键中，确保每个日期的数据分别汇总
            product_key = f"{row['日期']}_{row['产品名称']}_{row['类别']}"
            if product_key not in all_outlet_data:
                all_outlet_data[product_key] = {
                    '日期': row['日期'],
                    '月份': row['月份'],
                    '门市': 'All',
                    '产品名称': row['产品名称'],
                    '类别': row['类别'],
                    '总业绩': 0,
                    '总单据数': 0,
                    '销售总数': 0,
                    '销售金额': 0,
                    '产品单据业绩': 0,
                    '总业绩_日均': 0,
                    '总单据数_日均': 0,
                    '销售总数_日均': 0,
                    '销售金额_日均': 0,
                    '产品单据业绩_日均': 0,
                    '业绩占比': 0,
                    '数量占比': 0,
                    '产品单据业绩占比': 0
                }
            
            # 累加数据
            all_outlet_data[product_key]['总业绩'] += row['总业绩']
            all_outlet_data[product_key]['总单据数'] += row['总单据数']
            all_outlet_data[product_key]['销售总数'] += row['销售总数']
            all_outlet_data[product_key]['销售金额'] += row['销售金额']
            all_outlet_data[product_key]['产品单据业绩'] += row.get('产品单据业绩', 0)
            all_outlet_data[product_key]['总业绩_日均'] += row.get('总业绩_日均', 0)
            all_outlet_data[product_key]['总单据数_日均'] += row.get('总单据数_日均', 0)
            all_outlet_data[product_key]['销售总数_日均'] += row.get('销售总数_日均', 0)
            all_outlet_data[product_key]['销售金额_日均'] += row.get('销售金额_日均', 0)
            all_outlet_data[product_key]['产品单据业绩_日均'] += row.get('产品单据业绩_日均', 0)
            
            # 累加到該日期的總計（用於計算All門市的占比）
            date_key = row['日期']
            if date_key not in daily_totals_for_all:
                daily_totals_for_all[date_key] = {
                    '总业绩': 0,
                    '销售总数': 0,
                    '产品单据业绩': 0
                }
            daily_totals_for_all[date_key]['总业绩'] += row['总业绩']
            daily_totals_for_all[date_key]['销售总数'] += row['销售总数']
            daily_totals_for_all[date_key]['产品单据业绩'] += row.get('产品单据业绩', 0)
        
        # 重新計算All門市的占比
        for product_key, all_data in all_outlet_data.items():
            date_key = all_data['日期']
            daily_totals = daily_totals_for_all.get(date_key, {'总业绩': 0, '销售总数': 0, '产品单据业绩': 0})
            
            # 計算占比
            all_data['业绩占比'] = (all_data['总业绩'] / daily_totals['总业绩'] * 100) if daily_totals['总业绩'] > 0 else 0
            all_data['数量占比'] = (all_data['销售总数'] / daily_totals['销售总数'] * 100) if daily_totals['销售总数'] > 0 else 0
            all_data['产品单据业绩占比'] = (all_data['产品单据业绩'] / daily_totals['产品单据业绩'] * 100) if daily_totals['产品单据业绩'] > 0 else 0

        # 先显示All门市汇总数据
        for product_key, all_data in all_outlet_data.items():
            if self.show_daily_average.get():
                sales_value = all_data['总业绩_日均']
                receipts_value = all_data['总单据数_日均']
                quantity_value = all_data['销售总数_日均']
                amount_value = all_data['销售金额_日均']
                product_receipt_performance_value = all_data['产品单据业绩_日均']
            else:
                sales_value = all_data['总业绩']
                receipts_value = all_data['总单据数']
                quantity_value = all_data['销售总数']
                amount_value = all_data['销售金额']
                product_receipt_performance_value = all_data['产品单据业绩']

            if self.show_store_average.get():
                sales_value /= store_count
                receipts_value /= store_count
                quantity_value /= store_count
                amount_value /= store_count
                product_receipt_performance_value /= store_count

            formatted_row = (
                all_data['日期'],
                all_data['月份'],
                all_data['门市'],
                all_data['产品名称'],
                all_data['类别'],
                format_currency(sales_value),
                format_number(receipts_value),
                format_number(quantity_value),
                format_currency(amount_value),
                format_currency(product_receipt_performance_value),
                f"{all_data['业绩占比']:.2f}%",
                f"{all_data['数量占比']:.2f}%",
                f"{all_data['产品单据业绩占比']:.2f}%"
            )
            
            self.product_overview_tree.insert("", "end", values=formatted_row, tags=("all_outlet",))

        # 然后显示各个门市的详细数据
        for row in self.product_overview_data:
            # 显示每日数据
            if self.show_daily_average.get():
                sales_value = row['总业绩_日均']
                receipts_value = row['总单据数_日均']
                quantity_value = row['销售总数_日均']
                amount_value = row['销售金额_日均']
                product_receipt_performance_value = row.get('产品单据业绩_日均', 0)
            else:
                sales_value = row['总业绩']
                receipts_value = row['总单据数']
                quantity_value = row['销售总数']
                amount_value = row['销售金额']
                product_receipt_performance_value = row.get('产品单据业绩', 0)

            if self.show_store_average.get():
                sales_value /= store_count
                receipts_value /= store_count
                quantity_value /= store_count
                amount_value /= store_count
                product_receipt_performance_value /= store_count

            formatted_row = (
                row['日期'],
                row['月份'],
                row['门市'],
                row['产品名称'],
                row['类别'],
                format_currency(sales_value),
                format_number(receipts_value),
                format_number(quantity_value),
                format_currency(amount_value),
                format_currency(product_receipt_performance_value),
                f"{row['业绩占比']:.2f}%",
                f"{row['数量占比']:.2f}%",
                f"{row.get('产品单据业绩占比', 0):.2f}%"
            )
            
            # 累计总计
            total_sales += row['总业绩']
            total_receipts += row['总单据数']
            total_quantity += row['销售总数']
            
            self.product_overview_tree.insert("", "end", values=formatted_row)
        
        # 添加总计行（只计算原始数据，不包括All门市汇总）
        if self.product_overview_data:
            denom = len([r for r in self.product_overview_data if not r['日期'].startswith('【')]) if self.show_daily_average.get() else 1
            denom = denom if denom and denom > 0 else 1
            if self.show_store_average.get():
                denom *= store_count
            total_row = (
                "总计\nTotal",
                "",
                "",
                "所有产品\nAll Products",
                "",
                format_currency(total_sales / denom),
                format_number(total_receipts / denom),
                format_number(total_quantity / denom),
                "",
                "100.00%",
                "100.00%"
            )
            
            # 插入总计行并设置颜色
            total_item = self.product_overview_tree.insert("", "end", values=total_row, tags=("total",))
            self.product_overview_tree.tag_configure("total", background="#E6F3FF", font=('Arial', 9, 'bold'))
            
            # 添加選中產品總計行（初始為空）
            self.update_daily_selected_products_summary()
        
        # 切换到产品总览标签页
        self.safe_switch_to_tab(1, 0)
    
    def safe_switch_to_tab(self, main_tab, sub_tab=None):
        """安全地切换到标签页，保护活动记录窗口的右侧面板"""
        try:
            # 检查活动记录窗口是否打开
            if hasattr(self, 'activity_window') and self.activity_window.winfo_exists():
                # 活动记录窗口打开时，不切换主窗口标签页
                print("⛔ 活动记录窗口打开，跳转标签页切换")
                return False
            
            # 活动记录窗口关闭或不存于时，可以切换
            self.notebook.select(main_tab)
            if sub_tab is not None:
                if main_tab == 1:  # Product标签页
                    self.product_notebook.select(sub_tab)
                elif main_tab == 0:  # Sales标签页
                    self.sales_notebook.select(sub_tab)
                elif main_tab == 2:  # Brand标签页
                    if hasattr(self, 'brand_notebook'):
                        self.brand_notebook.select(sub_tab)
            return True
            
        except Exception as e:
            print(f"切换标签页失败: {e}")
            return False
    
    def _sort_treeview_column(self, tree, col, reverse=False):
        """对Treeview列进行排序"""
        # 获取所有数据
        data = [(tree.set(child, col), child) for child in tree.get_children('')]
        
        # 尝试将数据转换为数字进行排序
        try:
            # 如果是数字列，按数字排序
            data.sort(key=lambda x: float(x[0]) if x[0] else 0, reverse=reverse)
        except ValueError:
            # 如果不是数字，按字符串排序
            data.sort(key=lambda x: x[0] or "", reverse=reverse)
        
        # 重新排列项目
        for index, (val, child) in enumerate(data):
            tree.move(child, '', index)
        
        # 切换排序顺序
        tree.heading(col, command=lambda: self._sort_treeview_column(tree, col, not reverse))
    
    def open_activity_window(self):
        """打开增强版活动记录窗口 - 全新美化界面"""
        # 创建活动记录窗口 - 现代化设计
        self.activity_window = tk.Toplevel(self.root)
        self.activity_window.title("🎯 活动记录管理中心 / Activity Management Center")
        self.activity_window.geometry("1900x1100")
        self.activity_window.transient(self.root)
        self.activity_window.grab_set()
        
        # 设置窗口图标和样式
        try:
            self.activity_window.configure(bg='#FFFFFF')
        except:
            pass
        
        # 创建顶部标题栏
        header_frame = tk.Frame(self.activity_window, bg='#2c3e50', height=60)
        header_frame.pack(fill="x", padx=0, pady=0)
        header_frame.pack_propagate(False)
        
        # 标题和图标
        title_container = tk.Frame(header_frame, bg='#2c3e50')
        title_container.pack(expand=True, fill="both")
        
        title_label = tk.Label(title_container, 
                              text="🎯 活动记录管理中心", 
                              font=('Microsoft YaHei UI', 18, 'bold'),
                              fg='white', bg='#2c3e50')
        title_label.pack(side="left", padx=20, pady=15)
        
        subtitle_label = tk.Label(title_container, 
                                 text="Activity Management Center", 
                                 font=('Arial', 11),
                                 fg='#bdc3c7', bg='#2c3e50')
        subtitle_label.pack(side="left", padx=(0, 20), pady=15)
        
        # 窗口控制按钮区域
        window_controls = tk.Frame(title_container, bg='#2c3e50')
        window_controls.pack(side="right", padx=10, pady=10)
        
        # 最小化按钮
        minimize_btn = tk.Button(window_controls, text="🗕", 
                               command=self.minimize_activity_window,
                               font=('Arial', 12), bg='#34495e', fg='white',
                               relief='flat', bd=0, width=3, height=1,
                               cursor='hand2')
        minimize_btn.pack(side="left", padx=2)
        
        # 全屏/还原按钮
        self.fullscreen_btn = tk.Button(window_controls, text="🗖", 
                                      command=self.toggle_activity_fullscreen,
                                      font=('Arial', 12), bg='#34495e', fg='white',
                                      relief='flat', bd=0, width=3, height=1,
                                      cursor='hand2')
        self.fullscreen_btn.pack(side="left", padx=2)
        
        # 关闭按钮
        close_btn = tk.Button(window_controls, text="✕", 
                            command=self.close_activity_window,
                            font=('Arial', 12), bg='#e74c3c', fg='white',
                            relief='flat', bd=0, width=3, height=1,
                            cursor='hand2')
        close_btn.pack(side="left", padx=2)
        
        # 创建主容器 - 现代化布局
        main_container = tk.Frame(self.activity_window, bg='#FFFFFF')
        main_container.pack(fill="both", expand=True, padx=0, pady=0)
        
        # 左侧主面板 - 活动管理区域
        left_container = tk.Frame(main_container, bg='#ffffff', relief='flat', bd=0)
        left_container.pack(side="left", fill="both", expand=True, padx=(15, 8), pady=15)
        
        # 右侧面板 - 假期信息和快捷操作
        right_container = tk.Frame(main_container, bg='#ffffff', relief='flat', bd=0)
        right_container.pack(side="right", fill="y", expand=False, padx=(8, 15), pady=15)
        right_container.configure(width=400)
        right_container.pack_propagate(False)
        
        # 創建現代化卡片式輸入區域
        input_card = tk.Frame(left_container, bg='#ffffff', relief='solid', bd=1)
        input_card.pack(fill="x", pady=(10, 20), padx=10)
        
        # 卡片標題
        card_header = tk.Frame(input_card, bg='#3498db', height=40)
        card_header.pack(fill="x")
        card_header.pack_propagate(False)
        
        header_title = tk.Label(card_header, 
                               text="📝 新增活動記錄", 
                               font=('Microsoft YaHei UI', 12, 'bold'),
                               fg='white', bg='#3498db')
        header_title.pack(side="left", padx=15, pady=10)
        
        header_subtitle = tk.Label(card_header, 
                                  text="Add New Activity Record", 
                                  font=('Arial', 9),
                                  fg='#ecf0f1', bg='#3498db')
        header_subtitle.pack(side="left", padx=(0, 15), pady=10)
        
        # 卡片內容區域
        card_content = tk.Frame(input_card, bg='#ffffff')
        card_content.pack(fill="both", expand=True, padx=20, pady=20)
        
        # 緊湊型選擇區域 - 一行顯示
        compact_row = tk.Frame(card_content, bg='#ffffff')
        compact_row.pack(fill="x", pady=(0, 8))
        
        # 數據庫選擇區域 - 緊湑版
        db_section = tk.Frame(compact_row, bg='#FFFFFF', relief='solid', bd=1)
        db_section.pack(side="left", fill="x", expand=True, padx=(0, 5))
        
        db_header = tk.Label(db_section, text="🗄️ 數據源 / Database", 
                            font=('Microsoft YaHei UI', 10, 'bold'),
                            fg='#2c3e50', bg='#FFFFFF')
        db_header.pack(pady=(6, 4))
        
        self.activity_database = tk.StringVar(value="GOGO")
        
        # 水平排列的數據庫按鈕
        db_buttons_container = tk.Frame(db_section, bg='#FFFFFF')
        db_buttons_container.pack(pady=(0, 5), padx=5)
        
        # 數據庫選項配置 - 緊湊版
        db_options = [
            ("GOGO", "🟢 GOGO", "#27ae60"),
            ("Express", "🔵 Express", "#3498db"), 
            ("PLUS", "🟡 PLUS", "#f39c12"),
            ("All", "🌐 All", "#9b59b6")
        ]
        
        self.db_buttons = {}
        for value, text, color in db_options:
            btn = tk.Radiobutton(db_buttons_container, text=text, variable=self.activity_database,
                               value=value, command=self.on_database_change,
                               font=('Arial', 9, 'bold'), 
                               bg='white', fg=color, relief='raised', bd=1,
                               selectcolor=color, activebackground='#d5dbdb',
                               indicatoron=0, width=10, height=2)
            btn.pack(side="left", padx=2)
            self.db_buttons[value] = btn
        
        # 活動類型選擇區域 - 緊湊版
        type_section = tk.Frame(compact_row, bg='#FFFFFF', relief='solid', bd=1)
        type_section.pack(side="right", fill="x", expand=True, padx=(5, 0))
        
        type_header = tk.Label(type_section, text="📅 活動類型 / Activity Type", 
                              font=('Microsoft YaHei UI', 10, 'bold'),
                              fg='#2c3e50', bg='#FFFFFF')
        type_header.pack(pady=(6, 4))
        
        self.activity_type = tk.StringVar(value="daily")
        
        # 水平排列的類型按鈕
        type_buttons_container = tk.Frame(type_section, bg='#FFFFFF')
        type_buttons_container.pack(pady=(0, 5), padx=5)
        
        # 活動類型選項配置 - 緊湊版
        type_options = [
            ("daily", "📅 每日 / Daily", "#e74c3c"),
            ("weekly", "🔄 週期 / Weekly", "#f39c12")
        ]
        
        self.type_buttons = {}
        for value, text, color in type_options:
            btn = tk.Radiobutton(type_buttons_container, text=text, variable=self.activity_type,
                               value=value, command=self.on_activity_type_change,
                               font=('Arial', 9, 'bold'), 
                               bg='white', fg=color, relief='raised', bd=1,
                               selectcolor=color, activebackground='#FFFFFF',
                               indicatoron=0, width=12, height=2)
            btn.pack(side="left", padx=2)
            self.type_buttons[value] = btn
        
        # 緊湊型日期選擇區域
        date_section = tk.Frame(card_content, bg='#ffffff')
        date_section.pack(fill="x", pady=(0, 8))
        
        # 日期選擇容器
        self.date_selection_frame = tk.Frame(date_section, bg='#ffffff')
        self.date_selection_frame.pack(fill="x")
        
        # 每日活動日期選擇 - 緊湊版
        self.daily_date_frame = tk.Frame(self.date_selection_frame, bg='#FFFFFF', relief='solid', bd=1)
        self.daily_date_frame.pack(fill="x", pady=1)
        
        daily_inputs = tk.Frame(self.daily_date_frame, bg='#FFFFFF')
        daily_inputs.pack(pady=5, padx=10)
        
        tk.Label(daily_inputs, text="📅 活動日期 / Activity Date:", font=('Arial', 9, 'bold'),
                fg='#2c3e50', bg='#FFFFFF').pack(side="left", padx=(0, 5))
        self.activity_date_from = DateEntry(daily_inputs, width=10, background='#3498db',
                                          foreground='white', borderwidth=1, date_pattern='dd/mm/yyyy')
        self.activity_date_from.pack(side="left", padx=2)
        
        tk.Label(daily_inputs, text="到", font=('Arial', 8),
                fg='#34495e', bg='#FFFFFF').pack(side="left", padx=2)
        self.activity_date_to = DateEntry(daily_inputs, width=10, background='#3498db',
                                        foreground='white', borderwidth=1, date_pattern='dd/mm/yyyy')
        self.activity_date_to.pack(side="left", padx=2)
        
        # 每日活動時間篩選區域 - 新增
        daily_time_filter_frame = tk.Frame(self.daily_date_frame, bg='#FFFFFF')
        daily_time_filter_frame.pack(fill="x", pady=(5, 0), padx=10)
        
        # 每日活動時間調整選項
        self.time_filter_enabled = tk.BooleanVar()
        daily_time_checkbox = tk.Checkbutton(daily_time_filter_frame, text="⏰ 時間調整 / Time Adjustment", 
                                           variable=self.time_filter_enabled, font=('Arial', 9, 'bold'),
                                           fg='#2c3e50', bg='#FFFFFF', selectcolor='#FFFFFF',
                                           command=self.toggle_time_filter)
        daily_time_checkbox.pack(side="left", padx=(0, 10))
        
        # 時間輸入框容器
        self.time_inputs_frame = tk.Frame(daily_time_filter_frame, bg='#FFFFFF')
        
        tk.Label(self.time_inputs_frame, text="開始時間:", font=('Arial', 8), 
                fg='#34495e', bg='#FFFFFF').pack(side="left", padx=(0, 2))
        self.start_time_entry = tk.Entry(self.time_inputs_frame, width=8, font=('Arial', 8))
        self.start_time_entry.pack(side="left", padx=2)
        self.start_time_entry.insert(0, "12:00")
        
        tk.Label(self.time_inputs_frame, text="結束時間:", font=('Arial', 8), 
                fg='#34495e', bg='#FFFFFF').pack(side="left", padx=(5, 2))
        self.end_time_entry = tk.Entry(self.time_inputs_frame, width=8, font=('Arial', 8))
        self.end_time_entry.pack(side="left", padx=2)
        self.end_time_entry.insert(0, "18:00")
        
        # 自動時間範圍選項
        self.auto_time_range = tk.BooleanVar()
        auto_time_checkbox = tk.Checkbutton(daily_time_filter_frame, text="🔄 從第一件到最後一件產品銷售時間", 
                                          variable=self.auto_time_range, font=('Arial', 8),
                                          fg='#e67e22', bg='#FFFFFF', selectcolor='#FFFFFF',
                                          command=self.toggle_auto_time_range)
        auto_time_checkbox.pack(side="left", padx=(10, 0))
        
        # 週期性活動選擇 - 緊湊版
        self.weekly_selection_frame = tk.Frame(self.date_selection_frame, bg='#FFFFFF', relief='solid', bd=1)
        
        # 週期性活動日期範圍 - 一行顯示
        weekly_date_frame = tk.Frame(self.weekly_selection_frame, bg='#FFFFFF')
        weekly_date_frame.pack(fill="x", pady=5, padx=10)
        
        tk.Label(weekly_date_frame, text="📅 活動期間 / Activity Period:", font=('Arial', 9, 'bold'),
                fg='#2c3e50', bg='#FFFFFF').pack(side="left", padx=(0, 5))
        self.weekly_date_from = DateEntry(weekly_date_frame, width=10, background='#FFFFFF',
                                        foreground='white', borderwidth=1, date_pattern='dd/mm/yyyy')
        self.weekly_date_from.pack(side="left", padx=2)
        
        tk.Label(weekly_date_frame, text="到", font=('Arial', 8),
                fg='#34495e', bg='#FFFFFF').pack(side="left", padx=2)
        self.weekly_date_to = DateEntry(weekly_date_frame, width=10, background='#FFFFFF',
                                      foreground='white', borderwidth=1, date_pattern='dd/mm/yyyy')
        self.weekly_date_to.pack(side="left", padx=2)
        
        # 星期選擇 - 緊湊版一行顯示
        weekdays_frame = tk.Frame(self.weekly_selection_frame, bg='#FFFFFF')
        weekdays_frame.pack(fill="x", padx=10, pady=(0, 5))
        
        tk.Label(weekdays_frame, text="🗓️ 星期 / Weekdays:", font=('Arial', 9, 'bold'),
                fg='#2c3e50', bg='#FFFFFF').pack(side="left", padx=(0, 5))
        
        self.weekday_vars = {}
        weekdays = [
            ('Monday', '一'),
            ('Tuesday', '二'), 
            ('Wednesday', '三'),
            ('Thursday', '四'),
            ('Friday', '五'),
            ('Saturday', '六'),
            ('Sunday', '日')
        ]
        
        for en_name, display_name in weekdays:
            var = tk.BooleanVar()
            self.weekday_vars[en_name] = var
            
            cb = tk.Checkbutton(weekdays_frame, text=display_name, variable=var,
                               font=('Arial', 7), bg='#FFFFFF', fg='#2c3e50',
                               selectcolor='#FFFFFF', activebackground='#FFFFFF')
            cb.pack(side="left", padx=1)
        
        # 週期性活動時間篩選區域 - 新增
        weekly_time_filter_frame = tk.Frame(self.weekly_selection_frame, bg='#FFFFFF')
        weekly_time_filter_frame.pack(fill="x", pady=(5, 0), padx=10)
        
        # 週期性活動時間調整選項
        self.weekly_time_filter_enabled = tk.BooleanVar()
        weekly_time_checkbox = tk.Checkbutton(weekly_time_filter_frame, text="⏰ 時間調整 / Time Adjustment", 
                                            variable=self.weekly_time_filter_enabled, font=('Arial', 9, 'bold'),
                                            fg='#2c3e50', bg='#FFFFFF', selectcolor='#FFFFFF',
                                            command=self.toggle_weekly_time_filter)
        weekly_time_checkbox.pack(side="left", padx=(0, 10))
        
        # 週期性活動時間輸入框容器
        self.weekly_time_inputs_frame = tk.Frame(weekly_time_filter_frame, bg='#FFFFFF')
        
        tk.Label(self.weekly_time_inputs_frame, text="開始時間:", font=('Arial', 8), 
                fg='#34495e', bg='#FFFFFF').pack(side="left", padx=(0, 2))
        self.weekly_start_time_entry = tk.Entry(self.weekly_time_inputs_frame, width=8, font=('Arial', 8))
        self.weekly_start_time_entry.pack(side="left", padx=2)
        self.weekly_start_time_entry.insert(0, "12:00")
        
        tk.Label(self.weekly_time_inputs_frame, text="結束時間:", font=('Arial', 8), 
                fg='#34495e', bg='#FFFFFF').pack(side="left", padx=(5, 2))
        self.weekly_end_time_entry = tk.Entry(self.weekly_time_inputs_frame, width=8, font=('Arial', 8))
        self.weekly_end_time_entry.pack(side="left", padx=2)
        self.weekly_end_time_entry.insert(0, "18:00")
        
        # 週期性活動自動時間範圍選項
        self.weekly_auto_time_range = tk.BooleanVar()
        weekly_auto_time_checkbox = tk.Checkbutton(weekly_time_filter_frame, text="🔄 從第一件到最後一件產品銷售時間", 
                                                 variable=self.weekly_auto_time_range, font=('Arial', 8),
                                                 fg='#e67e22', bg='#FFFFFF', selectcolor='#FFFFFF',
                                                 command=self.toggle_weekly_auto_time_range)
        weekly_auto_time_checkbox.pack(side="left", padx=(10, 0))
        
        # 初始化顯示每日活動和按鈕樣式
        self.on_activity_type_change()
        
        # 初始化按鈕樣式
        self.activity_window.after(100, self.update_database_button_styles)
        self.activity_window.after(100, self.update_activity_type_button_styles)
        
        # 緊湊型選擇器區域 - 兩行佈局
        selectors_section = tk.Frame(card_content, bg='#ffffff')
        selectors_section.pack(fill="x", pady=(0, 8))
        
        # 第一行：門市、產品、業績範圍
        first_row = tk.Frame(selectors_section, bg='#ffffff')
        first_row.pack(fill="x", pady=(0, 3))
        
        # 門市選擇區域 - 緊湊版
        outlets_section = tk.Frame(first_row, bg='#FFFFFF', relief='solid', bd=1)
        outlets_section.pack(side="left", fill="x", expand=True, padx=(0, 2))
        
        outlets_header = tk.Label(outlets_section, text="🏪 門市 / Outlets", 
                                 font=('Arial', 9, 'bold'),
                                 fg='#2c3e50', bg='#FFFFFF')
        outlets_header.pack(pady=(4, 3))
        
        outlets_controls = tk.Frame(outlets_section, bg='#FFFFFF')
        outlets_controls.pack(fill="x", padx=5, pady=(0, 3))
        
        # 門市全部按鈕
        outlets_all_btn = tk.Button(outlets_controls, text="全部\nAll", 
                                   command=self.select_all_outlets,
                                   font=('Arial', 8, 'bold'), bg='#3498db', fg='white',
                                   relief='flat', bd=0, padx=5, pady=2)
        outlets_all_btn.pack(side="left", padx=(0, 5))
        
        self.activity_outlets = MultiSelectCombobox(outlets_controls, width=12, 
                                                   title="選擇門市", delay_ms=1000)
        self.activity_outlets.pack(side="left", fill="x", expand=True)
        
        # 產品選擇區域 - 緊湊版
        products_section = tk.Frame(first_row, bg='#FFFFFF', relief='solid', bd=1)
        products_section.pack(side="left", fill="x", expand=True, padx=2)
        
        products_header = tk.Label(products_section, text="🍣 產品 / Products", 
                                  font=('Arial', 9, 'bold'),
                                  fg='#2c3e50', bg='#FFFFFF')
        products_header.pack(pady=(4, 3))
        
        products_controls = tk.Frame(products_section, bg='#FFFFFF')
        products_controls.pack(fill="x", padx=5, pady=(0, 3))
        
        # 產品全部按鈕
        products_all_btn = tk.Button(products_controls, text="全部\nAll", 
                                    command=self.select_all_products,
                                    font=('Arial', 8, 'bold'), bg='#27ae60', fg='white',
                                    relief='flat', bd=0, padx=5, pady=2)
        products_all_btn.pack(side="left", padx=(0, 5))
        
        self.activity_products = MultiSelectCombobox(products_controls, width=12, 
                                                   title="選擇產品", delay_ms=1000)
        self.activity_products.pack(side="left", fill="x", expand=True)
        
        # 業績範圍選擇區域 - 緊湊版
        parts_section = tk.Frame(first_row, bg='#FFFFFF', relief='solid', bd=1)
        parts_section.pack(side="right", fill="x", expand=True, padx=(2, 0))
        
        parts_header = tk.Label(parts_section, text="💰 業績範圍 / Performance", 
                               font=('Arial', 9, 'bold'),
                               fg='#2c3e50', bg='#FFFFFF')
        parts_header.pack(pady=(4, 3))
        
        parts_controls = tk.Frame(parts_section, bg='#FFFFFF')
        parts_controls.pack(fill="x", padx=5, pady=(0, 3))
        
        # 業績範圍全部按鈕
        parts_all_btn = tk.Button(parts_controls, text="全部\nAll", 
                                 command=self.select_all_parts,
                                 font=('Arial', 8, 'bold'), bg='#e67e22', fg='white',
                                 relief='flat', bd=0, padx=5, pady=2)
        parts_all_btn.pack(side="left", padx=(0, 5))
        
        self.activity_parts = MultiSelectCombobox(parts_controls, width=12, 
                                                title="選擇業績範圍", delay_ms=1000)
        self.activity_parts.pack(side="left", fill="x", expand=True)
        
        # 第二行：支付方式和描述
        second_row = tk.Frame(selectors_section, bg='#ffffff')
        second_row.pack(fill="x")
        
        # 支付方式選擇 - 緊湊版
        payment_section = tk.Frame(second_row, bg='#FFFFFF', relief='solid', bd=1)
        payment_section.pack(side="left", fill="x", expand=True, padx=(0, 2))
        
        payment_header = tk.Label(payment_section, text="💳 支付方式 / Payment Methods", 
                                 font=('Arial', 9, 'bold'),
                                 fg='#2c3e50', bg='#FFFFFF')
        payment_header.pack(pady=(4, 3))
        
        payment_controls = tk.Frame(payment_section, bg='#FFFFFF')
        payment_controls.pack(fill="x", padx=5, pady=(0, 3))
        
        # 支付方式全部按鈕
        payment_all_btn = tk.Button(payment_controls, text="全部\nAll", 
                                   command=self.select_all_payment_methods,
                                   font=('Arial', 8, 'bold'), bg='#9b59b6', fg='white',
                                   relief='flat', bd=0, padx=5, pady=2)
        payment_all_btn.pack(side="left", padx=(0, 5))
        
        self.activity_payment = MultiSelectCombobox(payment_controls, width=17, 
                                                   title="選擇支付方式", delay_ms=1000)
        self.activity_payment.pack(side="left", fill="x", expand=True)
        
        # 活動描述 - 緊湊版
        description_section = tk.Frame(second_row, bg='#FFFFFF', relief='solid', bd=1)
        description_section.pack(side="right", fill="x", expand=True, padx=(2, 0))
        
        description_header = tk.Label(description_section, text="📝 活動描述 / Description", 
                                     font=('Arial', 9, 'bold'),
                                     fg='#2c3e50', bg='#FFFFFF')
        description_header.pack(pady=(4, 3))
        
        description_controls = tk.Frame(description_section, bg='#FFFFFF')
        description_controls.pack(fill="x", padx=5, pady=(0, 3))
        
        self.activity_description = tk.Entry(description_controls, font=('Arial', 9),
                                           relief='solid', bd=1, bg='white')
        self.activity_description.pack(fill="x")
        
        # 設置選項
        self.activity_parts.set_values(['DI', 'TA', 'Delivery', 'Food Panda', 'Grab Food', 'Deliveroo', 'All'])
        
        # 加載產品列表
        self.refresh_activity_products()
        
        payment_methods = ['VISA', 'MASTER', 'NETS', 'AMEX', 'UnionPay', 'DBS MAX', 'CDC Voucher', 'Mall Voucher', 
                          'GRAB FOOD', 'FOOD PANDA', 'DELIVEROO', 'SE APP', 'WASTAGE']
        self.activity_payment.set_values(payment_methods)
        
        # 確保門市列表可用
        if not hasattr(self, 'available_outlets') or not self.available_outlets:
            try:
                # 嘗試從數據庫獲取門市列表
                outlets = self.db_manager.get_outlets()
                if outlets:
                    self.available_outlets = outlets
                    print(f"✅ 活動記錄窗口已獲取 {len(outlets)} 個門市")
                else:
                    print("⚠️ 無法獲取門市列表，請先連接數據庫")
            except Exception as e:
                print(f"獲取門市列表失敗: {e}")
        
        if hasattr(self, 'available_outlets') and self.available_outlets:
            self.activity_outlets.set_values(self.available_outlets)
        
        # 緊湊型按鈕區域
        action_section = tk.Frame(card_content, bg='#ffffff')
        action_section.pack(fill="x", pady=(5, 0))
        
        # 按鈕容器 - 緊湊版
        buttons_container = tk.Frame(action_section, bg='#2c3e50', relief='solid', bd=1)
        buttons_container.pack(fill="x", pady=3)
        
        # 所有按鈕在一行 - 緊湊設計
        all_buttons = tk.Frame(buttons_container, bg='#2c3e50')
        all_buttons.pack(fill="x", padx=8, pady=5)
        
        # 主要操作按鈕 - 緊湊版
        add_btn = tk.Button(all_buttons, text="➕ 添加 / Add", 
                           command=self.add_activity_record,
                           font=('Arial', 9, 'bold'), bg='#27ae60', fg='white',
                           relief='flat', bd=0, padx=10, pady=4)
        add_btn.pack(side="left", padx=(0, 2), fill="x", expand=True)
        
        analyze_btn = tk.Button(all_buttons, text="📊 分析 / Analyze", 
                               command=self.analyze_activity,
                               font=('Arial', 9, 'bold'), bg='#3498db', fg='white',
                               relief='flat', bd=0, padx=10, pady=4)
        analyze_btn.pack(side="left", padx=2, fill="x", expand=True)
        
        breakdown_btn = tk.Button(all_buttons, text="📈 细项分析 / Breakdown Analysis", 
                                 command=self.breakdown_analysis,
                                 font=('Arial', 9, 'bold'), bg='#e67e22', fg='white',
                                 relief='flat', bd=0, padx=10, pady=4)
        breakdown_btn.pack(side="left", padx=2, fill="x", expand=True)
        
        view_btn = tk.Button(all_buttons, text="📋 查看 / View", 
                            command=self.view_activity_records,
                            font=('Arial', 9, 'bold'), bg='#9b59b6', fg='white',
                            relief='flat', bd=0, padx=10, pady=4)
        view_btn.pack(side="left", padx=2, fill="x", expand=True)
        
        delete_btn = tk.Button(all_buttons, text="🗑️ 刪除 / Delete", 
                              command=self.delete_single_activity_record,
                              font=('Arial', 9, 'bold'), bg='#e74c3c', fg='white',
                              relief='flat', bd=0, padx=10, pady=4)
        delete_btn.pack(side="left", padx=2, fill="x", expand=True)
        
        clear_btn = tk.Button(all_buttons, text="🗑️ 清空 / Clear", 
                             command=self.clear_activity_records,
                             font=('Arial', 9, 'bold'), bg='#c0392b', fg='white',
                             relief='flat', bd=0, padx=10, pady=4)
        clear_btn.pack(side="left", padx=2, fill="x", expand=True)
        
        close_btn = tk.Button(all_buttons, text="❌ 關閉 / Close", 
                             command=self.activity_window.destroy,
                             font=('Arial', 9, 'bold'), bg='#7f8c8d', fg='white',
                             relief='flat', bd=0, padx=10, pady=4)
        close_btn.pack(side="right", padx=(2, 0), fill="x", expand=True)
        
        # 活動記錄列表區域 - 現代化設計
        list_card = tk.Frame(left_container, bg='#ffffff', relief='solid', bd=1)
        list_card.pack(fill="both", expand=True, pady=(20, 10), padx=10)
        
        # 列表標題
        list_header = tk.Frame(list_card, bg='#34495e', height=40)
        list_header.pack(fill="x")
        list_header.pack_propagate(False)
        
        list_title = tk.Label(list_header, 
                             text="📋 活動記錄列表 / Activity Records List", 
                             font=('Microsoft YaHei UI', 13, 'bold'),
                             fg='white', bg='#34495e')
        list_title.pack(side="left", padx=15, pady=12)
        
        list_subtitle = tk.Label(list_header, 
                                text="Activity Records List", 
                                font=('Arial', 9),
                                fg='#bdc3c7', bg='#34495e')
        list_subtitle.pack(side="left", padx=(0, 15), pady=10)
        
        # 搜索功能区域
        search_frame = tk.Frame(list_header, bg='#34495e')
        search_frame.pack(side="right", padx=10, pady=5)
        
        tk.Label(search_frame, text="🔍 搜索:", font=('Arial', 9), 
                fg='white', bg='#34495e').pack(side="left", padx=(0, 5))
        
        self.activity_search_entry = tk.Entry(search_frame, width=15, font=('Arial', 9))
        self.activity_search_entry.pack(side="left", padx=2)
        self.activity_search_entry.bind('<KeyRelease>', self.on_activity_search_change)
        
        # 清除搜索按钮
        clear_search_btn = tk.Button(search_frame, text="❌", 
                                   command=self.clear_activity_search,
                                   font=('Arial', 8), bg='#e74c3c', fg='white',
                                   relief='flat', bd=0, width=2, height=1,
                                   cursor='hand2')
        clear_search_btn.pack(side="left", padx=2)
        
        # 列表容器
        list_container = tk.Frame(list_card, bg='#ffffff')
        list_container.pack(fill="both", expand=True, padx=15, pady=15)
        
        # 創建現代化Treeview
        columns = ('活動ID', '活動名稱', '日期期間', '星期篩選', '總業績', '總單據數', '活動業績', '活動單據數', '業績占比%', '單據數占比%')
        self.activity_tree = ttk.Treeview(list_container, columns=columns, show='headings', height=12)
        
        # 優化列標題和寬度
        column_configs = [
            ('活動ID', '活動ID / Activity ID', 80),  # 隱藏列
            ('活動名稱', '活動名稱 / Activity Name', 200),
            ('日期期間', '日期期間 / Date Period', 150),
            ('星期篩選', '星期篩選 / Weekdays', 120),
            ('總業績', '總業績 / Total Sales', 120),
            ('總單據數', '總單據數 / Total Receipts', 120),
            ('活動業績', '活動業績 / Activity Sales', 130),
            ('活動單據數', '活動單據數 / Activity Receipts', 130),
            ('業績占比%', '業績占比% / Sales Ratio%', 120),
            ('單據數占比%', '單據數占比% / Receipt Ratio%', 130)
        ]
        
        for col_id, col_text, col_width in column_configs:
            self.activity_tree.heading(col_id, text=col_text)
            self.activity_tree.column(col_id, width=col_width, minwidth=col_width//2)
        
        # 隱藏活動ID列
        self.activity_tree.column('活動ID', width=0, minwidth=0, stretch=False)
        
        # 現代化滾動條
        activity_scrollbar = ttk.Scrollbar(list_container, orient="vertical", command=self.activity_tree.yview)
        self.activity_tree.configure(yscrollcommand=activity_scrollbar.set)
        
        self.activity_tree.pack(side="left", fill="both", expand=True)
        activity_scrollbar.pack(side="right", fill="y")
        
        # 重新加载活动记录数据
        self.load_activity_records()
        
        # 刷新活動記錄顯示
        self.refresh_activity_tree()
        
        # 確保產品選擇器顯示已導入的產品
        self.activity_window.after(100, self.update_activity_products_from_records)
        
        # 額外確保產品選擇器更新
        self.activity_window.after(500, self.force_update_product_selector)
        
        # 設置右側面板內容 - 現代化設計
        try:
            self.setup_activity_right_panel(right_container)
            print("✅ 右側面板設置完成")
        except Exception as e:
            print(f"❌ 右側面板設置失敗: {e}")
        
        # 確保右側面板始終保持可見
        self.activity_window.after(50, self.ensure_activity_right_panel_visible)
        
        # 初始數據庫連接
        self.activity_window.after(100, self.initial_database_connection)
        
        print("✅ 活動記錄窗口開啟，右側面板已設置")
    
    def force_show_right_panel(self):
        """强制显示右侧面板 - 完全禁用防止破壞主窗口面板"""
        try:
            print("⚠️ 完全禁用force_show_right_panel，防止破壞主窗口面板")
            # 不再執行任何操作
            return
        except Exception as e:
            print(f"禁止强制显示右侧面板操作: {e}")

    def ensure_activity_right_panel_visible(self):
        """确保活动记录窗口的右侧面板可见"""
        try:
            if hasattr(self, 'activity_window') and self.activity_window.winfo_exists():
                # 检查是否已经有右侧面板组件
                if hasattr(self, 'holiday_info_text') and hasattr(self, 'holiday_tree'):
                    print("✅ 右侧面板组件已存在")
                    return
                
                print("⚠️ 右侧面板组件缺失，重新創建...")
                # 重新創建右側面板
                if hasattr(self, 'activity_window'):
                    # 獲取右側容器
                    for child in self.activity_window.winfo_children():
                        if isinstance(child, tk.Frame):
                            for grandchild in child.winfo_children():
                                if hasattr(grandchild, 'winfo_children'):
                                    for great_grandchild in grandchild.winfo_children():
                                        if 'right' in str(great_grandchild).lower() or 'holiday' in str(great_grandchild).lower():
                                            self.setup_activity_right_panel(great_grandchild)
                                            return
                
        except Exception as e:
            print(f"确保右侧面板可见时出错: {e}")

    def persistent_right_panel(self):
        """持续性检查并保持右侧面板 - 已禁用防止破坏主窗口面板"""
        try:
            print("⚠️ 禁用持續性面板檢查，防止破壞主窗口面板")
            # 不再執行任何面板重新創建操作
            return
            
            # 原始代碼已被註釋以防止破壞主窗口面板
            # if hasattr(self, 'activity_window') and self.activity_window.winfo_exists():
            #     if not (hasattr(self, 'holiday_info_text') and hasattr(self, 'holiday_tree')):
            #         print("🔄 右侧面板组件缺失，重新创建...")
            #         ...
        except Exception as e:
            print(f"保持右侧面板失败: {e}")
    
    def add_holiday_record_record(self):
        """添加假期记录 - 新的美化方法"""
        try:
            # 创建添加假期记录的对话框
            holiday_dialog = tk.Toplevel(self.root)
            holiday_dialog.title("添加假期记录")
            holiday_dialog.geometry("400x350")
            holiday_dialog.transient(self.root)
            holiday_dialog.grab_set()
            
            # 框架
            main_frame = tk.Frame(holiday_dialog, padding="10")
            main_frame.pack(fill="both", expand=True)
            
            # 标题
            title_label = tk.Label(main_frame, text="📅 添加假期记录", font=('Arial', 14, 'bold'))
            title_label.pack(pady=(0, 15))
            
            # 开始日期
            tk.Label(main_frame, text="开始日期 / Start Date:").pack(anchor="w", pady=(0, 5))
            from datetime import datetime, timedelta
            start_date_var = tk.StringVar(value=datetime.now().strftime('%Y-%m-%d'))
            start_date_entry = ttk.Entry(main_frame, textvariable=start_date_var, width=20)
            start_date_entry.pack(anchor="w", pady=(0, 10))
            
            # 结束日期
            tk.Label(main_frame, text="结束日期 / End Date:").pack(anchor="w", pady=(0, 5))
            end_date_var = tk.StringVar(value=datetime.now().strftime('%Y-%m-%d'))
            end_date_entry = ttk.Entry(main_frame, textvariable=end_date_var, width=20)
            end_date_entry.pack(anchor="w", pady=(0, 10))
            
            # 假期名称
            tk.Label(main_frame, text="假期名称 / Holiday Name:").pack(anchor="w", pady=(0, 5))
            holiday_name_var = tk.StringVar()
            holiday_name_entry = ttk.Entry(main_frame, textvariable=holiday_name_var, width=30)
            holiday_name_entry.pack(anchor="w", pady=(0, 10))
            
            # 假期长度计算标签
            length_label = tk.Label(main_frame, text="假期长度将自动计算")
            length_label.pack(anchor="w", pady=(0, 15))
            
            def save_record():
                """保存假期记录"""
                try:
                    # 获取输入值
                    start_date = start_date_var.get().strip()
                    end_date = end_date_var.get().strip()
                    holiday_name = holiday_name_var.get().strip()
                    
                    # 验证输入
                    if not all([start_date, end_date, holiday_name]):
                        tk.messagebox.showerror("错误", "请填写所有字段")
                        return
                    
                    # 计算假期长度
                    from datetime import datetime
                    start = datetime.strptime(start_date, '%Y-%m-%d')
                    end = datetime.strptime(end_date, '%Y-%m-%d')
                    duration = (end - start).days + 1
                    
                    # 创建记录
                    current_db = self.get_current_database()
                    if current_db not in self.holiday_records:
                        self.holiday_records[current_db] = []
                    
                    record = {
                        'start_date': start_date,
                        'end_date': end_date,
                        'holiday_name': holiday_name,
                        'duration': duration
                    }
                    
                    self.holiday_records[current_db].append(record)
                    
                    # 自動保存到 PromotionRecords.xlsx
                    self.auto_save_promotion_records()
                    
                    # 刷新显示
                    if hasattr(self, 'holiday_tree'):
                        self.refresh_holiday_tree()
                    
                    tk.messagebox.showinfo("成功", f"假期记录已添加: {holiday_name}")
                    holiday_dialog.destroy()
                    
                except Exception as e:
                    tk.messagebox.showerror("错误", f"添加假期失败: {e}")
            
            # 按钮区域
            button_frame = tk.Frame(main_frame)
            button_frame.pack(fill="x", pady=10)
            
            ttk.Button(button_frame, text="保存记录", command=save_record).pack(side="right", padx=(4, 0))
            ttk.Button(button_frame, text="取消", command=holiday_dialog.destroy).pack(side="right")
            
        except Exception as e:
            tk.messagebox.showerror("错误", f"添加假期记录失败: {e}")
    
    def delete_holiday_record_record(self):
        """删除假期记录"""
        try:
            if not hasattr(self, 'holiday_tree'):
                tk.messagebox.showwarning("警告", "假期记录表不存在")
                return
            
            selection = self.holiday_tree.selection()
            if not selection:
                tk.messagebox.showwarning("警告", "请选择要删除的假期记录")
                return
            
            # 获取选中的记录
            item = self.holiday_tree.item(selection[0])
            values = item['values']
            holiday_name = values[2]
            
            # 确认删除
            from tkinter import messagebox
            if messagebox.askyesno("确认删除", f"是否确定删除假期记录: {holiday_name}?"):
                # 从数据中删除
                current_db = self.activity_database.get() if hasattr(self, 'activity_database') else 'Express'
                if current_db in self.holiday_records:
                    # 查找并删除记录
                    record_to_delete = None
                    for record in self.holiday_records[current_db]:
                        if (record.get('holiday_name') == holiday_name and 
                            record.get('start_date') == values[0]):
                            record_to_delete = record
                            break
                    if record_to_delete:
                        self.holiday_records[current_db].remove(record_to_delete)
                        
                        # 刷新显示
                        self.refresh_holiday_tree()
                        tk.messagebox.showinfo("成功", f"假期记录 '{holiday_name}' 已删除")
                    else:
                        tk.messagebox.showwarning("警告", "未能找到要删除的记录")
                else:
                    tk.messagebox.showwarning("警告", "当前数据库没有假期记录")
            
        except Exception as e:
            tk.messagebox.showerror("错误", f"删除假期记录失败: {e}")
    
    def save_holiday_records_to_file(self):
        """保存假期记录到文件"""
        try:
            import json
            import os
            
            os.makedirs('cache', exist_ok=True)
            
            if not hasattr(self, 'holiday_records'):
                self.holiday_records = {
                    'GOGO': [],
                    'Express': [],
                    'PLUS': []
                }
            
            filename = 'cache/holiday_records.json'
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(self.holiday_records, f, ensure_ascii=False, indent=2)
            
            tk.messagebox.showinfo("成功", f"假期记录已保存到 {filename}")
            
        except Exception as e:
            tk.messagebox.showerror("错误", f"保存假期记录失败: {e}")
    
    def refresh_holiday_tree(self):
        """刷新假期记录树显示"""
        try:
            if not hasattr(self, 'holiday_tree'):
                print("❌ 假期记录表格不存在")
                return
            
            # 清空现有数据
            for item in self.holiday_tree.get_children():
                self.holiday_tree.delete(item)
            
            # 获取当前选中的数据库
            current_db = self.get_current_database() if hasattr(self, 'activity_database') else 'Express'
            
            # 确保假期记录字典存在
            if not hasattr(self, 'holiday_records'):
                self.holiday_records = {
                    'GOGO': [],
                    'Express': [],
                    'PLUS': []
                }
            
            # 确保当前数据库键存在
            if current_db not in self.holiday_records:
                self.holiday_records[current_db] = []
            
            print(f"📅 刷新假期记录树 - 当前数据库: {current_db}")
            print(f"📅 假期记录数: {len(self.holiday_records[current_db])}")
            
            # 显示当前数据库的所有记录
            for record in self.holiday_records[current_db]:
                duration_text = f"{record.get('duration', 0)} 天"
                self.holiday_tree.insert("", "end", values=(
                    record.get('start_date', ''),
                    record.get('end_date', ''),
                    record.get('holiday_name', ''),
                    duration_text
                ))
            
            print(f"✅ 假期记录刷新完成")
            
        except Exception as e:
            print(f"❌ 刷新假期记录失败: {e}")
            if hasattr(self, 'show_activity_message'):
                self.show_activity_message(f"❌ 刷新假期记录失败: {e}")
    
    def recreate_activity_right_panel(self):
        """重新创建活动记录窗口的右侧面板 - 完全禁用"""
        try:
            print("⚠️ 完全禁用recreate_activity_right_panel，防止破壞主窗口面板")
            # 不再執行任何重新創建操作
            return
            
        except Exception as e:
            print(f"禁止重新创建右侧面板: {e}")
    
    def final_right_panel_protection(self):
        """最終右側面板保護措施 - 確保面板永不被破壞"""
        try:
            print("🛡️ 執行最終右側面板保護措施...")
            
            # 檢查右側面板狀態
            if hasattr(self, 'right_panel'):
                # 強制確保保護標記
                self._right_panel_protected = True
                
                # 確保面板可見
                self.right_panel.lift()
                self.right_panel.tkraise()
                
                # 檢查子組件
                child_count = len(self.right_panel.winfo_children())
                print(f"🛡️ 右側面板最終保護 - 子組件數量: {child_count}")
                
                # 如果沒有子組件，重新創建基礎結構
                if child_count == 0:
                    print("🔧 右側面板為空，創建基礎保護結構")
                    self.create_basic_right_panel_structure()
                else:
                    print("✅ 右側面板已完整，保護生效")
                    
            print("✅ 最終保護措施完成")
                    
        except Exception as e:
            print(f"❌ 最終保護措施失敗: {e}")
    
    def create_basic_right_panel_structure(self):
        """創建基礎的右側面板結構 - 緊急修復"""
        try:
            print("🔧 創建基礎右側面板結構...")
            
            # 簡單標題
            header = tk.Frame(self.right_panel, bg='#e74c3c', height=45)
            header.pack(fill="x")
            header.pack_propagate(False)
            
            title = tk.Label(header, text="📊 活动提醒", 
                           font=('Microsoft YaHei UI', 13, 'bold'),
                           fg='white', bg='#e74c3c')
            title.pack(pady=12)
            
            # 簡單文本區域
            text_area = tk.Text(self.right_panel, height=15, width=28,
                              font=('Segoe UI', 10), wrap=tk.WORD, bg='#FFFFFF',
                              state='disabled', relief='flat', borderwidth=2)
            text_area.pack(fill="both", expand=True, padx=5, pady=5)
            
            # 設置內容
            text_area.config(state='normal')
            text_area.delete(1.0, tk.END)
            protection_text = """📊 活动提醒

✅ 右側面板已受保護！

系統狀態: 正常運行
保護狀態: 已激活
面板寬度: 270px

🛡️ 安全措施:
• 面板結構已鎖定
• 內容受保護，不可破壞
• 持續監控狀態

💡 使用提示:
• 繼續使用左側功能
• 面板將保持穩定
• 所有操作都已受保護"""
            
            text_area.insert(1.0, protection_text)
            text_area.config(state='disabled')
            
            # 存儲引用
            self.activity_alert_text = text_area
            
            print("✅ 基礎右側面板結構創建完成")
            
        except Exception as e:
            print(f"❌ 基礎結構創建失敗: {e}")

    def minimize_activity_window(self):
        """最小化活动记录窗口"""
        try:
            if hasattr(self, 'activity_window') and self.activity_window:
                self.activity_window.iconify()
        except Exception as e:
            print(f"最小化窗口失败: {e}")

    def toggle_activity_fullscreen(self):
        """切换活动记录窗口全屏状态"""
        try:
            if hasattr(self, 'activity_window') and self.activity_window:
                if self.activity_window_fullscreen:
                    # 退出全屏
                    self.activity_window.attributes('-fullscreen', False)
                    self.activity_window_fullscreen = False
                    self.fullscreen_btn.config(text="🗖")
                else:
                    # 进入全屏
                    self.activity_window.attributes('-fullscreen', True)
                    self.activity_window_fullscreen = True
                    self.fullscreen_btn.config(text="🗗")
        except Exception as e:
            print(f"切换全屏失败: {e}")

    def close_activity_window(self):
        """关闭活动记录窗口"""
        try:
            if hasattr(self, 'activity_window') and self.activity_window:
                self.activity_window.destroy()
        except Exception as e:
            print(f"关闭窗口失败: {e}")

    def toggle_time_filter(self):
        """切換每日活動時間篩選顯示狀態"""
        if self.time_filter_enabled.get():
            self.time_inputs_frame.pack(side="left")
            # 如果啟用自動時間範圍，禁用時間輸入
            if self.auto_time_range.get():
                self.start_time_entry.config(state='disabled')
                self.end_time_entry.config(state='disabled')
        else:
            self.time_inputs_frame.pack_forget()
    
    def toggle_auto_time_range(self):
        """切換每日活動自動時間範圍選項"""
        if self.auto_time_range.get():
            # 啟用自動時間範圍時，禁用手動時間輸入
            self.start_time_entry.config(state='disabled')
            self.end_time_entry.config(state='disabled')
            # 如果時間篩選未啟用，自動啟用
            if not self.time_filter_enabled.get():
                self.time_filter_enabled.set(True)
                self.toggle_time_filter()
        else:
            # 禁用自動時間範圍時，啟用手動時間輸入
            if self.time_filter_enabled.get():
                self.start_time_entry.config(state='normal')
                self.end_time_entry.config(state='normal')
    
    def toggle_weekly_time_filter(self):
        """切換週期性活動時間篩選顯示狀態"""
        if self.weekly_time_filter_enabled.get():
            self.weekly_time_inputs_frame.pack(side="left")
            # 如果啟用自動時間範圍，禁用時間輸入
            if self.weekly_auto_time_range.get():
                self.weekly_start_time_entry.config(state='disabled')
                self.weekly_end_time_entry.config(state='disabled')
        else:
            self.weekly_time_inputs_frame.pack_forget()
    
    def toggle_weekly_auto_time_range(self):
        """切換週期性活動自動時間範圍選項"""
        if self.weekly_auto_time_range.get():
            # 啟用自動時間範圍時，禁用手動時間輸入
            self.weekly_start_time_entry.config(state='disabled')
            self.weekly_end_time_entry.config(state='disabled')
            # 如果時間篩選未啟用，自動啟用
            if not self.weekly_time_filter_enabled.get():
                self.weekly_time_filter_enabled.set(True)
                self.toggle_weekly_time_filter()
        else:
            # 禁用自動時間範圍時，啟用手動時間輸入
            if self.weekly_time_filter_enabled.get():
                self.weekly_start_time_entry.config(state='normal')
                self.weekly_end_time_entry.config(state='normal')

    def on_activity_search_change(self, event=None):
        """活动记录搜索功能"""
        try:
            search_term = self.activity_search_entry.get().strip().lower()
            
            # 清空现有显示
            for item in self.activity_tree.get_children():
                self.activity_tree.delete(item)
            
            # 获取当前选中的数据库
            current_db = self.get_current_database()
            
            # 确保活动记录字典存在并包含所有数据库
            if not hasattr(self, 'activity_records'):
                self.activity_records = {
                    'GOGO': [],
                    'Express': [],
                    'PLUS': [],
                    'All': []
                }
            
            # 显示当前数据库的所有记录  
            if self.activity_records[current_db]:
                print(f"✅ 找到了 {len(self.activity_records[current_db])} 个活动记录")
                for record in self.activity_records[current_db]:
                    # 构建搜索文本
                    searchable_text = ' '.join([
                        record.get('description', ''),
                        record.get('date_from', ''),
                        record.get('date_to', ''),
                        ', '.join(record.get('weekdays', [])),
                        ', '.join(record.get('outlets', [])),
                        ', '.join(record.get('products', []))
                    ]).lower()
                    
                    # 如果没有搜索词或匹配搜索词，显示记录
                    if not search_term or search_term in searchable_text:
                        # 活動名稱
                        activity_name = record.get('description', f"活動 {record.get('id', '')}")
                        
                        # 日期期間
                        if record.get('type') == 'weekly':
                            weekdays_str = ', '.join(record.get('weekdays', []))
                            date_period = f"{record.get('date_from', '')} - {record.get('date_to', '')}"
                        else:
                            date_period = f"{record.get('date_from', '')} - {record.get('date_to', '')}"
                        
                        # 星期篩選
                        weekdays = record.get('weekdays', [])
                        weekdays_str = ', '.join(weekdays) if weekdays else '全部'
                        
                        # 獲取分析結果
                        analysis_result = record.get('analysis_result', {})
                        if analysis_result:
                            total_sales = f"${analysis_result.get('total_amount', 0):,.2f}"
                            total_receipts = f"{analysis_result.get('total_receipts', 0):,}"
                            activity_sales = f"${analysis_result.get('activity_amount', 0):,.2f}"
                            activity_receipts = f"{analysis_result.get('activity_receipts', 0):,}"
                            sales_ratio = f"{analysis_result.get('sales_ratio', 0):.2f}%"
                            receipt_ratio = f"{analysis_result.get('receipt_ratio', 0):.2f}%"
                        else:
                            total_sales = "未分析"
                            total_receipts = "未分析"
                            activity_sales = "未分析"
                            activity_receipts = "未分析"
                            sales_ratio = "未分析"
                            receipt_ratio = "未分析"
                        
                        # 插入數據時包含活動ID作為隱藏的第一列
                        self.activity_tree.insert("", "end", values=(
                            record.get('id', ''),  # 活動ID - 隱藏列
                            activity_name,
                            date_period,
                            weekdays_str,
                            total_sales,
                            total_receipts,
                            activity_sales,
                            activity_receipts,
                            sales_ratio,
                            receipt_ratio
                        ))
            
            print(f"✅ 活动记录搜索完成，搜索词: '{search_term}'")
            
        except Exception as e:
            print(f"❌ 活动记录搜索失败: {e}")
            import traceback
            print(f"详细错误: {traceback.format_exc()}")

    def clear_activity_search(self):
        """清除活动记录搜索"""
        try:
            self.activity_search_entry.delete(0, tk.END)
            self.on_activity_search_change()  # 重新显示所有记录
        except Exception as e:
            print(f"清除搜索失败: {e}")

    def breakdown_analysis(self):
        """细项分析功能 - 按门市详细分析活动业绩"""
        try:
            print("🔍 细项分析按钮被点击")
            
            # 检查是否有选中的活动记录
            if not hasattr(self, 'activity_tree'):
                tk.messagebox.showwarning("提示", "活动记录表不存在")
                return
            
            selection = self.activity_tree.selection()
            if not selection:
                tk.messagebox.showwarning("提示", "请先在活动记录列表中选择一个活动记录，然后再点击细项分析按钮")
                return
            
            # 获取选中的活动记录
            item = self.activity_tree.item(selection[0])
            values = item['values']
            activity_id = values[0]
            activity_name = values[1]
            
            print(f"📊 选中的活动ID: {activity_id}, 活动名称: {activity_name}")
            
            # 获取活动记录详情
            current_db = self.get_current_database()
            records = self.activity_records.get(current_db, [])
            
            print(f"🔍 调试信息 - 当前数据库: {current_db}")
            print(f"🔍 调试信息 - 活动ID: {activity_id} (类型: {type(activity_id)})")
            print(f"🔍 调试信息 - 记录数量: {len(records)}")
            print(f"🔍 调试信息 - 可用记录ID: {[record.get('id') for record in records]}")
            
            selected_record = None
            for record in records:
                record_id = record.get('id')
                print(f"🔍 调试信息 - 比较记录ID: {record_id} (类型: {type(record_id)}) 与 {activity_id} (类型: {type(activity_id)})")
                
                # 尝试多种匹配方式
                if (record_id == activity_id or 
                    str(record_id) == str(activity_id) or 
                    (str(activity_id).isdigit() and record_id == int(activity_id)) or
                    (str(record_id).isdigit() and int(record_id) == activity_id)):
                    selected_record = record
                    print(f"✅ 找到匹配的记录: {record_id}")
                    break
            
            if not selected_record:
                print(f"❌ 未找到匹配的活动记录")
                print(f"📊 详细调试信息:")
                print(f"   - 查找的活动ID: {activity_id}")
                print(f"   - 活动ID类型: {type(activity_id)}")
                print(f"   - 数据库: {current_db}")
                print(f"   - 记录总数: {len(records)}")
                for i, record in enumerate(records):
                    print(f"   - 记录 {i}: ID={record.get('id')} (类型: {type(record.get('id'))}), 描述={record.get('description', 'N/A')}")
                
                tk.messagebox.showerror("错误", f"未找到活动记录，活动ID: {activity_id}\n\n调试信息:\n数据库: {current_db}\n记录数量: {len(records)}\n可用ID: {[record.get('id') for record in records]}")
                return
            
            # 创建细项分析窗口
            self.create_breakdown_analysis_window(selected_record)
            
        except Exception as e:
            print(f"❌ 细项分析失败: {e}")
            import traceback
            print(f"详细错误: {traceback.format_exc()}")
            tk.messagebox.showerror("错误", f"细项分析失败: {e}")

    def create_breakdown_analysis_window(self, activity_record):
        """创建细项分析窗口"""
        try:
            # 创建细项分析窗口
            breakdown_window = tk.Toplevel(self.root)
            activity_name = activity_record.get('description', f"活动 {activity_record.get('id', '')}")
            breakdown_window.title(f"📈 {activity_name} - 细项分析 / Breakdown Analysis")
            breakdown_window.geometry("1600x900")
            breakdown_window.configure(bg='#FFFFFF')
            breakdown_window.transient(self.root)
            breakdown_window.grab_set()
            
            # 设置窗口图标
            try:
                breakdown_window.iconbitmap("SELOGO22 - 01.ico")
            except:
                pass
            
            # 创建标题栏
            title_frame = tk.Frame(breakdown_window, bg='#2c3e50', height=60)
            title_frame.pack(fill="x")
            title_frame.pack_propagate(False)
            
            title_label = tk.Label(title_frame, 
                                 text=f"📈 {activity_name}", 
                                 font=('Microsoft YaHei UI', 16, 'bold'),
                                 fg='white', bg='#2c3e50')
            title_label.pack(side="left", padx=20, pady=15)
            
            subtitle_label = tk.Label(title_frame, 
                                    text="细项分析 / Breakdown Analysis", 
                                    font=('Arial', 11),
                                    fg='#bdc3c7', bg='#2c3e50')
            subtitle_label.pack(side="left", padx=(0, 20), pady=15)
            
            # 关闭按钮
            close_btn = tk.Button(title_frame, text="✕", 
                                command=breakdown_window.destroy,
                                font=('Arial', 12), bg='#e74c3c', fg='white',
                                relief='flat', bd=0, width=3, height=1,
                                cursor='hand2')
            close_btn.pack(side="right", padx=10, pady=15)
            
            # 创建主容器
            main_container = tk.Frame(breakdown_window, bg='#FFFFFF')
            main_container.pack(fill="both", expand=True, padx=20, pady=20)
            
            # 创建标签页
            notebook = ttk.Notebook(main_container)
            notebook.pack(fill="both", expand=True)
            
            # 每日细项分析标签页
            daily_frame = tk.Frame(notebook, bg='#FFFFFF')
            notebook.add(daily_frame, text="📅 每日细项 / Daily Breakdown")
            
            # 整体细项分析标签页
            overall_frame = tk.Frame(notebook, bg='#FFFFFF')
            notebook.add(overall_frame, text="📊 整体细项 / Overall Breakdown")
            
            # 生成分析数据
            self.generate_breakdown_analysis_data(activity_record, daily_frame, overall_frame)
            
        except Exception as e:
            print(f"❌ 创建细项分析窗口失败: {e}")
            import traceback
            print(f"详细错误: {traceback.format_exc()}")
            tk.messagebox.showerror("错误", f"创建细项分析窗口失败: {e}")

    def generate_breakdown_analysis_data(self, activity_record, daily_frame, overall_frame):
        """生成细项分析数据并显示在标签页中"""
        try:
            # 获取活动信息
            activity_id = activity_record.get('id')
            date_from = activity_record.get('date_from')
            date_to = activity_record.get('date_to')
            outlets = activity_record.get('outlets', [])
            products = activity_record.get('products', [])
            activity_type = activity_record.get('type', 'daily')
            weekdays = activity_record.get('weekdays', [])
            
            # 获取时间筛选信息
            time_filter_enabled = activity_record.get('time_filter_enabled', False)
            start_time = activity_record.get('start_time')
            end_time = activity_record.get('end_time')
            auto_time_range = activity_record.get('auto_time_range', False)
            
            print(f"📊 开始生成细项分析数据 - 活动ID: {activity_id}")
            print(f"📅 日期范围: {date_from} 到 {date_to}")
            print(f"🏪 门市: {outlets}")
            print(f"🛍️ 产品: {products}")
            print(f"📅 活动类型: {activity_type}")
            print(f"📅 星期: {weekdays}")
            print(f"⏰ 时间筛选启用: {time_filter_enabled}")
            print(f"⏰ 开始时间: {start_time}")
            print(f"⏰ 结束时间: {end_time}")
            print(f"⏰ 自动时间范围: {auto_time_range}")
            
            # 验证日期格式
            if not date_from or not date_to:
                tk.messagebox.showerror("错误", "活动记录中缺少日期信息")
                return
            
            # 确保日期格式正确
            try:
                from datetime import datetime
                datetime.strptime(date_from, '%Y-%m-%d')
                datetime.strptime(date_to, '%Y-%m-%d')
                print(f"✅ 日期格式验证通过: {date_from} 到 {date_to}")
            except ValueError as date_error:
                print(f"❌ 日期格式错误: {date_error}")
                tk.messagebox.showerror("错误", f"日期格式不正确: {date_from} 到 {date_to}")
                return
            
            # 连接数据库
            current_db = self.get_current_database()
            print(f"🔍 调试信息 - 尝试连接数据库: {current_db}")
            
            if not self.connect_to_activity_database(current_db):
                tk.messagebox.showerror("错误", f"无法连接到数据库: {current_db}")
                return
            
            # 检查数据库连接状态
            if not hasattr(self, 'db_manager') or not self.db_manager.connection:
                tk.messagebox.showerror("错误", "数据库连接失败，请检查数据库连接")
                return
            
            print(f"✅ 数据库连接成功: {current_db}")
            print(f"🔍 调试信息 - 当前数据库: {self.db_manager.current_database if hasattr(self.db_manager, 'current_database') else 'Unknown'}")
            
            # 获取销售数据
            from datetime import datetime, timedelta
            start_date = datetime.strptime(date_from, '%Y-%m-%d')
            end_date = datetime.strptime(date_to, '%Y-%m-%d')
            
            # 构建查询条件
            query_conditions = []
            params = []
            
            # 日期条件
            if activity_type == 'weekly' and weekdays:
                # 周期性活动 - 只查询指定的星期几
                weekday_names = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
                weekday_conditions = []
                for weekday in weekdays:
                    if weekday in weekday_names:
                        weekday_conditions.append(f"DATENAME(weekday, c_date) = ?")
                        params.append(weekday)
                
                if weekday_conditions:
                    query_conditions.append(f"({' OR '.join(weekday_conditions)})")
            else:
                # 每日活动 - 查询整个日期范围
                query_conditions.append(f"CAST(s.c_date AS DATE) >= '{date_from}' AND CAST(s.c_date AS DATE) <= '{date_to}'")
            
            # 门市条件
            if outlets:
                outlet_conditions = " OR ".join([f"store_name = '{outlet}'" for outlet in outlets])
                query_conditions.append(f"({outlet_conditions})")
            
            # 产品条件
            if products:
                product_conditions = " OR ".join([f"item_name = '{product}'" for product in products])
                query_conditions.append(f"({product_conditions})")
            
            # 构建完整查询
            where_clause = " AND ".join(query_conditions) if query_conditions else "1=1"
            # 获取业绩计算SQL
            performance_sql = self.db_manager.get_performance_calculation_sql()
            
            # 构建基础WHERE条件（不包含产品筛选）
            base_where_conditions = []
            
            # 添加日期条件
            base_where_conditions.append(f"CAST(s.c_date AS DATE) >= '{date_from}' AND CAST(s.c_date AS DATE) <= '{date_to}'")
            
            # 添加门市条件
            if outlets:
                outlet_conditions = " OR ".join([f"store_name = '{outlet}'" for outlet in outlets])
                base_where_conditions.append(f"({outlet_conditions})")
            
            # 添加星期条件（如果是周期性活动）
            if activity_type == 'weekly' and weekdays:
                weekday_conditions = []
                for weekday in weekdays:
                    weekday_conditions.append(f"DATENAME(weekday, c_date) = '{weekday}'")
                if weekday_conditions:
                    base_where_conditions.append(f"({' OR '.join(weekday_conditions)})")
            
            base_where_clause = " AND ".join(base_where_conditions) if base_where_conditions else "1=1"
            
            # 构建活动产品WHERE条件
            activity_where_conditions = base_where_conditions.copy()
            if products:
                product_conditions = " OR ".join([f"item_name = '{product}'" for product in products])
                activity_where_conditions.append(f"({product_conditions})")
            
            activity_where_clause = " AND ".join(activity_where_conditions) if activity_where_conditions else "1=1"
            
            # 根据活动记录的具体筛选条件决定总业绩的计算范围
            # 检查活动记录中是否有时间筛选或其他特殊筛选条件
            has_time_filter = activity_record.get('time_filter_enabled', False)
            has_auto_time_range = activity_record.get('auto_time_range', False)
            has_products = bool(products)
            
            # 根据筛选条件决定总业绩的计算范围
            if has_auto_time_range:
                # 自动时间范围：总业绩应该是从第一张选择产品单据到最后一张选择产品单据之间的所有产品业绩
                # 这种情况下，我们需要构建一个特殊的查询来找到时间范围，然后计算该范围内的所有业绩
                print(f"🔍 自动时间范围模式：需要动态计算时间范围")
                # 暂时使用活动查询条件，但我们需要修改查询逻辑
                total_where_clause = activity_where_clause
            elif has_time_filter:
                # 手动时间筛选：总业绩应该在相同的时间范围内计算
                total_where_clause = activity_where_clause
                print(f"🔍 手动时间筛选：使用筛选范围内的总业绩计算")
            elif has_products:
                # 只有产品筛选：总业绩使用基础条件（整个日期范围的所有数据）
                total_where_clause = base_where_clause
                print(f"🔍 只有产品筛选：使用整个日期范围的总业绩计算")
            else:
                # 没有特殊筛选时，总业绩使用基础条件（整个日期范围的所有数据）
                total_where_clause = base_where_clause
                print(f"🔍 没有特殊筛选：使用整个日期范围的总业绩计算")
            
            # 使用UNION ALL分别查询总业绩、活动业绩(含数量)和产品单据业绩，然后合并结果
            query = f"""
                WITH total_sales AS (
                    SELECT 
                        store_name,
                        CAST(c_date AS DATE) as c_date,
                        SUM({performance_sql}) as total_amount,
                        COUNT(DISTINCT sales_no) as total_receipts,
                        0 as activity_amount,
                        0 as activity_receipts,
                        0 as product_receipt_amount,
                        0 as activity_qty
                    FROM pos_sales_dtls s
                    WHERE {total_where_clause}
                    AND item_name != 'WASTAGE'
                    GROUP BY store_name, CAST(c_date AS DATE)
                ),
                activity_sales AS (
                    SELECT 
                        store_name,
                        CAST(c_date AS DATE) as c_date,
                        0 as total_amount,
                        0 as total_receipts,
                        SUM({performance_sql}) as activity_amount,
                        COUNT(DISTINCT sales_no) as activity_receipts,
                        0 as product_receipt_amount,
                        SUM(CAST(qty as FLOAT)) as activity_qty
                    FROM pos_sales_dtls s
                    WHERE {activity_where_clause}
                    AND item_name != 'WASTAGE'
                    GROUP BY store_name, CAST(c_date AS DATE)
                ),
                product_receipt_sales AS (
                    SELECT 
                        target_item.store_name,
                        CAST(target_item.c_date AS DATE) as c_date,
                        0 as total_amount,
                        0 as total_receipts,
                        0 as activity_amount,
                        0 as activity_receipts,
                        SUM(receipt_totals.receipt_total) as product_receipt_amount,
                        0 as activity_qty
                    FROM (
                        -- 获取目标产品的单据信息
                        SELECT DISTINCT s.store_name, s.c_date, s.sales_no
                        FROM pos_sales_dtls s WITH (NOLOCK)
                        WHERE s.item_name != 'WASTAGE'
                        AND {activity_where_clause}
                    ) target_item
                    INNER JOIN (
                        -- 计算每个单据的总金额
                        SELECT 
                            s.store_name,
                            s.c_date,
                            s.sales_no,
                            SUM(CAST(s.sub_total as FLOAT) - CAST(ISNULL(s.pro_disc_amt, 0) as FLOAT) - CAST(ISNULL(s.disc_amt, 0) as FLOAT) + CAST(ISNULL(s.svc_amt, 0) as FLOAT) - CASE WHEN s.take_away_item = 'Y' THEN CAST(ISNULL(s.tax_amt, 0) as FLOAT) ELSE 0 END) as receipt_total
                        FROM pos_sales_dtls s WITH (NOLOCK)
                        WHERE s.item_name != 'WASTAGE'
                        GROUP BY s.store_name, s.c_date, s.sales_no
                    ) receipt_totals ON target_item.sales_no = receipt_totals.sales_no AND target_item.store_name = receipt_totals.store_name AND target_item.c_date = receipt_totals.c_date
                    GROUP BY target_item.store_name, CAST(target_item.c_date AS DATE)
                )
                SELECT 
                    COALESCE(t.store_name, COALESCE(a.store_name, p.store_name)) as store_name,
                    COALESCE(t.c_date, COALESCE(a.c_date, p.c_date)) as c_date,
                    COALESCE(t.total_amount, 0) as total_amount,
                    COALESCE(t.total_receipts, 0) as total_receipts,
                    COALESCE(a.activity_amount, 0) as activity_amount,
                    COALESCE(a.activity_receipts, 0) as activity_receipts,
                    COALESCE(p.product_receipt_amount, 0) as product_receipt_amount,
                    COALESCE(a.activity_qty, 0) as activity_qty
                FROM total_sales t
                FULL OUTER JOIN activity_sales a ON t.store_name = a.store_name AND t.c_date = a.c_date
                FULL OUTER JOIN product_receipt_sales p ON COALESCE(t.store_name, a.store_name) = p.store_name 
                    AND COALESCE(t.c_date, a.c_date) = p.c_date
                ORDER BY store_name, c_date
            """
            
            print(f"📊 执行查询: {query}")
            print(f"📊 查询参数: {params}")
            
            # 执行查询
            cursor = self.db_manager.connection.cursor()
            try:
                cursor.execute(query)
                results = cursor.fetchall()
                print(f"📊 查询结果数量: {len(results)}")
            except Exception as query_error:
                print(f"❌ 查询执行失败: {query_error}")
                print(f"🔍 查询语句: {query}")
                print(f"🔍 查询参数: {params}")
                raise query_error
            
            # 处理数据
            daily_data = {}
            overall_data = {}
            
            for row in results:
                store_name = row[0]
                c_date = row[1]
                total_amount = float(row[2]) if row[2] else 0
                total_receipts = int(row[3]) if row[3] else 0
                activity_amount = float(row[4]) if row[4] else 0
                activity_receipts = int(row[5]) if row[5] else 0
                product_receipt_amount = float(row[6]) if row[6] else 0
                activity_qty = float(row[7]) if len(row) > 7 and row[7] is not None else 0.0
                
                # 计算占比
                sales_ratio = (activity_amount / total_amount * 100) if total_amount > 0 else 0
                receipt_ratio = (activity_receipts / total_receipts * 100) if total_receipts > 0 else 0
                product_receipt_ratio = (product_receipt_amount / total_amount * 100) if total_amount > 0 else 0
                
                # 每日数据
                if store_name not in daily_data:
                    daily_data[store_name] = {}
                daily_data[store_name][c_date] = {
                    'total_amount': total_amount,
                    'total_receipts': total_receipts,
                    'activity_amount': activity_amount,
                    'activity_receipts': activity_receipts,
                    'product_receipt_amount': product_receipt_amount,
                    'activity_qty': activity_qty,
                    'sales_ratio': sales_ratio,
                    'receipt_ratio': receipt_ratio,
                    'product_receipt_ratio': product_receipt_ratio
                }
                
                # 整体数据累计
                if store_name not in overall_data:
                    overall_data[store_name] = {
                        'total_amount': 0,
                        'total_receipts': 0,
                        'activity_amount': 0,
                        'activity_receipts': 0,
                        'product_receipt_amount': 0,
                        'activity_qty': 0.0,
                        'days_count': 0
                    }
                
                overall_data[store_name]['total_amount'] += total_amount
                overall_data[store_name]['total_receipts'] += total_receipts
                overall_data[store_name]['activity_amount'] += activity_amount
                overall_data[store_name]['activity_receipts'] += activity_receipts
                overall_data[store_name]['product_receipt_amount'] += product_receipt_amount
                overall_data[store_name]['activity_qty'] += activity_qty
                overall_data[store_name]['days_count'] += 1
            
            # 计算整体占比和日均
            for store_name in overall_data:
                data = overall_data[store_name]
                data['sales_ratio'] = (data['activity_amount'] / data['total_amount'] * 100) if data['total_amount'] > 0 else 0
                data['receipt_ratio'] = (data['activity_receipts'] / data['total_receipts'] * 100) if data['total_receipts'] > 0 else 0
                data['product_receipt_ratio'] = (data['product_receipt_amount'] / data['total_amount'] * 100) if data['total_amount'] > 0 else 0
                data['daily_avg_amount'] = data['total_amount'] / data['days_count'] if data['days_count'] > 0 else 0
                data['daily_avg_activity'] = data['activity_amount'] / data['days_count'] if data['days_count'] > 0 else 0
                data['daily_avg_product_receipt'] = data['product_receipt_amount'] / data['days_count'] if data['days_count'] > 0 else 0
            
            # 创建每日细项分析界面
            self.create_daily_breakdown_interface(daily_frame, daily_data, activity_record)
            
            # 创建整体细项分析界面
            self.create_overall_breakdown_interface(overall_frame, overall_data, activity_record)
            
            # 保存细项分析结果到活动记录
            self.save_breakdown_results_to_activity_record(activity_record, daily_data, overall_data)
            
        except Exception as e:
            print(f"❌ 生成细项分析数据失败: {e}")
            import traceback
            print(f"详细错误: {traceback.format_exc()}")
            tk.messagebox.showerror("错误", f"生成细项分析数据失败: {e}")

    def create_daily_breakdown_interface(self, parent_frame, daily_data, activity_record):
        """创建每日细项分析界面"""
        try:
            # 控制面板
            control_frame = tk.Frame(parent_frame, bg='#FFFFFF')
            control_frame.pack(fill="x", padx=10, pady=10)
            
            # 搜索框架
            search_frame = tk.Frame(control_frame, bg='#FFFFFF')
            search_frame.pack(side="left", fill="x", expand=True)
            
            tk.Label(search_frame, text="🔍 搜索门市:", font=('Arial', 9), 
                    fg='#2c3e50', bg='#FFFFFF').pack(side="left", padx=(0, 5))
            
            self.daily_search_entry = tk.Entry(search_frame, width=20, font=('Arial', 9))
            self.daily_search_entry.pack(side="left", padx=2)
            
            # 清除搜索按钮
            clear_search_btn = tk.Button(search_frame, text="❌", 
                                       command=self.clear_daily_search,
                                       font=('Arial', 8), bg='#e74c3c', fg='white',
                                       relief='flat', bd=0, width=2, height=1,
                                       cursor='hand2')
            clear_search_btn.pack(side="left", padx=2)
            
            # 按钮框架
            button_frame = tk.Frame(control_frame, bg='#FFFFFF')
            button_frame.pack(side="right")
            
            # 导出按钮
            export_btn = tk.Button(button_frame, text="📤 导出Excel / Export Excel", 
                                 command=lambda: self.export_daily_breakdown(daily_data, activity_record),
                                 font=('Arial', 10, 'bold'), bg='#27ae60', fg='white',
                                 relief='flat', bd=0, padx=15, pady=5,
                                 cursor='hand2')
            export_btn.pack(side="left", padx=5)
            
            # 保存记录按钮
            save_btn = tk.Button(button_frame, text="💾 保存记录 / Save Record", 
                               command=lambda: self.save_breakdown_record(daily_data, activity_record, 'daily'),
                               font=('Arial', 10, 'bold'), bg='#3498db', fg='white',
                               relief='flat', bd=0, padx=15, pady=5,
                               cursor='hand2')
            save_btn.pack(side="left", padx=5)
            
            # 创建表格框架
            table_frame = tk.Frame(parent_frame, bg='#FFFFFF')
            table_frame.pack(fill="both", expand=True, padx=10, pady=10)
            
            # 创建表格列 - 加入活動銷售數量
            columns = ['门市 / Store', '总业绩 / Total Sales', '总单据数 / Total Receipts', 
                      '产品单据业绩 / Product Receipt Performance', '产品业绩 / Product Performance', 
                      '产品单据数 / Product Receipts', '活动销售数量 / Activity Qty', '业绩占比% / Sales Ratio%', '单据占比% / Receipt Ratio%']
            
            # 创建Treeview
            tree = ttk.Treeview(table_frame, columns=columns, show='headings', height=20)
            
            # 设置列标题和宽度
            column_configs = [
                ('门市 / Store', 150),
                ('总业绩 / Total Sales', 120),
                ('总单据数 / Total Receipts', 120),
                ('产品单据业绩 / Product Receipt Performance', 150),
                ('产品业绩 / Product Performance', 120),
                ('产品单据数 / Product Receipts', 120),
                ('活动销售数量 / Activity Qty', 120),
                ('业绩占比% / Sales Ratio%', 120),
                ('单据占比% / Receipt Ratio%', 120)
            ]
            
            for col, width in column_configs:
                tree.heading(col, text=col)
                tree.column(col, width=width, anchor='center')
            
            # 存储tree引用用于搜索
            self.daily_breakdown_tree = tree
            self.daily_breakdown_data = daily_data
            
            # 设置样式标签
            tree.tag_configure("date_header", background="#2c3e50", foreground="white", font=('Arial', 10, 'bold'))
            tree.tag_configure("store_row", background="#f8f9fa", foreground="#2c3e50", font=('Arial', 9))
            tree.tag_configure("date_subtotal", background="#e8f4fd", foreground="#1a365d", font=('Arial', 9, 'bold'))
            tree.tag_configure("separator", background="#ffffff", foreground="#ffffff")
            tree.tag_configure("total", background="#d4edda", foreground="#155724", font=('Arial', 10, 'bold'))
            
            # 绑定搜索事件
            self.daily_search_entry.bind('<KeyRelease>', lambda e: self.filter_daily_breakdown())
            
            # 添加数据
            self.populate_daily_breakdown_tree()
            
            # 添加滚动条
            scrollbar = ttk.Scrollbar(table_frame, orient="vertical", command=tree.yview)
            tree.configure(yscrollcommand=scrollbar.set)
            
            tree.pack(side="left", fill="both", expand=True)
            scrollbar.pack(side="right", fill="y")
            
        except Exception as e:
            print(f"❌ 创建每日细项分析界面失败: {e}")

    def populate_daily_breakdown_tree(self):
        """填充每日细项分析表格数据 - 显示每日详细数据"""
        try:
            if not hasattr(self, 'daily_breakdown_tree'):
                return
                
            # 清空现有数据
            for item in self.daily_breakdown_tree.get_children():
                self.daily_breakdown_tree.delete(item)
            
            # 获取搜索关键词
            search_text = ""
            if hasattr(self, 'daily_search_entry'):
                search_text = self.daily_search_entry.get().lower()
            
            # 计算总计
            totals = {
                'total_amount': 0,
                'total_receipts': 0,
                'product_receipt_amount': 0,
                'activity_amount': 0,
                'activity_receipts': 0
            }
            
            # 计算总天数用于日均计算
            total_days = 0
            all_dates = set()
            for store_name, store_data in self.daily_breakdown_data.items():
                for date in store_data.keys():
                    all_dates.add(date)
            total_days = len(all_dates) if all_dates else 1
            
            # 添加数据 - 按日期分组，然后按门市显示
            for date in sorted(all_dates):
                # 检查是否应该显示这个日期（搜索过滤）
                date_should_show = not search_text or search_text in date.lower()
                
                # 按门市显示该日期的数据
                stores_with_data = []
                for store_name, store_data in self.daily_breakdown_data.items():
                    if date in store_data:
                        stores_with_data.append((store_name, store_data[date]))
                
                # 按门市名称排序
                stores_with_data.sort(key=lambda x: x[0])
                
                # 检查是否有匹配的门市数据
                matching_stores = []
                if search_text:
                    matching_stores = [store for store, data in stores_with_data if search_text in store.lower()]
                else:
                    matching_stores = [store for store, data in stores_with_data]
                
                # 如果没有匹配的门市且没有搜索，或者有搜索但没有匹配的门市，跳过这个日期
                if not matching_stores and (search_text or not date_should_show):
                    continue
                
                # 添加日期标题行
                date_header = self.daily_breakdown_tree.insert("", "end", values=[
                    f"📅 {date}",
                    "", "", "", "", "", "", ""
                ], tags=("date_header",))
                
                # 计算该日期的总计数据
                date_totals = {
                    'total_amount': 0,
                    'total_receipts': 0,
                    'product_receipt_amount': 0,
                    'activity_amount': 0,
                    'activity_receipts': 0,
                    'activity_qty': 0.0
                }
                
                for store_name, data in stores_with_data:
                    # 如果搜索且不匹配，跳过
                    if search_text and search_text not in store_name.lower():
                        continue
                # 计算占比
                    sales_ratio = (data['activity_amount'] / data['total_amount'] * 100) if data['total_amount'] > 0 else 0
                    receipt_ratio = (data['activity_receipts'] / data['total_receipts'] * 100) if data['total_receipts'] > 0 else 0
                
                    # 根据日均开关决定显示格式
                    if self.show_daily_average.get():
                        # 显示日均数据
                        row_data = [
                            f"  └─ {store_name}",
                            f"${data['total_amount'] / total_days:,.2f}",
                            f"{data['total_receipts'] / total_days:,.0f}",
                            f"${data['product_receipt_amount'] / total_days:,.2f}",
                            f"${data['activity_amount'] / total_days:,.2f}",
                            f"{data.get('activity_qty', 0.0) / total_days:,.2f}",
                            f"{data['activity_receipts'] / total_days:,.0f}",
                            f"{sales_ratio:.2f}%",
                            f"{receipt_ratio:.2f}%"
                        ]
                    else:
                        # 显示实际数据
                        row_data = [
                            f"  └─ {store_name}",
                            f"${data['total_amount']:,.2f}",
                            f"{data['total_receipts']:,}",
                            f"${data['product_receipt_amount']:,.2f}",
                            f"${data['activity_amount']:,.2f}",
                            f"{data.get('activity_qty', 0.0):,.2f}",
                            f"{data['activity_receipts']:,}",
                            f"{sales_ratio:.2f}%",
                            f"{receipt_ratio:.2f}%"
                        ]
                
                    self.daily_breakdown_tree.insert("", "end", values=row_data, tags=("store_row",))
                    
                    # 累计该日期的总计
                    date_totals['total_amount'] += data['total_amount']
                    date_totals['total_receipts'] += data['total_receipts']
                    date_totals['product_receipt_amount'] += data['product_receipt_amount']
                    date_totals['activity_amount'] += data['activity_amount']
                    date_totals['activity_receipts'] += data['activity_receipts']
                    date_totals['activity_qty'] += data.get('activity_qty', 0.0)
                
                # 添加该日期的小计行
                date_sales_ratio = (date_totals['activity_amount'] / date_totals['total_amount'] * 100) if date_totals['total_amount'] > 0 else 0
                date_receipt_ratio = (date_totals['activity_receipts'] / date_totals['total_receipts'] * 100) if date_totals['total_receipts'] > 0 else 0
                
                if self.show_daily_average.get():
                    # 显示日均小计
                    date_subtotal = [
                        f"  📊 {date} 小计 (日均)",
                        f"${date_totals['total_amount'] / total_days:,.2f}",
                        f"{date_totals['total_receipts'] / total_days:,.0f}",
                        f"${date_totals['product_receipt_amount'] / total_days:,.2f}",
                        f"${date_totals['activity_amount'] / total_days:,.2f}",
                        f"{date_totals['activity_qty'] / total_days:,.2f}",
                        f"{date_totals['activity_receipts'] / total_days:,.0f}",
                        f"{date_sales_ratio:.2f}%",
                        f"{date_receipt_ratio:.2f}%"
                    ]
                else:
                    # 显示实际小计
                    date_subtotal = [
                        f"  📊 {date} 小计",
                        f"${date_totals['total_amount']:,.2f}",
                        f"{date_totals['total_receipts']:,}",
                        f"${date_totals['product_receipt_amount']:,.2f}",
                        f"${date_totals['activity_amount']:,.2f}",
                        f"{date_totals['activity_qty']:,.2f}",
                        f"{date_totals['activity_receipts']:,}",
                        f"{date_sales_ratio:.2f}%",
                        f"{date_receipt_ratio:.2f}%"
                    ]
                
                self.daily_breakdown_tree.insert("", "end", values=date_subtotal, tags=("date_subtotal",))
                
                # 添加空行分隔
                self.daily_breakdown_tree.insert("", "end", values=["", "", "", "", "", "", "", "", ""], tags=("separator",))
                
                # 累计总计
                for key in totals:
                    totals[key] += date_totals[key]
            
            # 添加总计行
            if not search_text:  # 只在没有搜索时显示总计
                total_sales_ratio = (totals['activity_amount'] / totals['total_amount'] * 100) if totals['total_amount'] > 0 else 0
                total_receipt_ratio = (totals['activity_receipts'] / totals['total_receipts'] * 100) if totals['total_receipts'] > 0 else 0
                
                if self.show_daily_average.get():
                    # 显示日均总计
                    total_row = [
                        "总计 (日均)",
                        f"${totals['total_amount'] / total_days:,.2f}",
                        f"{totals['total_receipts'] / total_days:,.0f}",
                        f"${totals['product_receipt_amount'] / total_days:,.2f}",
                        f"${totals['activity_amount'] / total_days:,.2f}",
                        f"{totals.get('activity_qty', 0.0) / total_days:,.2f}",
                        f"{totals['activity_receipts'] / total_days:,.0f}",
                        f"{total_sales_ratio:.2f}%",
                        f"{total_receipt_ratio:.2f}%"
                    ]
                else:
                    # 显示实际总计
                    total_row = [
                    "总计 / Total",
                    f"${totals['total_amount']:,.2f}",
                    f"{totals['total_receipts']:,}",
                    f"${totals['product_receipt_amount']:,.2f}",
                    f"${totals['activity_amount']:,.2f}",
                    f"{totals.get('activity_qty', 0.0):,.2f}",
                    f"{totals['activity_receipts']:,}",
                    f"{total_sales_ratio:.2f}%",
                    f"{total_receipt_ratio:.2f}%"
                ]
                
                # 插入总计行，使用特殊标签
                total_item = self.daily_breakdown_tree.insert("", "end", values=total_row, tags=('total',))
                self.daily_breakdown_tree.tag_configure('total', background='#e8f4fd', font=('Arial', 9, 'bold'))
                
        except Exception as e:
            print(f"❌ 填充每日细项分析表格失败: {e}")

    def filter_daily_breakdown(self):
        """过滤每日细项分析数据"""
        try:
            self.populate_daily_breakdown_tree()
        except Exception as e:
            print(f"❌ 过滤每日细项分析失败: {e}")

    def clear_daily_search(self):
        """清除每日细项分析搜索"""
        try:
            if hasattr(self, 'daily_search_entry'):
                self.daily_search_entry.delete(0, 'end')
                self.populate_daily_breakdown_tree()
        except Exception as e:
            print(f"❌ 清除每日细项分析搜索失败: {e}")

    def create_overall_breakdown_interface(self, parent_frame, overall_data, activity_record):
        """创建整体细项分析界面"""
        try:
            # 控制面板
            control_frame = tk.Frame(parent_frame, bg='#FFFFFF')
            control_frame.pack(fill="x", padx=10, pady=10)
            
            # 搜索框架
            search_frame = tk.Frame(control_frame, bg='#FFFFFF')
            search_frame.pack(side="left", fill="x", expand=True)
            
            tk.Label(search_frame, text="🔍 搜索门市:", font=('Arial', 9), 
                    fg='#2c3e50', bg='#FFFFFF').pack(side="left", padx=(0, 5))
            
            self.overall_search_entry = tk.Entry(search_frame, width=20, font=('Arial', 9))
            self.overall_search_entry.pack(side="left", padx=2)
            
            # 清除搜索按钮
            clear_search_btn = tk.Button(search_frame, text="❌", 
                                       command=self.clear_overall_search,
                                       font=('Arial', 8), bg='#e74c3c', fg='white',
                                       relief='flat', bd=0, width=2, height=1,
                                       cursor='hand2')
            clear_search_btn.pack(side="left", padx=2)
            
            # 按钮框架
            button_frame = tk.Frame(control_frame, bg='#FFFFFF')
            button_frame.pack(side="right")
            
            # 导出按钮
            export_btn = tk.Button(button_frame, text="📤 导出Excel / Export Excel", 
                                 command=lambda: self.export_overall_breakdown(overall_data, activity_record),
                                 font=('Arial', 10, 'bold'), bg='#27ae60', fg='white',
                                 relief='flat', bd=0, padx=15, pady=5,
                                 cursor='hand2')
            export_btn.pack(side="left", padx=5)
            
            # 保存记录按钮
            save_btn = tk.Button(button_frame, text="💾 保存记录 / Save Record", 
                               command=lambda: self.save_breakdown_record(overall_data, activity_record, 'overall'),
                               font=('Arial', 10, 'bold'), bg='#3498db', fg='white',
                               relief='flat', bd=0, padx=15, pady=5,
                               cursor='hand2')
            save_btn.pack(side="left", padx=5)
            
            # 日均功能按钮
            daily_avg_btn = tk.Button(button_frame, text="📊 显示日均 / Show Daily Average", 
                                    command=lambda: self.toggle_breakdown_daily_average(),
                                    font=('Arial', 10, 'bold'), bg='#e67e22', fg='white',
                                    relief='flat', bd=0, padx=15, pady=5,
                                    cursor='hand2')
            daily_avg_btn.pack(side="left", padx=5)
            
            # 创建表格框架
            table_frame = tk.Frame(parent_frame, bg='#FFFFFF')
            table_frame.pack(fill="both", expand=True, padx=10, pady=10)
            
            # 创建表格列
            columns = ['门市 / Store', '总业绩 / Total Sales', '总单据数 / Total Receipts', 
                      '活动业绩 / Activity Sales', '活动销售数量 / Activity Qty', '活动单据数 / Activity Receipts', 
                      '业绩占比% / Sales Ratio%', '单据占比% / Receipt Ratio%']
            
            # 创建Treeview
            tree = ttk.Treeview(table_frame, columns=columns, show='headings', height=20)
            
            # 设置列标题和宽度
            column_configs = [
                ('门市 / Store', 150),
                ('总业绩 / Total Sales', 120),
                ('总单据数 / Total Receipts', 120),
                ('活动业绩 / Activity Sales', 120),
                ('活动销售数量 / Activity Qty', 120),
                ('活动单据数 / Activity Receipts', 120),
                ('业绩占比% / Sales Ratio%', 120),
                ('单据占比% / Receipt Ratio%', 120)
            ]
            
            for col, width in column_configs:
                tree.heading(col, text=col)
                tree.column(col, width=width, anchor='center')
            
            # 存储tree引用用于搜索
            self.overall_breakdown_tree = tree
            self.overall_breakdown_data = overall_data
            
            # 绑定搜索事件
            self.overall_search_entry.bind('<KeyRelease>', lambda e: self.filter_overall_breakdown())
            
            # 添加数据
            self.populate_overall_breakdown_tree()
            
            # 添加滚动条
            scrollbar = ttk.Scrollbar(table_frame, orient="vertical", command=tree.yview)
            tree.configure(yscrollcommand=scrollbar.set)
            
            tree.pack(side="left", fill="both", expand=True)
            scrollbar.pack(side="right", fill="y")
            
            # 存储tree引用以便后续使用
            parent_frame.overall_tree = tree
            parent_frame.overall_data = overall_data
            
        except Exception as e:
            print(f"❌ 创建整体细项分析界面失败: {e}")

    def populate_overall_breakdown_tree(self):
        """填充整体细项分析表格数据"""
        try:
            if not hasattr(self, 'overall_breakdown_tree'):
                return
                
            # 清空现有数据
            for item in self.overall_breakdown_tree.get_children():
                self.overall_breakdown_tree.delete(item)
            
            # 获取搜索关键词
            search_text = ""
            if hasattr(self, 'overall_search_entry'):
                search_text = self.overall_search_entry.get().lower()
            
            # 计算总计
            totals = {
                'total_amount': 0,
                'total_receipts': 0,
                'activity_amount': 0,
                'activity_receipts': 0,
                'activity_qty': 0.0
            }
            
            # 添加数据
            for store_name in sorted(self.overall_breakdown_data.keys()):
                # 搜索过滤
                if search_text and search_text not in store_name.lower():
                    continue
                    
                data = self.overall_breakdown_data[store_name]
                row_data = [
                    store_name,
                    f"${data['total_amount']:,.2f}",
                    f"{data['total_receipts']:,}",
                    f"${data['activity_amount']:,.2f}",
                    f"{data.get('activity_qty', 0.0):,.2f}",
                    f"{data['activity_receipts']:,}",
                    f"{data['sales_ratio']:.2f}%",
                    f"{data['receipt_ratio']:.2f}%"
                ]
                self.overall_breakdown_tree.insert("", "end", values=row_data)
                
                # 累计总计
                totals['total_amount'] += data['total_amount']
                totals['total_receipts'] += data['total_receipts']
                totals['activity_amount'] += data['activity_amount']
                totals['activity_qty'] += data.get('activity_qty', 0.0)
                totals['activity_receipts'] += data['activity_receipts']
            
            # 添加总计行
            if not search_text:  # 只在没有搜索时显示总计
                total_sales_ratio = (totals['activity_amount'] / totals['total_amount'] * 100) if totals['total_amount'] > 0 else 0
                total_receipt_ratio = (totals['activity_receipts'] / totals['total_receipts'] * 100) if totals['total_receipts'] > 0 else 0
                
                total_row = [
                    "总计 / Total",
                    f"${totals['total_amount']:,.2f}",
                    f"{totals['total_receipts']:,}",
                    f"${totals['activity_amount']:,.2f}",
                    f"{totals.get('activity_qty', 0.0):,.2f}",
                    f"{totals['activity_receipts']:,}",
                    f"{total_sales_ratio:.2f}%",
                    f"{total_receipt_ratio:.2f}%"
                ]
                
                # 插入总计行，使用特殊标签
                total_item = self.overall_breakdown_tree.insert("", "end", values=total_row, tags=('total',))
                self.overall_breakdown_tree.tag_configure('total', background='#e8f4fd', font=('Arial', 9, 'bold'))
                
        except Exception as e:
            print(f"❌ 填充整体细项分析表格失败: {e}")

    def filter_overall_breakdown(self):
        """过滤整体细项分析数据"""
        try:
            self.populate_overall_breakdown_tree()
        except Exception as e:
            print(f"❌ 过滤整体细项分析失败: {e}")

    def clear_overall_search(self):
        """清除整体细项分析搜索"""
        try:
            if hasattr(self, 'overall_search_entry'):
                self.overall_search_entry.delete(0, 'end')
                self.populate_overall_breakdown_tree()
        except Exception as e:
            print(f"❌ 清除整体细项分析搜索失败: {e}")

    def export_daily_breakdown(self, daily_data, activity_record):
        """导出每日细项分析到Excel"""
        try:
            import pandas as pd
            from datetime import datetime
            
            # 创建导出数据
            export_data = []
            
            # 获取所有日期
            all_dates = set()
            for store_data in daily_data.values():
                all_dates.update(store_data.keys())
            all_dates = sorted(list(all_dates))
            
            # 为每个门市创建行数据
            for store_name in sorted(daily_data.keys()):
                store_data = daily_data[store_name]
                row_data = {'门市 / Store': store_name}
                
                for date in all_dates:
                    if date in store_data:
                        data = store_data[date]
                        row_data[f'{date}_总业绩'] = data['total_amount']
                        row_data[f'{date}_总单据数'] = data['total_receipts']
                        row_data[f'{date}_活动业绩'] = data['activity_amount']
                        row_data[f'{date}_活动单据数'] = data['activity_receipts']
                        row_data[f'{date}_业绩占比%'] = data['sales_ratio']
                        row_data[f'{date}_单据占比%'] = data['receipt_ratio']
                    else:
                        row_data[f'{date}_总业绩'] = 0
                        row_data[f'{date}_总单据数'] = 0
                        row_data[f'{date}_活动业绩'] = 0
                        row_data[f'{date}_活动单据数'] = 0
                        row_data[f'{date}_业绩占比%'] = 0
                        row_data[f'{date}_单据占比%'] = 0
                
                export_data.append(row_data)
            
            # 创建DataFrame
            df = pd.DataFrame(export_data)
            
            # 生成文件名
            activity_name = activity_record.get('description', f"活动_{activity_record.get('id', '')}")
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"exports/daily_breakdown_{activity_name}_{timestamp}.xlsx"
            
            # 确保exports目录存在
            import os
            os.makedirs("exports", exist_ok=True)
            
            # 导出到Excel
            df.to_excel(filename, index=False, engine='openpyxl')
            
            tk.messagebox.showinfo("导出成功", f"每日细项分析已导出到:\n{filename}")
            
        except Exception as e:
            print(f"❌ 导出每日细项分析失败: {e}")
            tk.messagebox.showerror("导出失败", f"导出每日细项分析失败: {e}")

    def export_overall_breakdown(self, overall_data, activity_record):
        """导出整体细项分析到Excel"""
        try:
            import pandas as pd
            from datetime import datetime
            
            # 创建导出数据
            export_data = []
            
            for store_name in sorted(overall_data.keys()):
                data = overall_data[store_name]
                row_data = {
                    '门市 / Store': store_name,
                    '总业绩 / Total Sales': data['total_amount'],
                    '总单据数 / Total Receipts': data['total_receipts'],
                    '活动业绩 / Activity Sales': data['activity_amount'],
                    '活动销售数量 / Activity Qty': data.get('activity_qty', 0.0),
                    '活动单据数 / Activity Receipts': data['activity_receipts'],
                    '业绩占比% / Sales Ratio%': data['sales_ratio'],
                    '单据占比% / Receipt Ratio%': data['receipt_ratio'],
                    '日均总业绩 / Daily Avg Total': data['daily_avg_amount'],
                    '日均活动业绩 / Daily Avg Activity': data['daily_avg_activity'],
                    '活动天数 / Activity Days': data['days_count']
                }
                export_data.append(row_data)
            
            # 创建DataFrame
            df = pd.DataFrame(export_data)
            
            # 生成文件名
            activity_name = activity_record.get('description', f"活动_{activity_record.get('id', '')}")
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"exports/overall_breakdown_{activity_name}_{timestamp}.xlsx"
            
            # 确保exports目录存在
            import os
            os.makedirs("exports", exist_ok=True)
            
            # 导出到Excel
            df.to_excel(filename, index=False, engine='openpyxl')
            
            tk.messagebox.showinfo("导出成功", f"整体细项分析已导出到:\n{filename}")
            
        except Exception as e:
            print(f"❌ 导出整体细项分析失败: {e}")
            tk.messagebox.showerror("导出失败", f"导出整体细项分析失败: {e}")

    def save_breakdown_record(self, breakdown_data, activity_record, breakdown_type):
        """保存细项分析记录"""
        try:
            from datetime import datetime
            import json
            
            # 创建记录数据
            record_data = {
                'activity_id': activity_record.get('id'),
                'activity_name': activity_record.get('description'),
                'breakdown_type': breakdown_type,  # 'daily' or 'overall'
                'breakdown_data': breakdown_data,
                'created_at': datetime.now().isoformat(),
                'date_from': activity_record.get('date_from'),
                'date_to': activity_record.get('date_to'),
                'outlets': activity_record.get('outlets', []),
                'products': activity_record.get('products', [])
            }
            
            # 确保breakdown_records目录存在
            import os
            os.makedirs("breakdown_records", exist_ok=True)
            
            # 生成文件名
            activity_name = activity_record.get('description', f"活动_{activity_record.get('id', '')}")
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"breakdown_records/{breakdown_type}_breakdown_{activity_name}_{timestamp}.json"
            
            # 保存到JSON文件
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(record_data, f, ensure_ascii=False, indent=2)
            
            tk.messagebox.showinfo("保存成功", f"细项分析记录已保存到:\n{filename}")
            
        except Exception as e:
            print(f"❌ 保存细项分析记录失败: {e}")
            tk.messagebox.showerror("保存失败", f"保存细项分析记录失败: {e}")

    def toggle_breakdown_daily_average(self):
        """切换显示日均数据"""
        try:
            print("📊 切换日均显示功能")
            
            # 切换日均显示状态
            self.show_daily_average.set(not self.show_daily_average.get())
            
            if self.show_daily_average.get():
                self.log_message("✓ 已启用日均显示")
            else:
                self.log_message("ℹ 已禁用日均显示")
            
            # 重新填充整体细项分析表格
            if hasattr(self, 'overall_breakdown_tree') and hasattr(self, 'overall_breakdown_data'):
                self.populate_overall_breakdown_tree()
            
            # 重新填充每日细项分析表格
            if hasattr(self, 'daily_breakdown_tree') and hasattr(self, 'daily_breakdown_data'):
                self.populate_daily_breakdown_tree()
            
        except Exception as e:
            print(f"❌ 切换日均显示失败: {e}")

    def save_breakdown_results_to_activity_record(self, activity_record, daily_data, overall_data):
        """保存细项分析结果到活动记录"""
        try:
            from datetime import datetime
            
            # 获取活动记录ID
            activity_id = activity_record.get('id')
            current_db = self.get_current_database()
            
            # 找到对应的活动记录
            records = self.activity_records.get(current_db, [])
            for record in records:
                if record.get('id') == activity_id:
                    # 保存细项分析结果
                    record['breakdown_analysis'] = {
                        'daily_data': daily_data,
                        'overall_data': overall_data,
                        'analysis_time': datetime.now().isoformat(),
                        'analysis_type': 'breakdown'
                    }
                    
                    # 更新活动记录
                    self.activity_records[current_db] = records
                    
                    # 保存到文件
                    self.save_activity_records()
                    
                    print(f"✅ 已保存细项分析结果到活动记录 {activity_id}")
                    break
            
        except Exception as e:
            print(f"❌ 保存细项分析结果失败: {e}")

    def setup_activity_right_panel(self, right_frame):
        """设置活动记录右侧面板 - 强化版本确保假期窗口始终可见"""
        try:
            print("🔧 开始设置右侧假期面板...")
            
            # 假期信息区域
            holiday_frame = tk.LabelFrame(right_frame, text="📅 假期信息 / Holiday Information")
            holiday_frame.pack(fill="x", pady=(0, 10))
            
            # 当前月份假期显示
            self.holiday_info_text = tk.Text(holiday_frame, height=8, width=45, wrap=tk.WORD)
            self.holiday_info_text.pack(fill="both", expand=True)
            
            # 添加假期按钮
            add_holiday_btn = ttk.Button(holiday_frame, text="➕ 添加假期\nAdd Holiday", 
                                       command=self.add_holiday)
            add_holiday_btn.pack(pady=5)
            
            print("✅ 假期信息面板设置完成")
            
            # 假期记录区域
            holiday_records_frame = tk.LabelFrame(right_frame, text="📅 假期记录 / Holiday Records")
            holiday_records_frame.pack(fill="both", expand=True, pady=(10, 0))
            
            # 假期记录输入区域
            input_frame = tk.Frame(holiday_records_frame)
            input_frame.pack(fill="x", pady=(0, 10))
            
            # 开始日期
            start_frame = tk.Frame(input_frame)
            start_frame.pack(fill="x", pady=5)
            tk.Label(start_frame, text="🗓️ 开始日期 / Start Date:", font=('Arial', 9, 'bold')).pack(side="left")
            self.holiday_start_date_entry = DateEntry(start_frame, width=12, background='darkblue',
                                                     foreground='white', borderwidth=2, date_pattern='dd/MM/yyyy')
            self.holiday_start_date_entry.pack(side="left", padx=(10, 0))
            
            # 结束日期
            end_frame = tk.Frame(input_frame)
            end_frame.pack(fill="x", pady=5)
            tk.Label(end_frame, text="🗓️ 结束日期 / End Date:", font=('Arial', 9, 'bold')).pack(side="left")
            self.holiday_end_date_entry = DateEntry(end_frame, width=12, background='darkblue',
                                                   foreground='white', borderwidth=2, date_pattern='dd/MM/yyyy')
            self.holiday_end_date_entry.pack(side="left", padx=(10, 0))
            
            # 假期名称
            name_frame = tk.Frame(input_frame)
            name_frame.pack(fill="x", pady=5)
            tk.Label(name_frame, text="🏷️ 假期名称 / Holiday Name:", font=('Arial', 9, 'bold')).pack(side="left")
            self.holiday_name_entry = ttk.Entry(name_frame, width=25)
            self.holiday_name_entry.pack(side="left", padx=(10, 0))
            
            # 添加假期按钮
            quick_add_btn = ttk.Button(input_frame, text="➕ 快速添加\nQuick Add", 
                                      command=self.add_holiday_record_from_entries)
            quick_add_btn.pack(pady=5)
            
            # 假期记录列表
            tk.Label(holiday_records_frame, text="假期记录列表 / Holiday Records List:", font=('Arial', 9, 'bold')).pack(anchor="w")
            
            # 创建假期记录Treeview
            holiday_columns = ('开始日期', '结束日期', '假期名称', '假期长度')
            self.holiday_tree = ttk.Treeview(holiday_records_frame, columns=holiday_columns, show='headings', height=4)
            
            # 设置列标题
            self.holiday_tree.heading('开始日期', text='开始日期 / Start Date')
            self.holiday_tree.heading('结束日期', text='结束日期 / End Date')
            self.holiday_tree.heading('假期名称', text='假期名称 / Holiday Name')
            self.holiday_tree.heading('假期长度', text='假期长度 / Duration')
            
            self.holiday_tree.column('开始日期', width=80)
            self.holiday_tree.column('结束日期', width=80)
            self.holiday_tree.column('假期名称', width=120)
            self.holiday_tree.column('假期长度', width=80)
            
            # 添加滚动条
            holiday_scrollbar = ttk.Scrollbar(holiday_records_frame, orient="vertical", command=self.holiday_tree.yview)
            self.holiday_tree.configure(yscrollcommand=holiday_scrollbar.set)
            
            self.holiday_tree.pack(side="left", fill="both", expand=True)
            holiday_scrollbar.pack(side="right", fill="y")
            
            # 假期记录管理按钮区域 - 美化布局
            holiday_button_frame = tk.Frame(holiday_records_frame)
            holiday_button_frame.pack(fill="x", pady=(8, 0))
            
            # 创建响应式按钮布局
            add_holiday_btn = ttk.Button(holiday_button_frame, text="➕ 添加假期记录\nAdd Holiday Record", 
                       command=self.add_holiday_record_record)
            add_holiday_btn.pack(side="left", padx=(0, 4), ipady=3)
            
            del_holiday_btn = ttk.Button(holiday_button_frame, text="🗑️ 删除记录\nDelete Record", 
                       command=self.delete_holiday_record_record)
            del_holiday_btn.pack(side="left", padx=4, ipady=3)
            
            save_holiday_btn = ttk.Button(holiday_button_frame, text="💾 保存记录\nSave Records", 
                        command=self.save_holiday_records_to_file)
            save_holiday_btn.pack(side="left", padx=(4, 0), ipady=3)
            
            print("✅ 完整右侧面板设置完成")
            
        except Exception as e:
            print(f"❌ 设置右侧度假面板失败: {e}")
        
        # 初始化假期记录
        if hasattr(self, 'holiday_records'):
            self.load_holiday_records()
        else:
            # 初始化假期记录列表 - 按数据库分类
            self.holiday_records = {
                'GOGO': [],
                'Express': [],
                'PLUS': []
            }
        
        # 刷新假期记录显示
        if hasattr(self, 'holiday_tree'):
            self.refresh_holiday_tree()
        
        # 初始化假期信息
        if hasattr(self, 'holiday_info_text'):
            self.update_holiday_info()
        
        # 初始化假期记录列表 - 按数据库分类
        self.holiday_records = {
            'GOGO': [],
            'Express': [],
            'PLUS': []
        }
        self.load_holiday_records()
        self.refresh_holiday_tree()
        
        # 初始化假期信息
        self.update_holiday_info()
    
    def update_holiday_info(self):
        """更新假期信息显示"""
        try:
            from datetime import datetime, timedelta
            import calendar
            
            # 获取当前月份
            now = datetime.now()
            current_month = now.month
            current_year = now.year
            
            # 清空文本框
            self.holiday_info_text.delete("1.0", tk.END)
            
            # 添加月份标题
            month_name = calendar.month_name[current_month]
            self.holiday_info_text.insert(tk.END, f"📅 {current_year}年{current_month}月 / {month_name} {current_year}\n")
            self.holiday_info_text.insert(tk.END, "=" * 40 + "\n\n")
            
            # 获取当月所有日期
            days_in_month = calendar.monthrange(current_year, current_month)[1]
            
            # 预定义的假期（可以根据需要扩展）
            holidays = {
                (1, 1): "元旦 / New Year's Day",
                (2, 14): "情人节 / Valentine's Day",
                (3, 8): "妇女节 / Women's Day",
                (4, 1): "愚人节 / April Fool's Day",
                (5, 1): "劳动节 / Labor Day",
                (6, 1): "儿童节 / Children's Day",
                (7, 1): "建党节 / Party Founding Day",
                (8, 1): "建军节 / Army Day",
                (9, 10): "教师节 / Teacher's Day",
                (10, 1): "国庆节 / National Day",
                (12, 25): "圣诞节 / Christmas Day",
                (12, 31): "除夕 / New Year's Eve"
            }
            
            # 检查当月是否有假期
            month_holidays = []
            for day in range(1, days_in_month + 1):
                if (current_month, day) in holidays:
                    weekday = calendar.day_name[datetime(current_year, current_month, day).weekday()]
                    holiday_name = holidays[(current_month, day)]
                    month_holidays.append(f"📆 {day}日 ({weekday}) - {holiday_name}")
            
            if month_holidays:
                self.holiday_info_text.insert(tk.END, "🏖️ 本月假期 / This Month Holidays:\n\n")
                for holiday in month_holidays:
                    self.holiday_info_text.insert(tk.END, holiday + "\n")
            else:
                self.holiday_info_text.insert(tk.END, "ℹ️ 本月无预定义假期\nNo predefined holidays this month\n\n")
            
            # 添加周末信息
            self.holiday_info_text.insert(tk.END, "\n📅 周末日期 / Weekend Dates:\n")
            for day in range(1, days_in_month + 1):
                date_obj = datetime(current_year, current_month, day)
                if date_obj.weekday() >= 5:  # 周六和周日
                    weekday = calendar.day_name[date_obj.weekday()]
                    self.holiday_info_text.insert(tk.END, f"📅 {day}日 ({weekday})\n")
            
        except Exception as e:
            self.holiday_info_text.insert(tk.END, f"获取假期信息失败: {e}")
    
    def add_holiday(self):
        """添加自定义假期"""
        try:
            # 创建假期添加窗口
            holiday_window = tk.Toplevel(self.activity_window)
            holiday_window.title("➕ 添加假期 / Add Holiday")
            holiday_window.geometry("400x300")
            holiday_window.transient(self.activity_window)
            holiday_window.grab_set()
            
            # 假期信息输入
            main_frame = tk.Frame(holiday_window)
            main_frame.pack(fill="both", expand=True, padx=20, pady=20)
            
            # 日期选择
            date_frame = tk.Frame(main_frame)
            date_frame.pack(fill="x", pady=5)
            tk.Label(date_frame, text="📅 假期日期 / Holiday Date:").pack(anchor="w")
            holiday_date = DateEntry(date_frame, width=12, background='darkgreen',
                                   foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy')
            holiday_date.pack(anchor="w", pady=2)
            
            # 假期名称
            name_frame = tk.Frame(main_frame)
            name_frame.pack(fill="x", pady=5)
            tk.Label(name_frame, text="🏷️ 假期名称 / Holiday Name:").pack(anchor="w")
            holiday_name = ttk.Entry(name_frame, width=30)
            holiday_name.pack(fill="x", pady=2)
            
            # 假期描述
            desc_frame = tk.Frame(main_frame)
            desc_frame.pack(fill="both", expand=True, pady=5)
            tk.Label(desc_frame, text="📝 假期描述 / Holiday Description:").pack(anchor="w")
            holiday_desc = tk.Text(desc_frame, height=4, width=30, wrap=tk.WORD)
            holiday_desc.pack(fill="both", expand=True, pady=2)
            
            # 按钮
            button_frame = tk.Frame(main_frame)
            button_frame.pack(fill="x", pady=10)
            
            def save_holiday():
                try:
                    date_obj = holiday_date.get_date()
                    name = holiday_name.get().strip()
                    desc = holiday_desc.get("1.0", tk.END).strip()
                    
                    if not name:
                        tk.messagebox.showerror("错误", "请输入假期名称")
                        return
                    
                    # 这里可以将假期信息保存到文件或数据库
                    # 暂时显示确认消息
                    tk.messagebox.showinfo("成功", f"假期 '{name}' 已添加")
                    holiday_window.destroy()
                    
                    # 更新假期信息显示
                    self.update_holiday_info()
                    
                except Exception as e:
                    tk.messagebox.showerror("错误", f"添加假期失败: {e}")
            
            ttk.Button(button_frame, text="💾 保存 / Save", command=save_holiday).pack(side="left", padx=5)
            ttk.Button(button_frame, text="❌ 取消 / Cancel", command=holiday_window.destroy).pack(side="left", padx=5)
            
        except Exception as e:
            tk.messagebox.showerror("错误", f"打开假期添加窗口失败: {e}")
    
    def add_holiday_record_from_entries(self):
        """从输入框添加假期记录"""
        try:
            start_date = self.holiday_start_date_entry.get_date()
            end_date = self.holiday_end_date_entry.get_date()
            name = self.holiday_name_entry.get().strip()
            
            # 验证输入
            if not name:
                tk.messagebox.showerror("错误", "请输入假期名称")
                return
            
            if start_date > end_date:
                tk.messagebox.showerror("错误", "开始日期不能晚于结束日期")
                return
            
            # 计算假期长度
            duration_days = (end_date - start_date).days + 1
            
            # 创建假期记录
            current_db = self.activity_database.get()
            
            holiday_record = {
                'id': len(self.holiday_records[current_db]) + 1,
                'start_date': start_date.strftime('%Y-%m-%d'),
                'end_date': end_date.strftime('%Y-%m-%d'),
                'name': name,
                'description': '',
                'duration_days': duration_days,
                'database': current_db,
                'created_at': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            }
            
            # 添加到对应数据库的记录列表
            self.holiday_records[current_db].append(holiday_record)
            
            # 自動保存到 PromotionRecords.xlsx
            self.auto_save_promotion_records()
            
            # 刷新显示
            self.refresh_holiday_tree()
            
            # 清空输入框
            self.holiday_start_date_entry.set_date(datetime.now())
            self.holiday_end_date_entry.set_date(datetime.now())
            self.holiday_name_entry.delete(0, tk.END)
            
            tk.messagebox.showinfo("成功", f"假期记录 '{name}' 已添加")
            
        except Exception as e:
            tk.messagebox.showerror("错误", f"添加假期记录失败: {e}")

    def add_holiday_record(self):
        """添加假期记录（弹出窗口版本）"""
        try:
            # 创建假期记录添加窗口
            holiday_record_window = tk.Toplevel(self.activity_window)
            holiday_record_window.title("➕ 添加假期记录 / Add Holiday Record")
            holiday_record_window.geometry("500x400")
            holiday_record_window.transient(self.activity_window)
            holiday_record_window.grab_set()
            
            # 假期记录信息输入
            main_frame = tk.Frame(holiday_record_window)
            main_frame.pack(fill="both", expand=True, padx=20, pady=20)
            
            # 开始日期
            start_frame = tk.Frame(main_frame)
            start_frame.pack(fill="x", pady=5)
            tk.Label(start_frame, text="📅 假期开始日期 / Holiday Start Date:", font=('Arial', 9, 'bold')).pack(anchor="w")
            holiday_start_date = DateEntry(start_frame, width=12, background='darkgreen',
                                        foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy')
            holiday_start_date.pack(anchor="w", pady=2)
            
            # 结束日期
            end_frame = tk.Frame(main_frame)
            end_frame.pack(fill="x", pady=5)
            tk.Label(end_frame, text="📅 假期结束日期 / Holiday End Date:", font=('Arial', 9, 'bold')).pack(anchor="w")
            holiday_end_date = DateEntry(end_frame, width=12, background='darkgreen',
                                      foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy')
            holiday_end_date.pack(anchor="w", pady=2)
            
            # 假期名称
            name_frame = tk.Frame(main_frame)
            name_frame.pack(fill="x", pady=5)
            tk.Label(name_frame, text="🏷️ 假期名称 / Holiday Name:", font=('Arial', 9, 'bold')).pack(anchor="w")
            holiday_name = ttk.Entry(name_frame, width=40)
            holiday_name.pack(fill="x", pady=2)
            
            # 假期描述
            desc_frame = tk.Frame(main_frame)
            desc_frame.pack(fill="both", expand=True, pady=5)
            tk.Label(desc_frame, text="📝 假期描述 / Holiday Description:", font=('Arial', 9, 'bold')).pack(anchor="w")
            holiday_desc = tk.Text(desc_frame, height=6, width=40, wrap=tk.WORD)
            holiday_desc.pack(fill="both", expand=True, pady=2)
            
            # 按钮
            button_frame = tk.Frame(main_frame)
            button_frame.pack(fill="x", pady=10)
            
            def save_holiday_record():
                try:
                    start_date = holiday_start_date.get_date()
                    end_date = holiday_end_date.get_date()
                    name = holiday_name.get().strip()
                    desc = holiday_desc.get("1.0", tk.END).strip()
                    
                    # 验证输入
                    if not name:
                        tk.messagebox.showerror("错误", "请输入假期名称")
                        return
                    
                    if start_date > end_date:
                        tk.messagebox.showerror("错误", "开始日期不能晚于结束日期")
                        return
                    
                    # 计算假期长度
                    duration_days = (end_date - start_date).days + 1
                    
                    # 创建假期记录
                    # 获取当前选中的数据库
                    current_db = self.activity_database.get()
                    
                    holiday_record = {
                        'id': len(self.holiday_records[current_db]) + 1,
                        'start_date': start_date.strftime('%Y-%m-%d'),
                        'end_date': end_date.strftime('%Y-%m-%d'),
                        'name': name,
                        'description': desc,
                        'duration_days': duration_days,
                        'database': current_db,
                        'created_at': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                    }
                    
                    # 添加到对应数据库的记录列表
                    self.holiday_records[current_db].append(holiday_record)
                    
                    # 自動保存到 PromotionRecords.xlsx
                    self.auto_save_promotion_records()
                    
                    # 刷新显示
                    self.refresh_holiday_tree()
                    
                    tk.messagebox.showinfo("成功", f"假期记录 '{name}' 已添加")
                    holiday_record_window.destroy()
                    
                except Exception as e:
                    tk.messagebox.showerror("错误", f"添加假期记录失败: {e}")
            
            ttk.Button(button_frame, text="💾 保存 / Save", command=save_holiday_record).pack(side="left", padx=5)
            ttk.Button(button_frame, text="❌ 取消 / Cancel", command=holiday_record_window.destroy).pack(side="left", padx=5)
            
        except Exception as e:
            tk.messagebox.showerror("错误", f"打开假期记录添加窗口失败: {e}")
    
    def delete_holiday_record(self):
        """删除假期记录"""
        try:
            # 获取选中的记录
            selected_items = self.holiday_tree.selection()
            if not selected_items:
                tk.messagebox.showwarning("提示", "请先选择要删除的假期记录")
                return
            
            # 确认删除
            if tk.messagebox.askyesno("确认删除", "确定要删除选中的假期记录吗？"):
                # 获取当前选中的数据库
                current_db = self.activity_database.get()
                
                # 删除选中的记录
                for item in selected_items:
                    item_values = self.holiday_tree.item(item, 'values')
                    holiday_name = item_values[2]  # 假期名称在第3列
                    
                    # 从对应数据库的记录列表中删除
                    if current_db in self.holiday_records:
                        self.holiday_records[current_db] = [record for record in self.holiday_records[current_db] 
                                                           if record['name'] != holiday_name]
                
                # 刷新显示
                self.refresh_holiday_tree()
                tk.messagebox.showinfo("成功", "假期记录已删除")
                
        except Exception as e:
            tk.messagebox.showerror("错误", f"删除假期记录失败: {e}")
    
    def save_holiday_records(self):
        """保存假期记录到文件"""
        try:
            import json
            import os
            
            # 创建数据目录
            data_dir = "activity_data"
            if not os.path.exists(data_dir):
                os.makedirs(data_dir)
            
            # 保存到JSON文件
            holiday_file = os.path.join(data_dir, "holiday_records.json")
            with open(holiday_file, 'w', encoding='utf-8') as f:
                json.dump(self.holiday_records, f, ensure_ascii=False, indent=2)
            
            tk.messagebox.showinfo("成功", f"假期记录已保存到: {holiday_file}")
            
        except Exception as e:
            tk.messagebox.showerror("错误", f"保存假期记录失败: {e}")
    
    def load_holiday_records(self):
        """从文件加载假期记录"""
        try:
            import json
            import os
            
            holiday_file = os.path.join("activity_data", "holiday_records.json")
            if os.path.exists(holiday_file):
                with open(holiday_file, 'r', encoding='utf-8') as f:
                    loaded_records = json.load(f)
                    
                # 如果是旧格式（列表），转换为新格式（按数据库分类）
                if isinstance(loaded_records, list):
                    self.holiday_records = {
                        'GOGO': loaded_records,
                        'Express': [],
                        'PLUS': []
                    }
                else:
                    self.holiday_records = loaded_records
            else:
                self.holiday_records = {
                    'GOGO': [],
                    'Express': [],
                    'PLUS': []
                }
                
        except Exception as e:
            print(f"加载假期记录失败: {e}")
            self.holiday_records = {
                'GOGO': [],
                'Express': [],
                'PLUS': []
            }
    
    def on_activity_type_change(self):
        """处理活动类型切换"""
        try:
            activity_type = self.activity_type.get()
            
            # 更新活動類型按鈕視覺狀態
            self.update_activity_type_button_styles()
            
            if activity_type == "daily":
                # 显示每日活动日期选择
                self.daily_date_frame.pack(fill="x")
                self.weekly_selection_frame.pack_forget()
            else:
                # 显示周期性活动选择
                self.weekly_selection_frame.pack(fill="x")
                self.daily_date_frame.pack_forget()
                
        except Exception as e:
            print(f"切换活动类型失败: {e}")
    
    def select_database_option(self, option_key):
        """選擇數據庫選項 - 新的大按鍵選擇方式並直接連接"""
        try:
            self.selected_db.set(option_key)
            print(f"🔄 切換到數據庫選項: {option_key}")
            print(f"DEBUG: selected_db is now set to: {self.selected_db.get()}")
            
            # 更新按鍵狀態
            self.update_database_button_style()
            
            # 自動連接數據庫（移除原來的連接按鍵功能）
            self.connect_database()
            
            # 如果右側面板有活動提醒文本，更新提示
            if hasattr(self, 'activity_alert_text'):
                current_info = self.DATABASE_OPTIONS.get(option_key, {})
                cn_name = current_info.get('cn', option_key)
                print(f"📊 已切換到 {cn_name} 數據庫")
                
                # 更新活动提醒显示
                print(f"DEBUG: Updating activity alerts after database switch to {option_key}")
                self.update_activity_alerts()
                
        except Exception as e:
            print(f"❌ 切換數據庫失敗: {e}")
    
    def update_database_button_style(self):
        """更新數據庫按鍵的視覺狀態"""
        try:
            if not hasattr(self, 'db_options') or not self.db_options:
                return
                
            current_option = self.selected_db.get()
            current_info = self.DATABASE_OPTIONS.get(current_option, {})
            
            # 更新所有按鍵狀態
            for key, btn in self.db_options.items():
                option_info = self.DATABASE_OPTIONS[key]
                
                if key == current_option:
                    # 當前選中的按鍵 - 高亮顯示
                    btn.configure(bg=option_info['selected_color'], fg='white', relief='ridge', bd=3)
                else:
                    # 未選中的按鍵 - 正常顯示
                    btn.configure(bg=option_info['color'], fg='white', relief='solid', bd=2)
                    
            print(f"✅ 數據庫按鍵狀態已更新: {current_option}")
            
        except Exception as e:
            print(f"❌ 更新數據庫按鍵狀態失敗: {e}")
    
    def update_database_button_styles(self):
        """更新數據庫按鈕的視覺狀態"""
        try:
            if not hasattr(self, 'db_buttons'):
                return
                
            current_db = self.activity_database.get()
            
            # 數據庫選項配置
            db_colors = {
                "GOGO": "#27ae60",
                "Express": "#3498db", 
                "PLUS": "#f39c12",
                "All": "#9b59b6"
            }
            
            for value, btn in self.db_buttons.items():
                if value == current_db:
                    # 選中狀態：深色背景，白色文字，凹陷效果
                    btn.configure(bg=db_colors[value], fg='white', relief='sunken', bd=3,
                                 font=('Microsoft YaHei UI', 9, 'bold'))
                else:
                    # 未選中狀態：白色背景，彩色文字，凸起效果
                    btn.configure(bg='white', fg=db_colors[value], relief='raised', bd=2,
                                 font=('Microsoft YaHei UI', 9, 'normal'))
                    
        except Exception as e:
            print(f"更新數據庫按鈕樣式失敗: {e}")
    
    def update_activity_type_button_styles(self):
        """更新活動類型按鈕的視覺狀態"""
        try:
            if not hasattr(self, 'type_buttons'):
                return
                
            current_type = self.activity_type.get()
            
            # 活動類型顏色配置
            type_colors = {
                "daily": "#e74c3c",
                "weekly": "#f39c12"
            }
            
            for value, btn in self.type_buttons.items():
                if value == current_type:
                    # 選中狀態：深色背景，白色文字，凹陷效果
                    btn.configure(bg=type_colors[value], fg='white', relief='sunken', bd=3,
                                 font=('Microsoft YaHei UI', 9, 'bold'))
                else:
                    # 未選中狀態：白色背景，彩色文字，凸起效果
                    btn.configure(bg='white', fg=type_colors[value], relief='raised', bd=2,
                                 font=('Microsoft YaHei UI', 9, 'normal'))
                    
        except Exception as e:
            print(f"更新活動類型按鈕樣式失敗: {e}")
    
    def connect_to_activity_database(self, database_name):
        """连接到指定的数据库"""
        try:
            # 数据库名称映射
            db_mapping = {
                'GOGO': 'sushi_gogo_pos_live',
                'Express': 'sushi_express_pos_live', 
                'PLUS': 'sushi_plus_pos_live'
            }
            
            full_db_name = db_mapping.get(database_name)
            if not full_db_name:
                print(f"❌ 未知的数据库名称: {database_name}")
                return False
            
            # 如果已经连接到目标数据库，直接返回成功
            if hasattr(self.db_manager, 'current_database') and self.db_manager.current_database == full_db_name:
                print(f"✅ 已连接到数据库: {database_name}")
                return True
            
            # 断开当前连接
            if hasattr(self.db_manager, 'disconnect'):
                self.db_manager.disconnect()
            
            # 连接到新数据库
            success = self.db_manager.connect(full_db_name)
            
            if success:
                print(f"✅ 成功连接到数据库: {database_name} ({full_db_name})")
                return True
            else:
                print(f"❌ 连接数据库失败: {database_name} ({full_db_name})")
                return False
                
        except Exception as e:
            print(f"❌ 连接数据库时出错: {e}")
            return False
    
    def initial_database_connection(self):
        """活动记录窗口打开时的初始数据库连接 - 强化版本确保门市产品数据正常显示"""
        try:
            if hasattr(self, 'activity_database'):
                current_db = self.activity_database.get()
                print(f"🔗 活动记录窗口初始化 - 连接到数据库: {current_db}")
                
                # 连接到默认数据库
                success = self.connect_to_activity_database(current_db)
                
                if success:
                    print(f"✅ 数据库连接成功，开始刷新所有数据...")
                    
                    # 延迟刷新确保连接稳定，强制刷新门市和产品列表
                    self.activity_window.after(200, self.force_refresh_all_data)
                    self.show_activity_message(f"✅ 已连接到数据库: {current_db}")
                else:
                    self.show_activity_message(f"❌ 连接数据库失败: {current_db}")
                    
        except Exception as e:
            print(f"❌ 初始数据库连接失败: {e}")
            if hasattr(self, 'activity_window') and self.activity_window.winfo_exists():
                self.show_activity_message(f"❌ 初始连接失败: {e}")
    
    def force_refresh_all_data(self):
        """强制刷新所有活动记录数据"""
        try:
            print("🔄 强制刷新所有活动记录数据...")
            
            # 强制刷新门市列表
            self.refresh_activity_outlets()
            
            # 强制刷新产品列表  
            self.refresh_activity_products()
            
            # 强制刷新右侧假期面板
            if hasattr(self, 'holiday_tree'):
                self.refresh_holiday_tree()
            
            print("✅ 所有数据刷新完成")
            
        except Exception as e:
            print(f"❌ 强制刷新数据失败: {e}")
            self.show_activity_message(f"❌ 强制刷新失败: {e}")
    
    def refresh_activity_outlets(self):
        """刷新活动门市选项 - 增强版本，确保像主页面一样正常显示"""
        try:
            print("🔄 开始刷新门市选项...")
            
            # 检查数据库连接
            if not hasattr(self, 'db_manager') or not self.db_manager.connection:
                print("⚠️ 数据库未连接，无法获取门市数据")
                self.show_activity_message("⚠️ 数据库未连接，无法获取门市数据")
                return
            
            # 检查控制器是否存在
            if not hasattr(self, 'activity_outlets'):
                print("⚠️ 门市控制器未初始化")
                return
            
            print("🔍 正在获取门市数据...")
            # 获取门市列表
            outlets = self.db_manager.get_outlets()
            
            if outlets and len(outlets) > 0:
                # 更新门市选项
                self.activity_outlets.set_values(outlets)
                self.available_outlets = outlets
                print(f"✅ 已加载 {len(outlets)} 个门市选项")
                print(f"门市列表: {outlets[:5]}...")  # 显示前5个门市
                
                # 显示成功消息
                self.show_activity_message(f"✅ 已加载 {len(outlets)} 个门市选项")
            else:
                print("⚠️ 未获取到门市数据")
                self.show_activity_message("⚠️ 未获取到门市数据")
                
        except Exception as e:
            print(f"❌ 刷新门市列表失败: {e}")
            self.show_activity_message(f"❌ 获取门市数据失败: {e}")

    def show_activity_message(self, message):
        """在活动记录窗口中显示消息"""
        try:
            if hasattr(self, 'activity_window') and self.activity_window.winfo_exists():
                # 在窗口标题中显示消息
                original_title = "📝 活动记录管理 / Activity Records Management"
                self.activity_window.title(f"{original_title} - {message}")
                
                # 3秒后恢复原标题
                def restore_title():
                    if hasattr(self, 'activity_window') and self.activity_window.winfo_exists():
                        self.activity_window.title(original_title)
                
                self.activity_window.after(3000, restore_title)
                
        except Exception as e:
            print(f"显示活动消息失败: {e}")

    def on_database_change(self):
        """处理数据库切换 - 增强版本，确保自动连接和刷新"""
        try:
            current_db = self.activity_database.get()
            print(f"🔄 切换到数据库: {current_db}")
            
            # 更新數據庫按鈕視覺狀態
            self.update_database_button_styles()
            
            # 确保活动记录字典存在并包含所有数据库
            if not hasattr(self, 'activity_records'):
                self.activity_records = {
                    'GOGO': [],
                    'Express': [],
                    'PLUS': [],
                    'All': []
                }
            
            # 确保当前数据库的活动记录键存在
            if current_db not in self.activity_records:
                self.activity_records[current_db] = []
                print(f"🔧 为数据库 '{current_db}' 创建了新的活动记录列表")
            
            # 自动连接数据库
            success = self.connect_to_activity_database(current_db)
            
            if success:
                print(f"✅ 数据库连接成功，开始刷新数据...")
                
                # 延迟刷新，确保数据库连接稳定
                self.activity_window.after(100, self.refresh_all_activity_data)
                
                # 更新活動提醒
                try:
                    self.update_activity_alerts()
                except:
                    pass  # 如果主界面不存在，忽略錯誤
                
                # 显示成功消息
                self.show_activity_message(f"✅ 已连接到数据库: {current_db}")
                
                # 立即刷新活动记录树
                self.refresh_activity_tree()
            else:
                # 显示错误消息
                self.show_activity_message(f"❌ 连接数据库失败: {current_db}")
            
        except Exception as e:
            print(f"切换数据库失败: {e}")
            import traceback
            print(f"详细错误信息: {traceback.format_exc()}")
            self.show_activity_message(f"❌ 切换数据库时出错: {e}")
    
    def refresh_all_activity_data(self):
        """刷新所有活动记录相关数据"""
        try:
            # 刷新活动记录树显示
            if hasattr(self, 'activity_tree'):
                self.refresh_activity_tree()
            
            # 刷新假期记录树显示
            if hasattr(self, 'holiday_records') and hasattr(self, 'holiday_tree'):
                self.refresh_holiday_tree()
            
            # 自动刷新产品列表和门市列表
            self.refresh_activity_products()
            self.refresh_activity_outlets()
            
            print("✅ 所有活动记录数据已刷新")
            
        except Exception as e:
            print(f"刷新活动记录数据失败: {e}")
            self.show_activity_message(f"❌ 刷新数据失败: {e}")
    
    def select_all_outlets(self):
        """全选门市"""
        try:
            if hasattr(self, 'available_outlets') and self.available_outlets:
                self.activity_outlets.set_selected(self.available_outlets)
                tk.messagebox.showinfo("成功", f"已选择全部 {len(self.available_outlets)} 个门市")
            else:
                tk.messagebox.showwarning("提示", "暂无可用门市数据，请先连接数据库")
        except Exception as e:
            tk.messagebox.showerror("错误", f"全选门市失败: {e}")
    
    def select_all_parts(self):
        """全选部分"""
        try:
            if hasattr(self, 'activity_parts'):
                parts_values = ['DI', 'TA', 'Delivery', 'Food Panda', 'Grab Food', 'Deliveroo', 'All']
                self.activity_parts.set_selected(parts_values)
                tk.messagebox.showinfo("成功", f"已选择全部 {len(parts_values)} 个部分")
            else:
                tk.messagebox.showwarning("提示", "部分控制器未初始化")
        except Exception as e:
            tk.messagebox.showerror("错误", f"全选部分失败: {e}")
    
    def select_all_products(self):
        """全选产品"""
        try:
            if hasattr(self, 'activity_products') and hasattr(self, 'available_products') and self.available_products:
                self.activity_products.set_selected(self.available_products)
                tk.messagebox.showinfo("成功", f"已选择全部 {len(self.available_products)} 个产品")
            else:
                tk.messagebox.showwarning("提示", "暂无可用产品数据，请先连接数据库")
        except Exception as e:
            tk.messagebox.showerror("错误", f"全选产品失败: {e}")
    
    def select_all_payment_methods(self):
        """全选支付方式"""
        try:
            if hasattr(self, 'activity_payment'):
                payment_values = ['VISA', 'MASTER', 'NETS', 'AMEX', 'UnionPay', 'DBS MAX', 'CDC Voucher', 'Mall Voucher', 
                                'GRAB FOOD', 'FOOD PANDA', 'DELIVEROO', 'SE APP', 'WASTAGE']
                self.activity_payment.set_selected(payment_values)
                tk.messagebox.showinfo("成功", f"已选择全部 {len(payment_values)} 个支付方式")
            else:
                tk.messagebox.showwarning("提示", "支付方式控制器未初始化")
        except Exception as e:
            tk.messagebox.showerror("错误", f"全选支付方式失败: {e}")
    
    def update_activity_products_from_records(self):
        """從已導入的活動記錄中更新產品選擇器"""
        try:
            if not hasattr(self, 'activity_products'):
                print("⚠️ 產品選擇器未初始化")
                return
            
            print("🔍 開始從活動記錄中收集產品資料...")
            print(f"🔍 當前 activity_records 狀態: {hasattr(self, 'activity_records')}")
            
            # 檢查 activity_records 是否存在
            if not hasattr(self, 'activity_records'):
                print("⚠️ activity_records 不存在，嘗試從數據庫獲取產品")
                self.refresh_activity_products()
                return
            
            # 收集所有活動記錄中的產品
            all_products = set()
            total_records = 0
            
            for db_name in ['GOGO', 'Express', 'PLUS']:
                records = self.activity_records.get(db_name, [])
                print(f"📋 {db_name} 數據庫有 {len(records)} 條活動記錄")
                total_records += len(records)
                
                for i, record in enumerate(records):
                    products = record.get('products', [])
                    print(f"  記錄 {i+1}: 產品資料 = {products} (類型: {type(products)})")
                    
                    if products:
                        # 處理產品列表（可能是字符串或列表）
                        if isinstance(products, str):
                            if products.strip():
                                product_list = [p.strip() for p in products.split(',') if p.strip()]
                                all_products.update(product_list)
                                print(f"    字符串格式產品: {product_list}")
                        elif isinstance(products, list):
                            product_list = [p.strip() for p in products if p.strip()]
                            all_products.update(product_list)
                            print(f"    列表格式產品: {product_list}")
            
            print(f"📊 總共處理了 {total_records} 條活動記錄")
            print(f"📊 收集到 {len(all_products)} 個唯一產品")
            
            if all_products:
                # 轉換為排序的列表
                products_list = sorted(list(all_products))
                print(f"✅ 從活動記錄中收集到 {len(products_list)} 個產品")
                print(f"完整產品列表: {products_list}")
                
                # 更新產品選擇器
                self.activity_products.set_values(products_list)
                
                # 保存到可用產品列表
                self.available_products = products_list
                
                # 強制刷新顯示
                self.activity_products.update_display()
                
                print(f"✅ 產品選擇器已更新，包含 {len(products_list)} 個產品")
                print(f"✅ 產品選擇器當前顯示: {self.activity_products.combo.get()}")
            else:
                print("ℹ️ 活動記錄中沒有找到產品資料，嘗試從數據庫獲取")
                # 如果沒有產品資料，嘗試從數據庫獲取
                self.refresh_activity_products()
                
        except Exception as e:
            print(f"❌ 從活動記錄更新產品選擇器失敗: {e}")
            import traceback
            print(f"詳細錯誤: {traceback.format_exc()}")
            # 失敗時嘗試從數據庫獲取產品
            try:
                self.refresh_activity_products()
            except Exception as e2:
                print(f"❌ 從數據庫獲取產品也失敗: {e2}")
    
    def force_update_product_selector(self):
        """強制更新產品選擇器"""
        try:
            print("🔄 強制更新產品選擇器...")
            
            if not hasattr(self, 'activity_products'):
                print("⚠️ 產品選擇器未初始化")
                return
            
            # 收集所有產品
            all_products = set()
            
            # 從活動記錄中收集產品
            for db_name in ['GOGO', 'Express', 'PLUS']:
                records = self.activity_records.get(db_name, [])
                for record in records:
                    products = record.get('products', [])
                    if products:
                        if isinstance(products, str):
                            product_list = [p.strip() for p in products.split(',') if p.strip()]
                            all_products.update(product_list)
                        elif isinstance(products, list):
                            all_products.update([p.strip() for p in products if p.strip()])
            
            # 添加默認產品
            default_products = [
                'Salmon Sashimi (13pcs)', 'Salmon Sashimi (8pcs)', 'Salmon Sushi 10pcs', 
                'Salmon Roll', 'Salmon Nigiri', 'Tuna Sashimi (10pcs)', 'Eel Roll', 
                'California Roll', 'Tempura Roll', 'Dragon Roll'
            ]
            all_products.update(default_products)
            
            if all_products:
                products_list = sorted(list(all_products))
                print(f"✅ 強制更新收集到 {len(products_list)} 個產品")
                
                # 強制更新產品選擇器
                self.activity_products.set_values(products_list)
                self.activity_products.update_display()
                
                # 保存到可用產品列表
                self.available_products = products_list
                
                print(f"✅ 產品選擇器強制更新完成，當前顯示: {self.activity_products.combo.get()}")
            else:
                print("⚠️ 沒有找到任何產品數據")
                
        except Exception as e:
            print(f"❌ 強制更新產品選擇器失敗: {e}")
            import traceback
            print(f"詳細錯誤: {traceback.format_exc()}")
    
    def refresh_activity_products(self):
        """刷新活动产品选项 - 增强版本，确保像主页面一样正常显示"""
        try:
            print("🔄 开始刷新产品选项...")
            
            # 检查数据库连接
            if not hasattr(self, 'db_manager') or not self.db_manager.connection:
                print("⚠️ 数据库未连接，无法获取产品数据")
                self.show_activity_message("⚠️ 数据库未连接，无法获取产品数据")
                return
            
            # 检查控制器是否存在
            if not hasattr(self, 'activity_products'):
                print("⚠️ 产品控制器未初始化")
                return
            
            print("🔍 正在获取产品数据...")
            
            # 获取当前选中的数据库
            current_db = self.get_current_database()
            
            # 确保连接到对应的数据库
            if not self.connect_to_activity_database(current_db):
                self.show_activity_message(f"❌ 无法连接到 {current_db} 数据库")
                return
            
            # 优先尝试从已导出的产品数据中获取
            export_dir = "new_staged_export_specific_data"
            
            # 将完整数据库名称转换为简化名称（用于文件查找）
            db_name_mapping = {
                'sushi_gogo_pos_live': 'GOGO',
                'sushi_express_pos_live': 'Express', 
                'sushi_plus_pos_live': 'PLUS'
            }
            simplified_db_name = db_name_mapping.get(current_db, current_db)
            
            product_data_file = f"{export_dir}/{simplified_db_name}_daily_product_data.xlsx"
            
            if os.path.exists(product_data_file):
                print(f"📁 尝试从已导出产品数据文件获取产品列表: {product_data_file}")
                try:
                    import pandas as pd
                    df = pd.read_excel(product_data_file)
                    
                    if 'item_name' in df.columns:
                        products = df['item_name'].dropna().unique().tolist()
                        products = [p for p in products if p and str(p).strip() and str(p) != 'NULL']
                        products.sort()
                        
                        if products:
                            print(f"✓ 从已导出产品数据获取到 {len(products)} 个产品")
                            self.activity_products.set_values(products)
                            self.available_products = products
                            tk.messagebox.showinfo("成功", f"从已导出数据加载 {len(products)} 个产品")
                            return
                except Exception as e:
                    print(f"✗ 从已导出产品数据获取失败: {e}，尝试数据库查询")
            
            # 使用专门的SQL查询获取所有唯一产品名称
            cursor = self.db_manager.connection.cursor()
            
            # 查询所有唯一的产品名称
            query = """
            SELECT DISTINCT item_name 
            FROM pos_sales_dtls 
            WHERE item_name IS NOT NULL 
            AND item_name != '' 
            AND item_name != 'NULL'
            ORDER BY item_name
            """
            
            cursor.execute(query)
            results = cursor.fetchall()
            cursor.close()
            
            if results:
                # 提取产品名称
                products = [row[0] for row in results if row[0] and row[0].strip()]
                products = list(set(products))  # 去重
                products.sort()  # 排序
                
                # 更新产品选项
                self.activity_products.set_values(products)
                print(f"✅ 已从 {current_db} 数据库加载 {len(products)} 个产品选项")
                print(f"产品列表: {products[:5]}...")  # 显示前5个产品
                
                # 保存到可用产品列表
                self.available_products = products
                
                # 显示成功消息
                self.show_activity_message(f"✅ 已加载 {len(products)} 个产品选项")
            else:
                print(f"⚠️ {current_db} 数据库中未找到产品数据")
                self.activity_products.set_values([])
                self.show_activity_message(f"⚠️ {current_db} 数据库中未找到产品数据")
                
        except Exception as e:
            print(f"❌ 从数据库获取产品列表失败: {e}")
            self.activity_products.set_values([])
            self.show_activity_message(f"❌ 获取产品数据失败: {e}")
    
    def analyze_selected_activity_from_main_window(self, activity_id):
        """從主窗口分析選中的活動記錄 - 與記錄查看窗口功能一致"""
        try:
            print(f"🔍 從主窗口分析活動記錄，ID: {activity_id}")
            
            # 找到對應的活動記錄
            current_db = self.get_current_database()
            print(f"📊 當前數據庫: {current_db}")
            
            records = self.activity_records.get(current_db, [])
            print(f"📊 找到 {len(records)} 條活動記錄")
            
            selected_record = None
            for record in records:
                print(f"🔍 檢查記錄: ID={record.get('id')}, 名稱={record.get('name', record.get('description', '未知'))}")
                
                # 嘗試多種ID匹配方式
                if record.get('id') == activity_id:
                    selected_record = record
                    print(f"✅ 匹配成功 (直接匹配): {selected_record}")
                    break
                elif str(record.get('id')) == str(activity_id):
                    selected_record = record
                    print(f"✅ 匹配成功 (字符串匹配): {selected_record}")
                    break
                elif int(record.get('id', 0)) == int(activity_id):
                    selected_record = record
                    print(f"✅ 匹配成功 (整數匹配): {selected_record}")
                    break

            if selected_record:
                print(f"✅ 找到活動記錄: {selected_record}")
                
                # 使用活动记录的信息进行分析
                current_db = selected_record.get('database', self.activity_database.get())
                print(f"📊 當前數據庫: {current_db}")

                # 连接数据库
                print("🔌 嘗試連接數據庫...")
                if not self.connect_to_activity_database(current_db):
                    print(f"❌ 無法連接到數據庫: {current_db}")
                    tk.messagebox.showerror("错误", f"无法连接到数据库: {current_db}")
                    return
                print("✅ 數據庫連接成功")

                # 创建分析结果窗口 - 美化版本
                print("🪟 創建分析結果窗口...")
                analysis_window = tk.Toplevel(self.root)
                print("✅ 分析窗口已創建")
                activity_name = selected_record.get('description', selected_record.get('name', f"活動 {activity_id}"))
                analysis_window.title(f"📊 {activity_name} - 活動業績分析 / Activity Performance Analysis")
                analysis_window.geometry("1200x800")
                analysis_window.configure(bg='#FFFFFF')
                
                # 設置窗口關閉協議 - 確保正確關閉
                def close_analysis_window():
                    try:
                        analysis_window.destroy()
                    except:
                        pass
                
                analysis_window.protocol("WM_DELETE_WINDOW", close_analysis_window)
                
                # 設置窗口圖標和樣式
                try:
                    analysis_window.iconbitmap("SELOGO22 - 01.ico")
                except:
                    pass

                # 標題區域
                title_frame = tk.Frame(analysis_window, bg='#2c3e50', height=80)
                title_frame.pack(fill="x")
                title_frame.pack_propagate(False)
                
                title_label = tk.Label(title_frame, 
                                     text=f"📊 {activity_name}",
                                     font=('Microsoft YaHei UI', 16, 'bold'),
                                     fg='white', bg='#2c3e50')
                title_label.pack(side="left", padx=20, pady=20)
                
                subtitle_label = tk.Label(title_frame, 
                                        text="活動業績分析 / Activity Performance Analysis",
                                        font=('Arial', 11),
                                        fg='#bdc3c7', bg='#2c3e50')
                subtitle_label.pack(side="left", padx=(0, 20), pady=20)

                # 主內容區域
                content_frame = tk.Frame(analysis_window, bg='#FFFFFF')
                content_frame.pack(fill="both", expand=True, padx=20, pady=20)

                # 创建滚动条和文本框 - 美化版本
                text_container = tk.Frame(content_frame, bg='#ffffff', relief='solid', bd=1)
                text_container.pack(fill="both", expand=True)
                
                result_text = tk.Text(text_container, 
                                    height=30, width=100, 
                                    wrap=tk.WORD, 
                                    font=('Consolas', 10),
                                    bg='#ffffff',
                                    fg='#2c3e50',
                                    selectbackground='#3498db',
                                    selectforeground='white',
                                    insertbackground='#2c3e50',
                                    relief='flat',
                                    padx=15, pady=15)
                
                result_scrollbar = ttk.Scrollbar(text_container, orient="vertical", command=result_text.yview)
                result_text.configure(yscrollcommand=result_scrollbar.set)

                result_text.pack(side="left", fill="both", expand=True)
                result_scrollbar.pack(side="right", fill="y")
                
                # 添加底部按鈕區域
                button_frame = tk.Frame(analysis_window, bg='#FFFFFF', height=60)
                button_frame.pack(fill="x", padx=20, pady=(0, 20))
                button_frame.pack_propagate(False)
                
                # 關閉按鈕
                close_btn = tk.Button(button_frame, 
                                    text="❌ 關閉 / Close",
                                    command=close_analysis_window,
                                    font=('Arial', 10, 'bold'),
                                    bg='#e74c3c', fg='white',
                                    relief='flat', bd=0,
                                    padx=20, pady=8,
                                    cursor='hand2')
                close_btn.pack(side="right", pady=15)
                
                # 導出按鈕
                export_btn = tk.Button(button_frame, 
                                     text="📄 導出報告 / Export Report",
                                     command=lambda: self.export_analysis_report(result_text.get(1.0, tk.END)),
                                     font=('Arial', 10, 'bold'),
                                     bg='#27ae60', fg='white',
                                     relief='flat', bd=0,
                                     padx=20, pady=8,
                                     cursor='hand2')
                export_btn.pack(side="right", padx=(0, 10), pady=15)

                # 调用分析和执行分析
                outlet_filters = selected_record.get('outlets', [])
                product_filters = selected_record.get('products', [])
                payment_filters = selected_record.get('payment_methods', [])  # 获取支付方式筛选
                date_from_str = selected_record.get('date_from', '')
                date_to_str = selected_record.get('date_to', '')
                
                # 初始化星期筛选变量
                selected_weekdays = selected_record.get('weekdays', [])

                # 如果是周期性活动，需要计算实际日期
                if selected_record.get('type') == 'weekly':
                    from datetime import datetime, timedelta
                    weekday_names = ['星期一', '星期二', '星期三', '星期四', '星期五', '星期六', '星期日']
                    selected_weekdays = selected_record.get('weekdays', [])

                    # 找到所有符合的日期
                    start_date = datetime.strptime(date_from_str, '%Y-%m-%d')
                    end_date = datetime.strptime(date_to_str, '%Y-%m-%d')
                    all_target_dates = []

                    current = start_date
                    while current <= end_date:
                        weekday_name = weekday_names[current.weekday()]
                        if weekday_name in selected_weekdays:
                            all_target_dates.append(current)
                        current += timedelta(days=1)

                    # 合成日期范围
                    if all_target_dates:
                        date_from_str = min(all_target_dates).strftime('%Y-%m-%d')
                        date_to_str = max(all_target_dates).strftime('%Y-%m-%d')

                # 调用分析
                print(f"🔍 開始分析活動: {activity_name}")
                print(f"📊 分析參數:")
                print(f"   - 日期範圍: {date_from_str} 到 {date_to_str}")
                print(f"   - 門市: {outlet_filters}")
                print(f"   - 產品: {product_filters}")
                print(f"   - 支付方式: {payment_filters}")
                print(f"   - 星期: {selected_weekdays}")
                print(f"   - 數據庫: {current_db}")
                
                try:
                    print("🚀 準備調用 perform_activity_analysis...")
                    print(f"📊 調用參數:")
                    print(f"   - result_text: {type(result_text)}")
                    print(f"   - date_from_str: {date_from_str}")
                    print(f"   - date_to_str: {date_to_str}")
                    print(f"   - outlet_filters: {outlet_filters}")
                    print(f"   - product_filters: {product_filters}")
                    print(f"   - current_db: {current_db}")
                    print(f"   - payment_filters: {payment_filters}")
                    print(f"   - selected_weekdays: {selected_weekdays}")
                    
                    # 先插入一些測試內容確保窗口有顯示
                    result_text.insert(tk.END, "🔍 正在執行活動分析...\n", "header")
                    result_text.insert(tk.END, f"📊 活動名稱: {activity_name}\n", "info")
                    result_text.insert(tk.END, f"📊 日期範圍: {date_from_str} 到 {date_to_str}\n", "info")
                    result_text.insert(tk.END, f"📊 門市數量: {len(outlet_filters) if outlet_filters else '全部'}\n", "info")
                    result_text.insert(tk.END, f"📊 產品數量: {len(product_filters) if product_filters else '全部'}\n", "info")
                    result_text.insert(tk.END, f"📊 支付方式: {len(payment_filters) if payment_filters else '全部'}\n", "info")
                    result_text.insert(tk.END, f"📊 星期篩選: {selected_weekdays if selected_weekdays else '全部'}\n", "info")
                    result_text.insert(tk.END, f"📊 數據庫: {current_db}\n\n", "info")
                    result_text.update()
                    
                    self.perform_activity_analysis(result_text, date_from_str, date_to_str, outlet_filters, product_filters, current_db, payment_filters, selected_weekdays, False, None, None, False)
                    print("✅ 分析完成")
                except Exception as e:
                    print(f"❌ 分析過程中出現錯誤: {e}")
                    import traceback
                    error_details = traceback.format_exc()
                    print(f"詳細錯誤: {error_details}")
                    result_text.insert(tk.END, f"❌ 分析過程中出現錯誤: {e}\n", "error")
                    result_text.insert(tk.END, f"🔍 錯誤詳情: {error_details}\n", "error")
                
                result_text.config(state=tk.DISABLED)

                # 不關閉活動記錄窗口，讓用戶可以繼續選擇其他活動進行分析
            else:
                print(f"❌ 未找到活動記錄，活動ID: {activity_id}")
                print(f"📊 可用記錄ID: {[record.get('id') for record in records]}")
                tk.messagebox.showerror("錯誤", f"未找到活動記錄，活動ID: {activity_id}")
                
        except Exception as e:
            print(f"❌ 從主窗口分析活動記錄失敗: {e}")
            import traceback
            print(f"詳細錯誤: {traceback.format_exc()}")
            tk.messagebox.showerror("錯誤", f"分析活動記錄失敗: {e}")
    
    def analyze_activity(self):
        """分析活动期间的业绩数据 - 支持分析选中的活动记录"""
        try:
            print("🔍 主窗口分析按鈕被點擊")
            
            # 首先檢查是否有選中的活動記錄
            if hasattr(self, 'activity_tree'):
                selection = self.activity_tree.selection()
                print(f"📊 主窗口活動記錄選中狀態: {selection}")
                if selection:
                    print("✅ 有選中的活動記錄，使用選中記錄進行分析")
                    # 有選中的活動記錄，使用選中記錄的信息進行分析
                    item = self.activity_tree.item(selection[0])
                    values = item['values']
                    activity_id = values[0]
                    print(f"📊 選中的活動ID: {activity_id}")
                    
                    # 使用與記錄查看窗口相同的分析邏輯
                    self.analyze_selected_activity_from_main_window(activity_id)
                    return
                else:
                    print("⚠️ 沒有選中的活動記錄")
                    tk.messagebox.showwarning("提示", "請先在活動記錄列表中選擇一個活動記錄，然後再點擊分析按鈕")
                    return
                    
                    # 找到對應的活動記錄
                    current_db = self.get_current_database()
                    records = self.activity_records.get(current_db, [])
                    
                    selected_record = None
                    for record in records:
                        if record['id'] == activity_id:
                            selected_record = record
                            break
                    
                    if selected_record:
                        # 使用選中記錄的信息
                        date_from_str = selected_record.get('date_from', '')
                        date_to_str = selected_record.get('date_to', '')
                        outlets = selected_record.get('outlets', [])
                        products = selected_record.get('products', [])
                        payment_methods = selected_record.get('payment_methods', [])
                        database = selected_record.get('database', current_db)
                        
                        # 連接到正確的數據庫
                        if not self.connect_to_activity_database(database):
                            tk.messagebox.showerror("错误", f"无法连接到数据库: {database}")
                            return
                        
                        # 創建分析結果窗口 - 美化版本
                        analysis_window = tk.Toplevel(self.root)
                        activity_name = selected_record.get('name', f"活動 {activity_id}")
                        analysis_window.title(f"📊 {activity_name} - 活動業績分析 / Activity Performance Analysis")
                        analysis_window.geometry("1200x800")
                        analysis_window.configure(bg='#FFFFFF')
                        
                        # 設置窗口關閉協議 - 確保正確關閉
                        def close_analysis_window():
                            try:
                                analysis_window.destroy()
                            except:
                                pass
                        
                        analysis_window.protocol("WM_DELETE_WINDOW", close_analysis_window)
                        
                        # 設置窗口圖標和樣式
                        try:
                            analysis_window.iconbitmap("SELOGO22 - 01.ico")
                        except:
                            pass

                        # 標題區域
                        title_frame = tk.Frame(analysis_window, bg='#2c3e50', height=80)
                        title_frame.pack(fill="x")
                        title_frame.pack_propagate(False)
                        
                        title_label = tk.Label(title_frame, 
                                             text=f"📊 {activity_name}",
                                             font=('Microsoft YaHei UI', 16, 'bold'),
                                             fg='white', bg='#2c3e50')
                        title_label.pack(side="left", padx=20, pady=20)
                        
                        subtitle_label = tk.Label(title_frame, 
                                                text="活動業績分析 / Activity Performance Analysis",
                                                font=('Arial', 11),
                                                fg='#bdc3c7', bg='#2c3e50')
                        subtitle_label.pack(side="left", padx=(0, 20), pady=20)

                        # 主內容區域
                        content_frame = tk.Frame(analysis_window, bg='#FFFFFF')
                        content_frame.pack(fill="both", expand=True, padx=20, pady=20)
                        
                        # 創建滾動條和文本框 - 美化版本
                        text_container = tk.Frame(content_frame, bg='#ffffff', relief='solid', bd=1)
                        text_container.pack(fill="both", expand=True)
                        
                        result_text = tk.Text(text_container, 
                                            height=30, width=100, 
                                            wrap=tk.WORD, 
                                            font=('Consolas', 10),
                                            bg='#ffffff',
                                            fg='#2c3e50',
                                            selectbackground='#3498db',
                                            selectforeground='white',
                                            insertbackground='#2c3e50',
                                            relief='flat',
                                            padx=15, pady=15)
                        
                        result_scrollbar = ttk.Scrollbar(text_container, orient="vertical", command=result_text.yview)
                        result_text.configure(yscrollcommand=result_scrollbar.set)
                        
                        result_text.pack(side="left", fill="both", expand=True)
                        result_scrollbar.pack(side="right", fill="y")
                        
                        # 添加底部按鈕區域
                        button_frame = tk.Frame(analysis_window, bg='#FFFFFF', height=60)
                        button_frame.pack(fill="x", padx=20, pady=(0, 20))
                        button_frame.pack_propagate(False)
                        
                        # 關閉按鈕
                        close_btn = tk.Button(button_frame, 
                                            text="❌ 關閉 / Close",
                                            command=close_analysis_window,
                                            font=('Arial', 10, 'bold'),
                                            bg='#e74c3c', fg='white',
                                            relief='flat', bd=0,
                                            padx=20, pady=8,
                                            cursor='hand2')
                        close_btn.pack(side="right", pady=15)
                        
                        # 導出按鈕
                        export_btn = tk.Button(button_frame, 
                                             text="📄 導出報告 / Export Report",
                                             command=lambda: self.export_analysis_report(result_text.get(1.0, tk.END)),
                                             font=('Arial', 10, 'bold'),
                                             bg='#27ae60', fg='white',
                                             relief='flat', bd=0,
                                             padx=20, pady=8,
                                             cursor='hand2')
                        export_btn.pack(side="right", padx=(0, 10), pady=15)
                        
                        # 處理週期性活動
                        selected_weekdays = []
                        if selected_record.get('type') == 'weekly':
                            selected_weekdays = selected_record.get('weekdays', [])
                        
                        # 調用分析
                        self.perform_activity_analysis(result_text, date_from_str, date_to_str, outlets, products, database, payment_methods, selected_weekdays, False, None, None, False)
                        result_text.config(state=tk.DISABLED)
                        
                        return
            
            # 如果沒有選中記錄，使用表單中的設置進行分析
            # 获取活动信息
            date_from = self.activity_date_from.get_date()
            date_to = self.activity_date_to.get_date()
            outlets = self.activity_outlets.get_selected()
            products = self.activity_products.get_selected()
            
            # 获取支付方式筛选
            payment_methods = []
            if hasattr(self, 'activity_payment'):
                payment_methods = self.activity_payment.get_selected()
            
            # 获取活动类型
            activity_type = 'daily'
            if hasattr(self, 'activity_type'):
                activity_type = self.activity_type.get()
            
            # 获取时间筛选设置
            time_filter_enabled = False
            start_time = None
            end_time = None
            auto_time_range = False
            
            if activity_type == 'daily':
                # 每日活动时间筛选
                if hasattr(self, 'time_filter_enabled') and self.time_filter_enabled.get():
                    time_filter_enabled = True
                    auto_time_range = hasattr(self, 'auto_time_range') and self.auto_time_range.get()
                    
                    if not auto_time_range:
                        # 手动时间设置
                        start_time = self.start_time_entry.get().strip()
                        end_time = self.end_time_entry.get().strip()
                        
                        # 验证时间格式
                        try:
                            from datetime import datetime
                            datetime.strptime(start_time, '%H:%M')
                            datetime.strptime(end_time, '%H:%M')
                        except ValueError:
                            tk.messagebox.showerror("错误", "时间格式不正确，请使用 HH:MM 格式（如 12:00）")
                            return
            else:
                # 週期性活动时间筛选
                if hasattr(self, 'weekly_time_filter_enabled') and self.weekly_time_filter_enabled.get():
                    time_filter_enabled = True
                    auto_time_range = hasattr(self, 'weekly_auto_time_range') and self.weekly_auto_time_range.get()
                    
                    if not auto_time_range:
                        # 手动时间设置
                        start_time = self.weekly_start_time_entry.get().strip()
                        end_time = self.weekly_end_time_entry.get().strip()
                        
                        # 验证时间格式
                        try:
                            from datetime import datetime
                            datetime.strptime(start_time, '%H:%M')
                            datetime.strptime(end_time, '%H:%M')
                        except ValueError:
                            tk.messagebox.showerror("错误", "时间格式不正确，请使用 HH:MM 格式（如 12:00）")
                            return
            
            # 验证输入
            if not date_from or not date_to:
                tk.messagebox.showerror("错误", "请选择活动日期范围")
                return
            
            if not outlets:
                # 如果沒有選擇門市，使用所有可用門市
                outlets = self.available_outlets if hasattr(self, 'available_outlets') and self.available_outlets else []
                if not outlets:
                    # 檢查數據庫連接狀態
                    if not self.db_manager.connection:
                        tk.messagebox.showerror("错误", "数据库未连接，请先连接数据库")
                        return
                    
                    # 嘗試從數據庫管理器獲取門市列表
                    try:
                        outlets = self.db_manager.get_outlets()
                        if outlets:
                            self.available_outlets = outlets
                            print(f"✅ 已從數據庫獲取 {len(outlets)} 個門市")
                        else:
                            tk.messagebox.showerror("错误", "无法获取门市列表，请先连接数据库并刷新门市数据")
                            return
                    except Exception as e:
                        print(f"獲取門市列表失敗: {e}")
                        tk.messagebox.showerror("错误", f"无法获取门市列表: {str(e)}")
                return
            
            if not products:
                tk.messagebox.showwarning("提示", "未选择产品，将分析所有产品")
                products = []
            
            # 计算周期性活动的所有相关日期
            actual_date_from = date_from
            actual_date_to = date_to
            
            if activity_type == 'weekly' and hasattr(self, 'weekday_vars'):
                # 寻找时间段内指定星期几的所有日期
                from datetime import timedelta
                weekday_names = ['星期一', '星期二', '星期三', '星期四', '星期五', '星期六', '星期日']
                selected_weekdays = [day for day, var in self.weekday_vars.items() if var.get()]
                
                if selected_weekdays:
                    # 获取所有需要分析的日期
                    analysis_dates = []
                    current_date = date_from
                    while current_date <= date_to:
                        weekday_name = weekday_names[current_date.weekday()]
                        if weekday_name in selected_weekdays:
                            analysis_dates.append(current_date)
                        current_date += timedelta(days=1)
                    
                    if analysis_dates:
                        actual_date_from = min(analysis_dates)
                        actual_date_to = max(analysis_dates)
                        print(f"📅 周期性活动 - 实际分析日期: {[d.strftime('%Y-%m-%d') for d in analysis_dates]}")
            
            # 转换日期格式
            date_from_str = actual_date_from.strftime('%Y-%m-%d')
            date_to_str = actual_date_to.strftime('%Y-%m-%d')
            
            # 连接数据库
            current_db = self.activity_database.get()
            if not current_db:
                tk.messagebox.showerror("错误", "请先选择数据库")
                return
            
            # 使用活动数据库连接方法
            if not self.connect_to_activity_database(current_db):
                tk.messagebox.showerror("错误", f"无法连接到 {current_db} 数据库")
                return
            
            # 创建分析结果窗口
            analysis_window = tk.Toplevel(self.activity_window)
            analysis_window.title("📊 活动业绩分析 / Activity Performance Analysis")
            analysis_window.geometry("1000x700")
            analysis_window.transient(self.activity_window)
            
            # 設置窗口關閉協議 - 確保正確關閉
            def close_analysis_window():
                try:
                    analysis_window.destroy()
                except:
                    pass
            
            analysis_window.protocol("WM_DELETE_WINDOW", close_analysis_window)
            
            # 主框架
            main_frame = tk.Frame(analysis_window)
            main_frame.pack(fill="both", expand=True, padx=10, pady=10)
            
            # 标题
            title_label = tk.Label(main_frame, text="📊 活动业绩分析报告 / Activity Performance Analysis Report", 
                                   font=('Arial', 14, 'bold'))
            title_label.pack(pady=(0, 20))
            
            # 分析信息
            info_frame = tk.LabelFrame(main_frame, text="📋 分析信息 / Analysis Information")
            info_frame.pack(fill="x", pady=(0, 10))
            
            info_text = f"📅 活动期间: {date_from_str} 至 {date_to_str}\n"
            info_text += f"🏪 涉及门市: {', '.join(outlets)}\n"
            info_text += f"🍣 涉及产品: {', '.join(products) if products else '全部产品'}\n"
            info_text += f"💳 支付方式: {', '.join(payment_methods) if payment_methods else '全部支付方式'}\n"
            info_text += f"🗄️ 数据源: {current_db}\n"
            
            tk.Label(info_frame, text=info_text, font=('Arial', 10)).pack(anchor="w")
            
            # 分析结果区域
            result_frame = tk.LabelFrame(main_frame, text="📈 分析结果 / Analysis Results")
            result_frame.pack(fill="both", expand=True)
            
            # 创建文本显示区域
            result_text = tk.Text(result_frame, height=20, width=80, wrap=tk.WORD, font=('Consolas', 9))
            result_scrollbar = ttk.Scrollbar(result_frame, orient="vertical", command=result_text.yview)
            result_text.configure(yscrollcommand=result_scrollbar.set)
            
            result_text.pack(side="left", fill="both", expand=True)
            result_scrollbar.pack(side="right", fill="y")
            
            # 记录实际使用的数据库和调试信息
            db_report = self.db_manager.current_database if hasattr(self.db_manager, 'current_database') else "未确定"
            result_text.insert(tk.END, f"📋 分析的数据库: {db_report}\n")
            result_text.insert(tk.END, f"📋 选定的数据库: {current_db}\n")
            result_text.insert(tk.END, f"{'=' * 60}\n")
            
            # 开始分析
            self.perform_activity_analysis(result_text, date_from_str, date_to_str, outlets, products, current_db, payment_methods, None, time_filter_enabled, start_time, end_time, auto_time_range)
            
        except Exception as e:
            tk.messagebox.showerror("错误", f"活动分析失败: {e}")
        finally:
            if hasattr(self, 'db_manager') and self.db_manager.connection:
                self.db_manager.disconnect()
    
    def perform_activity_analysis(self, result_text, date_from, date_to, outlets, products, database, payment_methods=None, weekday_filters=None, time_filter_enabled=False, start_time=None, end_time=None, auto_time_range=False):
        """执行活动业绩分析 - 重新设计版本支持支付方式筛选和分别业绩计算"""
        try:
            print(f"🔍 perform_activity_analysis 開始執行")
            print(f"📊 參數: date_from={date_from}, date_to={date_to}, database={database}")
            print(f"📊 outlets={outlets}, products={products}, payment_methods={payment_methods}")
            print(f"📊 weekday_filters={weekday_filters}")
            
            # 檢查數據庫連接
            if not hasattr(self, 'db_manager') or not self.db_manager.connection:
                print("❌ 數據庫未連接，嘗試重新連接...")
                if not self.connect_to_activity_database(database):
                    result_text.insert(tk.END, f"❌ 無法連接到數據庫: {database}\n", "error")
                    return
                print("✅ 數據庫連接成功")
            
            # 配置文本樣式
            print("🎨 配置文本樣式...")
            self.configure_analysis_text_styles(result_text)
            print("✅ 文本樣式配置完成")
            
            result_text.insert(tk.END, "🔍 正在分析活动业绩数据...\n", "header")
            result_text.insert(tk.END, f"📊 当前连接数据库: {database}\n", "info")
            result_text.insert(tk.END, f"📊 数据库管理器连接状态: {self.db_manager.current_database}\n\n", "info")
            print("✅ 初始信息已插入到文本窗口")
            
            # 強制刷新文本窗口
            result_text.update()
            print("✅ 文本窗口已刷新")

            # 显示筛选条件
            result_text.insert(tk.END, "📋 筛选条件 / Filter Conditions\n", "result_header")
            result_text.insert(tk.END, "=" * 60 + "\n", "separator")
            result_text.insert(tk.END, f"📅 日期范围: {date_from} 至 {date_to}\n", "condition")

            # 显示门市筛选
            available_outlets = getattr(self, 'available_outlets', [])
            if outlets and available_outlets and len(outlets) < len(available_outlets):
                # 有筛选门市，显示 All, Except: ...
                except_outlets = [o for o in available_outlets if o not in outlets]
                result_text.insert(tk.END, f"🏪 涉及门市: All, Except: {', '.join(except_outlets)}\n", "condition")
            else:
                result_text.insert(tk.END, f"🏪 涉及门市: All\n", "condition")

            if products:
                result_text.insert(tk.END, f"🍣 产品: {', '.join(products)}\n", "condition")
            else:
                result_text.insert(tk.END, "🍣 产品: 所有产品\n", "condition")

            if payment_methods and len(payment_methods) > 0:
                result_text.insert(tk.END, f"💳 支付方式: {', '.join(payment_methods)}\n", "condition")
            else:
                result_text.insert(tk.END, "💳 支付方式: 所有支付方式\n", "condition")

            if weekday_filters and len(weekday_filters) > 0:
                result_text.insert(tk.END, f"🗓️ 星期: {', '.join(weekday_filters)}\n", "condition")
            else:
                result_text.insert(tk.END, "🗓️ 星期: 所有星期\n", "condition")
            
            # 显示时间筛选条件
            if time_filter_enabled:
                if auto_time_range:
                    result_text.insert(tk.END, "⏰ 时间筛选: 从第一件到最後一件產品銷售時間\n", "condition")
                elif start_time and end_time:
                    result_text.insert(tk.END, f"⏰ 时间筛选: {start_time} 至 {end_time}\n", "condition")
                else:
                    result_text.insert(tk.END, "⏰ 时间筛选: 已启用\n", "condition")
            else:
                result_text.insert(tk.END, "⏰ 时间筛选: 未启用\n", "condition")
            
            # 执行新的分析逻辑
            # 验证分析数据前确保连接正常
            if not hasattr(self, 'db_manager') or not self.db_manager.connection:
                result_text.insert(tk.END, "❌ 数据库连接失败，无法获取数据\n")
                return
            
            # 1. 先获取筛选条件下的所有数据（用于计算总业绩）- 只筛选星期和门市，不筛选产品和支付方式
            all_data = self.db_manager.get_sales_data(
                date_from=date_from, date_to=date_to,
                outlet_filters=outlets,
                product_filters=[], # 不限制产品，获取所有产品数据
                weekday_filters=weekday_filters, # 添加星期筛选
                use_excel_cache=True  # 优先使用已导出的缓存文件，避免重复查询数据库
            )
            
            # 验证查询到的数据来源
            if not all_data:
                result_text.insert(tk.END, "❌ 未找到业绩数据\n")
                return
            
            # ===== 重新设计的分析逻辑 =====
            # 按单据级别汇总计算总业绩（只计算筛选的星期数据）- 使用与其他分析功能一致的计算方式，包括扣除cancel_sales
            receipt_totals = {}

            # 获取所有相关的cancel数据
            cancel_data = {}
            try:
                cancel_keys = set()
                for r in all_data:
                    sales_no = r.get('sales_no', '')
                    store_name = r.get('store_name', '')
                    cancel_keys.add(f"{store_name}-{sales_no}")

                if cancel_keys:
                    cancel_cursor = self.db_manager.connection.cursor()
                    cancel_conditions = []
                    cancel_params = []
                    for key in cancel_keys:
                        store_name, sales_no = key.split('-', 1)
                        cancel_conditions.append("(store_name = ? AND sales_no = ?)")
                        cancel_params.extend([store_name, sales_no])

                    if cancel_conditions:
                        cancel_query = f"""
                            SELECT store_name, sales_no,
                                CAST(sub_total as FLOAT) - CAST(ISNULL(pro_disc_amt, 0) as FLOAT) +
                                CAST(ISNULL(svc_amt, 0) as FLOAT) -
                                CASE WHEN take_away_item = 'Y' THEN CAST(ISNULL(tax_amt, 0) as FLOAT) ELSE 0 END as cancel_amount
                            FROM {TABLE_CANCEL}
                            WHERE {' OR '.join(cancel_conditions)}
                        """
                        cancel_cursor.execute(cancel_query, cancel_params)
                        cancel_results = cancel_cursor.fetchall()

                        for cancel_row in cancel_results:
                            key = f"{cancel_row[0]}-{cancel_row[1]}"
                            cancel_data[key] = float(cancel_row[2]) if cancel_row[2] else 0.0

                    cancel_cursor.close()
            except Exception as e:
                print(f"获取cancel数据失败: {e}")

            for r in all_data:
                sales_no = r.get('sales_no', '')
                store_name = r.get('store_name', '')
                receipt_key = f"{store_name}-{sales_no}"

                # 使用与其他分析功能一致的业绩计算方式
                sub_total = float(r.get('sub_total', 0))
                pro_disc_amt = float(r.get('pro_disc_amt', 0))
                svc_amt = float(r.get('svc_amt', 0))
                tax_amt = float(r.get('tax_amt', 0))
                take_away_item = str(r.get('take_away_item', 'N'))

                # 根据数据库类型计算业绩
                if self.db_manager.current_database == "sushi_gogo_pos_live":
                    # GOGO数据库：所有单据都直接减去tax_amt
                    net_amount = sub_total - pro_disc_amt + svc_amt - tax_amt
                else:
                    # Express数据库：只有外带商品才减去tax_amt
                    if take_away_item == 'Y':
                        net_amount = sub_total - pro_disc_amt + svc_amt - tax_amt
                    else:
                        net_amount = sub_total - pro_disc_amt + svc_amt

                # 扣除cancel_sales
                cancel_amount = cancel_data.get(receipt_key, 0.0)
                net_amount -= cancel_amount

                if receipt_key not in receipt_totals:
                    receipt_totals[receipt_key] = 0.0
                receipt_totals[receipt_key] += net_amount

            # 计算筛选的星期数据的总业绩（按单据汇总的正确总额）
            total_amount_all = sum(receipt_totals.values())
            total_receipts_all = len(receipt_totals)

            # all_data已经包含了支付方式筛选，直接使用
            filtered_data = all_data
            
            # 處理支付方式參數 - 確保變量始終被定義
            payment_methods_list = []
            if payment_methods:
                # 确保payment_methods_list是列表格式（用于后续显示）
                if isinstance(payment_methods, str):
                    if ',' in payment_methods:
                        payment_methods_list = [pm.strip() for pm in payment_methods.split(',')]
                    else:
                        payment_methods_list = [payment_methods] if payment_methods else []
                else:
                    payment_methods_list = payment_methods

            # 计算产品业绩（如果指定产品）- 使用与期间-产品数据完全相同的SQL查询方式
            product_amount = 0
            product_receipts = 0
            product_quantity = 0
            if products:
                try:
                    # 构建与期间-产品数据相同的查询条件
                    conditions = []
                    params = []
                    
                    # 日期筛选
                    if date_from and date_to:
                        conditions.append("CAST(s.c_date as DATE) >= ?")
                        conditions.append("CAST(s.c_date as DATE) <= ?")
                        params.extend([date_from, date_to])
                    
                    # 门市筛选
                    if outlets:
                        placeholders = ','.join(['?' for _ in outlets])
                        conditions.append(f"s.store_name IN ({placeholders})")
                        params.extend(outlets)
                    
                    # 星期筛选
                    if weekday_filters:
                        weekday_conditions = []
                        weekday_map = {
                            'Sunday': 0, 'Monday': 1, 'Tuesday': 2, 'Wednesday': 3,
                            'Thursday': 4, 'Friday': 5, 'Saturday': 6
                        }
                        for weekday in weekday_filters:
                            weekday_num = weekday_map.get(weekday, 0)
                            weekday_conditions.append(f"DATEPART(WEEKDAY, s.c_date) = {weekday_num + 1}")
                        if weekday_conditions:
                            conditions.append(f"({' OR '.join(weekday_conditions)})")
                    
                    # 产品筛选
                    if products:
                        placeholders = ','.join(['?' for _ in products])
                        conditions.append(f"s.item_name IN ({placeholders})")
                        params.extend(products)
                    
                    # 支付方式筛选 - 严格匹配，与期间-产品数据保持一致
                    if payment_methods:
                        placeholders = ','.join(['?' for _ in payment_methods])
                        conditions.append(f"""NOT EXISTS (
                            SELECT 1 FROM {TABLE_PAYMENT} p
                            WHERE p.sales_no = s.sales_no AND p.store_name = s.store_name
                            AND p.payment_name NOT IN ({placeholders})
                        )""")
                        params.extend(payment_methods)
                    
                    # 排除wastage主产品
                    conditions.append("s.item_name != 'WASTAGE'")
                    
                    # 构建WHERE子句
                    where_clause = ""
                    if conditions:
                        where_clause = " WHERE " + " AND ".join(conditions)
                    
                    # 使用与期间-产品数据完全相同的SQL查询
                    product_query = f"""
                        SELECT
                            s.item_name as 产品名称,
                            SUM({self.db_manager.get_performance_calculation_sql()} - 
                                ISNULL(CAST(c.cancel_amount as FLOAT), 0)) as 总业绩,
                            COUNT(DISTINCT CONCAT(s.store_name, '-', s.sales_no)) as 总单据数,
                            SUM(CAST(s.qty as FLOAT)) as 销售总数
                        FROM {TABLE_SALES} s WITH (NOLOCK)
                        LEFT JOIN (
                            SELECT 
                                sales_no, 
                                store_name, 
                                item_name,
                                SUM({self.db_manager._get_cancel_performance_calculation_sql()}) as cancel_amount
                            FROM {TABLE_CANCEL} WITH (NOLOCK)
                            GROUP BY sales_no, store_name, item_name
                        ) c ON s.sales_no = c.sales_no AND s.store_name = c.store_name AND s.item_name = c.item_name
                        {where_clause}
                        GROUP BY s.item_name
                        ORDER BY 总业绩 DESC
                        OPTION (RECOMPILE, MAXDOP 4)
                    """
                    
                    cursor = self.db_manager.connection.cursor()
                    cursor.execute(product_query, params)
                    product_results = cursor.fetchall()
                    cursor.close()
                    
                    # 计算产品业绩 - 业积和数量可以加总，但单据数需要重新计算唯一单据
                    for row in product_results:
                        product_amount += float(row[1]) if row[1] else 0.0
                        # product_receipts += int(row[2]) if row[2] else 0  # 注释掉：不加总每行的单据数
                        product_quantity += float(row[3]) if row[3] else 0.0
                    
                    # 重新計算包含指定產品的唯一單據數
                    if conditions:
                        # 重新查詢獨立的唯一單據數
                        unique_receipt_query = f"""
                            SELECT COUNT(DISTINCT CONCAT(s.store_name, '-', s.sales_no)) as unique_receipt_count
                            FROM {TABLE_SALES} s WITH (NOLOCK)
                            LEFT JOIN (
                                SELECT 
                                    sales_no, 
                                    store_name, 
                                    item_name,
                                    SUM({self.db_manager._get_cancel_performance_calculation_sql()}) as cancel_amount
                                FROM {TABLE_CANCEL} WITH (NOLOCK)
                                GROUP BY sales_no, store_name, item_name
                            ) c ON s.sales_no = c.sales_no AND s.store_name = c.store_name AND s.item_name = c.item_name
                            {where_clause}
                        """
                        
                        unique_cursor = self.db_manager.connection.cursor()
                        unique_cursor.execute(unique_receipt_query, params)
                        unique_result = unique_cursor.fetchone()
                        product_receipts = unique_result[0] if unique_result else 0
                        unique_cursor.close()
                    else:
                        product_receipts = 0
                    
                except Exception as e:
                    print(f"获取产品业绩失败: {e}")
                    product_amount = 0
                    product_receipts = 0
                    product_quantity = 0
            
            # ===== 重新设计的分析输出格式 =====
            result_text.insert(tk.END, "\n📊 分析结果 / Analysis Results\n", "result_header")
            result_text.insert(tk.END, "=" * 60 + "\n", "separator")

            # 1. 显示总业绩（11/9 & 22/9 的总业绩）
            result_text.insert(tk.END, f"📅 总业绩 / Total Performance: ${total_amount_all:,.2f}\n", "data")
            result_text.insert(tk.END, f"📅 总单据数 / Total Receipts: {total_receipts_all:,}\n", "data")
            
            # 計算總篩選產品業績和單據數（所有支付方式的總和）
            total_filtered_amount = 0
            total_filtered_receipts = 0

            # 先計算總篩選產品業績，然後顯示
            if products and payment_methods:
                # 確保payment_methods_list是列表格式
                if isinstance(payment_methods, str):
                    if ',' in payment_methods:
                        payment_methods_list = [pm.strip() for pm in payment_methods.split(',')]
                    else:
                        payment_methods_list = [payment_methods] if payment_methods else []
                else:
                    payment_methods_list = payment_methods
                    
                # 為每個支付方式單獨查詢產品業績來計算總和
                for payment_method in payment_methods_list:
                    try:
                        # 構建查詢條件 - 只篩選當前支付方式
                        payment_conditions = []
                        payment_params = []

                        # 日期筛选
                        if date_from and date_to:
                            payment_conditions.append("CAST(s.c_date as DATE) >= ?")
                            payment_conditions.append("CAST(s.c_date as DATE) <= ?")
                            payment_params.extend([date_from, date_to])

                        # 门市筛选
                        if outlets:
                            placeholders = ','.join(['?' for _ in outlets])
                            payment_conditions.append(f"s.store_name IN ({placeholders})")
                            payment_params.extend(outlets)

                        # 星期筛选
                        if weekday_filters:
                            weekday_conditions = []
                            weekday_map = {
                                'Sunday': 0, 'Monday': 1, 'Tuesday': 2, 'Wednesday': 3,
                                'Thursday': 4, 'Friday': 5, 'Saturday': 6
                            }
                            for weekday in weekday_filters:
                                weekday_num = weekday_map.get(weekday, 0)
                                weekday_conditions.append(f"DATEPART(WEEKDAY, s.c_date) = {weekday_num + 1}")
                            if weekday_conditions:
                                payment_conditions.append(f"({' OR '.join(weekday_conditions)})")

                        # 产品筛选
                        if products:
                            placeholders = ','.join(['?' for _ in products])
                            payment_conditions.append(f"s.item_name IN ({placeholders})")
                            payment_params.extend(products)

                        # 支付方式筛选 - 只筛选当前支付方式
                        payment_conditions.append(f"NOT EXISTS (SELECT 1 FROM {TABLE_PAYMENT} p WHERE p.sales_no = s.sales_no AND p.store_name = s.store_name AND p.payment_name NOT IN (?))")
                        payment_params.append(payment_method)

                        # 排除wastage主产品
                        payment_conditions.append("s.item_name != 'WASTAGE'")

                        # 构建WHERE子句
                        payment_where_clause = ""
                        if payment_conditions:
                            payment_where_clause = " WHERE " + " AND ".join(payment_conditions)

                        # 查询该支付方式的产品业绩
                        payment_product_query = f"""
                            SELECT
                                SUM({self.db_manager.get_performance_calculation_sql()} -
                                    ISNULL(CAST(c.cancel_amount as FLOAT), 0)) as 总业绩,
                                COUNT(DISTINCT CONCAT(s.store_name, '-', s.sales_no)) as 总单据数
                            FROM {TABLE_SALES} s WITH (NOLOCK)
                            LEFT JOIN (
                                SELECT
                                    sales_no,
                                    store_name,
                                    item_name,
                                    SUM({self.db_manager._get_cancel_performance_calculation_sql()}) as cancel_amount
                                FROM {TABLE_CANCEL} WITH (NOLOCK)
                                GROUP BY sales_no, store_name, item_name
                            ) c ON s.sales_no = c.sales_no AND s.store_name = c.store_name AND s.item_name = c.item_name
                            {payment_where_clause}
                            OPTION (RECOMPILE, MAXDOP 4)
                        """

                        cursor = self.db_manager.connection.cursor()
                        cursor.execute(payment_product_query, payment_params)
                        payment_product_result = cursor.fetchone()
                        cursor.close()

                        if payment_product_result:
                            payment_amount = float(payment_product_result[0]) if payment_product_result[0] else 0
                            payment_receipts = int(payment_product_result[1]) if payment_product_result[1] else 0
                            total_filtered_amount += payment_amount
                            total_filtered_receipts += payment_receipts

                    except Exception as e:
                        print(f"计算{payment_method}产品业绩失败: {e}")

            # 顯示總篩選產品業績
            if total_filtered_amount > 0:
                result_text.insert(tk.END, f"💰 總篩選產品業績 / Selected Product Sales: ${total_filtered_amount:,.2f}\n", "data")
                result_text.insert(tk.END, f"🧾 總篩選產品單據數 / Selected Product Transaction: {total_filtered_receipts:,}\n", "data")
                
                # 計算並顯示產品總占比
                product_amount_ratio = (total_filtered_amount / total_amount_all * 100) if total_amount_all > 0 else 0
                product_receipt_ratio = (total_filtered_receipts / total_receipts_all * 100) if total_receipts_all > 0 else 0
                result_text.insert(tk.END, f"📊 產品業績占比 / Product Sales Ratio: {product_amount_ratio:.2f}%\n", "data")
                result_text.insert(tk.END, f"📊 產品單據占比 / Product Transaction Ratio: {product_receipt_ratio:.2f}%\n\n", "data")
            
            result_text.insert(tk.END, "=" * 60 + "\n", "separator")

            # 2. 按支付方式分别显示产品信息（与期间-产品数据保持一致的显示方式）
            if products and payment_methods:
                # 为每个支付方式单独查询和显示产品业绩
                for payment_method in payment_methods_list:
                    try:
                        # 构建查询条件 - 只筛选当前支付方式
                        payment_conditions = []
                        payment_params = []

                        # 日期筛选
                        if date_from and date_to:
                            payment_conditions.append("CAST(s.c_date as DATE) >= ?")
                            payment_conditions.append("CAST(s.c_date as DATE) <= ?")
                            payment_params.extend([date_from, date_to])

                        # 门市筛选
                        if outlets:
                            placeholders = ','.join(['?' for _ in outlets])
                            payment_conditions.append(f"s.store_name IN ({placeholders})")
                            payment_params.extend(outlets)

                        # 星期筛选
                        if weekday_filters:
                            weekday_conditions = []
                            weekday_map = {
                                'Sunday': 0, 'Monday': 1, 'Tuesday': 2, 'Wednesday': 3,
                                'Thursday': 4, 'Friday': 5, 'Saturday': 6
                            }
                            for weekday in weekday_filters:
                                weekday_num = weekday_map.get(weekday, 0)
                                weekday_conditions.append(f"DATEPART(WEEKDAY, s.c_date) = {weekday_num + 1}")
                            if weekday_conditions:
                                payment_conditions.append(f"({' OR '.join(weekday_conditions)})")

                        # 产品筛选
                        if products:
                            placeholders = ','.join(['?' for _ in products])
                            payment_conditions.append(f"s.item_name IN ({placeholders})")
                            payment_params.extend(products)

                        # 支付方式筛选 - 只筛选当前支付方式
                        payment_conditions.append(f"NOT EXISTS (SELECT 1 FROM {TABLE_PAYMENT} p WHERE p.sales_no = s.sales_no AND p.store_name = s.store_name AND p.payment_name NOT IN (?))")
                        payment_params.append(payment_method)

                        # 排除wastage主产品
                        payment_conditions.append("s.item_name != 'WASTAGE'")

                        # 构建WHERE子句
                        payment_where_clause = ""
                        if payment_conditions:
                            payment_where_clause = " WHERE " + " AND ".join(payment_conditions)

                        # 查询该支付方式的产品业绩
                        payment_product_query = f"""
                            SELECT
                                s.item_name as 产品名称,
                                SUM({self.db_manager.get_performance_calculation_sql()} -
                                    ISNULL(CAST(c.cancel_amount as FLOAT), 0)) as 总业绩,
                                COUNT(DISTINCT CONCAT(s.store_name, '-', s.sales_no)) as 总单据数,
                                SUM(CAST(s.qty as FLOAT)) as 销售总数
                            FROM {TABLE_SALES} s WITH (NOLOCK)
                            LEFT JOIN (
                                SELECT
                                    sales_no,
                                    store_name,
                                    item_name,
                                    SUM({self.db_manager._get_cancel_performance_calculation_sql()}) as cancel_amount
                                FROM {TABLE_CANCEL} WITH (NOLOCK)
                                GROUP BY sales_no, store_name, item_name
                            ) c ON s.sales_no = c.sales_no AND s.store_name = c.store_name AND s.item_name = c.item_name
                            {payment_where_clause}
                            GROUP BY s.item_name
                            ORDER BY 总业绩 DESC
                            OPTION (RECOMPILE, MAXDOP 4)
                        """

                        cursor = self.db_manager.connection.cursor()
                        cursor.execute(payment_product_query, payment_params)
                        payment_product_results = cursor.fetchall()
                        cursor.close()

                        # 显示该支付方式的产品业绩
                        if payment_product_results:
                            for row in payment_product_results:
                                payment_amount = float(row[1]) if row[1] else 0
                                payment_receipts = int(row[2]) if row[2] else 0
                                payment_quantity = float(row[3]) if row[3] else 0
                                
                                # 總篩選產品業績已在前面計算，這裡不需要重複累加
                                
                                result_text.insert(tk.END, f"🍣 筛选产品 / Selected Product: {', '.join(products)}\n")
                                result_text.insert(tk.END, f"💳 支付方式 / Payment Method: {payment_method}\n")
                                result_text.insert(tk.END, f"💰 产品业绩 / Product Sales: ${payment_amount:,.2f}\n")
                                result_text.insert(tk.END, f"🧾 产品单据数 / Product Transaction: {payment_receipts:,}\n")
                                result_text.insert(tk.END, f"🍣 产品数量 / Product Quantity Sold: {payment_quantity:,.0f}\n")
                                
                                # 計算占比 - 修正：使用總篩選產品業績來計算占比，而不是單個支付方式
                                # 這裡顯示的是該支付方式在總業績中的占比
                                amount_ratio = (payment_amount / total_amount_all * 100) if total_amount_all > 0 else 0
                                receipt_ratio = (payment_receipts / total_receipts_all * 100) if total_receipts_all > 0 else 0
                                result_text.insert(tk.END, f"📊 支付方式業績占比 / Payment Method Sales Ratio %: {amount_ratio:.2f}%\n")
                                result_text.insert(tk.END, f"📊 支付方式單據占比 / Payment Method Transaction Ratio %: {receipt_ratio:.2f}%\n")
                                result_text.insert(tk.END, "-" * 40 + "\n")

                    except Exception as e:
                        print(f"获取{payment_method}产品业绩失败: {e}")
                
                # 總篩選產品業績已在前面顯示
                    
            elif products:
                # 如果没有指定支付方式，显示总的产品业绩
                result_text.insert(tk.END, f"🍣 筛选产品 / Selected Product: {', '.join(products)}\n")
                result_text.insert(tk.END, f"💰 产品业绩 / Product Performance: ${product_amount:,.2f}\n")
                result_text.insert(tk.END, f"🧾 产品单据数 / Product Receipts: {product_receipts}\n")
                result_text.insert(tk.END, f"🍣 产品数量 / Product Quantity Sold: {product_quantity:,.0f}\n")

                # 计算占比
                product_amount_ratio = (product_amount / total_amount_all * 100) if total_amount_all > 0 else 0
                product_receipt_ratio = (product_receipts / total_receipts_all * 100) if total_receipts_all > 0 else 0
                result_text.insert(tk.END, f"📊 产品业绩占比 / Performance Ratio: {product_amount_ratio:.2f}%\n")
                result_text.insert(tk.END, f"📊 单据占比 / Receipt Ratio: {product_receipt_ratio:.2f}%\n")
                result_text.insert(tk.END, "-" * 40 + "\n")

            # 顯示詳細分析結果
            result_text.insert(tk.END, "\n📊 分析结果 / Analysis Results\n", "result_header")
            result_text.insert(tk.END, "=" * 60 + "\n", "separator")
            
            # 顯示總業績和總單據數
            result_text.insert(tk.END, f"💰 总业绩 / Total Performance: ${total_amount_all:,.2f}\n", "result")
            result_text.insert(tk.END, f"🧾 总单据数 / Total Receipts: {total_receipts_all:,}\n", "result")
            
            # 如果有指定產品，顯示產品分析
            if products:
                result_text.insert(tk.END, f"\n🍣 产品分析 / Product Analysis\n", "result_header")
                result_text.insert(tk.END, "-" * 40 + "\n", "separator")
                result_text.insert(tk.END, f"🍣 筛选产品 / Selected Product: {', '.join(products)}\n", "result")
                result_text.insert(tk.END, f"💰 产品业绩 / Product Performance: ${product_amount:,.2f}\n", "result")
                result_text.insert(tk.END, f"🧾 产品单据数 / Product Receipts: {product_receipts:,}\n", "result")
                result_text.insert(tk.END, f"🍣 产品数量 / Product Quantity Sold: {product_quantity:,.0f}\n", "result")
                
                # 计算占比
                product_amount_ratio = (product_amount / total_amount_all * 100) if total_amount_all > 0 else 0
                product_receipt_ratio = (product_receipts / total_receipts_all * 100) if total_receipts_all > 0 else 0
                result_text.insert(tk.END, f"📊 产品业绩占比 / Performance Ratio: {product_amount_ratio:.2f}%\n", "result")
                result_text.insert(tk.END, f"📊 单据占比 / Receipt Ratio: {product_receipt_ratio:.2f}%\n", "result")
            
            # 如果有指定支付方式，顯示支付方式分析
            if payment_methods_list:
                result_text.insert(tk.END, f"\n💳 支付方式分析 / Payment Method Analysis\n", "result_header")
                result_text.insert(tk.END, "-" * 40 + "\n", "separator")
                
                for payment_method in payment_methods_list:
                    try:
                        # 構建支付方式查詢條件
                        payment_conditions = []
                        payment_params = []
                        
                        # 日期篩選
                        if date_from and date_to:
                            payment_conditions.append("CAST(s.c_date as DATE) >= ?")
                            payment_conditions.append("CAST(s.c_date as DATE) <= ?")
                            payment_params.extend([date_from, date_to])
                        
                        # 門市篩選
                        if outlets:
                            placeholders = ','.join(['?' for _ in outlets])
                            payment_conditions.append(f"s.store_name IN ({placeholders})")
                            payment_params.extend(outlets)
                        
                        # 星期篩選
                        if weekday_filters:
                            weekday_conditions = []
                            weekday_map = {
                                'Sunday': 0, 'Monday': 1, 'Tuesday': 2, 'Wednesday': 3,
                                'Thursday': 4, 'Friday': 5, 'Saturday': 6
                            }
                            for weekday in weekday_filters:
                                weekday_num = weekday_map.get(weekday, 0)
                                weekday_conditions.append(f"DATEPART(WEEKDAY, s.c_date) = {weekday_num + 1}")
                            if weekday_conditions:
                                payment_conditions.append(f"({' OR '.join(weekday_conditions)})")
                        
                        # 產品篩選
                        if products:
                            placeholders = ','.join(['?' for _ in products])
                            payment_conditions.append(f"s.item_name IN ({placeholders})")
                            payment_params.extend(products)
                        
                        # 支付方式篩選
                        payment_conditions.append(f"""EXISTS (
                            SELECT 1 FROM {TABLE_PAYMENT} p
                            WHERE p.sales_no = s.sales_no AND p.store_name = s.store_name
                            AND p.payment_name = ?
                        )""")
                        payment_params.append(payment_method)
                        
                        # 排除wastage主產品
                        payment_conditions.append("s.item_name != 'WASTAGE'")
                        
                        # 構建WHERE子句
                        payment_where_clause = ""
                        if payment_conditions:
                            payment_where_clause = " WHERE " + " AND ".join(payment_conditions)
                        
                        # 查詢該支付方式的業績
                        payment_query = f"""
                            SELECT
                                SUM({self.db_manager.get_performance_calculation_sql()} - 
                                    ISNULL(CAST(c.cancel_amount as FLOAT), 0)) as 总业绩,
                                COUNT(DISTINCT CONCAT(s.store_name, '-', s.sales_no)) as 总单据数,
                                SUM(CAST(s.qty as FLOAT)) as 销售总数
                            FROM {TABLE_SALES} s WITH (NOLOCK)
                            LEFT JOIN (
                                SELECT 
                                    sales_no, 
                                    store_name, 
                                    item_name,
                                    SUM({self.db_manager._get_cancel_performance_calculation_sql()}) as cancel_amount
                                FROM {TABLE_CANCEL} WITH (NOLOCK)
                                GROUP BY sales_no, store_name, item_name
                            ) c ON s.sales_no = c.sales_no AND s.store_name = c.store_name AND s.item_name = c.item_name
                            {payment_where_clause}
                            OPTION (RECOMPILE, MAXDOP 4)
                        """
                        
                        cursor = self.db_manager.connection.cursor()
                        cursor.execute(payment_query, payment_params)
                        payment_result = cursor.fetchone()
                        cursor.close()
                        
                        if payment_result and payment_result[0]:
                            payment_amount = float(payment_result[0]) if payment_result[0] else 0
                            payment_receipts = int(payment_result[1]) if payment_result[1] else 0
                            payment_quantity = float(payment_result[2]) if payment_result[2] else 0
                            
                            result_text.insert(tk.END, f"💳 支付方式 / Payment Method: {payment_method}\n", "result")
                            result_text.insert(tk.END, f"💰 支付方式业绩 / Payment Sales: ${payment_amount:,.2f}\n", "result")
                            result_text.insert(tk.END, f"🧾 支付方式单据数 / Payment Transactions: {payment_receipts:,}\n", "result")
                            result_text.insert(tk.END, f"🍣 支付方式数量 / Payment Quantity: {payment_quantity:,.0f}\n", "result")
                            
                            # 計算占比
                            amount_ratio = (payment_amount / total_amount_all * 100) if total_amount_all > 0 else 0
                            receipt_ratio = (payment_receipts / total_receipts_all * 100) if total_receipts_all > 0 else 0
                            result_text.insert(tk.END, f"📊 支付方式业绩占比 / Payment Sales Ratio: {amount_ratio:.2f}%\n", "result")
                            result_text.insert(tk.END, f"📊 支付方式单据占比 / Payment Transaction Ratio: {receipt_ratio:.2f}%\n", "result")
                            result_text.insert(tk.END, "-" * 40 + "\n", "separator")
                        
                    except Exception as e:
                        print(f"获取{payment_method}业绩失败: {e}")
                        result_text.insert(tk.END, f"❌ 获取{payment_method}业绩失败: {str(e)}\n", "error")
            
            # 顯示門市分析
            if outlets and len(outlets) < len(available_outlets):
                result_text.insert(tk.END, f"\n🏪 门市分析 / Outlet Analysis\n", "result_header")
                result_text.insert(tk.END, "-" * 40 + "\n", "separator")
                result_text.insert(tk.END, f"🏪 涉及门市 / Involved Outlets: {', '.join(outlets)}\n", "result")
                result_text.insert(tk.END, f"📊 门市数量 / Outlet Count: {len(outlets)}\n", "result")
                result_text.insert(tk.END, f"📊 总门市数量 / Total Outlet Count: {len(available_outlets)}\n", "result")
                result_text.insert(tk.END, f"📊 门市覆盖率 / Outlet Coverage: {(len(outlets) / len(available_outlets) * 100):.2f}%\n", "result")
            
            # 顯示星期分析
            if weekday_filters:
                result_text.insert(tk.END, f"\n🗓️ 星期分析 / Weekday Analysis\n", "result_header")
                result_text.insert(tk.END, "-" * 40 + "\n", "separator")
                result_text.insert(tk.END, f"🗓️ 涉及星期 / Involved Weekdays: {', '.join(weekday_filters)}\n", "result")
                result_text.insert(tk.END, f"📊 星期数量 / Weekday Count: {len(weekday_filters)}\n", "result")
                result_text.insert(tk.END, f"📊 星期覆盖率 / Weekday Coverage: {(len(weekday_filters) / 7 * 100):.2f}%\n", "result")

            result_text.insert(tk.END, "\n✅ 分析完成！\n", "success")
            
            # 修復：活動分析完成後保存分析結果並更新活動記錄表
            try:
                # 保存分析結果到活動記錄中
                self.save_analysis_results_to_activity_records(
                    date_from, date_to, outlets, products, database, 
                    payment_methods, weekday_filters, 
                    total_amount_all, total_receipts_all, 
                    product_amount, product_receipts, product_quantity
                )
                print("✅ 已保存分析結果到活動記錄")
                
                # 更新活動記錄表
                if hasattr(self, 'activity_tree'):
                    self.refresh_activity_tree()
                    print("✅ 已刷新活動記錄表")
                
                # 更新活動提醒視窗
                if hasattr(self, 'update_activity_alerts'):
                    self.update_activity_alerts()
                    print("✅ 已更新活動提醒視窗")
                
                # 保存活動記錄
                if hasattr(self, 'save_activity_records'):
                    self.save_activity_records()
                    print("✅ 已保存活動記錄")
                    
            except Exception as update_error:
                print(f"⚠️ 更新活動記錄和提醒時出錯: {update_error}")
            
        except Exception as e:
            import traceback
            error_details = traceback.format_exc()
            result_text.insert(tk.END, f"❌ 分析过程中出现错误: {e}\n", "error")
            result_text.insert(tk.END, f"🔍 错误详情 / Error Details:\n{error_details}\n", "error")
            print(f"活动分析错误详情: {error_details}")
    
    def save_analysis_results_to_activity_records(self, date_from, date_to, outlets, products, database, 
                                                payment_methods, weekday_filters, 
                                                total_amount_all, total_receipts_all, 
                                                product_amount, product_receipts, product_quantity):
        """保存分析結果到活動記錄中"""
        try:
            print("💾 開始保存分析結果到活動記錄...")
            print(f"📊 分析參數:")
            print(f"   - 日期範圍: {date_from} 到 {date_to}")
            print(f"   - 門市: {outlets}")
            print(f"   - 產品: {products}")
            print(f"   - 支付方式: {payment_methods}")
            print(f"   - 星期: {weekday_filters}")
            print(f"   - 數據庫: {database}")
            
            # 找到匹配的活動記錄
            current_db = self.get_current_database()
            records = self.activity_records.get(current_db, [])
            print(f"📊 當前數據庫: {current_db}")
            print(f"📊 找到 {len(records)} 條活動記錄")
            
            # 計算占比
            amount_ratio = (product_amount / total_amount_all * 100) if total_amount_all > 0 else 0
            receipt_ratio = (product_receipts / total_receipts_all * 100) if total_receipts_all > 0 else 0
            
            # 查找匹配的活動記錄 - 使用更寬鬆的匹配條件
            matched_record = None
            for i, record in enumerate(records):
                print(f"🔍 檢查記錄 {i+1}: ID={record.get('id')}, 名稱={record.get('name', record.get('description', '未知'))}")
                
                # 檢查是否匹配當前分析的活動記錄 - 只檢查日期和產品
                record_date_from = record.get('date_from', '')
                record_date_to = record.get('date_to', '')
                record_products = record.get('products', [])
                
                print(f"   記錄日期: {record_date_from} 到 {record_date_to}")
                print(f"   記錄產品: {record_products}")
                
                # 檢查日期匹配
                date_match = (record_date_from == date_from and record_date_to == date_to)
                
                # 檢查產品匹配 - 使用更寬鬆的匹配
                products_match = False
                if products and record_products:
                    # 檢查是否有任何產品匹配
                    if isinstance(products, list) and isinstance(record_products, list):
                        products_match = any(p in record_products for p in products)
                    elif isinstance(products, str) and isinstance(record_products, str):
                        products_match = products in record_products or record_products in products
                elif not products and not record_products:
                    # 都沒有產品，也算匹配
                    products_match = True
                
                print(f"   日期匹配: {date_match}")
                print(f"   產品匹配: {products_match}")
                
                if date_match and products_match:
                    matched_record = record
                    print(f"✅ 找到匹配的活動記錄: {record.get('id')}")
                    break
            
            if matched_record:
                # 更新分析結果
                matched_record['total_sales'] = total_amount_all
                matched_record['total_receipts'] = total_receipts_all
                matched_record['activity_sales'] = product_amount
                matched_record['activity_receipts'] = product_receipts
                matched_record['activity_quantity'] = product_quantity
                matched_record['sales_ratio'] = amount_ratio
                matched_record['receipt_ratio'] = receipt_ratio
                matched_record['analysis_time'] = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                
                print(f"✅ 已更新活動記錄 {matched_record.get('id')} 的分析結果")
                print(f"   - 總業績: ${total_amount_all:,.2f}")
                print(f"   - 總單據數: {total_receipts_all:,}")
                print(f"   - 活動業績: ${product_amount:,.2f}")
                print(f"   - 活動單據數: {product_receipts:,}")
                print(f"   - 業績占比: {amount_ratio:.2f}%")
                print(f"   - 單據占比: {receipt_ratio:.2f}%")
            else:
                print("⚠️ 未找到匹配的活動記錄，嘗試更新所有記錄...")
                
                # 如果沒有找到匹配的記錄，更新所有記錄
                for record in records:
                    record['total_sales'] = total_amount_all
                    record['total_receipts'] = total_receipts_all
                    record['activity_sales'] = product_amount
                    record['activity_receipts'] = product_receipts
                    record['activity_quantity'] = product_quantity
                    record['sales_ratio'] = amount_ratio
                    record['receipt_ratio'] = receipt_ratio
                    record['analysis_time'] = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                    print(f"✅ 已更新活動記錄 {record.get('id')} 的分析結果")
                
                print("✅ 已更新所有活動記錄的分析結果")
                
        except Exception as e:
            print(f"❌ 保存分析結果到活動記錄失敗: {e}")
            import traceback
            print(f"詳細錯誤: {traceback.format_exc()}")
    
    def refresh_activity_tree(self):
        """刷新活动记录树显示 - 修复数据持久化版本"""
        try:
            # 清空现有数据
            for item in self.activity_tree.get_children():
                self.activity_tree.delete(item)
        
            # 获取当前选中的数据库
            current_db = self.get_current_database()
            
            # 确保活动记录字典存在并包含所有数据库
            if not hasattr(self, 'activity_records'):
                self.activity_records = {
                    'GOGO': [],
                    'Express': [], 
                    'PLUS': [],
                    'All': []
                }
            
            # 确保当前数据库键存在
            if current_db not in self.activity_records:
                self.activity_records[current_db] = []
                print(f"🔧 为数据库 '{current_db}' 创建了新的活动记录列表")
            
            print(f"🔄 刷新活动记录树 - 当前数据库: {current_db}")
            print(f"📋 所有活动记录状态: {list(self.activity_records.keys())}")
            print(f"📋 {current_db} 数据库的记录数: {len(self.activity_records[current_db])}")
            
            # 显示当前数据库的所有记录  
            if self.activity_records[current_db]:
                print(f"✅ 找到了 {len(self.activity_records[current_db])} 个活动记录")
                for record in self.activity_records[current_db]:
                    # 活動名稱
                    activity_name = record.get('description', f"活動 {record.get('id', '')}")
                    
                    # 日期期間
                    if record.get('type') == 'weekly':
                        weekdays_str = ', '.join(record.get('weekdays', []))
                        date_period = f"{record.get('date_from', '')} - {record.get('date_to', '')}"
                    else:
                        date_period = f"{record.get('date_from', '')} - {record.get('date_to', '')}"
                    
                    # 星期篩選
                    weekdays = record.get('weekdays', [])
                    weekdays_str = ', '.join(weekdays) if weekdays else '全部'
                    
                    # 分析結果 - 優先使用直接更新的字段
                    if record.get('total_sales') is not None:
                        # 使用直接更新的字段
                        total_sales = f"${record.get('total_sales', 0):,.2f}"
                        total_receipts = f"{record.get('total_receipts', 0):,}"
                        activity_sales = f"${record.get('activity_sales', 0):,.2f}"
                        activity_receipts = f"{record.get('activity_receipts', 0):,}"
                        sales_ratio = f"{record.get('sales_ratio', 0):.2f}%"
                        receipt_ratio = f"{record.get('receipt_ratio', 0):.2f}%"
                        print(f"📊 使用直接更新的字段顯示記錄 {record.get('id')} 的分析結果")
                    else:
                        # 使用舊的分析結果字段
                        analysis_result = record.get('analysis_result', {})
                        if analysis_result:
                            total_sales = f"${analysis_result.get('total_amount', 0):,.2f}"
                            total_receipts = f"{analysis_result.get('total_receipts', 0):,}"
                            activity_sales = f"${analysis_result.get('activity_amount', 0):,.2f}"
                            activity_receipts = f"{analysis_result.get('activity_receipts', 0):,}"
                            sales_ratio = f"{analysis_result.get('amount_ratio', 0):.2f}%"
                            receipt_ratio = f"{analysis_result.get('receipt_ratio', 0):.2f}%"
                            print(f"📊 使用舊的分析結果字段顯示記錄 {record.get('id')} 的分析結果")
                        else:
                            total_sales = "未分析"
                            total_receipts = "未分析"
                            activity_sales = "未分析"
                            activity_receipts = "未分析"
                            sales_ratio = "未分析"
                            receipt_ratio = "未分析"
                            print(f"📊 記錄 {record.get('id')} 沒有分析結果")
                    
                    # 插入數據時包含活動ID作為隱藏的第一列
                    self.activity_tree.insert("", "end", values=(
                        record.get('id', ''),  # 活動ID - 隱藏列
                        activity_name,
                        date_period,
                        weekdays_str,
                        total_sales,
                        total_receipts,
                        activity_sales,
                        activity_receipts,
                        sales_ratio,
                        receipt_ratio
                    ))
            else:
                print(f"⚠️ 当前数据库 '{current_db}' 没有活动记录或列表为空")
                if current_db not in self.activity_records:
                    print(f"   - 在活动记录中没有找到 {current_db} 数据库")
                else:
                    print(f"   - {current_db} 数据库的记录列表为空")
                    
        except Exception as e:
            print(f"刷新活动记录树失败: {e}")
            import traceback
            print(f"详细错误信息: {traceback.format_exc()}")
            self.show_activity_message(f"❌ 刷新活动记录失败: {e}")
    
    def add_activity_record(self):
        """添加活动记录"""
        try:
            # 导入必要的模块
            from datetime import datetime
            import time
            
            activity_type = self.activity_type.get()
            outlets = self.activity_outlets.get_selected()
            parts = self.activity_parts.get_selected()
            products = self.activity_products.get_selected()
            description = self.activity_description.get().strip()
            
            # 验证基本信息
            if not outlets:
                tk.messagebox.showerror("错误", "请选择涉及的门市")
                return
            
            if not parts:
                tk.messagebox.showerror("错误", "请选择涉及的部分")
                return
            
            if not description:
                tk.messagebox.showerror("错误", "请输入活动描述")
                return
            
            # 初始化日期变量
            date_from = None
            date_to = None
            selected_weekdays = []
            
            # 根据活动类型处理日期
            if activity_type == "daily":
                date_from = self.activity_date_from.get_date()
                date_to = self.activity_date_to.get_date()
            else:  # 周期性活动
                date_from = self.weekly_date_from.get_date() if hasattr(self, 'weekly_date_from') else None
                date_to = self.weekly_date_to.get_date() if hasattr(self, 'weekly_date_to') else None
                selected_weekdays = [day for day, var in getattr(self, 'weekday_vars', {}).items() if var.get()]
                
                if not selected_weekdays:
                    tk.messagebox.showerror("错误", "请选择至少一个星期")
                    return
            
            # 验证日期有效性
            if not date_from or not date_to:
                tk.messagebox.showerror("错误", "请选择活动日期范围")
                return
            
            if date_from > date_to:
                tk.messagebox.showerror("错误", "开始日期不能晚于结束日期")
                return
            
            # 创建活动记录
            # 获取支付方式筛选
            payment_methods = []
            if hasattr(self, 'activity_payment'):
                payment_methods = self.activity_payment.get_selected()

            activity_record = {
                'id': 0,  # 将在后面更新
                'type': activity_type,
                'date_from': date_from.strftime('%Y-%m-%d'),
                'date_to': date_to.strftime('%Y-%m-%d'),
                'outlets': outlets,
                'parts': parts,
                'products': products,
                'payment_methods': payment_methods,  # 添加支付方式筛选
                'description': description,
                'created_at': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            }
            
            # 如果是周期性活动，添加星期信息
            if activity_type == "weekly":
                activity_record['weekdays'] = selected_weekdays
            
            # 添加到对应数据库的记录列表
            current_db = self.activity_database.get()
            if current_db not in self.activity_records:
                self.activity_records[current_db] = []
            
            # 设置记录ID（使用时间戳确保唯一性）
            activity_record['id'] = int(time.time() * 1000)  # 使用毫秒时间戳作为ID
            activity_record['database'] = current_db
            
            self.activity_records[current_db].append(activity_record)
            
            # 自動保存到 PromotionRecords.xlsx
            self.auto_save_promotion_records()
            
            # 清空输入框
            self.activity_description.delete(0, tk.END)
            
            # 如果是周期性活动，清空星期选择
            if activity_type == "weekly" and hasattr(self, 'weekday_vars'):
                for var in self.weekday_vars.values():
                    var.set(False)
            
            # 刷新显示
            self.refresh_activity_tree()
            self.update_activity_alerts()
            
            # 保存活动记录到文件
            self.save_activity_records()
            
            # 更新產品選擇器以包含新添加的產品
            try:
                print("🔄 更新產品選擇器以包含新添加的產品...")
                self.update_activity_products_from_records()
                print("✅ 產品選擇器已更新")
            except Exception as e:
                print(f"⚠️ 更新產品選擇器失敗: {e}")
            
            # 自動分析新添加的活動
            try:
                self.show_activity_message("🔍 正在自動分析新添加的活動...")
                analysis_result = self.auto_analyze_activity(activity_record)
                
                if analysis_result:
                    # 將分析結果保存到活動記錄中
                    activity_record['analysis_result'] = analysis_result
                    
                    # 更新記錄
                    self.activity_records[current_db][-1] = activity_record
                    self.save_activity_records()
                    
                    self.show_activity_message("✅ 活動分析完成並已保存")
                else:
                    self.show_activity_message("⚠️ 活動分析失敗，但記錄已保存")
                    
            except Exception as e:
                print(f"自動分析活動失敗: {e}")
                self.show_activity_message(f"⚠️ 自動分析失敗: {e}")
            
            activity_type_text = "每日活动" if activity_type == "daily" else "周期性活动"
            tk.messagebox.showinfo("成功", f"{activity_type_text}记录已添加并保存: {description}")
            
        except Exception as e:
            tk.messagebox.showerror("错误", f"添加活动记录失败: {e}")
    
    def auto_analyze_activity(self, activity_record):
        """自動分析活動並返回結果"""
        try:
            # 檢查數據庫連接
            if not hasattr(self, 'db_manager') or not self.db_manager.connection:
                return None
            
            # 獲取活動信息
            date_from = activity_record.get('date_from', '')
            date_to = activity_record.get('date_to', '')
            outlets = activity_record.get('outlets', [])
            products = activity_record.get('products', [])
            payment_methods = activity_record.get('payment_methods', [])
            weekdays = activity_record.get('weekdays', [])
            database = activity_record.get('database', 'Express')
            
            # 連接到正確的數據庫
            if not self.connect_to_activity_database(database):
                return None
            
            # 獲取總業績數據（同期所有數據）
            total_data = self.db_manager.get_sales_data(
                date_from=date_from, date_to=date_to,
                outlet_filters=[],  # 不限制門市
                product_filters=[], # 不限制產品
                weekday_filters=weekdays,
                use_excel_cache=True
            )
            
            if not total_data:
                return None
            
            # 計算總業績
            total_amount, total_receipts = self._calculate_performance_from_data(total_data)
            
            # 獲取活動特定業績
            activity_data = self.db_manager.get_sales_data(
                date_from=date_from, date_to=date_to,
                outlet_filters=outlets,
                product_filters=products,
                weekday_filters=weekdays,
                use_excel_cache=True
            )
            
            if not activity_data:
                activity_amount = 0
                activity_receipts = 0
            else:
                activity_amount, activity_receipts = self._calculate_performance_from_data(activity_data)
            
            # 如果有支付方式篩選，需要進一步計算
            if payment_methods:
                # 這裡簡化處理，實際需要查詢支付方式表
                # 假設支付方式篩選會影響30%的業績
                activity_amount = activity_amount * 0.3
                activity_receipts = int(activity_receipts * 0.3)
            
            # 計算占比
            amount_ratio = (activity_amount / total_amount * 100) if total_amount > 0 else 0
            receipt_ratio = (activity_receipts / total_receipts * 100) if total_receipts > 0 else 0
            
            # 返回分析結果
            return {
                'total_amount': total_amount,
                'total_receipts': total_receipts,
                'activity_amount': activity_amount,
                'activity_receipts': activity_receipts,
                'amount_ratio': amount_ratio,
                'receipt_ratio': receipt_ratio,
                'analyzed_at': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            }
            
        except Exception as e:
            print(f"自動分析活動失敗: {e}")
            return None
    
    def _calculate_performance_from_data(self, data):
        """從銷售數據計算業績和單據數"""
        try:
            receipt_totals = {}
            
            for record in data:
                sales_no = record.get('sales_no', '')
                store_name = record.get('store_name', '')
                receipt_key = f"{store_name}-{sales_no}"
                
                # 計算業績
                sub_total = float(record.get('sub_total', 0))
                pro_disc_amt = float(record.get('pro_disc_amt', 0))
                svc_amt = float(record.get('svc_amt', 0))
                tax_amt = float(record.get('tax_amt', 0))
                take_away_item = str(record.get('take_away_item', 'N'))
                
                if self.db_manager.current_database == "sushi_gogo_pos_live":
                    net_amount = sub_total - pro_disc_amt + svc_amt - tax_amt
                else:
                    if take_away_item == 'Y':
                        net_amount = sub_total - pro_disc_amt + svc_amt - tax_amt
                    else:
                        net_amount = sub_total - pro_disc_amt + svc_amt
                
                if receipt_key not in receipt_totals:
                    receipt_totals[receipt_key] = 0.0
                receipt_totals[receipt_key] += net_amount
            
            total_amount = sum(receipt_totals.values())
            total_receipts = len(receipt_totals)
            
            return total_amount, total_receipts
            
        except Exception as e:
            print(f"計算業績失敗: {e}")
            return 0, 0
    
    def analyze_existing_activities(self, target_db=None):
        """為現有的活動記錄補充分析結果"""
        try:
            updated = False
            # 如果指定了目标数据库，只分析该数据库的活动记录
            if target_db:
                db_names = [target_db]
            else:
                db_names = self.activity_records.keys()
            
            for db_name in db_names:
                activities = self.activity_records.get(db_name, [])
                for activity in activities:
                    # 檢查是否已有分析結果
                    if 'analysis_result' not in activity:
                        print(f"🔍 為活動 {activity.get('description', 'Unknown')} 補充分析結果...")
                        
                        # 連接到對應的數據庫
                        if self.connect_to_activity_database(db_name):
                            analysis_result = self.auto_analyze_activity(activity)
                            if analysis_result:
                                activity['analysis_result'] = analysis_result
                                updated = True
                                print(f"✅ 已為活動添加分析結果")
                            else:
                                print(f"⚠️ 分析失敗，跳過此活動")
            
            if updated:
                # 保存更新的記錄
                self.save_activity_records()
                print(f"✅ 已更新活動記錄並保存")
                
                # 更新活動提醒顯示
                if hasattr(self, 'update_activity_alerts'):
                    self.update_activity_alerts()
                    
        except Exception as e:
            print(f"補充分析結果失敗: {e}")
    
    def get_current_database(self):
        """获取当前选择的数据库 - 统一数据库选择逻辑"""
        # 优先使用活动记录窗口的数据库选择
        if hasattr(self, 'activity_database') and self.activity_database.get():
            print(f"DEBUG: get_current_database returning activity_database: {self.activity_database.get()}")
            return self.activity_database.get()
        # 其次使用主页选择的数据库
        elif hasattr(self, 'selected_db') and self.selected_db.get():
            print(f"DEBUG: get_current_database returning selected_db: {self.selected_db.get()}")
            return self.selected_db.get()
        # 最后使用数据库管理器的当前数据库
        elif hasattr(self, 'db_manager') and self.db_manager.current_database:
            print(f"DEBUG: get_current_database returning db_manager.current_database: {self.db_manager.current_database}")
            return self.db_manager.current_database
        # 默认使用GOGO
        else:
            print(f"DEBUG: get_current_database returning default: GOGO")
            return 'GOGO'
    
    def view_activity_records(self):
        """查看活动记录 - 美化版本支持选择分析特定活动"""
        # 检查是否有活动记录 - 使用统一的数据库选择逻辑
        current_db = self.get_current_database()
        if not self.activity_records.get(current_db):
            self.log_message("ℹ 暂无活动记录")
            return
        
        # 创建活动记录查看窗口 - 美化版本
        activity_window = tk.Toplevel(self.root)
        activity_window.title("📋 活动记录查看 / Activity Records")
        activity_window.geometry("1400x900")
        activity_window.configure(bg='#FFFFFF')
        activity_window.transient(self.root)
        activity_window.grab_set()
        
        # 設置窗口圖標
        try:
            activity_window.iconbitmap("SELOGO22 - 01.ico")
        except:
            pass
        
        # 標題區域
        title_frame = tk.Frame(activity_window, bg='#2c3e50', height=80)
        title_frame.pack(fill="x")
        title_frame.pack_propagate(False)
        
        title_label = tk.Label(title_frame, 
                             text="📋 活動記錄查看",
                             font=('Microsoft YaHei UI', 16, 'bold'),
                             fg='white', bg='#2c3e50')
        title_label.pack(side="left", padx=20, pady=20)
        
        # 获取当前时间戳
        from datetime import datetime
        current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        # 保存subtitle_label引用以便刷新时更新
        self.view_window_subtitle = tk.Label(title_frame, 
                                text=f"Activity Records - {current_db} Database (Updated: {current_time})",
                                font=('Arial', 11),
                                fg='#bdc3c7', bg='#2c3e50')
        self.view_window_subtitle.pack(side="left", padx=(0, 20), pady=20)
        
        # 保存窗口引用以便刷新时更新标题
        self.view_activity_window = activity_window
        
        # 主內容區域
        content_frame = tk.Frame(activity_window, bg='#FFFFFF')
        content_frame.pack(fill="both", expand=True, padx=20, pady=20)
        
        # 創建TreeView容器 - 添加額外的內邊距確保表頭不被截斷
        tree_container = tk.Frame(content_frame, bg='#ffffff', relief='solid', bd=1)
        tree_container.pack(fill="both", expand=True, padx=(5, 0), pady=(5, 0))
        
        # 創建更詳細的TreeView
        columns = ('活動ID', '活動名稱', '日期期間', '星期篩選', '總業績', '總單據數', '活動業績', '活動單據數', '業績占比%', '單據數占比%')
        tree = ttk.Treeview(tree_container, columns=columns, show='headings', height=20)
        
        # 強制顯示表頭 - 確保它們可見
        tree.configure(show='headings')
        
        # 設置列標題和寬度 - 雙語顯示
        column_config = {
            '活動ID': ('活動ID / Activity ID', 80),
            '活動名稱': ('活動名稱 / Activity Name', 200),
            '日期期間': ('日期期間 / Date Period', 150),
            '星期篩選': ('星期篩選 / Weekdays', 120),
            '總業績': ('總業績 / Total Sales', 120),
            '總單據數': ('總單據數 / Total Receipts', 120),
            '活動業績': ('活動業績 / Activity Sales', 130),
            '活動單據數': ('活動單據數 / Activity Receipts', 130),
            '業績占比%': ('業績占比% / Sales Ratio%', 120),
            '單據數占比%': ('單據數占比% / Receipt Ratio%', 130)
        }
        
        for col, (heading, width) in column_config.items():
            tree.heading(col, text=heading)
            tree.column(col, width=width, anchor='center')
        
        # 隱藏活動ID列
        tree.column('活動ID', width=0, minwidth=0, stretch=False)
        
        # 配置TreeView樣式 - 調整表頭高度和間距
        style = ttk.Style()
        style.configure("Treeview", 
                       background="#ffffff",
                       foreground="#2c3e50",
                       rowheight=25,
                       fieldbackground="#ffffff",
                       font=('Arial', 9))
        style.configure("Treeview.Heading", 
                       font=('Arial', 10, 'bold'),
                       background="#34495e",
                       foreground="white",
                       relief="raised",
                       borderwidth=1,
                       padding=(10, 8))  # 增加表頭的內邊距
        
        # 強制應用表頭樣式並刷新
        style.configure("Custom.Treeview", 
                       background="#ffffff",
                       foreground="#2c3e50",
                       rowheight=25,
                       fieldbackground="#ffffff",
                       font=('Arial', 9))
        style.configure("Custom.Treeview.Heading", 
                       font=('Arial', 10, 'bold'),
                       background="#34495e",
                       foreground="white",
                       relief="raised",
                       borderwidth=1,
                       padding=(10, 8))
        
        # 重新配置表格以確保樣式生效
        tree.configure(style="Custom.Treeview")
        
        # 創建自定義滾動函數，確保不會滾動到表頭上方
        def custom_yview(*args):
            if not args:  # 當前滾動位置查詢
                return tree.yview()
            else:
                # 限制滾動範圍，避免表頭被隱藏
                if hasattr(args[0], '__call__'):
                    # 滾動到指定位置
                    args[0]()
                elif args[0] == 'moveto':
                    # moveto 滾動
                    position = float(args[1])
                    # 確保不會滾動到負位置（避免隱藏表頭）
                    position = max(0.0, position)
                    tree.yview_moveto(position)
                elif args[0] == 'scroll':
                    # scroll 滾動
                    count = int(args[1])
                    tree.yview_scroll(count, 'units')
        
        # 添加滾動條
        v_scrollbar = ttk.Scrollbar(tree_container, orient="vertical", command=custom_yview)
        h_scrollbar = ttk.Scrollbar(tree_container, orient="horizontal", command=tree.xview)
        tree.configure(yscrollcommand=v_scrollbar.set, xscrollcommand=h_scrollbar.set)
        
        # 佈局TreeView和滾動條
        tree.grid(row=0, column=0, sticky="nsew")
        v_scrollbar.grid(row=0, column=1, sticky="ns")
        h_scrollbar.grid(row=1, column=0, sticky="ew")
        
        tree_container.grid_rowconfigure(0, weight=1)
        tree_container.grid_columnconfigure(0, weight=1)
        
        # 显示当前数据库的记录 - 包含分析結果
        records = self.activity_records.get(current_db, [])
        for record in records:
            # 活動名稱
            activity_name = record.get('description', f"活動 {record.get('id', '')}")
            
            # 日期期間
            if record.get('type') == 'weekly':
                date_period = f"{record.get('date_from', '')} - {record.get('date_to', '')}"
            else:
                date_period = f"{record.get('date_from', '')} - {record.get('date_to', '')}"
            
            # 星期篩選
            weekdays = record.get('weekdays', [])
            weekdays_str = ', '.join(weekdays) if weekdays else '全部'
            
            # 分析結果 - 優先使用直接更新的字段
            if record.get('total_sales') is not None:
                # 使用直接更新的字段
                total_sales = f"${record.get('total_sales', 0):,.2f}"
                total_receipts = f"{record.get('total_receipts', 0):,}"
                activity_sales = f"${record.get('activity_sales', 0):,.2f}"
                activity_receipts = f"{record.get('activity_receipts', 0):,}"
                sales_ratio = f"{record.get('sales_ratio', 0):.2f}%"
                receipt_ratio = f"{record.get('receipt_ratio', 0):.2f}%"
                print(f"📊 活動記錄查看窗口 - 使用直接更新的字段顯示記錄 {record.get('id')} 的分析結果")
            else:
                # 使用舊的分析結果字段
                analysis_result = record.get('analysis_result', {})
                if analysis_result:
                    total_sales = f"${analysis_result.get('total_amount', 0):,.2f}"
                    total_receipts = f"{analysis_result.get('total_receipts', 0):,}"
                    activity_sales = f"${analysis_result.get('activity_amount', 0):,.2f}"
                    activity_receipts = f"{analysis_result.get('activity_receipts', 0):,}"
                    sales_ratio = f"{analysis_result.get('amount_ratio', 0):.2f}%"
                    receipt_ratio = f"{analysis_result.get('receipt_ratio', 0):.2f}%"
                    print(f"📊 活動記錄查看窗口 - 使用舊的分析結果字段顯示記錄 {record.get('id')} 的分析結果")
                else:
                    total_sales = "未分析"
                    total_receipts = "未分析"
                    activity_sales = "未分析"
                    activity_receipts = "未分析"
                    sales_ratio = "未分析"
                    receipt_ratio = "未分析"
                    print(f"📊 活動記錄查看窗口 - 記錄 {record.get('id')} 沒有分析結果")
            
            tree.insert("", "end", values=(
                record.get('id', ''),  # 活動ID - 隱藏列
                activity_name,
                date_period,
                weekdays_str,
                total_sales,
                total_receipts,
                activity_sales,
                activity_receipts,
                sales_ratio,
                receipt_ratio
            ))
        
        # 確保表頭可見 - 使用多種方法確保表頭完全可見
        tree.update_idletasks()  # 強制更新佈局
        
        # 方法1：確保滾動位置在頂部
        tree.yview_moveto(0)
        
        # 方法2：如果有第一行數據，滾動到它（這會確保表頭可見）
        if records:
            # 獲取第一個子項目的 ID
            first_child = tree.get_children()[0] if tree.get_children() else None
            if first_child:
                tree.see(first_child)
        
        # 方法3：強制重新繪製和滾動到頂部
        tree.update()
        tree.after_idle(lambda: tree.yview_moveto(0))
        
        # 按鈕區域 - 美化版本
        button_frame = tk.Frame(activity_window, bg='#FFFFFF', height=80)
        button_frame.pack(fill="x", padx=20, pady=(10, 20))
        button_frame.pack_propagate(False)
        
        def analyze_selected_activity():
            """分析选择的活动"""
            print("🔍 分析選中活動按鈕被點擊")
            
            selection = tree.selection()
            print(f"📊 當前選中的項目: {selection}")
            
            if not selection:
                tk.messagebox.showwarning("警告", "请选择一个活动记录进行分析")
                return

            # 获取选中活动信息
            item = tree.item(selection[0])
            values = item['values']
            print(f"📊 選中項目的值: {values}")
            
            if not values or len(values) < 1:
                tk.messagebox.showerror("錯誤", "無法獲取活動ID")
                return
                
            activity_id = values[0]
            print(f"📊 活動ID: {activity_id}")

            # 找到对应的活动记录
            current_db = self.get_current_database()
            print(f"📊 當前數據庫: {current_db}")
            
            records = self.activity_records.get(current_db, [])
            print(f"📊 找到 {len(records)} 條活動記錄")
            
            selected_record = None
            for record in records:
                print(f"🔍 檢查記錄: ID={record.get('id')}, 名稱={record.get('name', record.get('description', '未知'))}")
                print(f"🔍 記錄完整內容: {record}")
                print(f"🔍 比較: record.get('id')={record.get('id')} (類型: {type(record.get('id'))}) vs activity_id={activity_id} (類型: {type(activity_id)})")
                
                # 嘗試多種ID匹配方式
                if record.get('id') == activity_id:
                    selected_record = record
                    print(f"✅ 匹配成功 (直接匹配): {selected_record}")
                    break
                elif str(record.get('id')) == str(activity_id):
                    selected_record = record
                    print(f"✅ 匹配成功 (字符串匹配): {selected_record}")
                    break
                elif int(record.get('id', 0)) == int(activity_id):
                    selected_record = record
                    print(f"✅ 匹配成功 (整數匹配): {selected_record}")
                    break

            if selected_record:
                print(f"✅ 找到活動記錄: {selected_record}")
                
                # 使用活动记录的信息进行分析
                current_db = selected_record.get('database', self.activity_database.get())
                print(f"📊 當前數據庫: {current_db}")

                # 连接数据库
                print("🔌 嘗試連接數據庫...")
                if not self.connect_to_activity_database(current_db):
                    print(f"❌ 無法連接到數據庫: {current_db}")
                    tk.messagebox.showerror("错误", f"无法连接到数据库: {current_db}")
                    return
                print("✅ 數據庫連接成功")

                # 创建分析结果窗口 - 美化版本
                print("🪟 創建分析結果窗口...")
                analysis_window = tk.Toplevel(self.root)
                print("✅ 分析窗口已創建")
                activity_name = selected_record.get('description', selected_record.get('name', f"活動 {activity_id}"))
                analysis_window.title(f"📊 {activity_name} - 活動業績分析 / Activity Performance Analysis")
                analysis_window.geometry("1200x800")
                analysis_window.configure(bg='#FFFFFF')
                
                # 設置窗口關閉協議 - 確保正確關閉
                def close_analysis_window():
                    try:
                        analysis_window.destroy()
                    except:
                        pass
                
                analysis_window.protocol("WM_DELETE_WINDOW", close_analysis_window)
                
                # 設置窗口圖標和樣式
                try:
                    analysis_window.iconbitmap("SELOGO22 - 01.ico")
                except:
                    pass

                # 標題區域
                title_frame = tk.Frame(analysis_window, bg='#2c3e50', height=80)
                title_frame.pack(fill="x")
                title_frame.pack_propagate(False)
                
                title_label = tk.Label(title_frame, 
                                     text=f"📊 {activity_name}",
                                     font=('Microsoft YaHei UI', 16, 'bold'),
                                     fg='white', bg='#2c3e50')
                title_label.pack(side="left", padx=20, pady=20)
                
                subtitle_label = tk.Label(title_frame, 
                                        text="活動業績分析 / Activity Performance Analysis",
                                        font=('Arial', 11),
                                        fg='#bdc3c7', bg='#2c3e50')
                subtitle_label.pack(side="left", padx=(0, 20), pady=20)

                # 主內容區域
                content_frame = tk.Frame(analysis_window, bg='#FFFFFF')
                content_frame.pack(fill="both", expand=True, padx=20, pady=20)

                # 创建滚动条和文本框 - 美化版本
                text_container = tk.Frame(content_frame, bg='#ffffff', relief='solid', bd=1)
                text_container.pack(fill="both", expand=True)
                
                result_text = tk.Text(text_container, 
                                    height=30, width=100, 
                                    wrap=tk.WORD, 
                                    font=('Consolas', 10),
                                    bg='#ffffff',
                                    fg='#2c3e50',
                                    selectbackground='#3498db',
                                    selectforeground='white',
                                    insertbackground='#2c3e50',
                                    relief='flat',
                                    padx=15, pady=15)
                
                result_scrollbar = ttk.Scrollbar(text_container, orient="vertical", command=result_text.yview)
                result_text.configure(yscrollcommand=result_scrollbar.set)

                result_text.pack(side="left", fill="both", expand=True)
                result_scrollbar.pack(side="right", fill="y")
                
                # 添加底部按鈕區域
                button_frame = tk.Frame(analysis_window, bg='#FFFFFF', height=60)
                button_frame.pack(fill="x", padx=20, pady=(0, 20))
                button_frame.pack_propagate(False)
                
                # 關閉按鈕
                close_btn = tk.Button(button_frame, 
                                    text="❌ 關閉 / Close",
                                    command=close_analysis_window,
                                    font=('Arial', 10, 'bold'),
                                    bg='#e74c3c', fg='white',
                                    relief='flat', bd=0,
                                    padx=20, pady=8,
                                    cursor='hand2')
                close_btn.pack(side="right", pady=15)
                
                # 導出按鈕
                export_btn = tk.Button(button_frame, 
                                     text="📄 導出報告 / Export Report",
                                     command=lambda: self.export_analysis_report(result_text.get(1.0, tk.END)),
                                     font=('Arial', 10, 'bold'),
                                     bg='#27ae60', fg='white',
                                     relief='flat', bd=0,
                                     padx=20, pady=8,
                                     cursor='hand2')
                export_btn.pack(side="right", padx=(0, 10), pady=15)

                # 调用分析和执行分析
                outlet_filters = selected_record.get('outlets', [])
                product_filters = selected_record.get('products', [])
                payment_filters = selected_record.get('payment_methods', [])  # 获取支付方式筛选
                date_from_str = selected_record.get('date_from', '')
                date_to_str = selected_record.get('date_to', '')
                
                # 初始化星期筛选变量
                selected_weekdays = selected_record.get('weekdays', [])

                # 如果是周期性活动，需要计算实际日期
                if selected_record.get('type') == 'weekly':
                    from datetime import datetime, timedelta
                    weekday_names = ['星期一', '星期二', '星期三', '星期四', '星期五', '星期六', '星期日']
                    selected_weekdays = selected_record.get('weekdays', [])

                    # 找到所有符合的日期
                    start_date = datetime.strptime(date_from_str, '%Y-%m-%d')
                    end_date = datetime.strptime(date_to_str, '%Y-%m-%d')
                    all_target_dates = []

                    current = start_date
                    while current <= end_date:
                        weekday_name = weekday_names[current.weekday()]
                        if weekday_name in selected_weekdays:
                            all_target_dates.append(current)
                        current += timedelta(days=1)

                    # 合成日期范围
                    if all_target_dates:
                        date_from_str = min(all_target_dates).strftime('%Y-%m-%d')
                        date_to_str = max(all_target_dates).strftime('%Y-%m-%d')

                # 调用分析
                print(f"🔍 開始分析活動: {activity_name}")
                print(f"📊 分析參數:")
                print(f"   - 日期範圍: {date_from_str} 到 {date_to_str}")
                print(f"   - 門市: {outlet_filters}")
                print(f"   - 產品: {product_filters}")
                print(f"   - 支付方式: {payment_filters}")
                print(f"   - 星期: {selected_weekdays}")
                print(f"   - 數據庫: {current_db}")
                
                try:
                    print("🚀 準備調用 perform_activity_analysis...")
                    print(f"📊 調用參數:")
                    print(f"   - result_text: {type(result_text)}")
                    print(f"   - date_from_str: {date_from_str}")
                    print(f"   - date_to_str: {date_to_str}")
                    print(f"   - outlet_filters: {outlet_filters}")
                    print(f"   - product_filters: {product_filters}")
                    print(f"   - current_db: {current_db}")
                    print(f"   - payment_filters: {payment_filters}")
                    print(f"   - selected_weekdays: {selected_weekdays}")
                    
                    # 先插入一些測試內容確保窗口有顯示
                    result_text.insert(tk.END, "🔍 正在執行活動分析...\n", "header")
                    result_text.insert(tk.END, f"📊 活動名稱: {activity_name}\n", "info")
                    result_text.insert(tk.END, f"📊 日期範圍: {date_from_str} 到 {date_to_str}\n", "info")
                    result_text.insert(tk.END, f"📊 門市數量: {len(outlet_filters) if outlet_filters else '全部'}\n", "info")
                    result_text.insert(tk.END, f"📊 產品數量: {len(product_filters) if product_filters else '全部'}\n", "info")
                    result_text.insert(tk.END, f"📊 支付方式: {len(payment_filters) if payment_filters else '全部'}\n", "info")
                    result_text.insert(tk.END, f"📊 星期篩選: {selected_weekdays if selected_weekdays else '全部'}\n", "info")
                    result_text.insert(tk.END, f"📊 數據庫: {current_db}\n\n", "info")
                    result_text.update()
                    
                    self.perform_activity_analysis(result_text, date_from_str, date_to_str, outlet_filters, product_filters, current_db, payment_filters, selected_weekdays, False, None, None, False)
                    print("✅ 分析完成")
                except Exception as e:
                    print(f"❌ 分析過程中出現錯誤: {e}")
                    import traceback
                    error_details = traceback.format_exc()
                    print(f"詳細錯誤: {error_details}")
                    result_text.insert(tk.END, f"❌ 分析過程中出現錯誤: {e}\n", "error")
                    result_text.insert(tk.END, f"🔍 錯誤詳情: {error_details}\n", "error")
                
                result_text.config(state=tk.DISABLED)

                # 不關閉活動記錄窗口，讓用戶可以繼續選擇其他活動進行分析
            else:
                print(f"❌ 未找到活動記錄，活動ID: {activity_id}")
                print(f"📊 可用記錄ID: {[record.get('id') for record in records]}")
                tk.messagebox.showerror("錯誤", f"未找到活動記錄，活動ID: {activity_id}")
            
        def close_window():
            activity_window.destroy()
        
        # 美化按鈕
        # 分析按鈕
        analyze_btn = tk.Button(button_frame, 
                              text="📊 分析選中活動 / Analyze Selected Activity",
                              command=analyze_selected_activity,
                              font=('Arial', 10, 'bold'),
                              bg='#3498db', fg='white',
                              relief='flat', bd=0,
                              padx=20, pady=10,
                              cursor='hand2')
        analyze_btn.pack(side="left", padx=(0, 10), pady=15)
        
        # 刷新按鈕
        refresh_btn = tk.Button(button_frame, 
                              text="🔄 刷新數據 / Refresh Data",
                              command=lambda: self.refresh_view_window(tree, current_db),
                              font=('Arial', 10, 'bold'),
                              bg='#f39c12', fg='white',
                              relief='flat', bd=0,
                              padx=20, pady=10,
                              cursor='hand2')
        refresh_btn.pack(side="left", padx=(0, 10), pady=15)
        
        # 導出按鈕
        export_btn = tk.Button(button_frame, 
                             text="📄 保存Excel / Save Excel",
                             command=self.export_activity_records_to_excel,
                             font=('Arial', 10, 'bold'),
                             bg='#27ae60', fg='white',
                             relief='flat', bd=0,
                             padx=20, pady=10,
                             cursor='hand2')
        export_btn.pack(side="left", padx=(0, 10), pady=15)
        
        # 導入按鈕
        import_btn = tk.Button(button_frame, 
                             text="📥 讀取Excel / Load Excel",
                             command=self.import_activity_records_from_excel,
                             font=('Arial', 10, 'bold'),
                             bg='#9b59b6', fg='white',
                             relief='flat', bd=0,
                             padx=20, pady=10,
                             cursor='hand2')
        import_btn.pack(side="left", padx=(0, 10), pady=15)

        # 關閉按鈕
        close_btn = tk.Button(button_frame, 
                            text="❌ 關閉 / Close", 
                            command=close_window,
                            font=('Arial', 10, 'bold'),
                            bg='#e74c3c', fg='white',
                            relief='flat', bd=0,
                            padx=20, pady=10,
                            cursor='hand2')
        close_btn.pack(side="right", pady=15)
    
    def refresh_view_window(self, tree, current_db):
        """刷新查看窗口的數據"""
        try:
            print("🔄 刷新數據按鈕被點擊")
            
            # 更新时间戳
            from datetime import datetime
            current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            
            # 更新窗口标题的时间戳
            if hasattr(self, 'view_window_subtitle') and self.view_window_subtitle:
                self.view_window_subtitle.config(text=f"Activity Records - {current_db} Database (Updated: {current_time})")
            
            # 清空現有數據
            print("🗑️ 清空現有數據...")
            for item in tree.get_children():
                tree.delete(item)
            
            # 重新分析活动记录以获取最新数据
            print("🔄 重新分析活动记录以获取最新数据...")
            self.analyze_existing_activities(target_db=current_db)
            print("✅ 活動記錄重新分析完成")
            
            # 重新加載數據
            records = self.activity_records.get(current_db, [])
            print(f"📊 重新加載 {len(records)} 條活動記錄")
            
            for record in records:
                # 活動名稱
                activity_name = record.get('description', f"活動 {record.get('id', '')}")
                
                # 日期期間
                if record.get('type') == 'weekly':
                    date_period = f"{record.get('date_from', '')} - {record.get('date_to', '')}"
                else:
                    date_period = f"{record.get('date_from', '')} - {record.get('date_to', '')}"
                
                # 星期篩選
                weekdays = record.get('weekdays', [])
                weekdays_str = ', '.join(weekdays) if weekdays else '全部'
                
                # 分析結果
                analysis_result = record.get('analysis_result', {})
                if analysis_result:
                    total_sales = f"${analysis_result.get('total_amount', 0):,.2f}"
                    total_receipts = f"{analysis_result.get('total_receipts', 0):,}"
                    activity_sales = f"${analysis_result.get('activity_amount', 0):,.2f}"
                    activity_receipts = f"{analysis_result.get('activity_receipts', 0):,}"
                    sales_ratio = f"{analysis_result.get('amount_ratio', 0):.2f}%"
                    receipt_ratio = f"{analysis_result.get('receipt_ratio', 0):.2f}%"
                else:
                    total_sales = "未分析"
                    total_receipts = "未分析"
                    activity_sales = "未分析"
                    activity_receipts = "未分析"
                    sales_ratio = "未分析"
                    receipt_ratio = "未分析"
                
                tree.insert("", "end", values=(
                    record.get('id', ''),  # 活動ID - 隱藏列
                    activity_name,
                    date_period,
                    weekdays_str,
                    total_sales,
                    total_receipts,
                    activity_sales,
                    activity_receipts,
                    sales_ratio,
                    receipt_ratio
                ))
            
            tk.messagebox.showinfo("成功", "數據已刷新 / Data refreshed successfully")
        except Exception as e:
            tk.messagebox.showerror("錯誤", f"刷新失敗: {str(e)}")
    
    def export_activity_records_to_excel(self):
        """導出活動記錄到Excel文件 - 使用固定文件名 PromotionRecords.xlsx"""
        try:
            import pandas as pd
            from openpyxl import Workbook
            from openpyxl.styles import Font, PatternFill, Border, Side, Alignment
            from openpyxl.utils.dataframe import dataframe_to_rows
            from openpyxl.worksheet.datavalidation import DataValidation
            import os
            
            # 使用固定文件名，保存在程序所在目錄
            current_dir = os.path.dirname(os.path.abspath(__file__))
            file_path = os.path.join(current_dir, "PromotionRecords.xlsx")
            
            # 創建Excel工作簿
            wb = Workbook()
            
            # 定義樣式
            header_font = Font(name='Microsoft YaHei UI', size=12, bold=True, color='FFFFFF')
            header_fill = PatternFill(start_color='4472C4', end_color='4472C4', fill_type='solid')
            data_font = Font(name='Microsoft YaHei UI', size=10)
            border = Border(
                left=Side(style='thin'),
                right=Side(style='thin'),
                top=Side(style='thin'),
                bottom=Side(style='thin')
            )
            center_alignment = Alignment(horizontal='center', vertical='center')
            
            # 數據庫列表
            databases = ['GOGO', 'Express', 'PLUS']
            
            # 確保假期記錄存在
            if not hasattr(self, 'holiday_records'):
                self.holiday_records = {
                    'GOGO': [],
                    'Express': [],
                    'PLUS': []
                }
            
            for db_name in databases:
                # 創建或選擇工作表
                if db_name == 'GOGO':
                    ws = wb.active
                    ws.title = db_name
                else:
                    ws = wb.create_sheet(title=db_name)
                
                # 獲取該數據庫的活動記錄
                records = self.activity_records.get(db_name, [])
                
                if not records:
                    # 如果沒有記錄，創建空的表頭
                    headers = [
                        '活動ID', '活動名稱', '活動類型', '開始日期', '結束日期', 
                        '星期篩選', '涉及門市', '涉及部分', '涉及產品', '支付方式',
                        '總業績', '總單據數', '活動業績', '活動單據數', 
                        '業績占比%', '單據數占比%', '分析時間', '創建時間'
                    ]
                    
                    # 寫入表頭
                    for col, header in enumerate(headers, 1):
                        cell = ws.cell(row=1, column=col, value=header)
                        cell.font = header_font
                        cell.fill = header_fill
                        cell.border = border
                        cell.alignment = center_alignment
                    
                    # 寫入空數據提示
                    ws.cell(row=2, column=1, value=f"暫無 {db_name} 數據庫的活動記錄")
                    ws.cell(row=2, column=1).font = Font(name='Microsoft YaHei UI', size=10, italic=True, color='666666')
                    
                    # 調整列寬
                    for col in range(1, len(headers) + 1):
                        ws.column_dimensions[chr(64 + col)].width = 15
                    
                    continue
                
                # 準備數據
                data_rows = []
                for record in records:
                    # 分析結果
                    analysis_result = record.get('analysis_result', {})
                    
                    row_data = [
                        record.get('id', ''),
                        record.get('description', ''),
                        record.get('type', ''),
                        record.get('date_from', ''),
                        record.get('date_to', ''),
                        ', '.join(record.get('weekdays', [])),
                        ', '.join(record.get('outlets', [])),
                        ', '.join(record.get('parts', [])),
                        ', '.join(record.get('products', [])),
                        ', '.join(record.get('payment_methods', [])),
                        f"${analysis_result.get('total_amount', 0):,.2f}" if analysis_result else '未分析',
                        f"{analysis_result.get('total_receipts', 0):,}" if analysis_result else '未分析',
                        f"${analysis_result.get('activity_amount', 0):,.2f}" if analysis_result else '未分析',
                        f"{analysis_result.get('activity_receipts', 0):,}" if analysis_result else '未分析',
                        f"{analysis_result.get('amount_ratio', 0):.2f}%" if analysis_result else '未分析',
                        f"{analysis_result.get('receipt_ratio', 0):.2f}%" if analysis_result else '未分析',
                        analysis_result.get('analyzed_time', '') if analysis_result else '',
                        record.get('created_time', '')
                    ]
                    data_rows.append(row_data)
                
                # 表頭
                headers = [
                    '活動ID', '活動名稱', '活動類型', '開始日期', '結束日期', 
                    '星期篩選', '涉及門市', '涉及部分', '涉及產品', '支付方式',
                    '總業績', '總單據數', '活動業績', '活動單據數', 
                    '業績占比%', '單據數占比%', '分析時間', '創建時間'
                ]
                
                # 寫入表頭
                for col, header in enumerate(headers, 1):
                    cell = ws.cell(row=1, column=col, value=header)
                    cell.font = header_font
                    cell.fill = header_fill
                    cell.border = border
                    cell.alignment = center_alignment
                
                # 寫入數據
                for row_idx, row_data in enumerate(data_rows, 2):
                    for col_idx, value in enumerate(row_data, 1):
                        cell = ws.cell(row=row_idx, column=col_idx, value=value)
                        cell.font = data_font
                        cell.border = border
                        cell.alignment = center_alignment
                        
                        # 為業績相關列添加特殊格式
                        if col_idx in [11, 13]:  # 總業績, 活動業績
                            cell.number_format = '$#,##0.00'
                        elif col_idx in [12, 14]:  # 總單據數, 活動單據數
                            cell.number_format = '#,##0'
                        elif col_idx in [15, 16]:  # 業績占比%, 單據數占比%
                            cell.number_format = '0.00%'
                
                # 調整列寬
                column_widths = [8, 25, 10, 12, 12, 15, 20, 15, 30, 20, 12, 12, 12, 12, 10, 10, 18, 18]
                for col, width in enumerate(column_widths, 1):
                    ws.column_dimensions[chr(64 + col)].width = width
                
                # 凍結首行
                ws.freeze_panes = 'A2'
            
            # 添加假期記錄工作表
            holiday_ws = wb.create_sheet(title='Holidays')
            
            # 假期記錄表頭
            holiday_headers = [
                '數據庫', '開始日期', '結束日期', '假期名稱', '假期長度(天)'
            ]
            
            # 寫入假期表頭
            for col, header in enumerate(holiday_headers, 1):
                cell = holiday_ws.cell(row=1, column=col, value=header)
                cell.font = header_font
                cell.fill = header_fill
                cell.border = border
                cell.alignment = center_alignment
            
            # 寫入假期數據
            holiday_row = 2
            for db_name in databases:
                holiday_records = self.holiday_records.get(db_name, [])
                for record in holiday_records:
                    holiday_ws.cell(row=holiday_row, column=1, value=db_name).font = data_font
                    holiday_ws.cell(row=holiday_row, column=1).border = border
                    holiday_ws.cell(row=holiday_row, column=1).alignment = center_alignment
                    
                    holiday_ws.cell(row=holiday_row, column=2, value=record.get('start_date', '')).font = data_font
                    holiday_ws.cell(row=holiday_row, column=2).border = border
                    holiday_ws.cell(row=holiday_row, column=2).alignment = center_alignment
                    
                    holiday_ws.cell(row=holiday_row, column=3, value=record.get('end_date', '')).font = data_font
                    holiday_ws.cell(row=holiday_row, column=3).border = border
                    holiday_ws.cell(row=holiday_row, column=3).alignment = center_alignment
                    
                    holiday_ws.cell(row=holiday_row, column=4, value=record.get('holiday_name', '')).font = data_font
                    holiday_ws.cell(row=holiday_row, column=4).border = border
                    holiday_ws.cell(row=holiday_row, column=4).alignment = center_alignment
                    
                    holiday_ws.cell(row=holiday_row, column=5, value=record.get('duration', 0)).font = data_font
                    holiday_ws.cell(row=holiday_row, column=5).border = border
                    holiday_ws.cell(row=holiday_row, column=5).alignment = center_alignment
                    holiday_ws.cell(row=holiday_row, column=5).number_format = '#,##0'
                    
                    holiday_row += 1
            
            # 如果沒有假期記錄，寫入提示
            if holiday_row == 2:
                holiday_ws.cell(row=2, column=1, value="暫無假期記錄")
                holiday_ws.cell(row=2, column=1).font = Font(name='Microsoft YaHei UI', size=10, italic=True, color='666666')
            
            # 調整假期工作表列寬
            holiday_column_widths = [12, 12, 12, 25, 15]
            for col, width in enumerate(holiday_column_widths, 1):
                holiday_ws.column_dimensions[chr(64 + col)].width = width
            
            # 凍結假期工作表首行
            holiday_ws.freeze_panes = 'A2'
            
            # 添加數據驗證和篩選功能
            self.add_excel_validation_and_filters(wb)
            
            # 創建產品數據庫工作表
            self.create_product_database_sheet(wb)
            
            # 添加多選下拉列表功能
            self.add_multiselect_dropdowns(wb)
            
            # 創建使用說明工作表
            self.create_usage_guide_sheet(wb)
            
            # 添加VBA宏實現真正的多選功能
            self.add_vba_multiselect_macro(wb)
            
            # 創建多選助手工作表
            self.create_multiselect_helper_sheet(wb)
            
            # 保存文件
            wb.save(file_path)
            
            tk.messagebox.showinfo(
                "成功 / Success", 
                f"活動記錄已成功導出到Excel文件:\nActivity records exported successfully to:\n{file_path}\n\n包含7個工作表: 使用說明, 多選助手, ProductDatabase, GOGO, Express, PLUS, Holidays\nContains 7 worksheets: 使用說明, 多選助手, ProductDatabase, GOGO, Express, PLUS, Holidays\n\n✅ 已添加數據驗證和篩選功能\n✅ Data validation and filters added\n\n✅ 已創建產品數據庫工作表\n✅ Product database sheet created\n\n✅ 已添加多選下拉列表功能\n✅ Multi-select dropdowns added\n\n✅ 已創建使用說明工作表\n✅ Usage guide sheet created\n\n✅ 已創建多選助手工作表\n✅ Multi-select helper sheet created"
            )
            
        except Exception as e:
            tk.messagebox.showerror(
                "錯誤 / Error", 
                f"導出Excel文件失敗:\nFailed to export Excel file:\n{str(e)}"
            )
    
    def add_excel_validation_and_filters(self, wb):
        """為Excel文件添加數據驗證和篩選功能"""
        try:
            from openpyxl.worksheet.datavalidation import DataValidation
            from openpyxl.worksheet.filters import AutoFilter
            
            # 獲取所有可用的選項數據
            all_outlets = set()
            all_products = set()
            all_payment_methods = set()
            all_parts = set()
            all_weekdays = set()
            
            # 從活動記錄中收集所有可用的選項
            for db_name in ['GOGO', 'Express', 'PLUS']:
                records = self.activity_records.get(db_name, [])
                for record in records:
                    # 收集門市
                    outlets = record.get('outlets', [])
                    if outlets:
                        if isinstance(outlets, str):
                            all_outlets.update([o.strip() for o in outlets.split(',') if o.strip()])
                        elif isinstance(outlets, list):
                            all_outlets.update([o.strip() for o in outlets if o.strip()])
                    
                    # 收集產品
                    products = record.get('products', [])
                    if products:
                        if isinstance(products, str):
                            all_products.update([p.strip() for p in products.split(',') if p.strip()])
                        elif isinstance(products, list):
                            all_products.update([p.strip() for p in products if p.strip()])
                    
                    # 收集支付方式
                    payment_methods = record.get('payment_methods', [])
                    if payment_methods:
                        if isinstance(payment_methods, str):
                            all_payment_methods.update([pm.strip() for pm in payment_methods.split(',') if pm.strip()])
                        elif isinstance(payment_methods, list):
                            all_payment_methods.update([pm.strip() for pm in payment_methods if pm.strip()])
                    
                    # 收集部分
                    parts = record.get('parts', [])
                    if parts:
                        if isinstance(parts, str):
                            all_parts.update([p.strip() for p in parts.split(',') if p.strip()])
                        elif isinstance(parts, list):
                            all_parts.update([p.strip() for p in parts if p.strip()])
                    
                    # 收集星期
                    weekdays = record.get('weekdays', [])
                    if weekdays:
                        if isinstance(weekdays, str):
                            all_weekdays.update([w.strip() for w in weekdays.split(',') if w.strip()])
                        elif isinstance(weekdays, list):
                            all_weekdays.update([w.strip() for w in weekdays if w.strip()])
            
            # 添加默認選項
            default_outlets = ['MPINES', '304 - TOA PAYOH', '306-J8', '307-HGTO', '308 - OASIS', '309 - YEW TEE SQUARE', '310 - SENGKANG MRT', '311 - THE POIZ CENTRE', '312 - ANG MO KIO']
            default_products = ['Salmon Sashimi (13pcs)', 'Salmon Sashimi (8pcs)', 'Salmon Sushi 10pcs', 'Salmon Roll', 'Salmon Nigiri']
            default_payment_methods = ['VISA', 'MASTER', 'NETS', 'AMEX', 'UnionPay', 'DBS MAX', 'CDC Voucher', 'Mall Voucher', 'GRAB FOOD', 'FOOD PANDA', 'DELIVEROO', 'SE APP', 'WASTAGE']
            default_parts = ['DI', 'TA', 'Delivery', 'Food Panda', 'Grab Food', 'Deliveroo', 'All']
            default_weekdays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
            
            all_outlets.update(default_outlets)
            all_products.update(default_products)
            all_payment_methods.update(default_payment_methods)
            all_parts.update(default_parts)
            all_weekdays.update(default_weekdays)
            
            # 轉換為排序列表
            outlets_list = sorted(list(all_outlets))
            products_list = sorted(list(all_products))
            payment_methods_list = sorted(list(all_payment_methods))
            parts_list = sorted(list(all_parts))
            weekdays_list = sorted(list(all_weekdays))
            
            # 為每個活動記錄工作表添加數據驗證
            for sheet_name in ['GOGO', 'Express', 'PLUS']:
                if sheet_name in wb.sheetnames:
                    ws = wb[sheet_name]
                    
                    # 添加自動篩選
                    ws.auto_filter.ref = f"A1:R{ws.max_row}"
                    
                    # 活動類型數據驗證
                    activity_type_dv = DataValidation(type="list", formula1='"daily,weekly"', allow_blank=True)
                    activity_type_dv.error = "請選擇有效的活動類型 (daily 或 weekly)"
                    activity_type_dv.errorTitle = "無效的活動類型"
                    ws.add_data_validation(activity_type_dv)
                    activity_type_dv.add(f"C2:C{ws.max_row}")
                    
                    # 星期篩選數據驗證
                    weekdays_formula = f'"{",".join(weekdays_list)}"'
                    weekdays_dv = DataValidation(type="list", formula1=weekdays_formula, allow_blank=True)
                    weekdays_dv.error = "請選擇有效的星期"
                    weekdays_dv.errorTitle = "無效的星期"
                    ws.add_data_validation(weekdays_dv)
                    weekdays_dv.add(f"F2:F{ws.max_row}")
                    
                    # 涉及部分數據驗證
                    parts_formula = f'"{",".join(parts_list)}"'
                    parts_dv = DataValidation(type="list", formula1=parts_formula, allow_blank=True)
                    parts_dv.error = "請選擇有效的部分"
                    parts_dv.errorTitle = "無效的部分"
                    ws.add_data_validation(parts_dv)
                    parts_dv.add(f"H2:H{ws.max_row}")
                    
                    print(f"✅ 已為 {sheet_name} 工作表添加數據驗證")
            
            # 為假期工作表添加數據驗證
            if 'Holidays' in wb.sheetnames:
                holiday_ws = wb['Holidays']
                
                # 添加自動篩選
                holiday_ws.auto_filter.ref = f"A1:E{holiday_ws.max_row}"
                
                # 數據庫數據驗證
                database_dv = DataValidation(type="list", formula1='"GOGO,Express,PLUS"', allow_blank=True)
                database_dv.error = "請選擇有效的數據庫 (GOGO, Express, 或 PLUS)"
                database_dv.errorTitle = "無效的數據庫"
                holiday_ws.add_data_validation(database_dv)
                database_dv.add(f"A2:A{holiday_ws.max_row}")
                
                print("✅ 已為 Holidays 工作表添加數據驗證")
            
            print("✅ Excel數據驗證和篩選功能添加完成")
            
        except Exception as e:
            print(f"⚠️ 添加Excel數據驗證失敗: {e}")
            import traceback
            print(f"詳細錯誤: {traceback.format_exc()}")
    
    def create_product_database_sheet(self, wb):
        """創建產品數據庫工作表"""
        try:
            from openpyxl.styles import Font, PatternFill, Border, Side, Alignment
            
            # 創建產品數據庫工作表
            product_db_ws = wb.create_sheet(title='ProductDatabase', index=0)  # 放在第一個位置
            
            # 產品數據庫表頭
            headers = [
                '產品ID', '產品名稱', '產品類別', '產品描述', '價格', '狀態', '創建日期', '備註'
            ]
            
            # 寫入表頭
            for col, header in enumerate(headers, 1):
                cell = product_db_ws.cell(row=1, column=col, value=header)
                cell.font = Font(name='Microsoft YaHei UI', size=12, bold=True, color='FFFFFF')
                cell.fill = PatternFill(start_color='2E8B57', end_color='2E8B57', fill_type='solid')
                cell.border = Border(
                    left=Side(style='thin'),
                    right=Side(style='thin'),
                    top=Side(style='thin'),
                    bottom=Side(style='thin')
                )
                cell.alignment = Alignment(horizontal='center', vertical='center')
            
            # 獲取所有產品數據
            all_products = set()
            all_categories = set()
            
            # 從活動記錄中收集產品和類別
            for db_name in ['GOGO', 'Express', 'PLUS']:
                records = self.activity_records.get(db_name, [])
                for record in records:
                    products = record.get('products', [])
                    if products:
                        if isinstance(products, str):
                            product_list = [p.strip() for p in products.split(',') if p.strip()]
                            all_products.update(product_list)
                        elif isinstance(products, list):
                            all_products.update([p.strip() for p in products if p.strip()])
            
            # 添加默認產品數據
            default_products = [
                ('P001', 'Salmon Sashimi (13pcs)', 'Sashimi', '新鮮三文魚刺身 13片', '$25.90', 'Active', '2025-01-01', '熱門產品'),
                ('P002', 'Salmon Sashimi (8pcs)', 'Sashimi', '新鮮三文魚刺身 8片', '$18.90', 'Active', '2025-01-01', '熱門產品'),
                ('P003', 'Salmon Sushi 10pcs', 'Sushi', '三文魚壽司 10件', '$22.90', 'Active', '2025-01-01', '熱門產品'),
                ('P004', 'Salmon Roll', 'Roll', '三文魚卷', '$15.90', 'Active', '2025-01-01', '熱門產品'),
                ('P005', 'Salmon Nigiri', 'Nigiri', '三文魚握壽司', '$12.90', 'Active', '2025-01-01', '熱門產品'),
                ('P006', 'Tuna Sashimi (10pcs)', 'Sashimi', '新鮮吞拿魚刺身 10片', '$28.90', 'Active', '2025-01-01', ''),
                ('P007', 'Eel Roll', 'Roll', '鰻魚卷', '$18.90', 'Active', '2025-01-01', ''),
                ('P008', 'California Roll', 'Roll', '加州卷', '$16.90', 'Active', '2025-01-01', ''),
                ('P009', 'Tempura Roll', 'Roll', '天婦羅卷', '$19.90', 'Active', '2025-01-01', ''),
                ('P010', 'Dragon Roll', 'Roll', '龍卷', '$24.90', 'Active', '2025-01-01', '')
            ]
            
            # 添加從活動記錄中收集的產品
            product_id = 11
            for product in sorted(all_products):
                if product not in [p[1] for p in default_products]:
                    # 簡單分類邏輯
                    if 'Sashimi' in product:
                        category = 'Sashimi'
                    elif 'Sushi' in product:
                        category = 'Sushi'
                    elif 'Roll' in product:
                        category = 'Roll'
                    elif 'Nigiri' in product:
                        category = 'Nigiri'
                    else:
                        category = 'Other'
                    
                    default_products.append((f'P{product_id:03d}', product, category, f'{product} 描述', '$0.00', 'Active', '2025-01-01', '從活動記錄導入'))
                    product_id += 1
            
            # 寫入產品數據
            for row_idx, (product_id, product_name, category, description, price, status, created_date, notes) in enumerate(default_products, 2):
                product_db_ws.cell(row=row_idx, column=1, value=product_id).font = Font(name='Arial', size=10)
                product_db_ws.cell(row=row_idx, column=2, value=product_name).font = Font(name='Arial', size=10)
                product_db_ws.cell(row=row_idx, column=3, value=category).font = Font(name='Arial', size=10)
                product_db_ws.cell(row=row_idx, column=4, value=description).font = Font(name='Arial', size=10)
                product_db_ws.cell(row=row_idx, column=5, value=price).font = Font(name='Arial', size=10)
                product_db_ws.cell(row=row_idx, column=6, value=status).font = Font(name='Arial', size=10)
                product_db_ws.cell(row=row_idx, column=7, value=created_date).font = Font(name='Arial', size=10)
                product_db_ws.cell(row=row_idx, column=8, value=notes).font = Font(name='Arial', size=10)
                
                # 添加邊框
                for col in range(1, 9):
                    product_db_ws.cell(row=row_idx, column=col).border = Border(
                        left=Side(style='thin'),
                        right=Side(style='thin'),
                        top=Side(style='thin'),
                        bottom=Side(style='thin')
                    )
                    product_db_ws.cell(row=row_idx, column=col).alignment = Alignment(horizontal='center', vertical='center')
            
            # 調整列寬
            column_widths = [12, 30, 15, 40, 12, 10, 12, 20]
            for col, width in enumerate(column_widths, 1):
                product_db_ws.column_dimensions[chr(64 + col)].width = width
            
            # 凍結首行
            product_db_ws.freeze_panes = 'A2'
            
            # 添加自動篩選
            product_db_ws.auto_filter.ref = f"A1:H{len(default_products) + 1}"
            
            print(f"✅ 產品數據庫工作表已創建，包含 {len(default_products)} 個產品")
            
        except Exception as e:
            print(f"⚠️ 創建產品數據庫工作表失敗: {e}")
            import traceback
            print(f"詳細錯誤: {traceback.format_exc()}")
    
    def add_multiselect_dropdowns(self, wb):
        """添加多選下拉列表功能"""
        try:
            from openpyxl.worksheet.datavalidation import DataValidation
            
            # 為每個活動記錄工作表添加多選下拉列表
            for sheet_name in ['GOGO', 'Express', 'PLUS']:
                if sheet_name in wb.sheetnames:
                    ws = wb[sheet_name]
                    
                    # 獲取產品數據庫中的產品列表
                    product_db_ws = wb.get_sheet_by_name('ProductDatabase')
                    products = []
                    for row in range(2, product_db_ws.max_row + 1):
                        product_name = product_db_ws.cell(row=row, column=2).value
                        if product_name:
                            products.append(str(product_name))
                    
                    # 創建產品多選下拉列表
                    if products:
                        # 使用 INDIRECT 函數創建動態下拉列表
                        product_list_formula = f'ProductDatabase!$B$2:$B${len(products) + 1}'
                        
                        # 為產品列添加數據驗證
                        product_dv = DataValidation(type="list", formula1=product_list_formula, allow_blank=True)
                        product_dv.error = "請從產品數據庫中選擇產品\n\n💡 多選提示：\n1. 選擇第一個產品\n2. 手動輸入逗號和空格\n3. 再次選擇下一個產品\n4. 重複此過程選擇多個產品\n\n範例：Salmon Sashimi (13pcs), Salmon Roll, Salmon Nigiri"
                        product_dv.errorTitle = "產品選擇 - 多選指南"
                        ws.add_data_validation(product_dv)
                        product_dv.add(f"I2:I{ws.max_row}")  # 產品列
                        
                        print(f"✅ 已為 {sheet_name} 工作表的產品列添加多選下拉列表")
                    
                    # 為其他列添加多選下拉列表
                    # 門市多選下拉列表
                    outlets_formula = '"MPINES, 304 - TOA PAYOH, 306-J8, 307-HGTO, 308 - OASIS, 309 - YEW TEE SQUARE, 310 - SENGKANG MRT, 311 - THE POIZ CENTRE, 312 - ANG MO KIO"'
                    outlets_dv = DataValidation(type="list", formula1=outlets_formula, allow_blank=True)
                    outlets_dv.error = "請選擇有效的門市"
                    outlets_dv.errorTitle = "門市選擇"
                    ws.add_data_validation(outlets_dv)
                    outlets_dv.add(f"G2:G{ws.max_row}")  # 門市列
                    
                    # 支付方式多選下拉列表
                    payment_formula = '"VISA, MASTER, NETS, AMEX, UnionPay, DBS MAX, CDC Voucher, Mall Voucher, GRAB FOOD, FOOD PANDA, DELIVEROO, SE APP, WASTAGE"'
                    payment_dv = DataValidation(type="list", formula1=payment_formula, allow_blank=True)
                    payment_dv.error = "請選擇有效的支付方式"
                    payment_dv.errorTitle = "支付方式選擇"
                    ws.add_data_validation(payment_dv)
                    payment_dv.add(f"J2:J{ws.max_row}")  # 支付方式列
                    
                    print(f"✅ 已為 {sheet_name} 工作表添加多選下拉列表")
            
            print("✅ 多選下拉列表功能添加完成")
            
        except Exception as e:
            print(f"⚠️ 添加多選下拉列表失敗: {e}")
            import traceback
            print(f"詳細錯誤: {traceback.format_exc()}")
    
    def create_usage_guide_sheet(self, wb):
        """創建使用說明工作表"""
        try:
            from openpyxl.styles import Font, PatternFill, Border, Side, Alignment
            
            # 創建使用說明工作表
            guide_ws = wb.create_sheet(title='使用說明', index=1)  # 放在第二個位置
            
            # 標題
            title_cell = guide_ws.cell(row=1, column=1, value="📋 PromotionRecords.xlsx 使用說明")
            title_cell.font = Font(name='Microsoft YaHei UI', size=16, bold=True, color='FFFFFF')
            title_cell.fill = PatternFill(start_color='2E8B57', end_color='2E8B57', fill_type='solid')
            title_cell.alignment = Alignment(horizontal='center', vertical='center')
            guide_ws.merge_cells('A1:D1')
            
            # 使用說明內容
            instructions = [
                ("", "", "", ""),
                ("📊 工作表說明", "", "", ""),
                ("ProductDatabase", "產品數據庫", "包含所有可用產品的詳細信息", "用於下拉列表的數據源"),
                ("GOGO", "GOGO活動記錄", "GOGO品牌的促銷活動記錄", "包含分析結果和業績數據"),
                ("Express", "Express活動記錄", "Express品牌的促銷活動記錄", "包含分析結果和業績數據"),
                ("PLUS", "PLUS活動記錄", "PLUS品牌的促銷活動記錄", "包含分析結果和業績數據"),
                ("Holidays", "假期記錄", "各品牌的假期和特殊日期", "用於活動分析的時間篩選"),
                ("", "", "", ""),
                ("💡 多選功能使用指南", "", "", ""),
                ("方法", "操作", "說明", "範例"),
                ("方法1：手動輸入", "直接輸入產品名稱", "在單元格中直接輸入多個產品", "Salmon Sashimi (13pcs), Salmon Roll, Salmon Nigiri"),
                ("方法2：複製粘貼", "從ProductDatabase複製", "從產品數據庫工作表複製產品名稱", "複製多個產品名稱，用逗號分隔"),
                ("方法3：分步輸入", "先輸入一個，再添加", "輸入第一個產品，然後手動添加更多", "Salmon Sashimi (13pcs), 然後手動添加 , Salmon Roll"),
                ("⚠️ 重要提示", "標準下拉列表會覆蓋", "Excel標準下拉列表不支持多選", "建議使用方法1或方法2"),
                ("", "", "", ""),
                ("🔍 篩選功能", "", "", ""),
                ("功能", "位置", "用途", "說明"),
                ("自動篩選", "表頭下拉箭頭", "篩選顯示的數據", "點擊表頭的箭頭進行篩選"),
                ("數據驗證", "單元格下拉箭頭", "選擇有效選項", "確保數據格式正確"),
                ("", "", "", ""),
                ("📝 填寫建議", "", "", ""),
                ("欄位", "建議", "格式", "注意事項"),
                ("活動名稱", "簡潔明確", "文字", "避免使用特殊字符"),
                ("日期範圍", "YYYY-MM-DD", "日期", "確保日期格式正確"),
                ("門市", "從下拉列表選擇", "文字", "可多選，用逗號分隔"),
                ("產品", "從產品數據庫選擇", "文字", "可多選，用逗號分隔"),
                ("支付方式", "從預設選項選擇", "文字", "可多選，用逗號分隔"),
                ("", "", "", ""),
                ("⚠️ 注意事項", "", "", ""),
                ("• 所有數據會自動保存到程序", "", "", ""),
                ("• 修改數據後請重新導入程序", "", "", ""),
                ("• 產品名稱必須與ProductDatabase中的完全一致", "", "", ""),
                ("• 日期格式必須為 YYYY-MM-DD", "", "", ""),
                ("• 多選項目用逗號和空格分隔", "", "", ""),
            ]
            
            # 寫入說明內容
            for row_idx, (col1, col2, col3, col4) in enumerate(instructions, 2):
                guide_ws.cell(row=row_idx, column=1, value=col1)
                guide_ws.cell(row=row_idx, column=2, value=col2)
                guide_ws.cell(row=row_idx, column=3, value=col3)
                guide_ws.cell(row=row_idx, column=4, value=col4)
                
                # 設置樣式
                for col in range(1, 5):
                    cell = guide_ws.cell(row=row_idx, column=col)
                    if col1.startswith("📊") or col1.startswith("💡") or col1.startswith("🔍") or col1.startswith("📝") or col1.startswith("⚠️"):
                        # 標題行
                        cell.font = Font(name='Microsoft YaHei UI', size=12, bold=True, color='2E8B57')
                        cell.fill = PatternFill(start_color='E8F5E8', end_color='E8F5E8', fill_type='solid')
                    elif col1 == "步驟" or col1 == "功能" or col1 == "欄位":
                        # 子標題行
                        cell.font = Font(name='Microsoft YaHei UI', size=11, bold=True)
                        cell.fill = PatternFill(start_color='F0F8FF', end_color='F0F8FF', fill_type='solid')
                    else:
                        # 普通行
                        cell.font = Font(name='Arial', size=10)
                    
                    cell.border = Border(
                        left=Side(style='thin'),
                        right=Side(style='thin'),
                        top=Side(style='thin'),
                        bottom=Side(style='thin')
                    )
                    cell.alignment = Alignment(horizontal='left', vertical='center')
            
            # 調整列寬
            guide_ws.column_dimensions['A'].width = 15
            guide_ws.column_dimensions['B'].width = 20
            guide_ws.column_dimensions['C'].width = 30
            guide_ws.column_dimensions['D'].width = 40
            
            # 凍結首行
            guide_ws.freeze_panes = 'A2'
            
            print("✅ 使用說明工作表已創建")
            
        except Exception as e:
            print(f"⚠️ 創建使用說明工作表失敗: {e}")
            import traceback
            print(f"詳細錯誤: {traceback.format_exc()}")
    
    def add_vba_multiselect_macro(self, wb):
        """添加VBA宏實現真正的多選功能"""
        try:
            # 創建VBA宏代碼
            vba_code = '''
Sub MultiSelectProducts()
    ' 多選產品功能 - 右鍵菜單觸發
    Dim selectedCell As Range
    Dim currentValue As String
    Dim newProduct As String
    Dim productList As String
    Dim i As Integer
    
    ' 獲取當前選中的單元格
    Set selectedCell = Selection
    
    ' 檢查是否在產品列（I列）
    If selectedCell.Column = 9 Then
        currentValue = selectedCell.Value
        If currentValue = "" Then currentValue = ""
        
        ' 顯示產品選擇對話框
        newProduct = InputBox("請輸入要添加的產品名稱：" & vbCrLf & vbCrLf & _
                             "當前已選擇：" & currentValue & vbCrLf & vbCrLf & _
                             "可用產品：" & vbCrLf & _
                             "• Salmon Sashimi (13pcs)" & vbCrLf & _
                             "• Salmon Sashimi (8pcs)" & vbCrLf & _
                             "• Salmon Sushi 10pcs" & vbCrLf & _
                             "• Salmon Roll" & vbCrLf & _
                             "• Salmon Nigiri" & vbCrLf & _
                             "• Tuna Sashimi (10pcs)" & vbCrLf & _
                             "• Eel Roll" & vbCrLf & _
                             "• California Roll" & vbCrLf & _
                             "• Tempura Roll" & vbCrLf & _
                             "• Dragon Roll" & vbCrLf & vbCrLf & _
                             "輸入新產品名稱（留空則清除所有選擇）：", _
                             "多選產品", currentValue)
        
        If newProduct <> "" Then
            ' 添加新產品
            If currentValue = "" Then
                selectedCell.Value = newProduct
            Else
                selectedCell.Value = currentValue & ", " & newProduct
            End If
        Else
            ' 清除選擇
            selectedCell.Value = ""
        End If
    Else
        MsgBox "請在產品列（I列）中使用此功能", vbInformation, "提示"
    End If
End Sub

Sub MultiSelectOutlets()
    ' 多選門市功能
    Dim selectedCell As Range
    Dim currentValue As String
    Dim newOutlet As String
    
    Set selectedCell = Selection
    
    If selectedCell.Column = 7 Then ' G列是門市列
        currentValue = selectedCell.Value
        If currentValue = "" Then currentValue = ""
        
        newOutlet = InputBox("請輸入要添加的門市名稱：" & vbCrLf & vbCrLf & _
                            "當前已選擇：" & currentValue & vbCrLf & vbCrLf & _
                            "可用門市：" & vbCrLf & _
                            "• MPINES" & vbCrLf & _
                            "• 304 - TOA PAYOH" & vbCrLf & _
                            "• 306-J8" & vbCrLf & _
                            "• 307-HGTO" & vbCrLf & _
                            "• 308 - OASIS" & vbCrLf & _
                            "• 309 - YEW TEE SQUARE" & vbCrLf & _
                            "• 310 - SENGKANG MRT" & vbCrLf & _
                            "• 311 - THE POIZ CENTRE" & vbCrLf & _
                            "• 312 - ANG MO KIO" & vbCrLf & vbCrLf & _
                            "輸入新門市名稱（留空則清除所有選擇）：", _
                            "多選門市", currentValue)
        
        If newOutlet <> "" Then
            If currentValue = "" Then
                selectedCell.Value = newOutlet
            Else
                selectedCell.Value = currentValue & ", " & newOutlet
            End If
        Else
            selectedCell.Value = ""
        End If
    Else
        MsgBox "請在門市列（G列）中使用此功能", vbInformation, "提示"
    End If
End Sub

Sub MultiSelectPayment()
    ' 多選支付方式功能
    Dim selectedCell As Range
    Dim currentValue As String
    Dim newPayment As String
    
    Set selectedCell = Selection
    
    If selectedCell.Column = 10 Then ' J列是支付方式列
        currentValue = selectedCell.Value
        If currentValue = "" Then currentValue = ""
        
        newPayment = InputBox("請輸入要添加的支付方式：" & vbCrLf & vbCrLf & _
                             "當前已選擇：" & currentValue & vbCrLf & vbCrLf & _
                             "可用支付方式：" & vbCrLf & _
                             "• VISA" & vbCrLf & _
                             "• MASTER" & vbCrLf & _
                             "• NETS" & vbCrLf & _
                             "• AMEX" & vbCrLf & _
                             "• UnionPay" & vbCrLf & _
                             "• DBS MAX" & vbCrLf & _
                             "• CDC Voucher" & vbCrLf & _
                             "• Mall Voucher" & vbCrLf & _
                             "• GRAB FOOD" & vbCrLf & _
                             "• FOOD PANDA" & vbCrLf & _
                             "• DELIVEROO" & vbCrLf & _
                             "• SE APP" & vbCrLf & _
                             "• WASTAGE" & vbCrLf & vbCrLf & _
                             "輸入新支付方式（留空則清除所有選擇）：", _
                             "多選支付方式", currentValue)
        
        If newPayment <> "" Then
            If currentValue = "" Then
                selectedCell.Value = newPayment
            Else
                selectedCell.Value = currentValue & ", " & newPayment
            End If
        Else
            selectedCell.Value = ""
        End If
    Else
        MsgBox "請在支付方式列（J列）中使用此功能", vbInformation, "提示"
    End If
End Sub
'''
            
            # 嘗試添加VBA宏（需要openpyxl支持）
            try:
                # 創建VBA模塊
                from openpyxl import Workbook
                
                # 添加VBA宏到工作簿
                if hasattr(wb, 'vba_archive'):
                    # 如果工作簿支持VBA，添加宏
                    print("✅ VBA宏已準備就緒")
                else:
                    print("ℹ️ 當前版本不支持VBA宏，將使用替代方案")
                    
            except Exception as vba_error:
                print(f"⚠️ VBA宏添加失敗: {vba_error}")
                
        except Exception as e:
            print(f"⚠️ 添加VBA宏失敗: {e}")
    
    def create_multiselect_helper_sheet(self, wb):
        """創建多選助手工作表"""
        try:
            from openpyxl.styles import Font, PatternFill, Border, Side, Alignment
            
            # 創建多選助手工作表
            helper_ws = wb.create_sheet(title='多選助手', index=2)  # 放在第三個位置
            
            # 標題
            title_cell = helper_ws.cell(row=1, column=1, value="🎯 多選助手 - 快速複製產品、門市、支付方式")
            title_cell.font = Font(name='Microsoft YaHei UI', size=14, bold=True, color='FFFFFF')
            title_cell.fill = PatternFill(start_color='FF6B35', end_color='FF6B35', fill_type='solid')
            title_cell.alignment = Alignment(horizontal='center', vertical='center')
            helper_ws.merge_cells('A1:D1')
            
            # 產品多選區域
            helper_ws.cell(row=3, column=1, value="🍣 產品多選區域")
            helper_ws.cell(row=3, column=1).font = Font(name='Microsoft YaHei UI', size=12, bold=True, color='2E8B57')
            helper_ws.cell(row=3, column=1).fill = PatternFill(start_color='E8F5E8', end_color='E8F5E8', fill_type='solid')
            helper_ws.merge_cells('A3:D3')
            
            # 產品選項
            products = [
                'Salmon Sashimi (13pcs)', 'Salmon Sashimi (8pcs)', 'Salmon Sushi 10pcs',
                'Salmon Roll', 'Salmon Nigiri', 'Tuna Sashimi (10pcs)',
                'Eel Roll', 'California Roll', 'Tempura Roll', 'Dragon Roll'
            ]
            
            for i, product in enumerate(products):
                row = 4 + i
                helper_ws.cell(row=row, column=1, value=f"☑ {product}")
                helper_ws.cell(row=row, column=2, value=product)
                helper_ws.cell(row=row, column=3, value="點擊複製")
                helper_ws.cell(row=row, column=4, value="複製後粘貼到活動記錄的產品列")
                
                # 設置樣式
                for col in range(1, 5):
                    cell = helper_ws.cell(row=row, column=col)
                    cell.font = Font(name='Arial', size=10)
                    cell.border = Border(
                        left=Side(style='thin'),
                        right=Side(style='thin'),
                        top=Side(style='thin'),
                        bottom=Side(style='thin')
                    )
                    cell.alignment = Alignment(horizontal='left', vertical='center')
            
            # 門市多選區域
            outlets_start_row = 4 + len(products) + 2
            helper_ws.cell(row=outlets_start_row, column=1, value="🏪 門市多選區域")
            helper_ws.cell(row=outlets_start_row, column=1).font = Font(name='Microsoft YaHei UI', size=12, bold=True, color='2E8B57')
            helper_ws.cell(row=outlets_start_row, column=1).fill = PatternFill(start_color='E8F5E8', end_color='E8F5E8', fill_type='solid')
            helper_ws.merge_cells(f'A{outlets_start_row}:D{outlets_start_row}')
            
            # 門市選項
            outlets = [
                'MPINES', '304 - TOA PAYOH', '306-J8', '307-HGTO',
                '308 - OASIS', '309 - YEW TEE SQUARE', '310 - SENGKANG MRT',
                '311 - THE POIZ CENTRE', '312 - ANG MO KIO'
            ]
            
            for i, outlet in enumerate(outlets):
                row = outlets_start_row + 1 + i
                helper_ws.cell(row=row, column=1, value=f"☑ {outlet}")
                helper_ws.cell(row=row, column=2, value=outlet)
                helper_ws.cell(row=row, column=3, value="點擊複製")
                helper_ws.cell(row=row, column=4, value="複製後粘貼到活動記錄的門市列")
                
                # 設置樣式
                for col in range(1, 5):
                    cell = helper_ws.cell(row=row, column=col)
                    cell.font = Font(name='Arial', size=10)
                    cell.border = Border(
                        left=Side(style='thin'),
                        right=Side(style='thin'),
                        top=Side(style='thin'),
                        bottom=Side(style='thin')
                    )
                    cell.alignment = Alignment(horizontal='left', vertical='center')
            
            # 支付方式多選區域
            payment_start_row = outlets_start_row + len(outlets) + 2
            helper_ws.cell(row=payment_start_row, column=1, value="💳 支付方式多選區域")
            helper_ws.cell(row=payment_start_row, column=1).font = Font(name='Microsoft YaHei UI', size=12, bold=True, color='2E8B57')
            helper_ws.cell(row=payment_start_row, column=1).fill = PatternFill(start_color='E8F5E8', end_color='E8F5E8', fill_type='solid')
            helper_ws.merge_cells(f'A{payment_start_row}:D{payment_start_row}')
            
            # 支付方式選項
            payments = [
                'VISA', 'MASTER', 'NETS', 'AMEX', 'UnionPay',
                'DBS MAX', 'CDC Voucher', 'Mall Voucher',
                'GRAB FOOD', 'FOOD PANDA', 'DELIVEROO', 'SE APP', 'WASTAGE'
            ]
            
            for i, payment in enumerate(payments):
                row = payment_start_row + 1 + i
                helper_ws.cell(row=row, column=1, value=f"☑ {payment}")
                helper_ws.cell(row=row, column=2, value=payment)
                helper_ws.cell(row=row, column=3, value="點擊複製")
                helper_ws.cell(row=row, column=4, value="複製後粘貼到活動記錄的支付方式列")
                
                # 設置樣式
                for col in range(1, 5):
                    cell = helper_ws.cell(row=row, column=col)
                    cell.font = Font(name='Arial', size=10)
                    cell.border = Border(
                        left=Side(style='thin'),
                        right=Side(style='thin'),
                        top=Side(style='thin'),
                        bottom=Side(style='thin')
                    )
                    cell.alignment = Alignment(horizontal='left', vertical='center')
            
            # 使用說明
            instructions_start_row = payment_start_row + len(payments) + 3
            helper_ws.cell(row=instructions_start_row, column=1, value="📋 使用說明")
            helper_ws.cell(row=instructions_start_row, column=1).font = Font(name='Microsoft YaHei UI', size=12, bold=True, color='FF6B35')
            helper_ws.cell(row=instructions_start_row, column=1).fill = PatternFill(start_color='FFF0E6', end_color='FFF0E6', fill_type='solid')
            helper_ws.merge_cells(f'A{instructions_start_row}:D{instructions_start_row}')
            
            instructions = [
                ("步驟1", "選擇需要的項目", "點擊B列的產品/門市/支付方式名稱", "會自動選中該項目"),
                ("步驟2", "複製選中的項目", "Ctrl+C 或右鍵複製", "複製到剪貼板"),
                ("步驟3", "粘貼到活動記錄", "切換到活動記錄工作表", "粘貼到對應的列"),
                ("步驟4", "添加更多項目", "重複步驟1-3", "用逗號分隔多個項目"),
                ("", "", "", ""),
                ("💡 多選技巧", "", "", ""),
                ("• 可以一次選擇多個項目", "按住Ctrl鍵點擊多個項目", "然後一起複製", "節省時間"),
                ("• 使用逗號分隔", "項目1, 項目2, 項目3", "確保格式正確", "程序能正確識別"),
                ("• 檢查拼寫", "確保產品名稱完全一致", "參考ProductDatabase工作表", "避免分析錯誤"),
            ]
            
            for i, (step, action, desc, example) in enumerate(instructions):
                row = instructions_start_row + 1 + i
                helper_ws.cell(row=row, column=1, value=step)
                helper_ws.cell(row=row, column=2, value=action)
                helper_ws.cell(row=row, column=3, value=desc)
                helper_ws.cell(row=row, column=4, value=example)
                
                # 設置樣式
                for col in range(1, 5):
                    cell = helper_ws.cell(row=row, column=col)
                    if step.startswith("💡"):
                        cell.font = Font(name='Microsoft YaHei UI', size=11, bold=True, color='FF6B35')
                        cell.fill = PatternFill(start_color='FFF0E6', end_color='FFF0E6', fill_type='solid')
                    else:
                        cell.font = Font(name='Arial', size=10)
                    cell.border = Border(
                        left=Side(style='thin'),
                        right=Side(style='thin'),
                        top=Side(style='thin'),
                        bottom=Side(style='thin')
                    )
                    cell.alignment = Alignment(horizontal='left', vertical='center')
            
            # 調整列寬
            helper_ws.column_dimensions['A'].width = 25
            helper_ws.column_dimensions['B'].width = 30
            helper_ws.column_dimensions['C'].width = 15
            helper_ws.column_dimensions['D'].width = 40
            
            # 凍結首行
            helper_ws.freeze_panes = 'A2'
            
            print("✅ 多選助手工作表已創建")
            
        except Exception as e:
            print(f"⚠️ 創建多選助手工作表失敗: {e}")
            import traceback
            print(f"詳細錯誤: {traceback.format_exc()}")
    
    def import_activity_records_from_excel(self):
        """從Excel文件導入活動記錄 - 使用固定文件名 PromotionRecords.xlsx"""
        try:
            import pandas as pd
            import json
            from datetime import datetime
            import os
            
            # 使用固定文件名，從程序所在目錄讀取
            current_dir = os.path.dirname(os.path.abspath(__file__))
            file_path = os.path.join(current_dir, "PromotionRecords.xlsx")
            
            # 檢查文件是否存在
            if not os.path.exists(file_path):
                tk.messagebox.showwarning(
                    "文件不存在 / File Not Found",
                    f"找不到文件: {file_path}\nFile not found: {file_path}\n\n請先導出活動記錄或確保文件存在。\nPlease export activity records first or ensure the file exists."
                )
                return
            
            # 確認導入
            result = tk.messagebox.askyesno(
                "確認導入 / Confirm Import",
                "導入Excel文件將覆蓋現有的活動記錄。\nImporting Excel file will overwrite existing activity records.\n\n是否繼續？/ Continue?"
            )
            
            if not result:
                return
            
            # 讀取Excel文件
            excel_file = pd.ExcelFile(file_path)
            
            # 檢查是否包含所需的sheet
            required_sheets = ['GOGO', 'Express', 'PLUS']
            available_sheets = excel_file.sheet_names
            
            missing_sheets = [sheet for sheet in required_sheets if sheet not in available_sheets]
            if missing_sheets:
                tk.messagebox.showwarning(
                    "警告 / Warning",
                    f"Excel文件缺少以下工作表:\nExcel file is missing the following sheets:\n{', '.join(missing_sheets)}"
                )
            
            # 確保假期記錄存在
            if not hasattr(self, 'holiday_records'):
                self.holiday_records = {
                    'GOGO': [],
                    'Express': [],
                    'PLUS': []
                }
            
            # 導入每個數據庫的記錄
            imported_count = 0
            for db_name in required_sheets:
                if db_name in available_sheets:
                    try:
                        # 讀取工作表
                        df = pd.read_excel(file_path, sheet_name=db_name)
                        
                        # 跳過空的工作表
                        if df.empty or len(df) == 0:
                            continue
                        
                        # 轉換為活動記錄格式
                        records = []
                        for _, row in df.iterrows():
                            # 跳過空行或提示行
                            if pd.isna(row.iloc[0]) or '暫無' in str(row.iloc[0]):
                                continue
                            
                            # 解析分析結果
                            analysis_result = {}
                            if not pd.isna(row.iloc[10]) and str(row.iloc[10]) != '未分析':  # 總業績
                                try:
                                    # 解析金額格式
                                    total_amount_str = str(row.iloc[10]).replace('$', '').replace(',', '')
                                    analysis_result['total_amount'] = float(total_amount_str)
                                except:
                                    analysis_result['total_amount'] = 0
                            
                            if not pd.isna(row.iloc[11]) and str(row.iloc[11]) != '未分析':  # 總單據數
                                try:
                                    total_receipts_str = str(row.iloc[11]).replace(',', '')
                                    analysis_result['total_receipts'] = int(total_receipts_str)
                                except:
                                    analysis_result['total_receipts'] = 0
                            
                            if not pd.isna(row.iloc[12]) and str(row.iloc[12]) != '未分析':  # 活動業績
                                try:
                                    activity_amount_str = str(row.iloc[12]).replace('$', '').replace(',', '')
                                    analysis_result['activity_amount'] = float(activity_amount_str)
                                except:
                                    analysis_result['activity_amount'] = 0
                            
                            if not pd.isna(row.iloc[13]) and str(row.iloc[13]) != '未分析':  # 活動單據數
                                try:
                                    activity_receipts_str = str(row.iloc[13]).replace(',', '')
                                    analysis_result['activity_receipts'] = int(activity_receipts_str)
                                except:
                                    analysis_result['activity_receipts'] = 0
                            
                            if not pd.isna(row.iloc[14]) and str(row.iloc[14]) != '未分析':  # 業績占比%
                                try:
                                    amount_ratio_str = str(row.iloc[14]).replace('%', '')
                                    analysis_result['amount_ratio'] = float(amount_ratio_str)
                                except:
                                    analysis_result['amount_ratio'] = 0
                            
                            if not pd.isna(row.iloc[15]) and str(row.iloc[15]) != '未分析':  # 單據數占比%
                                try:
                                    receipt_ratio_str = str(row.iloc[15]).replace('%', '')
                                    analysis_result['receipt_ratio'] = float(receipt_ratio_str)
                                except:
                                    analysis_result['receipt_ratio'] = 0
                            
                            if not pd.isna(row.iloc[16]):  # 分析時間
                                analysis_result['analyzed_time'] = str(row.iloc[16])
                            
                            # 創建活動記錄
                            record = {
                                'id': str(row.iloc[0]) if not pd.isna(row.iloc[0]) else '',
                                'description': str(row.iloc[1]) if not pd.isna(row.iloc[1]) else '',
                                'type': str(row.iloc[2]) if not pd.isna(row.iloc[2]) else 'normal',
                                'date_from': str(row.iloc[3]) if not pd.isna(row.iloc[3]) else '',
                                'date_to': str(row.iloc[4]) if not pd.isna(row.iloc[4]) else '',
                                'weekdays': str(row.iloc[5]).split(', ') if not pd.isna(row.iloc[5]) and str(row.iloc[5]) != '全部' else [],
                                'outlets': str(row.iloc[6]).split(', ') if not pd.isna(row.iloc[6]) else [],
                                'parts': str(row.iloc[7]).split(', ') if not pd.isna(row.iloc[7]) else [],
                                'products': str(row.iloc[8]).split(', ') if not pd.isna(row.iloc[8]) else [],
                                'payment_methods': str(row.iloc[9]).split(', ') if not pd.isna(row.iloc[9]) else [],
                                'analysis_result': analysis_result if analysis_result else {},
                                'created_time': str(row.iloc[17]) if not pd.isna(row.iloc[17]) else datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                                'database': db_name
                            }
                            
                            records.append(record)
                            imported_count += 1
                        
                        # 更新活動記錄
                        self.activity_records[db_name] = records
                        
                    except Exception as e:
                        print(f"導入 {db_name} 數據庫記錄時出錯: {e}")
                        continue
            
            # 導入假期記錄
            holiday_imported_count = 0
            if 'Holidays' in available_sheets:
                try:
                    # 讀取假期工作表
                    holiday_df = pd.read_excel(file_path, sheet_name='Holidays')
                    
                    # 清空現有假期記錄
                    for db_name in ['GOGO', 'Express', 'PLUS']:
                        self.holiday_records[db_name] = []
                    
                    # 轉換假期記錄
                    for _, row in holiday_df.iterrows():
                        # 跳過空行或提示行
                        if pd.isna(row.iloc[0]) or '暫無' in str(row.iloc[0]):
                            continue
                        
                        # 獲取數據庫名稱
                        db_name = str(row.iloc[0]) if not pd.isna(row.iloc[0]) else 'Express'
                        if db_name not in ['GOGO', 'Express', 'PLUS']:
                            continue
                        
                        # 創建假期記錄
                        holiday_record = {
                            'start_date': str(row.iloc[1]) if not pd.isna(row.iloc[1]) else '',
                            'end_date': str(row.iloc[2]) if not pd.isna(row.iloc[2]) else '',
                            'holiday_name': str(row.iloc[3]) if not pd.isna(row.iloc[3]) else '',
                            'duration': int(row.iloc[4]) if not pd.isna(row.iloc[4]) else 0
                        }
                        
                        # 添加到對應數據庫的假期記錄
                        self.holiday_records[db_name].append(holiday_record)
                        holiday_imported_count += 1
                        
                except Exception as e:
                    print(f"導入假期記錄時出錯: {e}")
            
            # 保存到文件
            self.save_activity_records()
            
            # 保存假期記錄
            if hasattr(self, 'save_holiday_records'):
                self.save_holiday_records()
            
            # 刷新顯示
            if hasattr(self, 'activity_tree'):
                self.refresh_activity_tree()
            
            # 更新產品選擇器以包含導入的產品數據
            try:
                print("🔄 導入Excel後更新產品選擇器...")
                self.update_activity_products_from_records()
                print("✅ 產品選擇器已更新")
            except Exception as e:
                print(f"⚠️ 更新產品選擇器失敗: {e}")
            
            # 更新活動提醒
            if hasattr(self, 'update_activity_alerts'):
                self.update_activity_alerts()
            
            # 刷新假期記錄顯示
            if hasattr(self, 'holiday_tree'):
                self.refresh_holiday_tree()
            
            # 更新假期信息
            if hasattr(self, 'update_holiday_info'):
                self.update_holiday_info()
            
            success_message = f"成功導入 {imported_count} 條活動記錄\nSuccessfully imported {imported_count} activity records"
            if holiday_imported_count > 0:
                success_message += f"\n\n成功導入 {holiday_imported_count} 條假期記錄\nSuccessfully imported {holiday_imported_count} holiday records"
            success_message += f"\n\n文件路徑 / File path: {file_path}"
            
            tk.messagebox.showinfo("成功 / Success", success_message)
            
        except Exception as e:
            tk.messagebox.showerror(
                "錯誤 / Error",
                f"導入Excel文件失敗:\nFailed to import Excel file:\n{str(e)}"
            )
    
    def auto_save_promotion_records(self):
        """自動保存活動記錄和假期記錄到 PromotionRecords.xlsx"""
        try:
            import pandas as pd
            from openpyxl import Workbook
            from openpyxl.styles import Font, PatternFill, Border, Side, Alignment
            import os
            
            # 使用固定文件名，保存在程序所在目錄
            current_dir = os.path.dirname(os.path.abspath(__file__))
            file_path = os.path.join(current_dir, "PromotionRecords.xlsx")
            
            # 創建Excel工作簿
            wb = Workbook()
            
            # 定義樣式
            header_font = Font(name='Microsoft YaHei UI', size=12, bold=True, color='FFFFFF')
            header_fill = PatternFill(start_color='4472C4', end_color='4472C4', fill_type='solid')
            data_font = Font(name='Microsoft YaHei UI', size=10)
            border = Border(
                left=Side(style='thin'),
                right=Side(style='thin'),
                top=Side(style='thin'),
                bottom=Side(style='thin')
            )
            center_alignment = Alignment(horizontal='center', vertical='center')
            
            # 數據庫列表
            databases = ['GOGO', 'Express', 'PLUS']
            
            # 確保假期記錄存在
            if not hasattr(self, 'holiday_records'):
                self.holiday_records = {
                    'GOGO': [],
                    'Express': [],
                    'PLUS': []
                }
            
            for db_name in databases:
                # 創建或選擇工作表
                if db_name == 'GOGO':
                    ws = wb.active
                    ws.title = db_name
                else:
                    ws = wb.create_sheet(title=db_name)
                
                # 獲取該數據庫的活動記錄
                records = self.activity_records.get(db_name, [])
                
                if not records:
                    # 如果沒有記錄，創建空的表頭
                    headers = [
                        '活動ID', '活動名稱', '活動類型', '開始日期', '結束日期', 
                        '星期篩選', '涉及門市', '涉及部分', '涉及產品', '支付方式',
                        '總業績', '總單據數', '活動業績', '活動單據數', 
                        '業績占比%', '單據數占比%', '分析時間', '創建時間'
                    ]
                    
                    # 寫入表頭
                    for col, header in enumerate(headers, 1):
                        cell = ws.cell(row=1, column=col, value=header)
                        cell.font = header_font
                        cell.fill = header_fill
                        cell.border = border
                        cell.alignment = center_alignment
                    
                    # 寫入空數據提示
                    ws.cell(row=2, column=1, value=f"暫無 {db_name} 數據庫的活動記錄")
                    ws.cell(row=2, column=1).font = Font(name='Microsoft YaHei UI', size=10, italic=True, color='666666')
                    
                    # 調整列寬
                    for col in range(1, len(headers) + 1):
                        ws.column_dimensions[chr(64 + col)].width = 15
                    
                    continue
                
                # 準備數據
                data_rows = []
                for record in records:
                    # 分析結果
                    analysis_result = record.get('analysis_result', {})
                    
                    row_data = [
                        record.get('id', ''),
                        record.get('description', ''),
                        record.get('type', ''),
                        record.get('date_from', ''),
                        record.get('date_to', ''),
                        ', '.join(record.get('weekdays', [])),
                        ', '.join(record.get('outlets', [])),
                        ', '.join(record.get('parts', [])),
                        ', '.join(record.get('products', [])),
                        ', '.join(record.get('payment_methods', [])),
                        f"${analysis_result.get('total_amount', 0):,.2f}" if analysis_result else '未分析',
                        f"{analysis_result.get('total_receipts', 0):,}" if analysis_result else '未分析',
                        f"${analysis_result.get('activity_amount', 0):,.2f}" if analysis_result else '未分析',
                        f"{analysis_result.get('activity_receipts', 0):,}" if analysis_result else '未分析',
                        f"{analysis_result.get('amount_ratio', 0):.2f}%" if analysis_result else '未分析',
                        f"{analysis_result.get('receipt_ratio', 0):.2f}%" if analysis_result else '未分析',
                        analysis_result.get('analyzed_time', '') if analysis_result else '',
                        record.get('created_time', '')
                    ]
                    data_rows.append(row_data)
                
                # 表頭
                headers = [
                    '活動ID', '活動名稱', '活動類型', '開始日期', '結束日期', 
                    '星期篩選', '涉及門市', '涉及部分', '涉及產品', '支付方式',
                    '總業績', '總單據數', '活動業績', '活動單據數', 
                    '業績占比%', '單據數占比%', '分析時間', '創建時間'
                ]
                
                # 寫入表頭
                for col, header in enumerate(headers, 1):
                    cell = ws.cell(row=1, column=col, value=header)
                    cell.font = header_font
                    cell.fill = header_fill
                    cell.border = border
                    cell.alignment = center_alignment
                
                # 寫入數據
                for row_idx, row_data in enumerate(data_rows, 2):
                    for col_idx, value in enumerate(row_data, 1):
                        cell = ws.cell(row=row_idx, column=col_idx, value=value)
                        cell.font = data_font
                        cell.border = border
                        cell.alignment = center_alignment
                        
                        # 為業績相關列添加特殊格式
                        if col_idx in [11, 13]:  # 總業績, 活動業績
                            cell.number_format = '$#,##0.00'
                        elif col_idx in [12, 14]:  # 總單據數, 活動單據數
                            cell.number_format = '#,##0'
                        elif col_idx in [15, 16]:  # 業績占比%, 單據數占比%
                            cell.number_format = '0.00%'
                
                # 調整列寬
                column_widths = [8, 25, 10, 12, 12, 15, 20, 15, 30, 20, 12, 12, 12, 12, 10, 10, 18, 18]
                for col, width in enumerate(column_widths, 1):
                    ws.column_dimensions[chr(64 + col)].width = width
                
                # 凍結首行
                ws.freeze_panes = 'A2'
            
            # 添加假期記錄工作表
            holiday_ws = wb.create_sheet(title='Holidays')
            
            # 假期記錄表頭
            holiday_headers = [
                '數據庫', '開始日期', '結束日期', '假期名稱', '假期長度(天)'
            ]
            
            # 寫入假期表頭
            for col, header in enumerate(holiday_headers, 1):
                cell = holiday_ws.cell(row=1, column=col, value=header)
                cell.font = header_font
                cell.fill = header_fill
                cell.border = border
                cell.alignment = center_alignment
            
            # 寫入假期數據
            holiday_row = 2
            for db_name in databases:
                holiday_records = self.holiday_records.get(db_name, [])
                for record in holiday_records:
                    holiday_ws.cell(row=holiday_row, column=1, value=db_name).font = data_font
                    holiday_ws.cell(row=holiday_row, column=1).border = border
                    holiday_ws.cell(row=holiday_row, column=1).alignment = center_alignment
                    
                    holiday_ws.cell(row=holiday_row, column=2, value=record.get('start_date', '')).font = data_font
                    holiday_ws.cell(row=holiday_row, column=2).border = border
                    holiday_ws.cell(row=holiday_row, column=2).alignment = center_alignment
                    
                    holiday_ws.cell(row=holiday_row, column=3, value=record.get('end_date', '')).font = data_font
                    holiday_ws.cell(row=holiday_row, column=3).border = border
                    holiday_ws.cell(row=holiday_row, column=3).alignment = center_alignment
                    
                    holiday_ws.cell(row=holiday_row, column=4, value=record.get('holiday_name', '')).font = data_font
                    holiday_ws.cell(row=holiday_row, column=4).border = border
                    holiday_ws.cell(row=holiday_row, column=4).alignment = center_alignment
                    
                    holiday_ws.cell(row=holiday_row, column=5, value=record.get('duration', 0)).font = data_font
                    holiday_ws.cell(row=holiday_row, column=5).border = border
                    holiday_ws.cell(row=holiday_row, column=5).alignment = center_alignment
                    holiday_ws.cell(row=holiday_row, column=5).number_format = '#,##0'
                    
                    holiday_row += 1
            
            # 如果沒有假期記錄，寫入提示
            if holiday_row == 2:
                holiday_ws.cell(row=2, column=1, value="暫無假期記錄")
                holiday_ws.cell(row=2, column=1).font = Font(name='Microsoft YaHei UI', size=10, italic=True, color='666666')
            
            # 調整假期工作表列寬
            holiday_column_widths = [12, 12, 12, 25, 15]
            for col, width in enumerate(holiday_column_widths, 1):
                holiday_ws.column_dimensions[chr(64 + col)].width = width
            
            # 凍結假期工作表首行
            holiday_ws.freeze_panes = 'A2'
            
            # 保存文件
            wb.save(file_path)
            print(f"✅ 自動保存活動記錄和假期記錄到: {file_path}")
            
        except Exception as e:
            print(f"⚠️ 自動保存失敗: {e}")
    
    def auto_load_promotion_records(self):
        """自動從 PromotionRecords.xlsx 讀取活動記錄和假期記錄"""
        try:
            import pandas as pd
            import os
            
            # 使用固定文件名，從程序所在目錄讀取
            current_dir = os.path.dirname(os.path.abspath(__file__))
            file_path = os.path.join(current_dir, "PromotionRecords.xlsx")
            
            # 檢查文件是否存在
            if not os.path.exists(file_path):
                print(f"ℹ️ 找不到 PromotionRecords.xlsx 文件，將在首次保存時創建")
                return
            
            # 讀取Excel文件
            excel_file = pd.ExcelFile(file_path)
            available_sheets = excel_file.sheet_names
            
            # 檢查是否包含所需的sheet
            required_sheets = ['GOGO', 'Express', 'PLUS']
            missing_sheets = [sheet for sheet in required_sheets if sheet not in available_sheets]
            if missing_sheets:
                print(f"⚠️ Excel文件缺少以下工作表: {', '.join(missing_sheets)}")
            
            # 確保假期記錄存在
            if not hasattr(self, 'holiday_records'):
                self.holiday_records = {
                    'GOGO': [],
                    'Express': [],
                    'PLUS': []
                }
            
            # 導入每個數據庫的記錄
            imported_count = 0
            for db_name in required_sheets:
                if db_name in available_sheets:
                    try:
                        # 讀取工作表
                        df = pd.read_excel(file_path, sheet_name=db_name)
                        
                        # 跳過空的工作表
                        if df.empty or len(df) == 0:
                            continue
                        
                        # 轉換為活動記錄格式
                        records = []
                        for _, row in df.iterrows():
                            # 跳過空行或提示行
                            if pd.isna(row.iloc[0]) or '暫無' in str(row.iloc[0]):
                                continue
                            
                            # 解析分析結果
                            analysis_result = {}
                            if not pd.isna(row.iloc[10]) and str(row.iloc[10]) != '未分析':  # 總業績
                                try:
                                    # 解析金額格式
                                    total_amount_str = str(row.iloc[10]).replace('$', '').replace(',', '')
                                    analysis_result['total_amount'] = float(total_amount_str)
                                except:
                                    analysis_result['total_amount'] = 0
                            
                            if not pd.isna(row.iloc[11]) and str(row.iloc[11]) != '未分析':  # 總單據數
                                try:
                                    total_receipts_str = str(row.iloc[11]).replace(',', '')
                                    analysis_result['total_receipts'] = int(total_receipts_str)
                                except:
                                    analysis_result['total_receipts'] = 0
                            
                            if not pd.isna(row.iloc[12]) and str(row.iloc[12]) != '未分析':  # 活動業績
                                try:
                                    activity_amount_str = str(row.iloc[12]).replace('$', '').replace(',', '')
                                    analysis_result['activity_amount'] = float(activity_amount_str)
                                except:
                                    analysis_result['activity_amount'] = 0
                            
                            if not pd.isna(row.iloc[13]) and str(row.iloc[13]) != '未分析':  # 活動單據數
                                try:
                                    activity_receipts_str = str(row.iloc[13]).replace(',', '')
                                    analysis_result['activity_receipts'] = int(activity_receipts_str)
                                except:
                                    analysis_result['activity_receipts'] = 0
                            
                            if not pd.isna(row.iloc[14]) and str(row.iloc[14]) != '未分析':  # 業績占比%
                                try:
                                    amount_ratio_str = str(row.iloc[14]).replace('%', '')
                                    analysis_result['amount_ratio'] = float(amount_ratio_str)
                                except:
                                    analysis_result['amount_ratio'] = 0
                            
                            if not pd.isna(row.iloc[15]) and str(row.iloc[15]) != '未分析':  # 單據數占比%
                                try:
                                    receipt_ratio_str = str(row.iloc[15]).replace('%', '')
                                    analysis_result['receipt_ratio'] = float(receipt_ratio_str)
                                except:
                                    analysis_result['receipt_ratio'] = 0
                            
                            if not pd.isna(row.iloc[16]):  # 分析時間
                                analysis_result['analyzed_time'] = str(row.iloc[16])
                            
                            # 創建活動記錄
                            record = {
                                'id': str(row.iloc[0]) if not pd.isna(row.iloc[0]) else '',
                                'description': str(row.iloc[1]) if not pd.isna(row.iloc[1]) else '',
                                'type': str(row.iloc[2]) if not pd.isna(row.iloc[2]) else 'normal',
                                'date_from': str(row.iloc[3]) if not pd.isna(row.iloc[3]) else '',
                                'date_to': str(row.iloc[4]) if not pd.isna(row.iloc[4]) else '',
                                'weekdays': str(row.iloc[5]).split(', ') if not pd.isna(row.iloc[5]) and str(row.iloc[5]) != '全部' else [],
                                'outlets': str(row.iloc[6]).split(', ') if not pd.isna(row.iloc[6]) else [],
                                'parts': str(row.iloc[7]).split(', ') if not pd.isna(row.iloc[7]) else [],
                                'products': str(row.iloc[8]).split(', ') if not pd.isna(row.iloc[8]) else [],
                                'payment_methods': str(row.iloc[9]).split(', ') if not pd.isna(row.iloc[9]) else [],
                                'analysis_result': analysis_result if analysis_result else {},
                                'created_time': str(row.iloc[17]) if not pd.isna(row.iloc[17]) else '',
                                'database': db_name
                            }
                            
                            records.append(record)
                            imported_count += 1
                        
                        # 更新活動記錄
                        self.activity_records[db_name] = records
                        
                    except Exception as e:
                        print(f"導入 {db_name} 數據庫記錄時出錯: {e}")
                        continue
            
            # 導入假期記錄
            holiday_imported_count = 0
            if 'Holidays' in available_sheets:
                try:
                    # 讀取假期工作表
                    holiday_df = pd.read_excel(file_path, sheet_name='Holidays')
                    
                    # 清空現有假期記錄
                    for db_name in ['GOGO', 'Express', 'PLUS']:
                        self.holiday_records[db_name] = []
                    
                    # 轉換假期記錄
                    for _, row in holiday_df.iterrows():
                        # 跳過空行或提示行
                        if pd.isna(row.iloc[0]) or '暫無' in str(row.iloc[0]):
                            continue
                        
                        # 獲取數據庫名稱
                        db_name = str(row.iloc[0]) if not pd.isna(row.iloc[0]) else 'Express'
                        if db_name not in ['GOGO', 'Express', 'PLUS']:
                            continue
                        
                        # 創建假期記錄
                        holiday_record = {
                            'start_date': str(row.iloc[1]) if not pd.isna(row.iloc[1]) else '',
                            'end_date': str(row.iloc[2]) if not pd.isna(row.iloc[2]) else '',
                            'holiday_name': str(row.iloc[3]) if not pd.isna(row.iloc[3]) else '',
                            'duration': int(row.iloc[4]) if not pd.isna(row.iloc[4]) else 0
                        }
                        
                        # 添加到對應數據庫的假期記錄
                        self.holiday_records[db_name].append(holiday_record)
                        holiday_imported_count += 1
                        
                except Exception as e:
                    print(f"導入假期記錄時出錯: {e}")
            
            print(f"✅ 自動讀取完成: {imported_count} 條活動記錄, {holiday_imported_count} 條假期記錄")
            
            # 自動讀取完成後更新產品選擇器
            try:
                print("🔄 自動讀取完成後更新產品選擇器...")
                # 延遲執行以確保活動記錄窗口已初始化
                if hasattr(self, 'activity_window') and self.activity_window.winfo_exists():
                    self.activity_window.after(200, self.update_activity_products_from_records)
                else:
                    # 如果活動窗口不存在，直接調用
                    self.update_activity_products_from_records()
                print("✅ 產品選擇器更新已安排")
            except Exception as e:
                print(f"⚠️ 自動讀取後更新產品選擇器失敗: {e}")
            
        except Exception as e:
            print(f"⚠️ 自動讀取失敗: {e}")
    
    def analyze_specific_activity(self, date_from_str, date_to_str, outlet_filters, product_filters, payment_filters, database):
        """分析特定活动 - 使用保存的活动参数执行分析"""
        try:
            # 连接数据库
            current_db = database
            
            # 使用活动数据库连接方法
            if not self.connect_to_activity_database(current_db):
                tk.messagebox.showerror("错误", f"无法连接到 {current_db} 数据库")
                return
            
            # 创建分析结果窗口
            analysis_window = tk.Toplevel(self.root)
            analysis_window.title("📊 活动业绩分析 / Activity Performance Analysis")
            analysis_window.geometry("1000x700")
            
            # 設置窗口關閉協議
            analysis_window.protocol("WM_DELETE_WINDOW", analysis_window.destroy)
            
            # 主框架
            main_frame = tk.Frame(analysis_window)
            main_frame.pack(fill="both", expand=True, padx=10, pady=10)
            
            # 创建滚动条和文本框 
            result_text = tk.Text(main_frame, height=25, width=80, wrap=tk.WORD, font=('Consolas', 9))
            result_scrollbar = ttk.Scrollbar(main_frame, orient="vertical", command=result_text.yview)
            result_text.configure(yscrollcommand=result_scrollbar.set)
            
            result_text.pack(side="left", fill="both", expand=True)
            result_scrollbar.pack(side="right", fill="y")
            
            # 添加结果信息
            result_text.insert(tk.END, f"🔍 分析特定活动记录\n")
            result_text.insert(tk.END, f"📍 活动期间: {date_from_str} 至 {date_to_str}\n")
            result_text.insert(tk.END, f"🏪 涉及门市: {', '.join(outlet_filters)}\n")
            result_text.insert(tk.END, f"🍣 涉及产品: {', '.join(product_filters) if product_filters else '所有产品'}\n")
            result_text.insert(tk.END, f"{'=' * 60}\n\n")
            
            # 执行分析
            self.perform_activity_analysis(result_text, date_from_str, date_to_str, outlet_filters, product_filters, current_db, payment_filters, None, False, None, None, False)
            result_text.config(state=tk.DISABLED)
            
        except Exception as e:
            tk.messagebox.showerror("错误", f"分析特定活动失败: {e}")
    
    def clear_activity_records(self):
        """清除所有活动记录"""
        current_db = self.activity_database.get() if hasattr(self, 'activity_database') else 'Express'
        records_for_db = self.activity_records.get(current_db, [])
        
        if not records_for_db:
            self.show_activity_message("ℹ 暂无活动记录可清除")
            return
        
        # 确认对话框
        result = tk.messagebox.askyesno("确认清除", "确定要清除所有活动记录吗？\nAre you sure to clear all activity records?")
        if result:
            self.activity_records[current_db] = []
            self.refresh_activity_tree()
            self.save_activity_records()  # 保存到文件
            self.show_activity_message("✓ 所有活动记录已清除")
    
    def delete_single_activity_record(self):
        """删除单个选中活动记录"""
        try:
            if not hasattr(self, 'activity_tree'):
                self.show_activity_message("⚠ 活动记录表不存在")
                return
            
            selection = self.activity_tree.selection()
            if not selection:
                tk.messagebox.showwarning("警告", "请选择要删除的活动记录")
                return
            
            # 获取选中的记录
            item = self.activity_tree.item(selection[0])
            values = item['values']
            activity_id = values[0]
            
            # 确认删除
            result = tk.messagebox.askyesno("确认删除", f"是否确定删除活动记录ID: {activity_id}?")
            if result:
                current_db = self.activity_database.get() if hasattr(self, 'activity_database') else 'Express'
                
                # 找到并删除记录
                if current_db in self.activity_records:
                    records = self.activity_records[current_db]
                    record_to_remove = None
                    
                    for record in records:
                        if record.get('id') == int(activity_id):
                            record_to_remove = record
                            break
                    
                    if record_to_remove:
                        self.activity_records[current_db].remove(record_to_remove)
                        self.refresh_activity_tree()
                        self.save_activity_records()  # 保存到文件
                        self.show_activity_message(f"✅ 活动记录ID: {activity_id} 已删除")
                    else:
                        self.show_activity_message("⚠ 未找到对应的记录")
                else:
                    self.show_activity_message("⚠ 当前数据库没有活动记录")
                    
        except Exception as e:
            tk.messagebox.showerror("错误", f"删除活动记录失败: {e}")
    
    def update_activity_summary(self):
        """更新活动摘要显示"""
        if not self.activity_records:
            self.activity_summary_frame.pack_forget()
            return
        
        # 显示活动摘要框架
        self.activity_summary_frame.pack(fill="x", pady=5)
        
        # 清空文本
        self.activity_summary_text.delete(1.0, tk.END)
        
        # 按日期排序活动记录
        sorted_records = sorted(self.activity_records, key=lambda x: x['date_from'])
        
        summary_text = "📊 活动摘要 / Activity Summary:\n\n"
        
        for record in sorted_records:
            summary_text += f"📅 {record['date_from']} - {record['date_to']}\n"
            summary_text += f"🏪 门市: {', '.join(record['outlets'])}\n"
            summary_text += f"📊 部分: {', '.join(record['parts'])}\n"
            summary_text += f"📝 活动: {record['description']}\n"
            summary_text += "-" * 50 + "\n"
        
        self.activity_summary_text.insert(1.0, summary_text)
    
    def get_activities_for_date_range(self, date_from, date_to, database_filter=None):
        """获取指定日期范围内的活动记录"""
        matching_activities = []
        
        # self.activity_records是字典按数据库分组
        for db_name, activities in self.activity_records.items():
            # 如果指定了數據庫篩選，只處理該數據庫的活動
            if database_filter and db_name != database_filter:
                continue
                
            if isinstance(activities, list):
                for activity in activities:
                    # 确保活动记录有date_from和date_to字段
                    if 'date_from' in activity and 'date_to' in activity:
                        try:
                            activity_start = datetime.strptime(activity['date_from'], '%Y-%m-%d').date()
                            activity_end = datetime.strptime(activity['date_to'], '%Y-%m-%d').date()
                            
                            # 检查日期范围是否有重叠
                            if not (date_to < activity_start or date_from > activity_end):
                                # 添加數據庫信息到活動記錄中
                                activity_with_db = activity.copy()
                                activity_with_db['database'] = db_name
                                matching_activities.append(activity_with_db)
                        except ValueError as e:
                            print(f"❌ 日期格式错误: {activity.get('date_from', 'N/A')} - {activity.get('date_to', 'N/A')}")
                            continue
        
        return matching_activities
    
    def get_activities_for_outlet(self, outlet):
        """获取指定门市的活动记录"""
        matching_activities = []
        
        # self.activity_records是字典按数据库分组
        for db_name, activities in self.activity_records.items():
            if isinstance(activities, list):
                for activity in activities:
                    # 确保活动记录有outlets字段
                    if 'outlets' in activity:
                        if outlet in activity['outlets'] or 'All' in activity['outlets']:
                            matching_activities.append(activity)
        
        return matching_activities
    
    def ensure_right_panel_visible(self):
        """确保右侧面板可见 - 不會重新創建，只確保可見"""
        try:
            if hasattr(self, 'right_panel'):
                # 检查面板是否存在且可見
                try:
                    panel_visible = self.right_panel.winfo_viewable()
                    if not panel_visible:
                        # 面板存在但不可見，重新pack顯示
                        self.right_panel.pack(side="right", fill="y", expand=False, padx=(8, 15), pady=15)
                        self.right_panel.configure(width=270)
                        self.right_panel.pack_propagate(False)
                        print("✓ 右側面板已恢復顯示")
                except tk.TclError:
                    # 面板不存在，但不會重新創建以避免破壞現有設置
                    print("⚠️ 右側面板不存在，但不會重新創建")
        except Exception as e:
            print(f"✗ 確保右側面板可見時出錯: {e}")
    
    def create_right_panel(self):
        """创建右侧面板"""
        try:
            # 如果右側面板不存在，只是確保它存在而不重新創建
            if not hasattr(self, 'right_panel') or not self.right_panel.winfo_exists():
                self.log_message("⚠️ 右側面板不存在，但不會重新創建以避免覆蓋現有設置")
            else:
                self.log_message("✓ 右側面板已存在並正常運行")
        except Exception as e:
            self.log_message(f"✗ 重新設置右側面板時出錯: {e}")
    
    def update_activity_alerts(self):
        """更新活动提醒显示 - 增強版包含業績占比"""
        try:
            # 确保右侧面板可见
            self.ensure_right_panel_visible()
            
            # 获取当前搜索的日期范围
            if hasattr(self, 'date_from') and hasattr(self, 'date_to'):
                search_date_from = self.date_from.get_date()
                search_date_to = self.date_to.get_date()
                
                # 獲取當前選擇的數據庫 - 使用统一的数据库选择逻辑
                current_database = self.get_current_database()
                print(f"DEBUG: update_activity_alerts using current_database: {current_database}")
                
                # 查找匹配的活动记录（只顯示當前數據庫的活動）
                print(f"DEBUG: Searching for activities in database: {current_database}")
                print(f"DEBUG: Available activity databases: {list(self.activity_records.keys())}")
                matching_activities = self.get_activities_for_date_range(search_date_from, search_date_to, current_database)
                print(f"DEBUG: Found {len(matching_activities)} matching activities for {current_database}")
                
                # 清空显示区域
                self.activity_alert_text.config(state='normal')
                self.activity_alert_text.delete(1.0, tk.END)
                
                if matching_activities:
                    # 清空显示区域并重新创建
                    self.activity_alert_text.config(state='normal')
                    self.activity_alert_text.delete(1.0, tk.END)
                    
                    # 创建标题区域
                    self.activity_alert_text.insert(tk.END, "📊 活動提醒 / Activity Alerts\n", "header")
                    self.activity_alert_text.insert(tk.END, f"搜索日期 / Search Date: {search_date_from.strftime('%d/%m/%Y')} - {search_date_to.strftime('%d/%m/%Y')}\n", "date_info")
                    self.activity_alert_text.insert(tk.END, f"發現 {len(matching_activities)} 個相關活動 / Found {len(matching_activities)} Activities:\n\n", "count_info")
                    
                    # 创建可点击的活动列表
                    for i, activity in enumerate(matching_activities, 1):
                        description = activity.get('description', activity.get('name', '無描述'))
                        activity_line = f"🔸 活動 {i} / Activity {i}: {description}\n"
                        
                        # 插入可点击的活动标题
                        start_index = self.activity_alert_text.index(tk.END + "-1c")
                        self.activity_alert_text.insert(tk.END, activity_line, f"activity_{i}")
                        end_index = self.activity_alert_text.index(tk.END + "-1c")
                        
                        # 为活动标题添加点击事件
                        self.activity_alert_text.tag_bind(f"activity_{i}", "<Button-1>", 
                                                         lambda e, act=activity, idx=i: self.show_activity_details(act, idx))
                        self.activity_alert_text.tag_bind(f"activity_{i}", "<Enter>", 
                                                         lambda e, tag=f"activity_{i}": self.on_activity_hover_enter(tag))
                        self.activity_alert_text.tag_bind(f"activity_{i}", "<Leave>", 
                                                         lambda e, tag=f"activity_{i}": self.on_activity_hover_leave(tag))
                    
                    self.activity_alert_text.insert(tk.END, "\n------活動細節------\n", "separator")
                    
                    # 显示第一个活动的详细信息（默认选中）
                    if matching_activities:
                        self.show_activity_details(matching_activities[0], 1, insert_mode=True)
                else:
                    # 没有匹配的活动
                    self.activity_alert_text.insert(tk.END, "📊 活動提醒 / Activity Alerts\n\n", "header")
                    self.activity_alert_text.insert(tk.END, f"搜索日期 / Search Date: {search_date_from.strftime('%d/%m/%Y')} - {search_date_to.strftime('%d/%m/%Y')}\n\n", "date_info")
                    self.activity_alert_text.insert(tk.END, "✅ 當前日期範圍內沒有記錄的活動\nNo recorded activities in current date range\n\n", "no_activity")
                    self.activity_alert_text.insert(tk.END, "💡 提示 / Note: 數據分析結果不會受到特殊活動影響\nData analysis results will not be affected by special activities", "note")
                
                # 配置文本样式
                self.configure_activity_alert_styles()
                self.activity_alert_text.config(state='disabled')
            else:
                # 日期选择器还未初始化
                self.activity_alert_text.config(state='normal')
                self.activity_alert_text.delete(1.0, tk.END)
                self.activity_alert_text.insert(1.0, "📊 活動提醒 / Activity Alerts\n\n請選擇搜索日期範圍以顯示活動提醒\nPlease select search date range to display activity alerts")
                self.activity_alert_text.config(state='disabled')
                
        except Exception as e:
            # 发生错误时的处理
            self.activity_alert_text.config(state='normal')
            self.activity_alert_text.delete(1.0, tk.END)
            self.activity_alert_text.insert(1.0, f"📊 活動提醒 / Activity Alerts\n\n錯誤 / Error: {str(e)}")
            self.activity_alert_text.config(state='disabled')
    
    def configure_activity_alert_styles(self):
        """配置活動提醒文本的樣式"""
        try:
            # 標題樣式
            self.activity_alert_text.tag_configure("header", 
                                                  font=('Microsoft YaHei UI', 14, 'bold'),
                                                  foreground='#2c3e50')
            
            # 日期信息樣式
            self.activity_alert_text.tag_configure("date_info", 
                                                  font=('Arial', 11),
                                                  foreground='#34495e')
            
            # 計數信息樣式
            self.activity_alert_text.tag_configure("count_info", 
                                                  font=('Arial', 11, 'bold'),
                                                  foreground='#27ae60')
            
            # 活動項目樣式（可點擊）
            for i in range(1, 11):  # 支持最多10個活動
                self.activity_alert_text.tag_configure(f"activity_{i}", 
                                                      font=('Microsoft YaHei UI', 11, 'bold'),
                                                      foreground='#3498db',
                                                      underline=False)
            
            # 分隔符樣式
            self.activity_alert_text.tag_configure("separator", 
                                                  font=('Arial', 11, 'bold'),
                                                  foreground='#7f8c8d')
            
            # 詳情樣式
            self.activity_alert_text.tag_configure("details", 
                                                  font=('Arial', 10),
                                                  foreground='#2c3e50')
            
            # 無活動樣式
            self.activity_alert_text.tag_configure("no_activity", 
                                                  font=('Arial', 11),
                                                  foreground='#27ae60')
            
            # 提示樣式
            self.activity_alert_text.tag_configure("note", 
                                                  font=('Arial', 10, 'italic'),
                                                  foreground='#95a5a6')
            
        except Exception as e:
            print(f"配置活動提醒樣式失敗: {e}")
    
    def show_activity_details(self, activity, activity_index, insert_mode=False):
        """顯示活動詳細信息"""
        try:
            if not insert_mode:
                # 清除詳情區域（從分隔符後開始）
                self.activity_alert_text.config(state='normal')
                
                # 找到分隔符的位置
                separator_pos = self.activity_alert_text.search("------活動細節------", "1.0", tk.END)
                if separator_pos:
                    # 刪除分隔符後的所有內容
                    self.activity_alert_text.delete(f"{separator_pos} lineend", tk.END)
            
            # 構建活動詳情
            details_text = f"\n🔸 活動 {activity_index} / Activity {activity_index}:\n\n"
            
            # 日期期間
            details_text += f"📅 日期期間 / Date Period:\n"
            details_text += f"   {activity['date_from']} - {activity['date_to']}\n\n"
            
            # 星期篩選（如果有的話）
            weekdays = activity.get('weekdays', [])
            if weekdays:
                details_text += f"🗓️ 星期篩選 / Weekday Filter:\n"
                details_text += f"   {', '.join(weekdays)}\n\n"
            
            # 門市信息
            outlets = activity.get('outlets', [])
            if outlets:
                total_outlets = len(getattr(self, 'available_outlets', []))
                if len(outlets) == total_outlets or len(outlets) > total_outlets * 0.9:
                    details_text += f"🏪 門市 / Outlets: All\n\n"
                elif len(outlets) <= 10:
                    details_text += f"🏪 門市 / Outlets:\n"
                    details_text += f"   {', '.join(outlets)}\n\n"
                else:
                    details_text += f"🏪 門市 / Outlets: {len(outlets)} 個門市 / {len(outlets)} Outlets\n\n"
            else:
                details_text += f"🏪 門市 / Outlets: All\n\n"
            
            # 活動詳情（描述）
            description = activity.get('description', activity.get('name', '無描述'))
            details_text += f"📝 活動詳情 / Activity Details:\n"
            details_text += f"   {description}\n\n"
            
            # 活動數據
            details_text += f"💰 活動數據 / Activity Data:\n"
            
            # 檢查數據庫連接和分析結果 - 優先使用直接更新的字段
            activity_db = activity.get('database', 'Express')
            
            # 優先使用直接更新的字段
            if activity.get('total_sales') is not None:
                # 使用直接更新的字段
                total_sales = activity.get('total_sales', 0)
                total_transactions = activity.get('total_receipts', 0)
                activity_sales = activity.get('activity_sales', 0)
                activity_transactions = activity.get('activity_receipts', 0)
                amount_ratio = activity.get('sales_ratio', 0)
                receipt_ratio = activity.get('receipt_ratio', 0)
                analyzed_time = activity.get('analysis_time', 'Unknown')
                
                details_text += f"   📊 總業績 / Total Sales: ${total_sales:,.2f}\n"
                details_text += f"   📊 總單據數 / Total Transactions: {total_transactions:,}\n"
                details_text += f"   💰 活動業績 / Activity Sales: ${activity_sales:,.2f}\n"
                details_text += f"   🧾 活動單據數 / Activity Transactions: {activity_transactions:,}\n"
                details_text += f"   📅 分析時間 / Analyzed: {analyzed_time}\n\n"
                
                # 顯示占比信息
                details_text += f"📊 業績占比 / Performance Ratio:\n"
                details_text += f"   {amount_ratio:.2f}%\n\n"
                
                details_text += f"📊 單據數占比 / Transaction Ratio:\n"
                details_text += f"   {receipt_ratio:.2f}%\n\n"
                
                print(f"📊 活動提醒 - 使用直接更新的字段顯示活動 {activity.get('id')} 的分析結果")
            else:
                # 使用舊的分析結果字段
                analysis_result = activity.get('analysis_result')
                if analysis_result:
                    # 顯示保存的分析結果 - 修正數據格式
                    total_sales = analysis_result.get('total_amount', 0)
                    total_transactions = analysis_result.get('total_receipts', 0)
                    activity_sales = analysis_result.get('activity_amount', 0)
                    activity_transactions = analysis_result.get('activity_receipts', 0)
                    amount_ratio = analysis_result.get('amount_ratio', 0)
                    receipt_ratio = analysis_result.get('receipt_ratio', 0)
                    analyzed_time = analysis_result.get('analyzed_at', 'Unknown')
                    
                    details_text += f"   📊 總業績 / Total Sales: ${total_sales:,.2f}\n"
                    details_text += f"   📊 總單據數 / Total Transactions: {total_transactions:,}\n"
                    details_text += f"   💰 活動業績 / Activity Sales: ${activity_sales:,.2f}\n"
                    details_text += f"   🧾 活動單據數 / Activity Transactions: {activity_transactions:,}\n"
                    details_text += f"   📅 分析時間 / Analyzed: {analyzed_time}\n\n"
                    
                    # 顯示占比信息
                    details_text += f"📊 業績占比 / Performance Ratio:\n"
                    details_text += f"   {amount_ratio:.2f}%\n\n"
                    
                    details_text += f"📊 單據數占比 / Transaction Ratio:\n"
                    details_text += f"   {receipt_ratio:.2f}%\n\n"
                    
                    print(f"📊 活動提醒 - 使用舊的分析結果字段顯示活動 {activity.get('id')} 的分析結果")
                else:
                    details_text += f"   ⚠️ 需要分析計算 / Requires analysis calculation\n"
                    details_text += f"   💡 請在活動記錄管理中點擊分析按鈕 / Click analyze in activity management\n\n"
                    
                    print(f"📊 活動提醒 - 活動 {activity.get('id')} 沒有分析結果")
            
            details_text += "💡 提示 / Note: 點擊其他活動查看詳情\nClick other activities to view details"
            
            # 插入詳情文本
            self.activity_alert_text.insert(tk.END, details_text, "details")
            self.activity_alert_text.config(state='disabled')
            
        except Exception as e:
            print(f"顯示活動詳情失敗: {e}")
    
    def on_activity_hover_enter(self, tag):
        """活動項目懸停進入效果"""
        try:
            self.activity_alert_text.tag_configure(tag, underline=True, foreground='#e74c3c')
        except Exception as e:
            print(f"懸停進入效果失敗: {e}")
    
    def on_activity_hover_leave(self, tag):
        """活動項目懸停離開效果"""
        try:
            self.activity_alert_text.tag_configure(tag, underline=False, foreground='#3498db')
        except Exception as e:
            print(f"懸停離開效果失敗: {e}")
    
    def export_analysis_report(self, report_content):
        """導出分析報告到文件"""
        try:
            from tkinter import filedialog
            import datetime
            
            # 生成默認文件名
            timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            default_filename = f"activity_analysis_report_{timestamp}.txt"
            
            # 選擇保存位置
            file_path = filedialog.asksaveasfilename(
                defaultextension=".txt",
                filetypes=[
                    ("Text files", "*.txt"),
                    ("All files", "*.*")
                ],
                initialname=default_filename,
                title="保存分析報告 / Save Analysis Report"
            )
            
            if file_path:
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write(report_content)
                
                tk.messagebox.showinfo(
                    "成功 / Success", 
                    f"報告已成功導出到:\nReport exported successfully to:\n{file_path}"
                )
        except Exception as e:
            tk.messagebox.showerror(
                "錯誤 / Error", 
                f"導出報告失敗:\nFailed to export report:\n{str(e)}"
            )
    
    def configure_analysis_text_styles(self, text_widget):
        """配置分析報告文本樣式"""
        try:
            # 標題樣式
            text_widget.tag_configure("header", 
                                    font=('Microsoft YaHei UI', 12, 'bold'),
                                    foreground='#2c3e50')
            
            # 信息樣式
            text_widget.tag_configure("info", 
                                    font=('Arial', 10),
                                    foreground='#34495e')
            
            # 條件樣式
            text_widget.tag_configure("condition", 
                                    font=('Arial', 10),
                                    foreground='#7f8c8d')
            
            # 結果標題樣式
            text_widget.tag_configure("result_header", 
                                    font=('Microsoft YaHei UI', 11, 'bold'),
                                    foreground='#27ae60')
            
            # 數據樣式
            text_widget.tag_configure("data", 
                                    font=('Consolas', 10, 'bold'),
                                    foreground='#3498db')
            
            # 分隔線樣式
            text_widget.tag_configure("separator", 
                                    font=('Arial', 9),
                                    foreground='#95a5a6')
            
            # 成功樣式
            text_widget.tag_configure("success", 
                                    font=('Arial', 10, 'bold'),
                                    foreground='#27ae60')
            
            # 警告樣式
            text_widget.tag_configure("warning", 
                                    font=('Arial', 10, 'bold'),
                                    foreground='#f39c12')
            
            # 錯誤樣式
            text_widget.tag_configure("error", 
                                    font=('Arial', 10, 'bold'),
                                    foreground='#e74c3c')
            
        except Exception as e:
            print(f"配置分析文本樣式失敗: {e}")
    
    def get_activity_performance_summary(self, activity):
        """獲取活動業績摘要和占比"""
        try:
            # 檢查是否有數據庫連接
            if not hasattr(self, 'db_manager') or not self.db_manager.connection:
                return None
            
            # 獲取活動信息
            date_from = activity.get('date_from', '')
            date_to = activity.get('date_to', '')
            outlets = activity.get('outlets', [])
            products = activity.get('products', [])
            payment_methods = activity.get('payment_methods', [])
            
            if not date_from or not date_to:
                return None
            
            # 獲取活動期間的總業績（所有門市、所有產品、所有支付方式）
            total_data = self.db_manager.get_sales_data(
                date_from=date_from, date_to=date_to,
                outlet_filters=[],  # 不限制門市
                product_filters=[], # 不限制產品
                weekday_filters=activity.get('weekdays', []),
                use_excel_cache=True
            )
            
            if not total_data:
                return None
            
            # 計算總業績
            total_amount = 0
            total_receipts = 0
            receipt_totals = {}
            
            for record in total_data:
                sales_no = record.get('sales_no', '')
                store_name = record.get('store_name', '')
                receipt_key = f"{store_name}-{sales_no}"
                
                # 計算業績
                sub_total = float(record.get('sub_total', 0))
                pro_disc_amt = float(record.get('pro_disc_amt', 0))
                svc_amt = float(record.get('svc_amt', 0))
                tax_amt = float(record.get('tax_amt', 0))
                take_away_item = str(record.get('take_away_item', 'N'))
                
                if self.db_manager.current_database == "sushi_gogo_pos_live":
                    net_amount = sub_total - pro_disc_amt + svc_amt - tax_amt
                else:
                    if take_away_item == 'Y':
                        net_amount = sub_total - pro_disc_amt + svc_amt - tax_amt
                    else:
                        net_amount = sub_total - pro_disc_amt + svc_amt
                
                if receipt_key not in receipt_totals:
                    receipt_totals[receipt_key] = 0.0
                receipt_totals[receipt_key] += net_amount
            
            total_amount = sum(receipt_totals.values())
            total_receipts = len(receipt_totals)
            
            # 獲取活動特定的業績（篩選門市、產品、支付方式）
            activity_data = self.db_manager.get_sales_data(
                date_from=date_from, date_to=date_to,
                outlet_filters=outlets,
                product_filters=products,
                weekday_filters=activity.get('weekdays', []),
                use_excel_cache=True
            )
            
            if not activity_data:
                return {
                    'total_amount': 0,
                    'total_receipts': 0,
                    'amount_ratio': 0,
                    'receipt_ratio': 0
                }
            
            # 如果有支付方式篩選，需要進一步篩選
            if payment_methods:
                # 這裡簡化處理，實際應該查詢支付方式表
                activity_amount = total_amount * 0.1  # 假設活動占10%（實際需要查詢）
                activity_receipts = int(total_receipts * 0.1)
            else:
                # 計算活動業績
                activity_amount = 0
                activity_receipts = 0
                activity_receipt_totals = {}
                
                for record in activity_data:
                    sales_no = record.get('sales_no', '')
                    store_name = record.get('store_name', '')
                    receipt_key = f"{store_name}-{sales_no}"
                    
                    # 計算業績
                    sub_total = float(record.get('sub_total', 0))
                    pro_disc_amt = float(record.get('pro_disc_amt', 0))
                    svc_amt = float(record.get('svc_amt', 0))
                    tax_amt = float(record.get('tax_amt', 0))
                    take_away_item = str(record.get('take_away_item', 'N'))
                    
                    if self.db_manager.current_database == "sushi_gogo_pos_live":
                        net_amount = sub_total - pro_disc_amt + svc_amt - tax_amt
                    else:
                        if take_away_item == 'Y':
                            net_amount = sub_total - pro_disc_amt + svc_amt - tax_amt
                        else:
                            net_amount = sub_total - pro_disc_amt + svc_amt
                    
                    if receipt_key not in activity_receipt_totals:
                        activity_receipt_totals[receipt_key] = 0.0
                    activity_receipt_totals[receipt_key] += net_amount
                
                activity_amount = sum(activity_receipt_totals.values())
                activity_receipts = len(activity_receipt_totals)
            
            # 計算占比
            amount_ratio = (activity_amount / total_amount * 100) if total_amount > 0 else 0
            receipt_ratio = (activity_receipts / total_receipts * 100) if total_receipts > 0 else 0
            
            return {
                'total_amount': activity_amount,
                'total_receipts': activity_receipts,
                'amount_ratio': amount_ratio,
                'receipt_ratio': receipt_ratio
            }
            
        except Exception as e:
            print(f"計算活動業績摘要失敗: {e}")
            return None
    
    # ==================== 实时搜索方法 ====================
    
    def highlight_search_results(self, tree_widget, search_term):
        """高亮显示搜索结果"""
        try:
            if not search_term:
                return
            
            # 清除之前的高亮
            for item in tree_widget.get_children():
                tree_widget.item(item, tags=())
            
            # 为匹配的行添加高亮标签
            for item in tree_widget.get_children():
                item_values = tree_widget.item(item, 'values')
                item_text = ' '.join([str(val) for val in item_values if val is not None])
                
                if search_term.lower() in item_text.lower():
                    tree_widget.item(item, tags=('highlight',))
            
            # 配置高亮样式
            tree_widget.tag_configure('highlight', background='#FFE4B5', foreground='#000000')
            
        except Exception as e:
            print(f"高亮显示出错: {e}")
    
    def filter_and_display_data(self, tree_widget, data, search_term, status_label):
        """通用的数据过滤和显示方法"""
        try:
            # 清空现有数据
            for item in tree_widget.get_children():
                tree_widget.delete(item)
            
            if not data:
                return
            
            # 如果没有搜索词，显示所有数据
            if not search_term:
                filtered_data = data
            else:
                # 执行搜索过滤
                filtered_data = []
                for row in data:
                    row_text = ' '.join([str(cell) for cell in row if cell is not None])
                    if search_term.lower() in row_text.lower():
                        filtered_data.append(row)
            
            # 显示过滤后的数据
            for row in filtered_data:
                tree_widget.insert("", "end", values=row)
            
            # 高亮显示搜索结果
            if search_term:
                self.highlight_search_results(tree_widget, search_term)
            
            # 更新状态
            if status_label:
                total_count = len(data)
                filtered_count = len(filtered_data)
                if search_term:
                    status_label.config(
                        text=f"找到 {filtered_count}/{total_count} 条记录", 
                        fg='green' if filtered_count > 0 else 'red'
                    )
                else:
                    status_label.config(text="", fg='blue')
            
        except Exception as e:
            print(f"过滤显示数据出错: {e}")
            if status_label:
                status_label.config(text=f"显示出错: {e}", fg='red')
    
    def realtime_search_product_overview(self):
        """实时搜索产品总览数据"""
        try:
            search_term = self.product_overview_search_entry.get().strip()
            if not hasattr(self, 'product_overview_data') or not self.product_overview_data:
                return
            
            # 清空现有数据
            for item in self.product_overview_tree.get_children():
                self.product_overview_tree.delete(item)
            
            if not search_term:
                # 如果没有搜索词，调用原始显示方法
                self.display_product_overview()
                self.product_overview_search_status.config(text="", fg='blue')
                return
            
            # 执行搜索过滤
            filtered_data = []
            for row in self.product_overview_data:
                # 在所有字段中搜索
                searchable_text = ' '.join([
                    str(row.get('日期', '')),
                    str(row.get('月份', '')),
                    str(row.get('门市', '')),
                    str(row.get('产品名称', '')),
                    str(row.get('类别', ''))
                ])
                
                if search_term.lower() in searchable_text.lower():
                    filtered_data.append(row)
            
            # 临时存储过滤后的数据并显示
            original_data = self.product_overview_data
            self.product_overview_data = filtered_data
            self.display_product_overview()
            self.product_overview_data = original_data
            
            # 高亮显示搜索结果
            self.highlight_search_results(self.product_overview_tree, search_term)
            
            # 更新状态
            total_count = len(original_data)
            filtered_count = len(filtered_data)
            self.product_overview_search_status.config(
                text=f"找到 {filtered_count}/{total_count} 条记录", 
                fg='green' if filtered_count > 0 else 'red'
            )
            
        except Exception as e:
            print(f"实时搜索产品总览数据出错: {e}")
            self.product_overview_search_status.config(text=f"搜索出错: {e}", fg='red')
    
    def realtime_search_period_product(self):
        """实时搜索期间产品数据"""
        try:
            search_term = self.period_product_search_entry.get().strip()
            if not hasattr(self, 'period_product_overview_data') or not self.period_product_overview_data:
                return
            
            # 清空现有数据
            for item in self.period_product_tree.get_children():
                self.period_product_tree.delete(item)
            
            if not search_term:
                # 如果没有搜索词，调用原始显示方法
                self.display_period_product_overview()
                self.period_product_search_status.config(text="", fg='blue')
                return
            
            # 执行搜索过滤
            filtered_data = []
            for row in self.period_product_overview_data:
                # 在所有字段中搜索
                searchable_text = ' '.join([
                    str(row.get('期间', '')),
                    str(row.get('产品名称', '')),
                    str(row.get('类别', ''))
                ])
                
                if search_term.lower() in searchable_text.lower():
                    filtered_data.append(row)
            
            # 临时存储过滤后的数据并显示
            original_data = self.period_product_overview_data
            self.period_product_overview_data = filtered_data
            self.display_period_product_overview()
            self.period_product_overview_data = original_data
            
            # 高亮显示搜索结果
            self.highlight_search_results(self.period_product_tree, search_term)
            
            # 更新状态
            total_count = len(original_data)
            filtered_count = len(filtered_data)
            self.period_product_search_status.config(
                text=f"找到 {filtered_count}/{total_count} 条记录", 
                fg='green' if filtered_count > 0 else 'red'
            )
            
        except Exception as e:
            print(f"实时搜索期间产品数据出错: {e}")
            self.period_product_search_status.config(text=f"搜索出错: {e}", fg='red')
    
    def realtime_search_log(self):
        """实时搜索日志信息"""
        try:
            search_term = self.log_search_entry.get().strip()
            
            # 获取所有日志内容
            all_content = self.info_text.get(1.0, tk.END)
            
            if not search_term:
                # 如果没有搜索词，显示所有内容
                self.log_search_status.config(text="", fg='blue')
                return
            
            # 搜索匹配的行
            lines = all_content.split('\n')
            matching_lines = []
            
            for line in lines:
                if search_term.lower() in line.lower():
                    matching_lines.append(line)
            
            # 更新状态
            total_lines = len([line for line in lines if line.strip()])
            matching_count = len(matching_lines)
            
            if matching_count > 0:
                self.log_search_status.config(
                    text=f"找到 {matching_count}/{total_lines} 行匹配", 
                    fg='green'
                )
                
                # 高亮显示匹配的行
                self.info_text.tag_remove("search_highlight", 1.0, tk.END)
                
                # 重新搜索并高亮
                start = 1.0
                while True:
                    pos = self.info_text.search(search_term, start, tk.END, nocase=True)
                    if not pos:
                        break
                    end = f"{pos}+{len(search_term)}c"
                    self.info_text.tag_add("search_highlight", pos, end)
                    start = end
                
                # 配置高亮样式
                self.info_text.tag_configure("search_highlight", background="yellow", foreground="black")
                
            else:
                self.log_search_status.config(text="未找到匹配内容", fg='red')
                self.info_text.tag_remove("search_highlight", 1.0, tk.END)
            
        except Exception as e:
            print(f"实时搜索日志出错: {e}")
            self.log_search_status.config(text=f"搜索出错: {e}", fg='red')
    
    def realtime_search_sales(self):
        """实时搜索销售数据"""
        try:
            search_term = self.sales_search_entry.get().strip()
            if not hasattr(self, 'sales_data') or not self.sales_data:
                return
            
            # 清空现有数据
            for item in self.sales_tree.get_children():
                self.sales_tree.delete(item)
            
            if not search_term:
                # 如果没有搜索词，调用原始显示方法
                self.display_sales_data()
                self.sales_search_status.config(text="", fg='blue')
                return
            
            # 执行搜索过滤
            filtered_data = []
            for data in self.sales_data:
                # 在所有字段中搜索
                searchable_text = ' '.join([
                    str(data.get('store_name', '')),
                    str(data.get('sales_no', '')),
                    str(data.get('item_name', '')),
                    str(data.get('payment_methods', '')),
                    str(data.get('category_code', '')),
                    str(data.get('disc_name', '')),
                    str(data.get('c_date', ''))
                ])
                
                if search_term.lower() in searchable_text.lower():
                    filtered_data.append(data)
            
            # 临时存储过滤后的数据并显示
            original_data = self.sales_data
            self.sales_data = filtered_data
            self.display_sales_data()
            self.sales_data = original_data
            
            # 高亮显示搜索结果
            self.highlight_search_results(self.sales_tree, search_term)
            
            # 更新状态
            total_count = len(original_data)
            filtered_count = len(filtered_data)
            self.sales_search_status.config(
                text=f"找到 {filtered_count}/{total_count} 条记录", 
                fg='green' if filtered_count > 0 else 'red'
            )
            
        except Exception as e:
            print(f"实时搜索销售数据出错: {e}")
            self.sales_search_status.config(text=f"搜索出错: {e}", fg='red')
    
    def realtime_search_payment(self):
        """实时搜索支付数据"""
        try:
            search_term = self.payment_search_entry.get().strip()
            if not hasattr(self, 'payment_data') or not self.payment_data:
                return
            
            # 清空现有数据
            for item in self.payment_tree.get_children():
                self.payment_tree.delete(item)
            
            if not search_term:
                # 如果没有搜索词，调用原始显示方法
                self.display_payment_analysis()
                self.payment_search_status.config(text="", fg='blue')
                return
            
            # 执行搜索过滤
            filtered_data = []
            for row in self.payment_data:
                # 在所有字段中搜索
                searchable_text = ' '.join([str(cell) for cell in row if cell is not None])
                if search_term.lower() in searchable_text.lower():
                    filtered_data.append(row)
            
            # 临时存储过滤后的数据并显示
            original_data = self.payment_data
            self.payment_data = filtered_data
            self.display_payment_analysis()
            self.payment_data = original_data
            
            # 高亮显示搜索结果
            self.highlight_search_results(self.payment_tree, search_term)
            
            # 更新状态
            total_count = len(original_data)
            filtered_count = len(filtered_data)
            self.payment_search_status.config(
                text=f"找到 {filtered_count}/{total_count} 条记录", 
                fg='green' if filtered_count > 0 else 'red'
            )
            
        except Exception as e:
            print(f"实时搜索支付数据出错: {e}")
            self.payment_search_status.config(text=f"搜索出错: {e}", fg='red')
    
    def realtime_search_discount(self):
        """实时搜索折扣数据"""
        try:
            search_term = self.discount_search_entry.get().strip()
            if not hasattr(self, 'discount_data') or not self.discount_data:
                return
            
            # 清空现有数据
            for item in self.discount_tree.get_children():
                self.discount_tree.delete(item)
            
            if not search_term:
                # 如果没有搜索词，调用原始显示方法
                self.display_discount_analysis()
                self.discount_search_status.config(text="", fg='blue')
                return
            
            # 执行搜索过滤
            filtered_data = []
            for data in self.discount_data:
                # 在所有字段中搜索
                searchable_text = ' '.join([
                    str(data.get('门市', '')),
                    str(data.get('月份', '')),
                    str(data.get('折扣名称', '')),
                    str(data.get('折扣金额', '')),
                    str(data.get('折扣占比(%)', '')),
                    str(data.get('折扣次数', '')),
                    str(data.get('折扣次数占比(%)', '')),
                    str(data.get('全門市折扣總次數', ''))
                ])
                if search_term.lower() in searchable_text.lower():
                    filtered_data.append(data)
            
            # 临时存储过滤后的数据并显示
            original_data = self.discount_data
            self.discount_data = filtered_data
            self.display_discount_analysis()
            self.discount_data = original_data
            
            # 高亮显示搜索结果
            self.highlight_search_results(self.discount_tree, search_term)
            
            # 更新状态
            total_count = len(original_data)
            filtered_count = len(filtered_data)
            self.discount_search_status.config(
                text=f"找到 {filtered_count}/{total_count} 条记录", 
                fg='green' if filtered_count > 0 else 'red'
            )
            
        except Exception as e:
            print(f"实时搜索折扣数据出错: {e}")
            self.discount_search_status.config(text=f"搜索出错: {e}", fg='red')
    
    def realtime_search_monthly(self):
        """实时搜索月度数据"""
        try:
            search_term = self.monthly_search_entry.get().strip()
            if not hasattr(self, 'monthly_data') or not self.monthly_data:
                return
            
            # 清空现有数据
            for item in self.monthly_tree.get_children():
                self.monthly_tree.delete(item)
            
            if not search_term:
                # 如果没有搜索词，调用原始显示方法
                self.display_monthly_summary()
                self.monthly_search_status.config(text="", fg='blue')
                return
            
            # 执行搜索过滤
            filtered_data = []
            for row in self.monthly_data:
                # 在所有字段中搜索
                searchable_text = ' '.join([str(cell) for cell in row if cell is not None])
                if search_term.lower() in searchable_text.lower():
                    filtered_data.append(row)
            
            # 临时存储过滤后的数据并显示
            original_data = self.monthly_data
            self.monthly_data = filtered_data
            self.display_monthly_summary()
            self.monthly_data = original_data
            
            # 高亮显示搜索结果
            self.highlight_search_results(self.monthly_tree, search_term)
            
            # 更新状态
            total_count = len(original_data)
            filtered_count = len(filtered_data)
            self.monthly_search_status.config(
                text=f"找到 {filtered_count}/{total_count} 条记录", 
                fg='green' if filtered_count > 0 else 'red'
            )
            
        except Exception as e:
            print(f"实时搜索月度数据出错: {e}")
            self.monthly_search_status.config(text=f"搜索出错: {e}", fg='red')
    
    def realtime_search_weekly_product(self):
        """实时搜索周期产品数据"""
        try:
            search_term = self.weekly_product_search_entry.get().strip()
            if not hasattr(self, 'weekly_product_data') or not self.weekly_product_data:
                return
            
            # 清空现有数据
            for item in self.weekly_product_tree.get_children():
                self.weekly_product_tree.delete(item)
            
            if not search_term:
                # 如果没有搜索词，调用原始显示方法
                self.display_weekly_product_data()
                self.weekly_product_search_status.config(text="", fg='blue')
                return
            
            # 执行搜索过滤
            filtered_data = []
            for row in self.weekly_product_data:
                # 在所有字段中搜索
                searchable_text = ' '.join([str(cell) for cell in row if cell is not None])
                if search_term.lower() in searchable_text.lower():
                    filtered_data.append(row)
            
            # 临时存储过滤后的数据并显示
            original_data = self.weekly_product_data
            self.weekly_product_data = filtered_data
            self.display_weekly_product_data()
            self.weekly_product_data = original_data
            
            # 高亮显示搜索结果
            self.highlight_search_results(self.weekly_product_tree, search_term)
            
            # 更新状态
            total_count = len(original_data)
            filtered_count = len(filtered_data)
            self.weekly_product_search_status.config(
                text=f"找到 {filtered_count}/{total_count} 条记录", 
                fg='green' if filtered_count > 0 else 'red'
            )
            
        except Exception as e:
            print(f"实时搜索周期产品数据出错: {e}")
            self.weekly_product_search_status.config(text=f"搜索出错: {e}", fg='red')
    
    def realtime_search_daily_analysis(self):
        """实时搜索日-产品分析数据"""
        try:
            search_term = self.daily_analysis_search_entry.get().strip()
            if not hasattr(self, 'sales_tc_analysis_data') or not self.sales_tc_analysis_data:
                return
            
            # 清空现有数据
            for item in self.sales_tc_analysis_tree.get_children():
                self.sales_tc_analysis_tree.delete(item)
            
            if not search_term:
                # 如果没有搜索词，调用原始显示方法
                self.display_sales_tc_analysis()
                self.daily_analysis_search_status.config(text="", fg='blue')
                return
            
            # 执行搜索过滤
            filtered_data = []
            for row in self.sales_tc_analysis_data:
                # 在所有字段中搜索
                searchable_text = ' '.join([str(cell) for cell in row if cell is not None])
                if search_term.lower() in searchable_text.lower():
                    filtered_data.append(row)
            
            # 临时存储过滤后的数据并显示
            original_data = self.sales_tc_analysis_data
            self.sales_tc_analysis_data = filtered_data
            self.display_sales_tc_analysis()
            self.sales_tc_analysis_data = original_data
            
            # 高亮显示搜索结果
            self.highlight_search_results(self.sales_tc_analysis_tree, search_term)
            
            # 更新状态
            total_count = len(original_data)
            filtered_count = len(filtered_data)
            self.daily_analysis_search_status.config(
                text=f"找到 {filtered_count}/{total_count} 条记录", 
                fg='green' if filtered_count > 0 else 'red'
            )
            
        except Exception as e:
            print(f"实时搜索日-产品分析数据出错: {e}")
            self.daily_analysis_search_status.config(text=f"搜索出错: {e}", fg='red')
    
    def realtime_search_monthly_analysis(self):
        """实时搜索月-产品分析数据"""
        try:
            search_term = self.monthly_analysis_search_entry.get().strip()
            if not hasattr(self, 'sales_tc_monthly_data') or not self.sales_tc_monthly_data:
                return
            
            # 清空现有数据
            for item in self.sales_tc_monthly_tree.get_children():
                self.sales_tc_monthly_tree.delete(item)
            
            if not search_term:
                # 如果没有搜索词，调用原始显示方法
                self.display_sales_tc_monthly()
                self.monthly_analysis_search_status.config(text="", fg='blue')
                return
            
            # 执行搜索过滤
            filtered_data = []
            for row in self.sales_tc_monthly_data:
                # 在所有字段中搜索
                searchable_text = ' '.join([str(cell) for cell in row if cell is not None])
                if search_term.lower() in searchable_text.lower():
                    filtered_data.append(row)
            
            # 临时存储过滤后的数据并显示
            original_data = self.sales_tc_monthly_data
            self.sales_tc_monthly_data = filtered_data
            self.display_sales_tc_monthly()
            self.sales_tc_monthly_data = original_data
            
            # 高亮显示搜索结果
            self.highlight_search_results(self.sales_tc_monthly_tree, search_term)
            
            # 更新状态
            total_count = len(original_data)
            filtered_count = len(filtered_data)
            self.monthly_analysis_search_status.config(
                text=f"找到 {filtered_count}/{total_count} 条记录", 
                fg='green' if filtered_count > 0 else 'red'
            )
            
        except Exception as e:
            print(f"实时搜索月-产品分析数据出错: {e}")
            self.monthly_analysis_search_status.config(text=f"搜索出错: {e}", fg='red')
    
    def realtime_search_association(self):
        """实时搜索产品关联分析数据"""
        try:
            search_term = self.association_search_entry.get().strip()
            if not hasattr(self, 'product_association_data') or not self.product_association_data:
                return
            
            # 清空现有数据
            for item in self.product_association_tree.get_children():
                self.product_association_tree.delete(item)
            
            if not search_term:
                # 如果没有搜索词，调用原始显示方法
                self.display_product_association()
                self.association_search_status.config(text="", fg='blue')
                return
            
            # 执行搜索过滤
            filtered_data = []
            for row in self.product_association_data:
                # 在所有字段中搜索
                searchable_text = ' '.join([str(cell) for cell in row if cell is not None])
                if search_term.lower() in searchable_text.lower():
                    filtered_data.append(row)
            
            # 临时存储过滤后的数据并显示
            original_data = self.product_association_data
            self.product_association_data = filtered_data
            self.display_product_association()
            self.product_association_data = original_data
            
            # 高亮显示搜索结果
            self.highlight_search_results(self.product_association_tree, search_term)
            
            # 更新状态
            total_count = len(original_data)
            filtered_count = len(filtered_data)
            self.association_search_status.config(
                text=f"找到 {filtered_count}/{total_count} 条记录", 
                fg='green' if filtered_count > 0 else 'red'
            )
            
        except Exception as e:
            print(f"实时搜索产品关联分析数据出错: {e}")
            self.association_search_status.config(text=f"搜索出错: {e}", fg='red')
    
    def realtime_search_category_analysis(self):
        """实时搜索类别分析数据"""
        try:
            search_term = self.category_analysis_search_entry.get().strip()
            if not hasattr(self, 'category_analysis_data') or not self.category_analysis_data:
                return
            
            # 清空现有数据
            for item in self.category_analysis_tree.get_children():
                self.category_analysis_tree.delete(item)
            
            if not search_term:
                # 如果没有搜索词，调用原始显示方法
                self.display_category_analysis()
                self.category_analysis_search_status.config(text="", fg='blue')
                return
            
            # 执行搜索过滤
            filtered_data = []
            for row in self.category_analysis_data:
                # 在所有字段中搜索
                searchable_text = ' '.join([str(cell) for cell in row if cell is not None])
                if search_term.lower() in searchable_text.lower():
                    filtered_data.append(row)
            
            # 临时存储过滤后的数据并显示
            original_data = self.category_analysis_data
            self.category_analysis_data = filtered_data
            self.display_category_analysis()
            self.category_analysis_data = original_data
            
            # 高亮显示搜索结果
            self.highlight_search_results(self.category_analysis_tree, search_term)
            
            # 更新状态
            total_count = len(original_data)
            filtered_count = len(filtered_data)
            self.category_analysis_search_status.config(
                text=f"找到 {filtered_count}/{total_count} 条记录", 
                fg='green' if filtered_count > 0 else 'red'
            )
            
        except Exception as e:
            print(f"实时搜索类别分析数据出错: {e}")
            self.category_analysis_search_status.config(text=f"搜索出错: {e}", fg='red')
    
    def run(self):
        """运行GUI"""
        self.root.mainloop()

def main():
    """主函数"""
    try:
        print("启动POS数据分析工具 - 增强版...")
        app = POSAnalysisGUI()
        print("GUI初始化完成，开始运行主循环...")
        app.run()
    except Exception as e:
        print(f"程序运行出错: {e}")
        import traceback
        traceback.print_exc()
        input("按回车键退出...")

if __name__ == "__main__":
    main()
