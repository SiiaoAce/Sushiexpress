import os
import sys
import threading
import time
import re
import copy
import csv
import traceback
import calendar
from datetime import datetime, timedelta
from collections import defaultdict
from dateutil.parser import parse
from typing import List, Optional, Tuple
try:
    from tkcalendar import DateEntry
except ImportError:
    DateEntry = None
import customtkinter as ctk
from tkinter import filedialog, messagebox, simpledialog
from openpyxl import load_workbook, Workbook
from openpyxl.utils import get_column_letter
from openpyxl.worksheet.worksheet import Worksheet
import codecs
import pandas as pd
from PIL import Image, ImageDraw, ImageFont
from openpyxl.cell.cell import MergedCell
import glob
import xlwings as xw
import tkinter.ttk as ttk
import tempfile
import uuid
import win32com.client
import base64
import pywintypes
import openpyxl
from openpyxl.styles import Alignment, Font, PatternFill, Border, Side
from calendar import monthcalendar
from typing import Dict, List, Tuple, Optional, Any, Union, Callable
import multiprocessing
multiprocessing.freeze_support()   # for PyInstaller on Windows



def safe_save_excel_workbook(workbook, file_path):
    """全局安全保存 Excel 工作簿函數，避免命名範圍問題"""
    try:
        import shutil
        import copy
        
        # 創建備份
        backup_path = file_path.replace('.xlsx', '_backup.xlsx')
        shutil.copy2(file_path, backup_path)
        
        # 使用工作簿複製方法，完全避免外部鏈接和命名範圍問題
        try:
            print(f"[DEBUG] 使用工作簿複製方法，避免所有Excel修復問題")
            
            # 創建新的工作簿
            new_wb = openpyxl.Workbook()
            
            # 刪除默認工作表
            if 'Sheet' in new_wb.sheetnames:
                del new_wb['Sheet']
            
            # 複製所有工作表
            for sheet in workbook.worksheets:
                new_ws = new_wb.create_sheet(sheet.title)
                
                # 複製所有數據和格式
                for row in sheet.iter_rows():
                    for cell in row:
                        new_cell = new_ws.cell(row=cell.row, column=cell.column)
                        
                        # 複製值（保持原始值，包括所有公式）
                        if cell.value is not None:
                            new_cell.value = cell.value
                            print(f"[DEBUG] 複製值: {cell.coordinate} = {cell.value}")
                        
                        # 安全複製格式，避免循環引用
                        try:
                            if cell.font:
                                from openpyxl.styles import Font
                                new_cell.font = Font(
                                    name=cell.font.name,
                                    size=cell.font.size,
                                    bold=cell.font.bold,
                                    italic=cell.font.italic,
                                    vertAlign=cell.font.vertAlign,
                                    underline=cell.font.underline,
                                    strike=cell.font.strike,
                                    color=cell.font.color
                                )
                        except Exception:
                            pass
                        
                        try:
                            if cell.fill and hasattr(cell.fill, 'fill_type'):
                                from openpyxl.styles import PatternFill
                                new_cell.fill = PatternFill(
                                    fill_type=cell.fill.fill_type,
                                    start_color=cell.fill.start_color,
                                    end_color=cell.fill.end_color
                                )
                        except Exception:
                            pass
                        
                        try:
                            if cell.alignment:
                                from openpyxl.styles import Alignment
                                new_cell.alignment = Alignment(
                                    horizontal=cell.alignment.horizontal,
                                    vertical=cell.alignment.vertical,
                                    text_rotation=cell.alignment.text_rotation,
                                    wrap_text=cell.alignment.wrap_text,
                                    shrink_to_fit=cell.alignment.shrink_to_fit,
                                    indent=cell.alignment.indent
                                )
                        except Exception:
                            pass
                        
                        try:
                            if cell.border:
                                from openpyxl.styles import Border, Side
                                new_cell.border = Border(
                                    left=Side(border_style=cell.border.left.style, color=cell.border.left.color),
                                    right=Side(border_style=cell.border.right.style, color=cell.border.right.color),
                                    top=Side(border_style=cell.border.top.style, color=cell.border.top.color),
                                    bottom=Side(border_style=cell.border.bottom.style, color=cell.border.bottom.color)
                                )
                        except Exception:
                            pass
                        
                        try:
                            if cell.number_format:
                                new_cell.number_format = cell.number_format
                        except Exception:
                            pass
                
                # 複製合併儲存格
                for merged_range in sheet.merged_cells.ranges:
                    new_ws.merge_cells(str(merged_range))
                
                # 複製列寬和行高
                for col in sheet.column_dimensions:
                    new_ws.column_dimensions[col].width = sheet.column_dimensions[col].width
                    # 複製列的隱藏狀態
                    if hasattr(sheet.column_dimensions[col], 'hidden'):
                        new_ws.column_dimensions[col].hidden = sheet.column_dimensions[col].hidden
                        print(f"[DEBUG] 複製列隱藏狀態: 列{col} = {sheet.column_dimensions[col].hidden}")
                
                for row in sheet.row_dimensions:
                    new_ws.row_dimensions[row].height = sheet.row_dimensions[row].height
                    # 複製行的隱藏狀態
                    if hasattr(sheet.row_dimensions[row], 'hidden'):
                        new_ws.row_dimensions[row].hidden = sheet.row_dimensions[row].hidden
                        print(f"[DEBUG] 複製行隱藏狀態: 行{row} = {sheet.row_dimensions[row].hidden}")
                
                # 固定設定凍結窗格為 A9
                try:
                    new_ws.freeze_panes = "A9"
                    print(f"[DEBUG] 設定固定凍結窗格: A9")
                except Exception as freeze_error:
                    print(f"[DEBUG] 設定凍結窗格失敗: {freeze_error}")
                
                # 複製工作表保護
                if sheet.protection:
                    new_ws.protection = sheet.protection
            
            # 保存新工作簿
            new_wb.save(file_path)
            new_wb.close()
            print(f"[DEBUG] 工作簿複製保存成功: {file_path}")
            
            # 刪除備份
            if os.path.exists(backup_path):
                os.remove(backup_path)
            
            return True
            
        except Exception as copy_error:
            print(f"[DEBUG] 工作簿複製失敗，使用新工作簿方法: {copy_error}")
            
            # 方法2：創建新工作簿
            new_wb = openpyxl.Workbook()
            
            # 刪除默認工作表
            if 'Sheet' in new_wb.sheetnames:
                del new_wb['Sheet']
            
            # 複製所有工作表
            for sheet in workbook.worksheets:
                new_ws = new_wb.create_sheet(sheet.title)
                
                # 複製所有數據和格式
                for row in sheet.iter_rows():
                    for cell in row:
                        new_cell = new_ws.cell(row=cell.row, column=cell.column)
                        
                        # 複製值，包括公式
                        if cell.value is not None:
                            new_cell.value = cell.value
                            print(f"[DEBUG] 複製值: {cell.coordinate} = {cell.value}")
                        
                        # 複製格式 - 使用安全的方法避免 StyleProxy 錯誤
                        if cell.has_style:
                            try:
                                # 只複製值，不複製樣式對象引用
                                if cell.font and hasattr(cell.font, 'name'):
                                    new_cell.font = openpyxl.styles.Font(
                                        name=cell.font.name,
                                        size=cell.font.size,
                                        bold=cell.font.bold,
                                        italic=cell.font.italic,
                                        color=cell.font.color
                                    )
                                # 完全跳過邊框複製，避免產生莫名的黑線
                                # 不複製邊框，讓 Excel 使用默認的網格線
                                pass
                                if cell.fill and hasattr(cell.fill, 'fill_type'):
                                    new_cell.fill = openpyxl.styles.PatternFill(
                                        fill_type=cell.fill.fill_type,
                                        start_color=cell.fill.start_color,
                                        end_color=cell.fill.end_color
                                    )
                                if cell.alignment and hasattr(cell.alignment, 'horizontal'):
                                    new_cell.alignment = openpyxl.styles.Alignment(
                                        horizontal=cell.alignment.horizontal,
                                        vertical=cell.alignment.vertical,
                                        wrap_text=cell.alignment.wrap_text
                                    )
                                new_cell.number_format = cell.number_format
                            except Exception as style_error:
                                print(f"⚠️ 複製樣式時出錯，跳過樣式: {style_error}")
                                # 如果樣式複製失敗，只複製值
                                pass
                
                # 複製合併儲存格
                for merged_range in sheet.merged_cells.ranges:
                    new_ws.merge_cells(str(merged_range))
                
                # 複製列寬和隱藏狀態
                for col_letter, dimension in sheet.column_dimensions.items():
                    new_ws.column_dimensions[col_letter].width = dimension.width
                    # 複製列的隱藏狀態
                    if hasattr(dimension, 'hidden'):
                        new_ws.column_dimensions[col_letter].hidden = dimension.hidden
                        print(f"[DEBUG] 複製列隱藏狀態: 列{col_letter} = {dimension.hidden}")
                
                # 複製行高和隱藏狀態
                for row_num, row_dimension in sheet.row_dimensions.items():
                    new_ws.row_dimensions[row_num] = row_dimension
                    # 複製行的隱藏狀態
                    if hasattr(row_dimension, 'hidden'):
                        new_ws.row_dimensions[row_num].hidden = row_dimension.hidden
                        print(f"[DEBUG] 複製行隱藏狀態: 行{row_num} = {row_dimension.hidden}")
                
                # 複製凍結窗格 (Freeze Panes)
                if sheet.freeze_panes:
                    new_ws.freeze_panes = sheet.freeze_panes
                
                # 複製條件格式
                try:
                    if hasattr(sheet, 'conditional_formatting') and hasattr(sheet.conditional_formatting, '_cf_rules'):
                        for sqref, rules in sheet.conditional_formatting._cf_rules.items():
                            if isinstance(rules, list):
                                for rule in rules:
                                    new_ws.conditional_formatting.add(sqref, rule)
                            else:
                                new_ws.conditional_formatting.add(sqref, rules)
                except Exception as cf_error:
                    print(f"⚠️ 複製條件格式時出錯: {cf_error}")
                
                # 複製工作表視圖設定
                try:
                    if hasattr(sheet, 'views') and sheet.views:
                        new_ws.views = sheet.views
                except Exception as views_error:
                    print(f"⚠️ 複製視圖設定時出錯: {views_error}")
                
                # 複製打印設定
                try:
                    if hasattr(sheet, 'print_options') and sheet.print_options:
                        new_ws.print_options = sheet.print_options
                    if hasattr(sheet, 'page_setup') and sheet.page_setup:
                        new_ws.page_setup = sheet.page_setup
                    if hasattr(sheet, 'page_margins') and sheet.page_margins:
                        new_ws.page_margins = sheet.page_margins
                except Exception as print_error:
                    print(f"⚠️ 複製打印設定時出錯: {print_error}")
            
            # 保存新工作簿
            new_wb.save(file_path)
            new_wb.close()
            
            print(f"[DEBUG] 使用新工作簿保存成功: {file_path}")
            
            # 刪除備份
            if os.path.exists(backup_path):
                os.remove(backup_path)
            
            return True
            
    except Exception as e:
        print(f"[DEBUG] 安全保存失敗，使用原始方法: {e}")
        # 如果安全保存失敗，使用原始方法
        try:
            workbook.save(file_path)
            return False
        except Exception as final_error:
            print(f"[DEBUG] 原始保存也失敗: {final_error}")
            # 如果原始保存也失敗，恢復備份
            if os.path.exists(backup_path):
                shutil.copy2(backup_path, file_path)
                os.remove(backup_path)
                print(f"[DEBUG] 已恢復備份文件")
            raise final_error


def normalize_supplier_name(name):
    return name.lower().replace(
    " ",
    "").replace(
        ".",
        "").replace(
            "_",
             "")


def get_week_of_month(dt: datetime) -> int:
    """
    根據實際星期來判斷是當月第幾週
    （週一為一週的開始）
    """
    year, month, day = dt.year, dt.month, dt.day
    month_cal = calendar.monthcalendar(year, month)
    week_no = 0
    for week in month_cal:
        if day in week:
            week_no = month_cal.index(week) 
            break
    return week_no


def find_supplier_file(supplier_name, files):
    norm_supplier = normalize_supplier_name(supplier_name)
    candidates = []
    exact_matches = []
    
    print(f"[DEBUG] 查找供应商文件: {supplier_name}")
    print(f"[DEBUG] 标准化供应商名称: {norm_supplier}")

    for f in files:
        # 獲取檔名（不含副檔名）
        filename_without_ext = os.path.splitext(f)[0]
        norm_f = normalize_supplier_name(filename_without_ext)
        
        # 精確匹配：檔名開頭完全匹配供應商名稱
        if norm_f.startswith(norm_supplier):
            remaining = norm_f[len(norm_supplier):]
            print(f"[DEBUG] 文件 {f} 开头匹配，剩余: '{remaining}'")
            
            # 檢查是否為精確匹配
            if not remaining or remaining.startswith(
                '_') or remaining.startswith('amendment'):
                print(f"[DEBUG] 添加到精确匹配（无剩余或下划线）")
                exact_matches.append(f)
            elif '(' in remaining and ')' in remaining:
                # 允許括號變體，如 "Super Q (Chawan)"
                print(f"[DEBUG] 添加到精确匹配（括号变体）")
                exact_matches.append(f)
            elif remaining.isalnum() or any(x in remaining.lower() for x in ['oct', 'nov', 'dec', 'jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'week']):
                # 允許時間標識，如 "octweek3"
                print(f"[DEBUG] 添加到精确匹配（时间标识）")
                exact_matches.append(f)
            else:
                print(f"[DEBUG] 添加到候选匹配")
                candidates.append(f)
        # 包含匹配：檔名包含供應商名稱
        elif norm_supplier in norm_f:
            print(f"[DEBUG] 文件 {f} 包含匹配，添加到候选")
            candidates.append(f)
        else:
            print(f"[DEBUG] 文件 {f} 不匹配")

    # 優先返回精確匹配
    if len(exact_matches) == 1:
        print(f"[DEBUG] 找到唯一精确匹配: {exact_matches[0]}")
        return exact_matches[0]
    elif len(exact_matches) > 1:
        print(f"[DEBUG] 找到多个精确匹配: {exact_matches}")
        # 如果有多个精确匹配，优先选择与供应商名称最匹配的文件
        # 如果供应商名称包含括号，优先选择包含括号的文件
        supplier_has_brackets = '(' in supplier_name and ')' in supplier_name
        
        if supplier_has_brackets:
            # 供应商名称包含括号，优先选择包含括号的文件
            for f in exact_matches:
                if '(' in f and ')' in f:
                    print(f"[DEBUG] 选择包含括号的文件: {f}")
                    return f
        
        # 供应商名称不包含括号，优先选择不包含括号的文件
        for f in exact_matches:
            if '(' not in f and ')' not in f:
                print(f"[DEBUG] 选择不包含括号的文件: {f}")
                return f
        
        # 如果都有括號或都沒有括號，選擇最短的
        return min(exact_matches, key=len)

    # 如果沒有精確匹配，使用候選匹配
    if len(candidates) == 1:
        return candidates[0]
    elif len(candidates) > 1:
        # 如果有多个候选匹配，优先选择与供应商名称最匹配的文件
        supplier_has_brackets = '(' in supplier_name and ')' in supplier_name
        
        if supplier_has_brackets:
            # 供应商名称包含括号，优先选择包含括号的文件
            for f in candidates:
                if '(' in f and ')' in f and f.startswith(supplier_name):
                    print(f"[DEBUG] 选择包含括号的候选文件: {f}")
                    return f
        
        # 供应商名称不包含括号，优先选择不包含括号的文件
        for f in candidates:
            if '(' not in f and ')' not in f and f.startswith(supplier_name):
                print(f"[DEBUG] 选择不包含括号的候选文件: {f}")
                return f
        
        # 嘗試找到以供應商名稱開頭的文件
        for f in candidates:
            if f.startswith(supplier_name):
                return f
        return candidates[0]

    return None


def find_all_supplier_files(supplier_name, files):
    """查找供应商的所有相关文件，支持多文件发送"""
    all_matches = []
    
    for f in files:
        # 获取文件名（不含副档名）
        filename_without_ext = os.path.splitext(f)[0]
        
        # 检查文件名是否以供应商名称开头（不区分大小写）
        if filename_without_ext.lower().startswith(supplier_name.lower()):
            # 接受所有相关文件，只要文件名以供应商名称开头
            # 支持各种格式：
            # - Super Q_Sep_Week_1.xlsx
            # - Super Q (Chawan)_Sep_Week_1.xlsx
            # - Super Q Sep_Week_1.xlsx
            # - Super Q_Amendment_Sep_1.xlsx
            all_matches.append(f)
    
    # 按文件名排序，确保顺序一致
    all_matches.sort()
    return all_matches

# ======== 资源路径处理 ========


def resource_path(relative_path):
    """获取资源文件的绝对路径"""
    try:
        base_path = sys._MEIPASS
    except AttributeError:
        base_path = os.path.abspath(".")
    return os.path.join(base_path, relative_path)


# ========== 全局配置 ==========
LOGO_PATH = resource_path("SELOGO22 - 01.png")
PASSWORD = "OPS123"
VERSION = "6.6.1"
DEVELOPER = "OPS - Voon Kee"

# 主题配置
ctk.set_appearance_mode("dark")
ctk.set_default_color_theme("blue")

# ========== 颜色主题系统 ==========
class ColorTheme:
    """颜色主题类"""
    def __init__(self, name, dark_bg, dark_panel, accent_blue, btn_hover, accent_green, 
                 accent_red, accent_purple, entry_bg, text_color, panel_bg, textbox_bg, 
                 gradient_colors=None, description=""):
        self.name = name
        self.dark_bg = dark_bg
        self.dark_panel = dark_panel
        self.accent_blue = accent_blue
        self.btn_hover = btn_hover
        self.accent_green = accent_green
        self.accent_red = accent_red
        self.accent_purple = accent_purple
        self.entry_bg = entry_bg
        self.text_color = text_color
        self.panel_bg = panel_bg
        self.textbox_bg = textbox_bg
        self.gradient_colors = gradient_colors or []
        self.description = description

# 预定义主题
THEMES = {
    "classic_blue": ColorTheme(
        name="經典藍\nClassic Blue",
        dark_bg="#0f172a",
        dark_panel="#1e293b", 
        accent_blue="#3b82f6",
        btn_hover="#2563eb",
        accent_green="#10b981",
        accent_red="#ef4444",
        accent_purple="#8b5cf6",
        entry_bg="#334155",
        text_color="#f1f5f9",
        panel_bg="#1e293b",
        textbox_bg="#0f172a",
        gradient_colors=["#0f172a", "#1e293b", "#334155", "#475569", "#64748b"],
        description="經典藍色主題，專業穩重"
    ),
    "pure_black": ColorTheme(
        name="純黑\nPure Black",
        dark_bg="#000000",
        dark_panel="#111111",
        accent_blue="#60a5fa",
        btn_hover="#3b82f6",
        accent_green="#34d399",
        accent_red="#f87171",
        accent_purple="#a78bfa",
        entry_bg="#1f1f1f",
        text_color="#ffffff",
        panel_bg="#111111",
        textbox_bg="#000000",
        gradient_colors=["#000000", "#111111", "#1f1f1f", "#2d2d2d", "#404040"],
        description="純黑主題，簡約時尚"
    ),
    "blue_gradient": ColorTheme(
        name="藍色漸變\nBlue Gradient",
        dark_bg="#0c4a6e",
        dark_panel="#075985",
        accent_blue="#0ea5e9",
        btn_hover="#0284c7",
        accent_green="#22d3ee",
        accent_red="#f472b6",
        accent_purple="#a855f7",
        entry_bg="#0369a1",
        text_color="#e0f2fe",
        panel_bg="#075985",
        textbox_bg="#0c4a6e",
        gradient_colors=["#0c4a6e", "#075985", "#0369a1", "#0284c7", "#0ea5e9"],
        description="藍色漸變主題，清新優雅"
    ),
    "bright_light": ColorTheme(
        name="明亮主題\nBright Light",
        dark_bg="#ffffff",
        dark_panel="#f8fafc",
        accent_blue="#2563eb",
        btn_hover="#3b82f6",
        accent_green="#059669",
        accent_red="#dc2626",
        accent_purple="#7c3aed",
        entry_bg="#e2e8f0",
        text_color="#1e293b",
        panel_bg="#f1f5f9",
        textbox_bg="#ffffff",
        gradient_colors=["#ffffff", "#f8fafc", "#e2e8f0", "#cbd5e1", "#94a3b8"],
        description="明亮清爽主題，適合白天使用"
    )
}

# 当前主题
CURRENT_THEME = "classic_blue"

def get_current_theme():
    """获取当前主题"""
    return THEMES.get(CURRENT_THEME, THEMES["classic_blue"])

def set_theme(theme_name):
    """设置主题"""
    global CURRENT_THEME
    if theme_name in THEMES:
        CURRENT_THEME = theme_name
        return True
    return False

def save_theme_config():
    """保存主题配置"""
    try:
        import json
        config = {"theme": CURRENT_THEME}
        with open("theme_config.json", "w", encoding="utf-8") as f:
            json.dump(config, f, ensure_ascii=False, indent=2)
    except Exception as e:
        print(f"保存主题配置失败: {e}")

def load_theme_config():
    """加载主题配置"""
    try:
        if os.path.exists("theme_config.json"):
            import json
            with open("theme_config.json", "r", encoding="utf-8") as f:
                config = json.load(f)
                if "theme" in config and config["theme"] in THEMES:
                    global CURRENT_THEME
                    CURRENT_THEME = config["theme"]
    except Exception as e:
        print(f"加载主题配置失败: {e}")

# 加载主题配置
load_theme_config()

# 颜色定义
DARK_BG = "#0f172a"
DARK_PANEL = "#1e293b"
ACCENT_BLUE = "#3b82f6"
BTN_HOVER = "#60a5fa"
ACCENT_GREEN = "#10b981"
ACCENT_RED = "#ef4444"
ACCENT_PURPLE = "#8b5cf6"
ACCENT_ORANGE = "#f97316"
ENTRY_BG = "#334155"
TEXT_COLOR = "#e2e8f0"
PANEL_BG = "#1e293b"
TEXTBOX_BG = "#0f172a"

# 字体配置
FONT_TITLE = ("Microsoft JhengHei", 24, "bold")
FONT_BIGBTN = ("Microsoft JhengHei", 16, "bold")
FONT_MID = ("Microsoft JhengHei", 14)
FONT_SUB = ("Microsoft JhengHei", 12)
FONT_ZH = ("Microsoft JhengHei", 12)
FONT_EN = ("Segoe UI", 11, "italic")
FONT_LOG = ("Consolas", 14)
FONT_SMALL = ("Microsoft JhengHei", 10)

# ========== 多语言支持 ==========


def t(text):
    translations = {
        "mapping_not_available": "分店供应商对应数据不可用\nOutlet-supplier mapping not available",
        "log_not_available": "日志数据不可用\nLog data not available",
        "info": "信息\nInformation",
        "processing": "處理中...\nProcessing...",
        "please_wait": "請稍候...\nPlease wait...",
        "error": "錯誤\nError",
        "login": "系統登錄\nSystem Login",
        "password": "輸入密碼...\nEnter password...",
        "login_btn": "登入\nLogin",
        "exit_confirm": "確定要退出應用程序嗎？\nAre you sure you want to exit the application?",
        "incorrect_pw": "密碼不正確，請重試\nIncorrect password, please try again",
        "main_title": "Sushi Express 自動化工具\nSushi Express Automation Tool",
        "select_function": "請選擇要執行的功能\nPlease select a function",
        "download_title": "Outlook 訂單下載\nOutlook Order Download",
        "download_desc": "下載本週的 Weekly Order 附件\nDownload weekly order attachments",
        "browse": "瀏覽...\nBrowse...",
        "start_download": "開始下載\nStart Download",
        "back_to_menu": "返回主菜單\nBack to Main Menu",
        "checklist_title": "Weekly Order 檢查表\nWeekly Order Checklist",
        "checklist_desc": "請選擇包含供應商訂單的資料夾\nSelect folder with supplier orders",
        "run_check": "執行檢查\nRun Check",
        "automation_title": "訂單自動整合\nOrder Automation",
        "automation_desc": "請選擇三個必要的資料夾\nSelect required folders",
        "source_folder": "來源資料夾 (Weekly Orders)\nSource Folder (Weekly Orders)",
        "supplier_folder": "供應商資料夾 (Supplier)\nSupplier Folder",
        "outlet_folder": "分店資料夾 (Outlet)\nOutlet Folder",
        "start_automation": "開始整合檔案\nStart Automation",
        "processing_orders": "處理訂單\nProcessing Orders",
        "outlet_suppliers": "分店供應商對應\nOutlet-Supplier Mapping",
        "exit_system": "退出系統\nExit System",
        "theme_selection": "主題選擇\nTheme Selection",
        "select_account": "選擇 Outlook 帳號\nSelect Outlook Account",
        "enter_index": "請輸入序號：\nPlease enter index:",
        "download_summary": "下載摘要\nDownload Summary",
        "auto_download": "自動下載\nAuto Downloaded",
        "skipped": "跳過\nSkipped",
        "saved_to": "保存到\nSaved to",
        "check_results": "檢查結果\nCheck Results",
        "success": "成功\nSuccess",
        "warning": "警告\nWarning",
        "folder_warning": "請先選擇所有必要的資料夾\nPlease select all required folders",
        "close": "關閉\nClose",
        "order_processing": "訂單處理進度\nOrder Processing Progress",
        "outlet_supplier_mapping": "分店-供應商對應關係\nOutlet-Supplier Mapping",
        "select_folder": "選擇文件夾\nSelect Folder",
        "view_mapping": "查看分店供應商對應\nView Outlet-Supplier Mapping",
        "view_log": "查看完整日誌\nView Full Log",
        "supplier_files": "已處理的供應商文件\nProcessed Supplier Files",
        "outlet_files": "已處理的分店文件\nProcessed Outlet Files",
        "outlet_orders": "分店訂購情況\nOutlet Orders",
        "supplier_orders": "供應商訂購情況\nSupplier Orders",
        "send_emails": "發送郵件\nSend Emails",
        "operation_supplies": "營運用品\nOperation Supplies",
        "ordering_function": "訂單功能\nOrdering Function",
        "monthend_function": "月結功能\nMonthend Closing Function",
        "function_selection": "功能選擇\nFunction Selection",
        "enter_monthend": "進入月結功能\nEnter Monthend Function",
        "ordering_function_title": "📋 訂單功能\nOrdering Function",
        "monthend_function_title": "📊 月結功能\nMonthend Closing Function",
        "monthend_related": "月結相關功能\nMonthend related functions",
        "monthend_function_nav": "📊 月結功能\nMonthend Function",
        "month_end_function": "📊 月結功能\nMonth-end Function",
        "back_to_main": "返回主菜單\nBack to Main",
        "coming_soon": "(即將推出 Coming Soon)",
        "outlook_order_download": "Outlook訂單下載\nOutlook Order Download",
        "order_automation": "訂單自動整合\nOrder Automation",
        "weekly_order_checklist": "每週訂單檢查表\nWeekly Order Checklist",
        "send_emails": "發送郵件\nSend Emails",
        "operation_supplies": "營運用品\nOperation Supplies",
        "monthend_download": "月結文件下載\nMonth-end Download",
        "monthly_order_summary": "訂單月度彙總\nMonthly Order Summary",
        "supplier_statement": "供應商對賬單\nSupplier Statement",
        "monthly_sales_report": "月度銷售報表\nMonthly Sales Report",
        "cost_analysis": "成本分析核算\nCost Analysis",
        "inventory_count": "庫存盤點整理\nInventory Count",
    }
    return translations.get(text, text)


def get_contrast_color(bg_color):
    # 簡單亮色/暗色對比
    if isinstance(bg_color, str) and bg_color.startswith('#'):
        r = int(bg_color[1:3], 16)
        g = int(bg_color[3:5], 16)
        b = int(bg_color[5:7], 16)
        luminance = (0.299 * r + 0.587 * g + 0.114 * b)
        return '#000000' if luminance > 186 else '#ffffff'
    return '#ffffff'

# ========== 工具函数 ==========


def load_image(path, max_size=(400, 130)):
    """安全加载图像"""
    try:
        if not os.path.exists(path):
            img = Image.new('RGB', max_size, color=DARK_BG[:3])
            draw = ImageDraw.Draw(img)
            font = ImageFont.truetype("arial.ttf", 24)
            draw.text((10, 10), "Logo Missing", fill="white", font=font)
        else:
            img = Image.open(path)
        img.thumbnail(max_size, Image.LANCZOS)
        return ctk.CTkImage(img, size=img.size)
    except Exception as e:
        print(f"Error loading image: {e}")
        return None

# ========== 自定义UI组件 ==========


class TopMostSuccessDialog(ctk.CTkToplevel):
    """置頂成功提示對話框"""

    def __init__(self, parent, title, message, auto_close_seconds=3):
        super().__init__(parent)
        self.title(title)
        self.geometry("400x200")
        self.resizable(False, False)
        self.transient(parent)
        self.grab_set()

        # 設置置頂
        self.attributes('-topmost', True)

        # 居中顯示
        self.center_window()

        # 設置背景色
        self.configure(fg_color=DARK_BG)

        # 主容器
        main_frame = ctk.CTkFrame(self, fg_color=DARK_PANEL, corner_radius=12)
        main_frame.pack(fill="both", expand=True, padx=20, pady=20)

        # 成功圖標
        icon_label = ctk.CTkLabel(
            main_frame,
            text="✅",
            font=("Microsoft YaHei", 32),
            text_color=ACCENT_GREEN
        )
        icon_label.pack(pady=(20, 10))

        # 標題
        title_label = ctk.CTkLabel(
            main_frame,
            text=title,
            font=("Microsoft YaHei", 16, "bold"),
            text_color="white"
        )
        title_label.pack(pady=(0, 10))

        # 消息
        message_label = ctk.CTkLabel(
            main_frame,
            text=message,
            font=("Microsoft YaHei", 12),
            text_color="#cccccc",
            wraplength=300
        )
        message_label.pack(pady=(0, 20))

        # 確定按鈕
        ok_button = ctk.CTkButton(
            main_frame,
            text="確定 / OK",
            command=self.destroy,
            fg_color=ACCENT_GREEN,
            hover_color="#059669",
            font=("Microsoft YaHei", 12, "bold"),
            width=100,
            height=32
        )
        ok_button.pack(pady=(0, 20))

        # 強制獲得焦點
        self.focus_force()

        # 自動關閉
        if auto_close_seconds > 0:
            self.after(auto_close_seconds * 1000, self.destroy)

    def center_window(self):
        """居中顯示視窗"""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        self.geometry(f"{width}x{height}+{x}+{y}")


def show_topmost_success(parent, title, message, auto_close_seconds=3):
    """顯示置頂成功提示對話框的便利函數"""
    TopMostSuccessDialog(parent, title, message, auto_close_seconds)


class OutlookAccountSelector(ctk.CTkToplevel):
    """美化的 Outlook 帳號選擇對話框"""

    def __init__(self, parent, account_names):
        super().__init__(parent)
        self.title("選擇 Outlook 帳號 / Select Outlook Account")
        self.geometry("600x550")  # 增加寬度和高度
        self.configure(fg_color=DARK_BG)
        self.selected_index = None

        # 設置為置頂並居中
        self.attributes('-topmost', True)
        self.resizable(True, True)  # 允許調整大小

        # 居中顯示
        self.update_idletasks()
        x = (self.winfo_screenwidth() // 2) - (600 // 2)
        y = (self.winfo_screenheight() // 2) - (550 // 2)
        self.geometry(f"600x550+{x}+{y}")

        # 主容器
        main_container = ctk.CTkFrame(self, fg_color="transparent")
        main_container.pack(fill="both", expand=True, padx=20, pady=20)

        # 標題
        title_label = ctk.CTkLabel(
            main_container,
            text="選擇 Outlook 帳號\nSelect Outlook Account",
            font=("Microsoft JhengHei", 18, "bold"),
            text_color=ACCENT_BLUE
        )
        title_label.pack(pady=(0, 10))

        # 說明文字
        info_label = ctk.CTkLabel(
            main_container,
            text="請選擇要用於下載郵件的 Outlook 帳號\nPlease select the Outlook account for downloading emails",
            font=("Microsoft JhengHei", 12),
            text_color=TEXT_COLOR
        )
        info_label.pack(pady=(0, 20))

        # 帳號列表框架
        list_frame = ctk.CTkFrame(
    main_container,
    fg_color=DARK_PANEL,
     corner_radius=10)
        list_frame.pack(fill="both", expand=True, pady=(0, 20))

        # 滾動框架
        scroll_frame = ctk.CTkScrollableFrame(
            list_frame, fg_color="transparent")
        scroll_frame.pack(fill="both", expand=True, padx=15, pady=15)

        # 帳號選項
        self.account_vars = []
        for i, account_name in enumerate(account_names):
            var = ctk.StringVar(value="")
            self.account_vars.append(var)

            # 帳號選項框架
            account_frame = ctk.CTkFrame(
    scroll_frame, fg_color=ENTRY_BG, corner_radius=8)
            account_frame.pack(fill="x", pady=5)

            # 單選按鈕
            radio_btn = ctk.CTkRadioButton(
                account_frame,
                text=f"[{i}] {account_name}",
                variable=var,
                value=str(i),
                font=("Microsoft JhengHei", 12),
                text_color=TEXT_COLOR,
                fg_color=ACCENT_BLUE,
                hover_color=BTN_HOVER,
                command=lambda idx=i: self._on_account_selected(idx)
            )
            radio_btn.pack(anchor="w", padx=15, pady=10)

        # 按鈕框架
        btn_frame = ctk.CTkFrame(main_container, fg_color="transparent")
        btn_frame.pack(fill="x", pady=(10, 0))

        # 取消按鈕
        cancel_btn = ctk.CTkButton(
            btn_frame,
            text="取消 / Cancel",
            command=self._on_cancel,
            fg_color="#6b7280",
            hover_color="#4b5563",
            font=("Microsoft JhengHei", 12, "bold"),
            corner_radius=8,
            width=120,
            height=40
        )
        cancel_btn.pack(side="right", padx=(10, 0))

        # 確定按鈕
        ok_btn = ctk.CTkButton(
            btn_frame,
            text="確定 / OK",
            command=self._on_ok,
            fg_color=ACCENT_GREEN,
            hover_color="#059669",
            font=("Microsoft JhengHei", 12, "bold"),
            corner_radius=8,
            width=120,
            height=40
        )
        ok_btn.pack(side="right", padx=(0, 10))

        # 確保視窗獲得焦點
        self.focus_force()
        self.grab_set()

        # 強制更新佈局
        self.update_idletasks()

    def _on_account_selected(self, index):
        """當選擇帳號時"""
        self.selected_index = index
        # 清除其他選項
        for i, var in enumerate(self.account_vars):
            if i != index:
                var.set("")

    def _on_ok(self):
        """確定按鈕"""
        if self.selected_index is not None:
            self.destroy()
        else:
            messagebox.showwarning("未選擇", "請先選擇一個 Outlook 帳號")

    def _on_cancel(self):
        """取消按鈕"""
        self.selected_index = None
        self.destroy()


def show_outlook_account_selector(parent, account_names):
    """顯示 Outlook 帳號選擇對話框"""
    dialog = OutlookAccountSelector(parent, account_names)

    # 等待對話框關閉
    try:
        if parent:
            parent.wait_window(dialog)
        else:
            dialog.wait_window()
    except Exception as e:
        print(f"對話框等待錯誤: {e}")

    return dialog.selected_index

# ========== 自定义UI组件 ==========


class GlowButton(ctk.CTkButton):
    """发光效果按钮（美化版）"""

    def __init__(self, master, text=None, glow_color=ACCENT_BLUE, **kwargs):
        super().__init__(master, text=text, **kwargs)
        self._glow_color = glow_color
        self._setup_style()
        self._bind_events()

    def _setup_style(self):
        self.configure(
            border_width=0,
            fg_color=self._glow_color,
            hover_color=self._adjust_color(self._glow_color, 40),
            text_color=get_contrast_color(self._glow_color),
            corner_radius=22,  # 更圆角
            font=("Microsoft JhengHei", 20, "bold"),  # 更大更粗
            height=70,  # 更高
            width=340,  # 更宽
            anchor="center"
        )

    def _bind_events(self):
        self.bind("<Enter>", self._on_enter)
        self.bind("<Leave>", self._on_leave)

    def _on_enter(self, event=None):
        self.configure(
    border_width=4, border_color=self._adjust_color(
        self._glow_color, 60), fg_color=self._adjust_color(
            self._glow_color, 20))

    def _on_leave(self, event=None):
        self.configure(border_width=0, fg_color=self._glow_color)

    @staticmethod
    def _adjust_color(color, amount):
        if isinstance(color, tuple) and len(color) >= 3:
            r, g, b = color[:3]
            adjusted = tuple(min(255, max(0, x + amount)) for x in (r, g, b))
            if len(color) == 4:
                return adjusted + (color[3],)
            return adjusted
        else:
            color = color.lstrip('#')
            rgb = tuple(int(color[i:i + 2], 16) for i in (0, 2, 4))
            adjusted = tuple(min(255, max(0, x + amount)) for x in rgb)
            return f"#{adjusted[0]:02x}{adjusted[1]:02x}{adjusted[2]:02x}"


class ProgressPopup(ctk.CTkToplevel):
    """进度显示弹窗"""

    def __init__(
    self,
    parent,
    title,
    start_date=None,
    end_date=None,
     outlet_count=None):
        super().__init__(parent)
        self.title(title)
        self.geometry("900x700")
        self.transient(parent)
        self.grab_set()
        self.parent = parent
        self.configure(fg_color=DARK_BG)
        self.log_text = ctk.CTkTextbox(
            self,
            wrap="word",
            font=FONT_LOG,
            fg_color=TEXTBOX_BG,
            text_color=TEXT_COLOR,
            corner_radius=10
        )
        self.log_text.pack(fill="both", expand=True, padx=20, pady=20)
        self.log_text.configure(state="normal")
        if start_date and end_date:
            self.log_text.insert(
    "end", f"📅 抓取日期範圍: {start_date} ~ {end_date}\n")
        self.log_text.configure(state="disabled")
        self.outlet_count_label = ctk.CTkLabel(
            self,
            text=f"🏪 已下載分店數量: {
    outlet_count if outlet_count is not None else 0} 間",
            font=("Microsoft JhengHei", 18, "bold"),
            text_color="#10b981"
        )
        self.outlet_count_label.pack(pady=(0, 10))
        close_btn = GlowButton(
            self,
            text=t("close"),
            command=self.destroy_popup,
            width=120,
            height=40
        )
        close_btn.pack(pady=10)

    def update_outlet_count(self, count):
        if self.outlet_count_label:
            self.outlet_count_label.configure(text=f"🏪 已下載分店數量: {count} 間")

    def destroy_popup(self):
        self.destroy()
        self.parent.progress_popup = None

    def log(self, message):
        self.log_text.configure(state="normal")
        self.log_text.insert("end", message)
        self.log_text.see("end")
        self.log_text.configure(state="disabled")
        # 強制更新UI
        self.update()


class MappingPopup(ctk.CTkToplevel):
    """分店-供应商映射显示"""

    def __init__(self, parent, title):
        super().__init__(parent)
        self.title(title)
        self.geometry("900x700")
        self.transient(parent)
        self.grab_set()
        self.parent = parent
        self.configure(fg_color=DARK_BG)

        self.mapping_text = ctk.CTkTextbox(
            self,
            wrap="word",
            font=FONT_LOG,
            fg_color=TEXTBOX_BG,
            text_color=TEXT_COLOR,
            corner_radius=10
        )
        self.mapping_text.pack(fill="both", expand=True, padx=20, pady=20)
        self.mapping_text.configure(state="disabled")

        close_btn = GlowButton(
            self,
            text=t("close"),
            command=self.destroy_popup,
            width=120,
            height=40
        )
        close_btn.pack(pady=10)

    def destroy_popup(self):
        self.destroy()
        self.parent.mapping_popup = None

    def update_mapping(self, mapping):
        self.mapping_text.configure(state="normal")
        self.mapping_text.delete("1.0", "end")
        self.mapping_text.insert("1.0", mapping)
        self.mapping_text.configure(state="disabled")


class ScrollableMessageBox(ctk.CTkToplevel):
    """可滚动消息框"""

    def __init__(self, parent, title, message):
        super().__init__(parent)
        self.title(title)
        self.geometry("900x700")
        self.transient(parent)
        self.grab_set()
        self.configure(fg_color=DARK_BG)

        self.text_box = ctk.CTkTextbox(
            self,
            wrap="word",
            font=FONT_LOG,
            fg_color=TEXTBOX_BG,
            text_color=TEXT_COLOR,
            corner_radius=10
        )
        self.text_box.pack(fill="both", expand=True, padx=20, pady=20)
        self.text_box.insert("1.0", message)
        self.text_box.configure(state="disabled")

        close_btn = GlowButton(
            self,
            text=t("close"),
            command=self.destroy,
            width=120,
            height=40
        )
        close_btn.pack(pady=10)


class MismatchCorrectionDialog(ctk.CTkToplevel):
    """Mismatch 修正和扣分對話框"""

    def __init__(self, parent, supplier, outlet, cover_status, remark):
        super().__init__(parent)
        self.title("Mismatch 修正和扣分 / Mismatch Correction & Deduction")
        self.geometry("800x700")
        self.transient(parent)
        self.grab_set()
        self.configure(fg_color=DARK_BG)
        self.supplier = supplier
        self.outlet = outlet
        self.cover_status = cover_status
        self.remark = remark

        # 居中顯示
        self.center_window()

        # 主容器
        main_frame = ctk.CTkFrame(self, fg_color="transparent")
        main_frame.pack(fill="both", expand=True, padx=20, pady=20)

        # 標題
        title_label = ctk.CTkLabel(
            main_frame,
            text="🔧 Mismatch 修正和扣分\n🔧 Mismatch Correction & Deduction",
            font=("Microsoft JhengHei", 18, "bold"),
            text_color=ACCENT_BLUE
        )
        title_label.pack(pady=(0, 20))

        # 錯誤信息顯示
        error_frame = ctk.CTkFrame(
    main_frame,
    fg_color=DARK_PANEL,
     corner_radius=12)
        error_frame.pack(fill="x", pady=(0, 20))

        ctk.CTkLabel(
            error_frame,
            text="錯誤信息 / Error Information:",
            font=("Microsoft JhengHei", 14, "bold"),
            text_color=ACCENT_RED
        ).pack(anchor="w", padx=15, pady=(15, 5))

        error_text = f"供應商: {supplier}\n分店: {outlet}\n狀態: {cover_status}\n錯誤: {remark}"
        ctk.CTkLabel(
            error_frame,
            text=error_text,
            font=("Microsoft JhengHei", 12),
            text_color=TEXT_COLOR,
            justify="left"
        ).pack(anchor="w", padx=15, pady=(0, 15))

        # 修正區域
        correction_frame = ctk.CTkFrame(
    main_frame, fg_color=DARK_PANEL, corner_radius=12)
        correction_frame.pack(fill="x", pady=(0, 20))

        ctk.CTkLabel(
            correction_frame,
            text="修正信息 / Correction Information:",
            font=("Microsoft JhengHei", 14, "bold"),
            text_color=ACCENT_GREEN
        ).pack(anchor="w", padx=15, pady=(15, 10))

        # 正確店名輸入
        ctk.CTkLabel(
            correction_frame,
            text="正確店名 / Correct Outlet Name:",
            font=("Microsoft JhengHei", 12),
            text_color=TEXT_COLOR
        ).pack(anchor="w", padx=15, pady=(5, 2))

        self.correct_outlet_var = ctk.StringVar()
        self.correct_outlet_entry = ctk.CTkEntry(
            correction_frame,
            textvariable=self.correct_outlet_var,
            font=("Microsoft JhengHei", 12),
            height=35,
            placeholder_text="輸入正確的店名..."
        )
        self.correct_outlet_entry.pack(fill="x", padx=15, pady=(0, 10))

        # 正確地址輸入
        ctk.CTkLabel(
            correction_frame,
            text="正確地址 / Correct Address:",
            font=("Microsoft JhengHei", 12),
            text_color=TEXT_COLOR
        ).pack(anchor="w", padx=15, pady=(5, 2))

        self.correct_address_var = ctk.StringVar()
        self.correct_address_entry = ctk.CTkEntry(
            correction_frame,
            textvariable=self.correct_address_var,
            font=("Microsoft JhengHei", 12),
            height=35,
            placeholder_text="輸入正確的地址..."
        )
        self.correct_address_entry.pack(fill="x", padx=15, pady=(0, 15))

        # 扣分區域
        deduction_frame = ctk.CTkFrame(
    main_frame, fg_color=DARK_PANEL, corner_radius=12)
        deduction_frame.pack(fill="x", pady=(0, 20))

        ctk.CTkLabel(
            deduction_frame,
            text="扣分信息 / Deduction Information:",
            font=("Microsoft JhengHei", 14, "bold"),
            text_color=ACCENT_PURPLE
        ).pack(anchor="w", padx=15, pady=(15, 10))

        # 扣分人員輸入
        ctk.CTkLabel(
            deduction_frame,
            text="扣分人員 / Deducted By:",
            font=("Microsoft JhengHei", 12),
            text_color=TEXT_COLOR
        ).pack(anchor="w", padx=15, pady=(5, 2))

        self.deducted_by_var = ctk.StringVar()
        self.deducted_by_entry = ctk.CTkEntry(
            deduction_frame,
            textvariable=self.deducted_by_var,
            font=("Microsoft JhengHei", 12),
            height=35,
            placeholder_text="輸入扣分人員姓名..."
        )
        self.deducted_by_entry.pack(fill="x", padx=15, pady=(0, 10))

        # 備註輸入
        ctk.CTkLabel(
            deduction_frame,
            text="備註 / Notes:",
            font=("Microsoft JhengHei", 12),
            text_color=TEXT_COLOR
        ).pack(anchor="w", padx=15, pady=(5, 2))

        self.notes_var = ctk.StringVar(value=supplier)  # 默認填入供應商名稱
        self.notes_entry = ctk.CTkEntry(
            deduction_frame,
            textvariable=self.notes_var,
            font=("Microsoft JhengHei", 12),
            height=35,
            placeholder_text="輸入備註（默認為供應商名稱）..."
        )
        self.notes_entry.pack(fill="x", padx=15, pady=(0, 15))

        # 按鈕區域
        btn_frame = ctk.CTkFrame(main_frame, fg_color="transparent")
        btn_frame.pack(fill="x", pady=(10, 0))

        # 取消按鈕
        cancel_btn = ctk.CTkButton(
            btn_frame,
            text="取消 / Cancel",
            command=self.destroy,
            fg_color="#6b7280",
            hover_color="#4b5563",
            font=("Microsoft JhengHei", 12, "bold"),
            corner_radius=8,
            width=120,
            height=40
        )
        cancel_btn.pack(side="right", padx=(10, 0))

        # 保存扣分記錄按鈕
        save_btn = ctk.CTkButton(
            btn_frame,
            text="保存扣分記錄\nSave Deduction",
            command=self._save_deduction_record,
            fg_color=ACCENT_RED,
            hover_color="#dc2626",
            font=("Microsoft JhengHei", 12, "bold"),
            corner_radius=8,
            width=150,
            height=40
        )
        save_btn.pack(side="right", padx=(0, 10))

        # 修正並保存按鈕
        correct_btn = ctk.CTkButton(
            btn_frame,
            text="修正並保存\nCorrect & Save",
            command=self._correct_and_save,
            fg_color=ACCENT_GREEN,
            hover_color="#059669",
            font=("Microsoft JhengHei", 12, "bold"),
            corner_radius=8,
            width=150,
            height=40
        )
        correct_btn.pack(side="right", padx=(0, 10))

        # 強制獲得焦點
        self.focus_force()

    def center_window(self):
        """居中顯示視窗"""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        self.geometry(f"{width}x{height}+{x}+{y}")

    def _save_deduction_record(self):
        """保存扣分記錄到 Excel"""
        try:
            from datetime import datetime
            import openpyxl
            from openpyxl.styles import Font, Alignment
            import os

            # 檢查必填欄位
            deducted_by = self.deducted_by_var.get().strip()
            if not deducted_by:
                messagebox.showwarning("警告", "請輸入扣分人員姓名！")
                return

            # 扣分表文件路徑
            deduction_file = "outlet_deduction_record.xlsx"

            # 如果文件不存在，創建新文件
            if not os.path.exists(deduction_file):
                wb = openpyxl.Workbook()
                ws = wb.active
                ws.title = "扣分記錄"

                # 設置標題行
                headers = ["日期", "類別", "描述", "扣分項目", "扣分", "扣分人員", "備註"]
                for col, header in enumerate(headers, 1):
                    cell = ws.cell(row=1, column=col, value=header)
                    cell.font = Font(bold=True)
                    cell.alignment = Alignment(horizontal="center")

                # 設置列寬
                ws.column_dimensions['A'].width = 12  # 日期
                ws.column_dimensions['B'].width = 15  # 類別
                ws.column_dimensions['C'].width = 50  # 描述
                ws.column_dimensions['D'].width = 12  # 扣分項目
                ws.column_dimensions['E'].width = 8   # 扣分
                ws.column_dimensions['F'].width = 15  # 扣分人員
                ws.column_dimensions['G'].width = 20  # 備註

                wb.save(deduction_file)

            # 打開現有文件
            wb = openpyxl.load_workbook(deduction_file)
            ws = wb.active

            # 找到下一個空行
            next_row = ws.max_row + 1

            # 填入數據
            today = datetime.now().strftime("%Y-%m-%d")
            ws.cell(row=next_row, column=1, value=today)  # A: 日期
            ws.cell(row=next_row, column=2, value="WeeklyOrder")  # B: 類別
            ws.cell(
    row=next_row,
    column=3,
     # C: 描述
     value="Order Wrong Data (e.g. Wrong Date, Wrong Outlet Selected, etc.)")
            ws.cell(row=next_row, column=4, value=10)  # D: 扣分項目 (固定10分)
            ws.cell(row=next_row, column=5, value=1)   # E: 扣分 (固定1分)
            ws.cell(row=next_row, column=6, value=deducted_by)  # F: 扣分人員
            ws.cell(
    row=next_row,
    column=7,
     value=self.notes_var.get().strip())  # G: 備註

            # 保存文件
            wb.save(deduction_file)

            messagebox.showinfo("成功", f"扣分記錄已保存到 {deduction_file}")

        except Exception as e:
            messagebox.showerror("錯誤", f"保存扣分記錄時發生錯誤：{str(e)}")

    def _correct_and_save(self):
        """修正錯誤並保存扣分記錄"""
        # 檢查修正信息
        correct_outlet = self.correct_outlet_var.get().strip()
        correct_address = self.correct_address_var.get().strip()

        if not correct_outlet and not correct_address:
            messagebox.showwarning("警告", "請至少填入正確的店名或地址！")
            return

        # 先保存扣分記錄
        self._save_deduction_record()

        # 顯示修正信息（這裡可以擴展為實際修正文件的功能）
        correction_info = f"修正信息已記錄：\n"
        if correct_outlet:
            correction_info += f"正確店名: {correct_outlet}\n"
        if correct_address:
            correction_info += f"正確地址: {correct_address}\n"

        messagebox.showinfo("修正完成", correction_info + "\n扣分記錄也已同時保存。")
        self.destroy()


class EmailConfirmationDialog(ctk.CTkToplevel):
    """邮件发送确认对话框（只顯示純文字，保留空行）"""

    def __init__(
        self,
        parent,
        mail_item,
        supplier_name,
        outlet_name,
        attachment_path,
        on_confirm):
        super().__init__(parent)
        self.title(f"确认邮件 - {supplier_name}")
        self.geometry("800x700")
        self.transient(parent)
        self.grab_set()
        self.mail_item = mail_item
        self.on_confirm = on_confirm
        self.attachment_path = attachment_path
        self.configure(fg_color=DARK_BG)
        info_frame = ctk.CTkFrame(self, fg_color=DARK_PANEL, corner_radius=12)
        info_frame.pack(fill="x", padx=20, pady=10)
        ctk.CTkLabel(info_frame,
    text=f"收件人(To)/To: {mail_item.To}",
    font=FONT_MID).pack(anchor="w",
    padx=10,
     pady=5)
        ctk.CTkLabel(info_frame,
    text=f"抄送(CC)/CC: {mail_item.CC}",
    font=FONT_MID).pack(anchor="w",
    padx=10,
     pady=5)
        ctk.CTkLabel(info_frame,
    text=f"主题/Subject: {mail_item.Subject}",
    font=FONT_MID).pack(anchor="w",
    padx=10,
     pady=5)
        ctk.CTkLabel(
    info_frame,
    text=f"供应商/Supplier: {supplier_name}",
    font=FONT_MID).pack(
        anchor="w",
        padx=10,
         pady=5)
        ctk.CTkLabel(
    info_frame,
    text=f"分店/Outlet: {outlet_name}",
    font=FONT_MID).pack(
        anchor="w",
        padx=10,
         pady=5)
        if attachment_path:
            file_name = os.path.basename(attachment_path)
            ctk.CTkLabel(
    info_frame,
    text=f"附件/Attachment: {file_name}",
    font=FONT_MID).pack(
        anchor="w",
        padx=10,
         pady=5)
        body_frame = ctk.CTkFrame(self, fg_color=DARK_PANEL, corner_radius=12)
        body_frame.pack(fill="both", expand=True, padx=20, pady=10)
        ctk.CTkLabel(
    body_frame,
    text="邮件正文/Email Body:",
    font=FONT_BIGBTN).pack(
        anchor="w",
        padx=10,
         pady=5)
        # 只顯示純文字，保留空行，避免名字被拆行
        import html
        raw_html = mail_item.HTMLBody or ""
        import re
        # 1. 只把結束分行標籤換成換行
        text = re.sub(
    r'(<br\s*/?>|</div>|</p>|</li>|</tr>|</td>)',
    '\n',
    raw_html,
     flags=re.IGNORECASE)
        # 2. 把開始標籤直接移除（不換行）
        text = re.sub(r'(<div>|<p>|<li>|<tr>|<td>)',
                      '', text, flags=re.IGNORECASE)
        # 3. 移除其他 HTML 標籤
        text = re.sub(r'<[^>]+>', '', text)
        # 4. decode HTML entity
        text = html.unescape(text)
        # 5. 移除開頭/結尾多餘空白
        text = text.strip()
        self.body_text = ctk.CTkTextbox(
    body_frame, wrap="word", height=300, font=FONT_MID)
        self.body_text.pack(fill="both", expand=True, padx=10, pady=5)
        self.body_text.insert("1.0", text)
        self.body_text.configure(state="disabled")
        btn_frame = ctk.CTkFrame(self, fg_color="transparent")
        btn_frame.pack(fill="x", padx=20, pady=10)
        ctk.CTkButton(
            btn_frame,
            text="发送邮件/Send Email",
            command=self._send_email,
            fg_color=ACCENT_GREEN,
            hover_color=BTN_HOVER
        ).pack(side="right", padx=10)
        ctk.CTkButton(
            btn_frame,
            text="取消/Cancel",
            command=self.destroy
        ).pack(side="right", padx=10)
        ctk.CTkButton(
            btn_frame,
            text="编辑正文/Edit Body",
            command=self._edit_body,
            fg_color=ACCENT_BLUE,
            hover_color=BTN_HOVER
        ).pack(side="left", padx=10)

    def _edit_body(self):
        self.body_text.configure(state="normal")

    def _send_email(self):
        try:
            # 1. 读取文本框内容
            body = self.body_text.get("1.0", "end-1c")

            # 2. 计算"月+周"英文字符串
            today = datetime.now()
            # 获取完整英文月份名称，如 "July"
            month_name = today.strftime("%B")
            # 使用正確的週數計算方法
            week_of_month = get_week_of_month(today)
            # 构造 "July Week 3"
            month_week_str = f"{month_name} Week {week_of_month}"

            # 3. 在模板中替换占位符
            body = body.replace("{week_no}", month_week_str)

            # 4. 转成 HTML 并发送
            html_body = body.replace("\n", "<br>")
            self.mail_item.HTMLBody = html_body
            self.mail_item.Send()
            self.on_confirm(True, "邮件发送成功！")
        except Exception as e:
            self.on_confirm(False, f"发送失败：{e}")
        finally:
            self.destroy()


class EmailSendConfirmationDialog(ctk.CTkToplevel):
    """美化的邮件发送确认对话框"""
    
    def __init__(self, parent, suppliers_list, on_confirm):
        super().__init__(parent)
        self.parent = parent
        self.suppliers_list = suppliers_list
        self.on_confirm = on_confirm
        self.result = False
        
        # 设置窗口属性
        self.title("確認發送\nConfirm Send")
        self.geometry("800x700")
        self.configure(fg_color=DARK_BG)
        
        # 设置置顶
        self.attributes('-topmost', True)
        self.transient(parent)
        self.grab_set()
        
        # 居中显示
        self._center_window()
        
        # 创建UI
        self._create_ui()
        
        # 绑定关闭事件
        self.protocol("WM_DELETE_WINDOW", self._on_cancel)
    
    def _center_window(self):
        """将窗口居中显示"""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        self.geometry(f"{width}x{height}+{x}+{y}")
    
    def _create_ui(self):
        """创建用户界面"""
        # 主容器
        main_frame = ctk.CTkFrame(self, fg_color=DARK_PANEL, corner_radius=15)
        main_frame.pack(fill="both", expand=True, padx=20, pady=20)
        
        # 标题区域
        title_frame = ctk.CTkFrame(main_frame, fg_color="transparent")
        title_frame.pack(fill="x", padx=20, pady=(20, 10))
        
        # 图标和标题
        icon_frame = ctk.CTkFrame(title_frame, fg_color="transparent")
        icon_frame.pack()
        
        # 问号图标（使用蓝色圆形背景）
        icon_label = ctk.CTkLabel(
            icon_frame,
            text="?",
            font=("Microsoft JhengHei", 48, "bold"),
            text_color="white",
            width=80,
            height=80,
            fg_color=ACCENT_BLUE,
            corner_radius=40
        )
        icon_label.pack(pady=(0, 15))
        
        # 标题文字
        title_text = f"確認要發送郵件給以下 {len(self.suppliers_list)} 個供應商嗎？\nConfirm sending email to the following {len(self.suppliers_list)} suppliers?"
        title_label = ctk.CTkLabel(
            title_frame,
            text=title_text,
            font=("Microsoft JhengHei", 16, "bold"),
            text_color=TEXT_COLOR,
            wraplength=400,
            justify="center"
        )
        title_label.pack(pady=(0, 20))
        
        # 供应商列表区域
        list_frame = ctk.CTkFrame(main_frame, fg_color=ENTRY_BG, corner_radius=10)
        list_frame.pack(fill="both", expand=True, padx=20, pady=(0, 20))
        
        # 供应商列表标题
        list_title = ctk.CTkLabel(
            list_frame,
            text="供應商列表\nSupplier List",
            font=("Microsoft JhengHei", 14, "bold"),
            text_color=TEXT_COLOR
        )
        list_title.pack(pady=(15, 10))
        
        # 供应商列表
        suppliers_text = "\n".join([f"• {supplier}" for supplier in self.suppliers_list])
        suppliers_label = ctk.CTkLabel(
            list_frame,
            text=suppliers_text,
            font=("Microsoft JhengHei", 12),
            text_color=TEXT_COLOR,
            justify="left",
            anchor="w"
        )
        suppliers_label.pack(pady=(0, 15), padx=20, fill="x")
        
        # 按钮区域
        button_frame = ctk.CTkFrame(main_frame, fg_color="transparent")
        button_frame.pack(fill="x", padx=20, pady=(0, 20))
        
        # 按钮容器
        btn_container = ctk.CTkFrame(button_frame, fg_color="transparent")
        btn_container.pack(expand=True)
        
        # 取消按钮
        cancel_btn = ctk.CTkButton(
            btn_container,
            text="取消\nCancel",
            command=self._on_cancel,
            fg_color=ACCENT_RED,
            hover_color="#dc2626",
            font=("Microsoft JhengHei", 14, "bold"),
            width=120,
            height=40,
            corner_radius=20
        )
        cancel_btn.pack(side="left", padx=(0, 15))
        
        # 确认按钮
        confirm_btn = ctk.CTkButton(
            btn_container,
            text="確認\nConfirm",
            command=self._on_confirm,
            fg_color=ACCENT_GREEN,
            hover_color="#059669",
            font=("Microsoft JhengHei", 14, "bold"),
            width=120,
            height=40,
            corner_radius=20
        )
        confirm_btn.pack(side="right", padx=(15, 0))
        
        # 移除 focus_set() 避免 TclError
    
    def _on_confirm(self):
        """确认发送"""
        self.result = True
        self.on_confirm(True)
        self.destroy()
    
    def _on_cancel(self):
        """取消发送"""
        self.result = False
        self.on_confirm(False)
        self.destroy()


class NavigationButton(ctk.CTkButton):
    """自定义导航按钮，支持选中状态"""

    def __init__(self, master, text, command, **kwargs):
        super().__init__(master, text=text, command=command, **kwargs)

        # 保存自定义颜色
        self.custom_fg_color = kwargs.get('fg_color', DARK_PANEL)
        self.custom_text_color = kwargs.get(
    'text_color', get_contrast_color(
        self.custom_fg_color))
        self.custom_border_color = kwargs.get(
            'border_color', self.custom_fg_color)
        self.custom_border_width = kwargs.get('border_width', 0)
        self.custom_height = kwargs.get('height', 50)

        # 设置默认颜色
        self.default_color = self.custom_fg_color
        self.selected_color = ACCENT_BLUE
        self.is_selected = False

        # 配置按钮 - 移除hover_color，使用我们自定义的悬停效果
        self.configure(
            fg_color=self.custom_fg_color,
            text_color=self.custom_text_color,
            border_width=self.custom_border_width,
            border_color=self.custom_border_color,
            corner_radius=10,
            font=FONT_BIGBTN,
            height=self.custom_height,
            anchor="center"
        )
        self._bind_events()

    def _bind_events(self):
        self.bind("<Enter>", self._on_enter)
        self.bind("<Leave>", self._on_leave)

    def _on_enter(self, event=None):
        if not self.is_selected:
            # 悬停时背景色变成边框颜色
            hover_color = self.custom_border_color
            self.configure(fg_color=hover_color)

    def _on_leave(self, event=None):
        if not self.is_selected:
            # 恢复原来的背景色
            self.configure(fg_color=self.custom_fg_color)

    def select(self):
        self.is_selected = True
        self.configure(
            fg_color=self.selected_color,
            border_width=2,
            border_color=ACCENT_GREEN,
            text_color="white"
        )

    def deselect(self):
        self.is_selected = False
        # 恢复自定义颜色
        self.configure(
            fg_color=self.custom_fg_color,
            border_width=self.custom_border_width,
            border_color=self.custom_border_color,
            text_color=self.custom_text_color
        )

    @staticmethod
    def _adjust_color(color, amount):
        if isinstance(color, str) and color.startswith("#"):
            color = color.lstrip('#')
            rgb = tuple(int(color[i:i + 2], 16) for i in (0, 2, 4))
            adjusted = tuple(min(255, max(0, x + amount)) for x in rgb)
            return f"#{adjusted[0]:02x}{adjusted[1]:02x}{adjusted[2]:02x}"
        return color

# ========== 送货日期验证工具 ==========


class DeliveryDateValidator:
    """送货日期验证工具"""

    DAYS_MAPPING = {
        'mon': 0, 'monday': 0, '星期一': 0,
        'tue': 1, 'tuesday': 1, '星期二': 1,
        'wed': 2, 'wednesday': 2, '星期三': 2,
        'thu': 3, 'thursday': 3, '星期四': 3,
        'fri': 4, 'friday': 4, '星期五': 4,
        'sat': 5, 'saturday': 5, '星期六': 5,
        'sun': 6, 'sunday': 6, '星期日': 6
    }

    def __init__(self, config_file=None):
        self.schedule = defaultdict(dict)
        if config_file:
            self.load_config(config_file)

    def load_config(self, config_file):
        """加载送货日期配置"""
        try:
            with open(config_file, mode='r', encoding='utf-8-sig') as f:
                reader = csv.DictReader(f)
                for row in reader:
                    supplier = row['supplier'].strip().upper()
                    outlet = row['outlet_code'].strip().upper()
                    days = self.parse_delivery_days(row['delivery_days'])

                    if outlet == "ALL":
                        self.schedule[supplier]['*'] = days
                    else:
                        self.schedule[supplier][outlet] = days
        except Exception as e:
            raise Exception(f"加载送货配置失败: {str(e)}")

    def parse_delivery_days(self, days_str):
        """解析送货日期字符串"""
        days = set()
        for day in days_str.split(','):
            day = day.strip().lower()
            if day in self.DAYS_MAPPING:
                days.add(self.DAYS_MAPPING[day])
        return days

    def get_delivery_days(self, supplier, outlet_code):
        supplier = supplier.strip().upper()
        outlet_code = outlet_code.strip().upper()
        outlet_specific = self.schedule.get(supplier, {}).get(outlet_code)
        if outlet_specific is not None:
            return outlet_specific
        return self.schedule.get(supplier, {}).get('*', set())

    def validate_order(
    self,
    supplier,
    outlet_code,
    order_date,
     log_callback=None):
        supplier = supplier.strip().upper()
        outlet_code = outlet_code.strip().upper()
        delivery_days = self.get_delivery_days(supplier, outlet_code)

        if not delivery_days:
            return True

        try:
            if isinstance(order_date, (int, float)):
                order_date = datetime(1899, 12, 30) + \
                                      timedelta(days=order_date)
            else:
                order_date = parse(str(order_date), fuzzy=True)

            order_weekday = order_date.weekday()

            if order_weekday not in delivery_days:
                day_name = ['Monday', 'Tuesday', 'Wednesday', 'Thursday',
                           'Friday', 'Saturday', 'Sunday'][order_weekday]
                if log_callback:
                    log_callback(
                        f"❌ 送货日期错误: {outlet_code} 向 {supplier} 下单\n"
                        f"  订单日期: {
    order_date.strftime('%Y-%m-%d')} ({day_name})\n"
                        f"  允许送货日: {self.format_days(delivery_days)}"
                    )
                return False
            return True
        except Exception as e:
            if log_callback:
                log_callback(
                    f"⚠️ 日期解析失败: {supplier}-{outlet_code} ({order_date}): {str(e)}")
            return False

    def format_days(self, day_numbers):
        """将数字转换为星期名称"""
        days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday',
               'Friday', 'Saturday', 'Sunday']
        return ", ".join(days[d] for d in sorted(day_numbers))

# ========== 统一配置管理器 ==========


class UnifiedConfigManager:
    """管理统一的Excel配置文件"""

    def __init__(self, config_path=None):
        self.config_path = config_path
        self.outlets = []
        self.suppliers = []
        self.delivery_schedule = []
        self.email_templates = {}
        self.supplier_requirements = {}

        if config_path:
            self.load_config(config_path)

    def load_config(self, config_path):
        """从Excel文件加载配置"""
        try:
            wb = load_workbook(config_path, data_only=True)

            # 读取分店信息 - 支持多種工作表名稱
            outlet_sheet = None
            for sheet_name in [
    "OUTLET",
    "Outlets",
    "Outlet",
    "outlets",
     "outlet"]:
                if sheet_name in wb.sheetnames:
                    outlet_sheet = wb[sheet_name]
                    print(f"[DEBUG] 找到門市工作表: {sheet_name}")
                    break

            if outlet_sheet:
                for row in outlet_sheet.iter_rows(min_row=2, values_only=True):
                    if row and row[0]:
                        outlet_data = {
                            "code": row[0].strip().upper() if isinstance(row[0], str) else str(row[0]).strip().upper(),
                            "name": row[1].strip() if len(row) > 1 and isinstance(row[1], str) else str(row[1]).strip() if len(row) > 1 and row[1] is not None else "",
                            "email": row[2].strip().lower() if len(row) > 2 and isinstance(row[2], str) else str(row[2]).strip().lower() if len(row) > 2 and row[2] is not None else "",
                            "address": row[3].strip() if len(row) > 3 and isinstance(row[3], str) else str(row[3]).strip() if len(row) > 3 and row[3] is not None else "",
                            "delivery_day": row[4].strip() if len(row) > 4 and isinstance(row[4], str) else str(row[4]).strip() if len(row) > 4 and row[4] is not None else "",
                            "brand": row[5].strip() if len(row) > 5 and isinstance(row[5], str) else str(row[5]).strip() if len(row) > 5 and row[5] is not None else "Dine-In"
                        }
                        self.outlets.append(outlet_data)

            # 读取供应商信息
            if "Suppliers" in wb.sheetnames:
                ws = wb["Suppliers"]
                for row in ws.iter_rows(min_row=2, values_only=True):
                    if row and row[0]:
                        self.suppliers.append({
                            "name": row[0].strip() if isinstance(row[0], str) else str(row[0]).strip(),
                            "email": row[1].strip().lower() if len(row) > 1 and isinstance(row[1], str) else str(row[1]).strip().lower() if len(row) > 1 and row[1] is not None else "",
                            "contact": row[2].strip() if len(row) > 2 and isinstance(row[2], str) else str(row[2]).strip() if len(row) > 2 and row[2] is not None else "",
                            "phone": row[3].strip() if len(row) > 3 and isinstance(row[3], str) else str(row[3]).strip() if len(row) > 3 and row[3] is not None else ""
                        })

            # 读取配送日程
            if "Delivery Schedule" in wb.sheetnames:
                ws = wb["Delivery Schedule"]
                for row in ws.iter_rows(min_row=2, values_only=True):
                    if row and row[0]:
                        self.delivery_schedule.append({
                            "supplier": row[0].strip() if isinstance(row[0], str) else str(row[0]).strip(),
                            "outlet_code": row[1].strip().upper() if len(row) > 1 and isinstance(row[1], str) else str(row[1]).strip().upper() if len(row) > 1 and row[1] is not None else "ALL",
                            "delivery_days": row[2].strip() if len(row) > 2 and isinstance(row[2], str) else str(row[2]).strip() if len(row) > 2 and row[2] is not None else ""
                        })

            # 读取邮件模板
            if "Email Templates" in wb.sheetnames:
                ws = wb["Email Templates"]
                for row in ws.iter_rows(min_row=2, values_only=True):
                    if row and len(row) > 0 and row[0]:
                        self.email_templates[row[0].strip() if isinstance(row[0], str) else str(row[0]).strip()] = {
                            "subject": row[1].strip() if len(row) > 1 and isinstance(row[1], str) else str(row[1]).strip() if len(row) > 1 and row[1] is not None else "",
                            "body": row[2].strip() if len(row) > 2 and isinstance(row[2], str) else str(row[2]).strip() if len(row) > 2 and row[2] is not None else ""
                        }

            # 读取供应商要求
            if "Supplier Requirements" in wb.sheetnames:
                ws = wb["Supplier Requirements"]
                for row in ws.iter_rows(min_row=2, values_only=True):
                    if row and row[0]:
                        supplier_name = row[0].strip() if isinstance(
                            row[0], str) else str(row[0]).strip()
                        # 修正：正確分割、去空格、轉大寫
                        outlet_codes = []
                        if len(row) > 1 and row[1] is not None:
                            for code in str(
    row[1]).replace(
        "\n", ",").replace(
            "，", ",").split(","):
                                code = code.strip().upper()
                                if code:
                                    outlet_codes.append(code)
                        self.supplier_requirements[supplier_name] = outlet_codes

            return True, f"成功加载配置文件: {len(self.outlets)} 分店, {len(self.suppliers)} 供应商"
        except Exception as e:
            return False, f"加载配置文件失败: {str(e)}"

    def get_outlet(self, code):
        # 根據分店代碼獲取分店全名
        if not code:
            return None
        if isinstance(code, str):
            code = code.strip().upper()
        else:
            code = str(code).upper()
        for outlet in self.outlets:
            if outlet['short_name'].upper() == code:
                return outlet['full_name']
        return None

    def get_supplier(self, name):
        # 根據供應商名稱獲取標準名稱
        if not name:
            return None
        if isinstance(name, str):
            name = name.strip().upper()
        else:
            name = str(name).upper()
        for supplier in self.suppliers:
            if supplier['name'].upper() == name:
                return supplier['name']
        return None

    def get_delivery_schedule(self, supplier, outlet_code):
        """获取特定供应商-分店的配送日程"""
        for schedule in self.delivery_schedule:
            if schedule["supplier"] == supplier and schedule["outlet_code"] == outlet_code:
                return schedule["delivery_days"]

        for schedule in self.delivery_schedule:
            if schedule["supplier"] == supplier and schedule["outlet_code"] == "ALL":
                return schedule["delivery_days"]

        return None

    def get_required_outlets(self, supplier_name):
        # 用 normalize 方式找 key，确保匹配
        key = str(supplier_name).strip().upper()
        for k in self.supplier_requirements:
            if str(k).strip().upper() == key:
                return self.supplier_requirements[k]
        return []

# ========== 邮件发送管理器 ==========


class EmailSender:
    """处理邮件发送功能"""

    def __init__(self, config_manager=None):
        self.config_manager = config_manager
        # 加载 GIF 图片资源
        self.email_gif = self._load_email_gif()

    def _load_email_gif(self):
        """加载邮件签名 GIF 图片"""
        try:
            gif_path = resource_path("email_gif.gif")
            if os.path.exists(gif_path):
                with open(gif_path, "rb") as f:
                    return f.read()
            return None
        except Exception as e:
            print(f"Error loading email GIF: {str(e)}")
            return None

    def _get_standard_subject(self, supplier_name):
        """生成标准邮件主题"""
        now = datetime.now()
        month_name = now.strftime("%B")
        week_in_month = get_week_of_month(now)
        return f"Sushi Express Weekly Order - {supplier_name} - {month_name} - Week {week_in_month}"

    def get_to_cc_emails(self, supplier_name, config_path):
        """根據 config excel 取得 TO/CC 郵件，並自動加 opsadmin 及 purchasing.admin，且CC不重複"""
        wb = load_workbook(config_path, data_only=True)
        to_emails = []
        cc_emails = []
        if "Suppliers" in wb.sheetnames:
            ws = wb["Suppliers"]
            for row in ws.iter_rows(min_row=2, values_only=True):
                if not row or not row[0]:
                    continue
                if str(row[0]).strip() == supplier_name:
                    typ = str(row[1]).strip().upper() if len(
                        row) > 1 and row[1] else "TO"
                    email = str(row[2]).strip() if len(
                        row) > 2 and row[2] else ""
                    if not email:
                        continue
                    if typ == "TO":
                        to_emails.append(email)
                    elif typ == "CC":
                        cc_emails.append(email)
        # 必須CC的名單
        must_cc = [
            "opsadmin@sushiexpress.com.sg",
            "purchasing.admin@sushiexpress.com.sg"
        ]
        for cc in must_cc:
            if cc not in cc_emails:
                cc_emails.append(cc)
        # 去重（不分大小寫）
        seen = set()
        cc_unique = []
        for e in cc_emails:
            elower = e.lower()
            if elower not in seen:
                cc_unique.append(e)
                seen.add(elower)
        return to_emails, cc_unique

    def send_email(
    self,
    to_emails,
    cc_emails,
    supplier_name,
    body,
    attachment_path=None,
    account_idx=None,
    use_content_id=True,
     subject=None):
        import time
        import pywintypes
        max_retries = 3
        for attempt in range(max_retries):
            try:
                import win32com.client
                import pythoncom
                import os
                import base64

                # 初始化 COM 組件
                pythoncom.CoInitialize()

                outlook = win32com.client.Dispatch("Outlook.Application")
                # --- 新增 CreateItem 自動重試 ---
                for create_attempt in range(3):
                    try:
                        mail = outlook.CreateItem(0)
                        break
                    except AttributeError as e:
                        if "CreateItem" in str(e):
                            print(
    f"[RETRY] Outlook COM 還沒準備好，第 {
        create_attempt + 1} 次重試...")
                            time.sleep(2)
                            outlook = win32com.client.Dispatch(
                                "Outlook.Application")
                            continue
                        else:
                            raise
                else:
                    from tkinter import messagebox
                    messagebox.showerror(
    "邮件发送失败", "Outlook 啟動異常，請確認 Outlook 已開啟且無彈窗。")
                    return None, "Outlook 啟動異常，請確認 Outlook 已開啟且無彈窗。"
                # --- 其餘原本的 send_email 流程 ---
                if account_idx is not None:
                    mapi = outlook.GetNamespace("MAPI")
                    accounts = [
    mapi.Folders.Item(
        i +
        1) for i in range(
            mapi.Folders.Count)]
                    if 0 <= account_idx < len(accounts):
                        account = accounts[account_idx]
                        if hasattr(mail, 'SendUsingAccount'):
                            for acc in outlook.Session.Accounts:
                                if acc.DisplayName == account.Name:
                                    mail.SendUsingAccount = acc
                                    break
                # 處理收件人
                if isinstance(to_emails, list):
                    to_emails_fixed = ';'.join(to_emails) if to_emails else ''
                else:
                    to_emails_fixed = to_emails.replace(
    '，', ';').replace(
        ',', ';') if to_emails else ''
                if isinstance(cc_emails, list):
                    cc_emails_fixed = ';'.join(cc_emails) if cc_emails else ''
                else:
                    cc_emails_fixed = cc_emails.replace(
    '，', ';').replace(
        ',', ';') if cc_emails else ''
                mail.To = to_emails_fixed
                mail.CC = cc_emails_fixed
                if subject:
                    mail.Subject = subject
                else:
                    mail.Subject = self._get_standard_subject(supplier_name)
                # 添加 GIF 簽名
                possible_gif_paths = [
                    "email_gif.gif",
                    os.path.join(os.path.dirname(__file__), "email_gif.gif"),
                    os.path.join(os.getcwd(), "email_gif.gif"),
                    os.path.abspath("email_gif.gif")
                ]
                signature_gif_path = None
                for path in possible_gif_paths:
                    if os.path.exists(path):
                        signature_gif_path = path
                        break
                print(f"[DEBUG] 檢查 GIF 文件路徑: {possible_gif_paths}")
                print(f"[DEBUG] 找到的 GIF 文件: {signature_gif_path}")
                print(f"[DEBUG] 當前工作目錄: {os.getcwd()}")
                print(f"[DEBUG] 腳本目錄: {os.path.dirname(__file__)}")
                html_body = body
                if not any(
    tag in body.lower() for tag in [
        '<br',
        '<p',
        '<div',
        '<table',
        '<ul',
        '<ol',
        '<li',
        '<b',
        '<strong',
        '<em',
         '<span']):
                    html_body = body.replace('\n', '<br>')
                if signature_gif_path and os.path.exists(signature_gif_path):
                    if use_content_id:
                        # Content-ID 方式（新版 Outlook 兼容）
                        cid = "sigimg001"
                        signature_html = f"""
                        <br><br>
                        <img src=\"cid:{cid}\" alt=\"Signature\" style=\"max-width: 400px;\">
                        """
                        html_body += signature_html
                        mail.HTMLBody = html_body
                        att = mail.Attachments.Add(
    os.path.abspath(signature_gif_path))
                        att.PropertyAccessor.SetProperty(
    "http://schemas.microsoft.com/mapi/proptag/0x3712001F", cid)
                        print(f"[DEBUG] 已用 Content-ID 插入 GIF 簽名")
                    else:
                        # base64 方式（舊版 Outlook 兼容）
                        with open(signature_gif_path, 'rb') as f:
                            gif_data = base64.b64encode(f.read()).decode()
                        signature_html = f"""
                        <br><br>
                        <img src=\"data:image/gif;base64,{gif_data}\" alt=\"Signature\" style=\"max-width: 400px;\">
                        """
                        html_body += signature_html
                        mail.HTMLBody = html_body
                        print(f"[DEBUG] 已用 base64 插入 GIF 簽名")
                else:
                    mail.HTMLBody = html_body
                # 添加订单附件
                if attachment_path:
                    if isinstance(attachment_path, list):
                        # 多文件附件的情况
                        for file_path in attachment_path:
                            if os.path.exists(file_path):
                                mail.Attachments.Add(file_path)
                                print(f"[DEBUG] 已添加附件: {os.path.basename(file_path)}")
                            else:
                                print(f"[WARNING] 附件文件不存在: {file_path}")
                    else:
                        # 单文件附件的情况
                        if os.path.exists(attachment_path):
                            mail.Attachments.Add(attachment_path)
                            print(f"[DEBUG] 已添加附件: {os.path.basename(attachment_path)}")
                        else:
                            print(f"[WARNING] 附件文件不存在: {attachment_path}")
                return mail
            except pywintypes.com_error as e:
                if hasattr(
    e, 'args') and len(
        e.args) > 0 and e.args[0] == -2147418111:
                    print(f"[RETRY] Outlook 忙碌中，第 {attempt + 1} 次重試...")
                    time.sleep(2)
                    continue
                else:
                    import traceback
                    print(traceback.format_exc())
                    from tkinter import messagebox
                    messagebox.showerror(
    "邮件发送失败", f"{
        str(e)}\n\n{
            traceback.format_exc()}")
                    return None, f"创建邮件失败: {str(e)}"
            except Exception as e:
                import traceback
                print(traceback.format_exc())
                from tkinter import messagebox
                messagebox.showerror(
    "邮件发送失败", f"{
        str(e)}\n\n{
            traceback.format_exc()}")
                return None, f"创建邮件失败: {str(e)}"
        # 如果重試後還是失敗
        from tkinter import messagebox
        messagebox.showerror("邮件发送失败", "Outlook 忙碌，重试多次仍失败。请稍后再试。")
        return None, "Outlook 忙碌，重试多次仍失败。请稍后再试。"

# ========== 订单自动化核心 ==========


class OrderAutomation:
    """订单自动化工具"""

    def __init__(self, outlet_config=None):
        # outlet_config: list of dicts with keys 'short_name', 'full_name'
        self.outlet_name_map = {}
        if outlet_config:
            for o in outlet_config:
                full = o.get('full_name', '').strip().lower()
                short = o.get('short_name', '').strip().upper()
                if full:
                    self.outlet_name_map[full] = short
                if short:
                    self.outlet_name_map[short.lower()] = short

    def get_short_code(self, f5val):
        val = (str(f5val) or '').strip().lower()
        if val in self.outlet_name_map:
            return self.outlet_name_map[val]
        # 雙向模糊比對
        for full, short in self.outlet_name_map.items():
            if full in val or val in full:
                return short
            # 單字比對
            for word in val.split():
                if word and word in full:
                    return short
        return 'UNKNOWN'

    @staticmethod
    def is_valid_date(cell_value, next_week_start, next_week_end):
        """检查是否为有效日期"""
        try:
            if isinstance(cell_value, (int, float)):
                base_date = datetime(1899, 12, 30)
                parsed = base_date + timedelta(days=cell_value)
            else:
                parsed = parse(str(cell_value), fuzzy=True, dayfirst=False)
            # 對於 Amendment 檔案，我們接受任何日期，不限制在特定週期內
            return True  # 暫時接受所有日期
        except:
            return False

    @classmethod
    def find_delivery_date_row(
    cls,
    ws,
    next_week_start,
    next_week_end,
    max_rows=200,
     file_path=None):
        """查找送货日期行"""
        valid_col_range = range(5, 12)
        invalid_labels = [
    "total",
    "total:",
    "sub-total",
    "sub-total:",
    "no. of cartons",
     "no. of cartons:"]
        found_blocks = []
        for i, row in enumerate(ws.iter_rows(min_row=1, max_row=max_rows)):
            cols = []
            for j, cell in enumerate(row):
                if j not in valid_col_range:
                    continue
                val = cell.value
                if cls.is_valid_date(val, next_week_start, next_week_end):
                    cols.append(j)
            if cols:
                found_blocks.append((i + 1, cols))
        for header_row, cols in found_blocks:
            for row_idx in range(header_row + 1, header_row + 200):
                label_val = ws.cell(row=row_idx, column=5).value
                label = str(label_val).lower().strip() if label_val else ""
                if any(invalid in label for invalid in invalid_labels):
                    continue
                for col_idx in cols:
                    qty_val = ws.cell(row=row_idx, column=col_idx + 1).value
                    if isinstance(qty_val, (int, float)) and qty_val > 0:
                        return header_row, cols
        return None, []

    @classmethod
    def run_automation(cls, source_folder, supplier_folder,
                      outlet_config=None, delivery_config=None,
                      log_callback=None, mapping_callback=None):
        """运行订单自动化（仅生成 supplier 文件）"""
        import os  # 确保 os 模块可用
        now = datetime.now()
        today = now.date()
        this_monday = today - timedelta(days=today.weekday())
        next_monday = this_monday + timedelta(days=7)
        next_sunday = next_monday + timedelta(days=6)
        start_of_period = datetime.combine(next_monday, datetime.min.time())
        end_of_period = datetime.combine(next_sunday, datetime.max.time())
        save_path = os.path.join(
    source_folder, f"next_week_order_log_{
        now.strftime('%Y%m%d_%H%M%S')}.txt")
        log_lines = [
    f"🎯 Next Week Order Integration Log\n",
    f"Scan Start Time: {now}\n",
    f"Target Week: {
        start_of_period.date()} to {
            end_of_period.date()}\n"]

        date_validator = DeliveryDateValidator(
            delivery_config) if delivery_config else None

        outlet_mapping = {}
        if outlet_config:
            try:
                outlet_mapping = {o['short_name']: o for o in outlet_config}
                if log_callback:
                    log_callback(f"✅ 已加载分店配置: {len(outlet_mapping)} 个分店")
            except Exception as e:
                if log_callback:
                    log_callback(f"⚠️ 分店配置加载失败: {str(e)}")

        # 新增：建立一個 OrderAutomation 實例用於 get_short_code
        oa_instance = cls(outlet_config) if outlet_config else cls()

        supplier_to_outlets = defaultdict(list)

        def log(message, include_timestamp=True):
            timestamp = datetime.now().strftime("%H:%M:%S") if include_timestamp else ""
            log_line = f"[{timestamp}] {message}" if include_timestamp else message
            log_lines.append(log_line + "\n")
            if log_callback:
                log_callback(log_line + "\n")

        files = [f for f in os.listdir(source_folder)
                 if f.endswith((".xlsx", ".xls")) and not f.startswith("~$")]
        total_files = len(files)

        if total_files == 0:
            log("未找到Excel文件\nNo Excel files found in source folder. Exiting.")
            return False, "在源文件夹中未找到Excel文件"

        log(f"找到 {total_files} 个Excel文件\nFound {total_files} Excel files")
        log(
    f"目标周期: {
        start_of_period.strftime('%Y-%m-%d')} 到 {
            end_of_period.strftime('%Y-%m-%d')}\nTarget period: {
                start_of_period.strftime('%Y-%m-%d')} to {
                    end_of_period.strftime('%Y-%m-%d')}")
        log(f"🔍 專注於下週訂單，忽略其他週期\n🔍 Focus on next week orders only, ignore other periods")

        for idx, file in enumerate(files):
            full_path = os.path.join(source_folder, file)
            try:
                # log(f"\n处理文件 {idx+1}/{total_files}: {file}\nProcessing file
                # {idx+1}/{total_files}: {file}")
                wb = load_workbook(full_path, data_only=True)
                # log(f"工作表: {', '.join(wb.sheetnames)}\nWorksheets: {',
                # '.join(wb.sheetnames)}")
                for sheetname in wb.sheetnames:
                    ws = wb[sheetname]
                    if ws.sheet_state != "visible":
                        continue  # 跳過隱藏工作表不 log，不顯示任何訊息
                    outlet_short = file.split('_')[0].strip(
                    ) if '_' in file else file.split('.')[0].strip()
                    # log(f"  工作表: {sheetname}, 文件名分店简称: '{outlet_short}'\n
                    # Sheet: {sheetname}, Short Name (from filename):
                    # '{outlet_short}'")
                    has_order = False
                    week_days = [
    'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']
                    for row in range(1, ws.max_row):
                        row_vals = [str(ws.cell(row=row, column=col).value).strip() if ws.cell(
                            row=row, column=col).value else '' for col in range(6, 13)]
                        weekday_count = sum(
    day in row_vals for day in week_days)
                        if 'Mon' in row_vals and weekday_count >= 3:
                            date_row = row + 1
                            date_cols = []
                            for idx2, col in enumerate(range(6, 13)):
                                val = ws.cell(row=date_row, column=col).value
                                parsed = None
                                try:
                                    if val:
                                        sval = str(val)
                                        if re.match(
    r"^\d{1,2}-[A-Za-z]{3,}$", sval):
                                            year = start_of_period.year
                                            sval = f"{sval}-{year}"
                                        if isinstance(val, (int, float)):
                                            base_date = datetime(1899, 12, 30)
                                            parsed = base_date + \
                                                timedelta(days=val)
                                        else:
                                            parsed = parse(
                                                sval, fuzzy=True, dayfirst=False)
                                except Exception:
                                    pass
                                if parsed and start_of_period.date() <= parsed.date() <= end_of_period.date():
                                    date_cols.append(col)
                            if date_cols:
                                for r in range(
                                    date_row + 1, min(date_row + 30, ws.max_row + 1)):
                                    found_order_this_row = False
                                    for c in date_cols:
                                        val = ws.cell(row=r, column=c).value
                                        if isinstance(val, (datetime,)):
                                            if val.date() > end_of_period.date():
                                                found_order_this_row = True
                                                break
                                        elif isinstance(val, (int, float)) and val > 0:
                                            has_order = True
                                            found_order_this_row = True
                                            break
                                    if found_order_this_row:
                                        break
                            if has_order:
                                break
                    if has_order:
                        # 只記錄有訂單的廠商與分店，不記錄細節
                        supplier_to_outlets[sheetname].append(
                            (outlet_short, full_path, sheetname))
            except Exception as e:
                error_msg = f"❌ 处理文件出错: {file}\n❌ Error processing {file}: {
    str(e)}\n{
        traceback.format_exc()}"
                log(error_msg)

        log("\n📊 下週訂單整合結果 / Next Week Order Integration Results:")
        for supplier, outlets in supplier_to_outlets.items():
            outlet_list = [str(o[0]) if o[0] else "UNKNOWN" for o in outlets]
            log(f"  📦 {supplier}: {', '.join(outlet_list)}")
        log(f"\n🎯 只處理下週訂單，共 {sum(len(outlets) for outlets in supplier_to_outlets.values())} 個門市有訂單")
        log("\nCreating supplier files...")
        supplier_files = []
        import os
        import xlwings as xw
        for sheetname, outlet_file_pairs in supplier_to_outlets.items():
            # use next Monday for Month_WeekX naming
            today_d = now.date()
            next_mon = today_d + timedelta(days=(7 - today_d.weekday()))
            month_abbr = next_mon.strftime('%b')
            week_in_month = ((next_mon.day - 1) // 7) + 1
            supplier_path = os.path.join(
    supplier_folder,
     f"{sheetname}_{month_abbr}_Week_{week_in_month}.xlsx")
            # rename legacy files (e.g., *_Week_XX.xlsx) to Month_WeekX if
            # present
            try:
                existing = None
                for fname in os.listdir(supplier_folder):
                    if fname.lower().endswith('.xlsx') and sheetname.lower() in fname.lower():
                        cand = os.path.join(supplier_folder, fname)
                        # skip temp/open files
                        if os.path.basename(cand).startswith('~$'):
                            continue
                        existing = cand
                        break
                if existing and os.path.normcase(
                    existing) != os.path.normcase(supplier_path):
                    if not os.path.exists(supplier_path):
                        os.replace(existing, supplier_path)
            except Exception:
                pass
            # 先建立空檔案
            if not os.path.exists(supplier_path):
                from openpyxl import Workbook
                wb = Workbook()
                wb.save(supplier_path)
            app = xw.App(visible=False)
            try:
                wb_dest = app.books.open(supplier_path)
                for outlet, src_file, original_sheet in outlet_file_pairs:
                    try:
                        wb_src = app.books.open(src_file)
                        sht = wb_src.sheets[original_sheet]
                        dest_sheet_name = outlet if outlet else original_sheet
                        # 刪除同名分頁（但要確保至少保留一個工作表）
                        sheets_to_delete = []
                        for s in wb_dest.sheets:
                            if s.name == dest_sheet_name:
                                sheets_to_delete.append(s)
                        
                        # 只有在有多個工作表時才刪除
                        if len(wb_dest.sheets) > 1:
                            for s in sheets_to_delete:
                                s.delete()
                            sht.api.Copy(Before=wb_dest.sheets[0].api)
                            # 檢查新複製的工作表名稱是否衝突，如果衝突則添加後綴
                            new_sheet = wb_dest.sheets[0]
                            original_name = dest_sheet_name
                            counter = 1
                            while any(s.name == dest_sheet_name for s in wb_dest.sheets if s != new_sheet):
                                dest_sheet_name = f"{original_name}_{counter}"
                                counter += 1
                            new_sheet.name = dest_sheet_name
                        else:
                            # 如果只有一個工作表，直接複製並重命名
                            sht.api.Copy(Before=wb_dest.sheets[0].api)
                            # 檢查新複製的工作表名稱是否衝突，如果衝突則添加後綴
                            new_sheet = wb_dest.sheets[0]
                            original_name = dest_sheet_name
                            counter = 1
                            while any(s.name == dest_sheet_name for s in wb_dest.sheets if s != new_sheet):
                                dest_sheet_name = f"{original_name}_{counter}"
                                counter += 1
                            new_sheet.name = dest_sheet_name
                        wb_src.close()
                        log(
    f"  ✅ {dest_sheet_name} 已複製進 {
        os.path.basename(supplier_path)}（格式/公式完整保留）")
                    except Exception as e:
                        log(
    f"    ❌ Failed to copy {outlet} in {sheetname}: {
        str(e)}\n{
            traceback.format_exc()}")
                # 刪除空白的 Sheet（如果存在且有其他工作表）
                try:
                    if len(wb_dest.sheets) > 1:  # 確保不是唯一的工作表
                        sheets_to_delete = []
                        for sheet in wb_dest.sheets:
                            if sheet.name in ['Sheet', 'Sheet1']:
                                # 檢查工作表是否真的是空白的
                                is_empty = True
                                try:
                                    if sheet.used_range is not None:
                                        # 檢查 used_range 中是否有實際數據
                                        for row in sheet.used_range.rows:
                                            for cell in row:
                                                if cell.value is not None and str(
                                                    cell.value).strip() != "":
                                                    is_empty = False
                                                    break
                                            if not is_empty:
                                                break
                                except:
                                    # 如果檢查失敗，假設不是空白的
                                    is_empty = False

                                if is_empty:
                                    sheets_to_delete.append(sheet)

                        # 刪除空白工作表
                        for sheet in sheets_to_delete:
                            sheet.delete()
                            log(f"  🗑️ 已刪除空白工作表: {sheet.name}")

                except Exception as e:
                    # 静默处理删除空白工作表时的错误，不显示错误信息
                    pass

                wb_dest.save()
                wb_dest.close()
                supplier_files.append(os.path.basename(supplier_path))
            finally:
                app.quit()
        result_text = "\n🎯 下週訂單整合完成 / Next Week Order Integration Complete:\n"
        result_text += f"📦 已處理供應商文件: {len(supplier_files)}\n"
        result_text += f"📅 目標週期: {
    start_of_period.strftime('%Y-%m-%d')} 到 {
        end_of_period.strftime('%Y-%m-%d')}\n\n"
        result_text += "📋 供應商文件列表:\n" + \
            "\n".join([f"  ✅ {file}" for file in supplier_files])
        log(result_text)
        try:
            with open(save_path, "w", encoding="utf-8") as logfile:
                logfile.writelines(log_lines)
            log(f"\nLog saved at: {save_path}")
            return True, f"订单整合完成！\n\n日志文件保存至:\n{save_path}\n\n{result_text}"
        except Exception as e:
            log(f"❌ Failed to write log file: {e}")
            return False, f"订单整合完成但日志保存失败:\n{str(e)}"

# ========== 增强版订单检查器 ==========


class EnhancedOrderChecker:
    """使用配置文件的订单检查器"""

    def __init__(self, config_manager=None):
        self.config_manager = config_manager
        # 新增：建立 full name/short name/email name normalize 映射到 short name
        self.fullname_to_short = {}
        if config_manager and hasattr(config_manager, 'config_path'):
            import pandas as pd
            import os
            config_path = config_manager.config_path if hasattr(
                config_manager, 'config_path') else None
            if config_path and os.path.exists(config_path):
                try:
                    df = pd.read_excel(config_path, sheet_name=None)
                    outlet_df = None
                    for key in df.keys():
                        if key.strip().lower() == "outlet":
                            outlet_df = df[key]
                            break
                    if outlet_df is not None:
                        for _, row in outlet_df.iterrows():
                            short = str(row.get("Short Name", "")).strip()
                            full = str(row.get("Outlet Full Name", "")).strip()
                            email_name = str(
                                row.get("Name in Email", "")).strip()
                            for n in [short, full, email_name]:
                                n_norm = self._normalize(n)
                                if n and n_norm:
                                    self.fullname_to_short[n_norm] = short
                except Exception as e:
                    print(
    "[EnhancedOrderChecker] Outlet mapping read error:", e)

    @staticmethod
    def _normalize(text):
        """标准化文本"""
        import re
        if not text:
            return ""
        # 只去除空格，保留括号内容以区分不同供应商
        return re.sub(r'[\s]', '', str(text).lower())

    def get_outlet_shortname(self, f5_value):
        """智能获取分店简称，优先用 config mapping"""
        import re

        if not f5_value or not isinstance(f5_value, str):
            return f"[EMPTY] {f5_value}"

        # 先嘗試完整匹配
        n = self._normalize(f5_value)
        if n in self.fullname_to_short:
            return self.fullname_to_short[n]

        # 處理包含配送日期資訊的 F5 值
        # 例如: "Sushi Express West Mall (MON,WED,FRI,SAT)" -> "Sushi Express West Mall"
        # 但保留包含門市代碼的括號，如 "Sushi Takeout CityVibe (GTM)"
        delivery_pattern = r'\s*\([A-Z]{2,4},[A-Z]{2,4},[A-Z]{2,4},[A-Z]{2,4}\)\s*$'
        cleaned_f5 = re.sub(delivery_pattern, '', f5_value.strip())

        if cleaned_f5 != f5_value:
            n = self._normalize(cleaned_f5)
            if n in self.fullname_to_short:
                return self.fullname_to_short[n]

        # fallback: 原有 hardcode/正则逻辑（可选）
        # ... existing code ...
        return f"[UNKNOWN] {f5_value}"

    def run_checklist(self, folder, log_callback=None, as_table=False):
        date_validator = None
        if self.config_manager:
            delivery_schedules = self.config_manager.delivery_schedule
            if delivery_schedules:
                date_validator = DeliveryDateValidator()
                date_validator.schedule = defaultdict(dict)
                for row in delivery_schedules:
                    supplier = row['supplier']
                    outlet = row['outlet_code']
                    days = DeliveryDateValidator().parse_delivery_days(
                        row['delivery_days'])
                    if outlet == "ALL":
                        date_validator.schedule[supplier]['*'] = days
                    else:
                        date_validator.schedule[supplier][outlet] = days
        supplier_keywords = {}
        if self.config_manager:
            # 首先扫描文件夹，找到所有供应商文件（包括变体），統一使用第一個底線前的名稱作為供應商名
            all_supplier_files = set()
            try:
                files = [f for f in os.listdir(folder) if f.endswith(".xlsx") and not f.startswith("~$")]
                for file in files:
                    base_no_ext = os.path.splitext(file)[0]
                    base_variant = base_no_ext.split('_')[0]
                    all_supplier_files.add(base_variant)
                    print(f"[DEBUG] 发现供应商文件: {base_no_ext} -> 基準: {base_variant}")
            except Exception as e:
                print(f"[DEBUG] 扫描供应商文件时出错: {e}")
            
            # 处理配置文件中的供应商
            for supplier in self.config_manager.suppliers:
                supplier_name = supplier["name"]
                keywords = [supplier_name.lower()]
                supplier_keywords[supplier_name] = keywords
                
                # 检查是否有括号变体文件
                if '(' not in supplier_name and ')' not in supplier_name:
                    for file_name in all_supplier_files:
                        if file_name.startswith(supplier_name) and '(' in file_name and ')' in file_name:
                            variant_name = file_name
                            # 为变体创建独立的供应商条目
                            if variant_name not in supplier_keywords:
                                supplier_keywords[variant_name] = [variant_name.lower()]
                                print(f"[DEBUG] 发现供应商变体: {supplier_name} -> {variant_name}")
            
            # 处理独立的括号变体文件（不在配置中的）
            for file_name in all_supplier_files:
                if '(' in file_name and ')' in file_name:
                    base_variant = file_name
                    if base_variant not in supplier_keywords:
                        supplier_keywords[base_variant] = [base_variant.lower()]
                        print(f"[DEBUG] 发现独立供应商变体: {base_variant}")

            # 处理獨立的非括號基礎供應商（例如有 Super Q 但配置中沒有）
            for file_name in all_supplier_files:
                if '(' not in file_name and ')' not in file_name:
                    base_name = file_name
                    if base_name not in supplier_keywords:
                        supplier_keywords[base_name] = [base_name.lower()]
                        print(f"[DEBUG] 发现独立供应商: {base_name}")

            # 不移除基礎名；保留基礎與各變體，確保同時處理 Super Q 與 Super Q (Chawan)
        must_have_outlets = {}
        if self.config_manager:
            for supplier in self.config_manager.suppliers:
                must_have_outlets[supplier["name"]] = self.config_manager.get_required_outlets(
                    supplier["name"])
            
            # 为变体供应商添加配置（继承基础供应商的配置）
            for supplier_name in supplier_keywords.keys():
                if supplier_name not in must_have_outlets:
                    # 查找对应的基础供应商
                    base_supplier = None
                    for config_supplier in self.config_manager.suppliers:
                        config_name = config_supplier["name"]
                        if supplier_name.startswith(config_name) and '(' in supplier_name:
                            base_supplier = config_name
                            break
                    
                    if base_supplier:
                        must_have_outlets[supplier_name] = must_have_outlets[base_supplier]
                        print(f"[DEBUG] 变体供应商 {supplier_name} 继承基础供应商 {base_supplier} 的配置")
                    else:
                        # 如果没有找到基础供应商，使用空配置
                        must_have_outlets[supplier_name] = []
                        print(f"[DEBUG] 变体供应商 {supplier_name} 使用空配置")
        
        print(f"[DEBUG] 最终供应商列表: {list(supplier_keywords.keys())}")
        print(f"[DEBUG] 供应商配置数量: {len(must_have_outlets)}")
        try:
            files = [f for f in os.listdir(folder) if f.endswith(
                ".xlsx") and not f.startswith("~$")]

            def file_key(f):
                # 提取第一个下划线之前的供应商名
                import os
                base = os.path.splitext(f)[0]  # 移除 .xlsx 扩展名
                supplier_name = base.split('_')[0]  # 取第一个下划线之前的部分
                return self._normalize(supplier_name)
            normalized_files = {file_key(f): f for f in files}
            output = []
            table = []
            for supplier, keywords in supplier_keywords.items():
                print(f"\n[DEBUG] ===== 处理供应商: {supplier} =====")
                matches = self._find_supplier_file(normalized_files, keywords)
                if not matches:
                    if as_table:
                        table.append({
                            "supplier": supplier,
                            "outlet": "-",
                            "cover_status": "❌",
                            "remark": "Supplier file not found"
                        })
                    else:
                        output.append(
    f"\n❌ {supplier} - Supplier file not found.")
                    continue
                for match in matches:
                    result, table_rows = self._process_supplier_file(
                        folder, match, must_have_outlets[supplier],
                        date_validator, log_callback, as_table=True, supplier=supplier
                    )
                if as_table:
                    table.extend(table_rows)
                else:
                    output.extend(result)
            if as_table:
                return table
            return "\n".join(output)
        except Exception as e:
            if as_table:
                return [{"supplier": "-", "outlet": "-",
                    "cover_status": "❌", "remark": f"Error: {str(e)}"}]
            return f"❌ Error running checklist: {
    str(e)}\n{
        traceback.format_exc()}"

    @classmethod
    def _find_supplier_file(cls, normalized_files, keywords):
        # 使用全局的find_supplier_file函数，它已经修复了括号变体的选择逻辑
        all_files = list(normalized_files.values())
        matches = []
        
        print(f"[DEBUG] 处理关键字: {keywords}")
        
        for keyword in keywords:
            # 使用修复后的find_supplier_file函数
            matched_file = find_supplier_file(keyword, all_files)
            if matched_file and matched_file not in matches:
                matches.append(matched_file)
                print(f"[DEBUG] 找到文件: {matched_file}")
        return matches if matches else None

    def _process_supplier_file(
    self,
    folder,
    filename,
    required_outlets,
    date_validator=None,
    log_callback=None,
    as_table=False,
     supplier=None):
        import os
        from openpyxl import load_workbook
        import tkinter.messagebox as messagebox
        output = []
        table = []
        found = set()
        unidentified = []
        date_errors = []
        unknown_f5 = set()
        try:
            wb = load_workbook(os.path.join(folder, filename), data_only=True)
            print(f"[DEBUG] 处理文件: {filename}")
            print(f"[DEBUG] 工作表列表: {wb.sheetnames}")
            
            for s in wb.sheetnames:
                # 跳过 sheet 名为 'Sheet' 或空白的 sheet
                if not s.strip() or s.strip().lower() == 'sheet':
                    print(f"[DEBUG] 跳过空白工作表: {s}")
                    continue
                try:
                    f5 = wb[s]["F5"].value
                    code = self.get_outlet_shortname(f5)
                    sheet_name = s.strip().upper()
                    short_name_mismatch = False

                    # 添加调试信息
                    print(f"[DEBUG] 处理工作表: {s}, F5: {f5}, Code: {code}")

                    # 處理特殊情況：如果 F5 映射結果與工作表名稱不同，但都指向同一個門市
                    # 例如：F5→BUGIS, Sheet→BJ，但都指向 SushiPlus Bugis
                    if code != sheet_name and "[UNKNOWN]" not in code and "[EMPTY]" not in code:
                        # 檢查是否都映射到同一個門市
                        f5_normalized = self._normalize(f5) if f5 else ""
                        sheet_normalized = self._normalize(sheet_name)

                        # 如果 F5 映射和工作表名稱都指向同一個門市，則不視為 mismatch
                        if f5_normalized in self.fullname_to_short and sheet_normalized in self.fullname_to_short:
                            if self.fullname_to_short[f5_normalized] == self.fullname_to_short[sheet_normalized]:
                                short_name_mismatch = False
                            else:
                                short_name_mismatch = True
                        else:
                            short_name_mismatch = True
                    if "[UNKNOWN]" in code or "[EMPTY]" in code:
                        print(f"[DEBUG] 工作表 {s} 有F5错误: F5={f5}, Code={code}")
                        unidentified.append((s, f5))
                        unknown_f5.add(str(f5).strip() if f5 else "[空白]")
                        if as_table:
                            table.append({
                                "supplier": supplier,
                                "outlet": s,
                                "cover_status": "⚠️",
                                "remark": f"F5 error: {f5}" + (f"; Short name mismatch: F5→{code}, Sheet→{sheet_name}" if short_name_mismatch else "")
                            })
                    else:
                        print(f"[DEBUG] 工作表 {s} 处理成功: F5={f5}, Code={code}")
                        found.add(code)
                        date_status = "-"
                        remark = ""
                        if date_validator:
                            delivery_date = wb[s]['F8'].value if 'F8' in wb[s] else None
                            if delivery_date:
                                is_valid = date_validator.validate_order(
                                    supplier,
                                    code,
                                    delivery_date,
                                    log_callback
                                )
                                if not is_valid:
                                    date_status = "❌"
                                    remark = "Invalid delivery date"
                                    date_errors.append(code)
                                else:
                                    date_status = "✔️"
                            else:
                                date_status = "⚠️"
                                remark = ""
                        if short_name_mismatch:
                            if remark:
                                remark += "; "
                            remark += f"Short name mismatch: F5→{code}, Sheet→{sheet_name}"
                        if as_table:
                            table.append({
                                "supplier": supplier,
                                "outlet": code,
                                "cover_status": "✔️",
                                "remark": remark
                            })
                except Exception as e:
                    unidentified.append((s, f"[F5 error: {e}]"))
                    if as_table:
                        table.append({
                            "supplier": supplier,
                            "outlet": s,
                            "cover_status": "⚠️",
                            "remark": f"F5 error: {e} (sheet: {s}, file: {filename})"
                        })
            required = set([str(x).strip().upper() for x in required_outlets])
            found = set([str(x).strip().upper() for x in found])
            print(f"[DEBUG] supplier={supplier}")
            print(f"[DEBUG] required={required}")
            print(f"[DEBUG] found={found}")
            print(f"[DEBUG] missing={required - found}")
            print(f"[DEBUG] all sheet names in {filename}: {wb.sheetnames}")
            print(f"[DEBUG] unidentified sheets: {unidentified}")
            print(f"[DEBUG] unknown F5 values: {unknown_f5}")
            print(f"[DEBUG] F5 to code mappings:")
            for s in wb.sheetnames:
                if not s.strip() or s.strip().lower() == 'sheet':
                    continue
                try:
                    f5 = wb[s]["F5"].value
                    code = self.get_outlet_shortname(f5)
                    print(f"  Sheet: {s}, F5: {f5}, Code: {code}")
                except Exception as e:
                    print(f"  Sheet: {s}, F5 Error: {e}")

            # 檢查 missing outlet 是否有對應的 sheet 但 F5 和 sheet name 不一致
            missing_with_sheet_mismatch = set()
            for sheet_name in wb.sheetnames:
                if not sheet_name.strip() or sheet_name.strip().lower() == 'sheet':
                    continue
                sheet_name_upper = sheet_name.strip().upper()
                if sheet_name_upper in required and sheet_name_upper not in found:
                    try:
                        f5 = wb[sheet_name]["F5"].value
                        code = self.get_outlet_shortname(f5)
                        if code != sheet_name_upper and "[UNKNOWN]" not in code and "[EMPTY]" not in code:
                            missing_with_sheet_mismatch.add(sheet_name_upper)
                    except:
                        pass

            for o in sorted(required - found):
                if as_table:
                    if o in missing_with_sheet_mismatch:
                        # 有 sheet 但 F5 和 sheet name 不一致
                        table.append({
                            "supplier": supplier,
                            "outlet": o,
                            "cover_status": "⚠️",
                            "remark": f"Short name mismatch: Sheet→{o}"
                        })
                    else:
                        # 真正的 missing outlet
                        table.append({
                            "supplier": supplier,
                            "outlet": o,
                            "cover_status": "❌",
                            "remark": "Missing outlet"
                        })
            if as_table:
                # 检查结束后，弹窗提醒所有未能 mapping 的 F5 内容
                if unknown_f5:
                    msg = "以下 F5 内容未能自动 mapping 到 short name，请补充到 config 的 OUTLET sheet：\n" + \
                        "\n".join(f"- {f5val}" for f5val in sorted(unknown_f5))
                    try:
                        messagebox.showwarning("智能提示/Smart Reminder", msg)
                    except Exception:
                        print("[智能提示]", msg)
                return output, table
            # 原本文字报表
            output.append(f"\n=== {filename} ===")
            output.append(
    f"📊 Required: {
        len(required)}, Found: {
            len(found)}, Missing: {
                len(
                    required -
                     found)}")
            for o in sorted(required & found):
                output.append(f"✔️ {o}")
            for o in sorted(required - found):
                output.append(f"❌ {o}")
            for s, v in unidentified:
                output.append(f"⚠️ {s} => {v}")
            if unknown_f5:
                output.append(
                    "[智能提示] 以下 F5 内容未能自动 mapping 到 short name，请补充到 config 的 OUTLET sheet：")
                for f5val in sorted(unknown_f5):
                    output.append(f"  - {f5val}")
            return output, table
        except Exception as e:
            if as_table:
                return output, [{"supplier": "-", "outlet": "-",
                    "cover_status": "❌", "remark": f"Error: {str(e)}"}]
            return f"❌ Error running checklist: {
    str(e)}\n{
        traceback.format_exc()}", []

# ========== 增强版订单自动化 ==========


class EnhancedOrderAutomation(OrderAutomation):
    """支持邮件发送的订单自动化"""

    def __init__(self, config_manager=None):
        super().__init__()
        self.config_manager = config_manager
        self.email_sender = EmailSender(config_manager)

    def run_automation(self, source_folder, supplier_folder,
                      log_callback=None, mapping_callback=None,
                      email_callback=None):
        """运行自动化流程（仅 supplier 整合）"""
        import os  # 确保 os 模块可用
        success, result = super().run_automation(
            source_folder, supplier_folder,
            log_callback=log_callback, mapping_callback=mapping_callback
        )
        if not success:
            return success, result
        supplier_files = []
        for file in os.listdir(supplier_folder):
            if file.endswith(".xlsx") and "Week" in file:
                supplier_name = file.split("_")[0]
                supplier_files.append({
                    "path": os.path.join(supplier_folder, file),
                    "supplier": supplier_name
                })
        if self.config_manager and email_callback:
            email_callback(supplier_files)
        return success, result


class YellowHighlightedOrderAutomation(OrderAutomation):
    """只整合有黃色標記的訂單"""
    # 是否在無黃色標記但偵測到本週數量時也納入（預設關閉，維持嚴格模式）
    ENABLE_FALLBACK_WHEN_NO_YELLOW = False
    # 是否啟用廣泛的標記色檢測（預設關閉，避免誤檢測）
    ENABLE_BROAD_MARKER_DETECTION = False

    def __init__(self, config_manager=None):
        super().__init__()
        self.config_manager = config_manager

    def has_yellow_highlight(self, ws, row, col):
        """檢查指定單元格是否有黃色標記（包含 RGB、索引色、前景色/背景色）。
        注意：條件式格式造成的顏色 OpenPyXL 不會評估，只能盡量偵測靜態填色。
        """
        # 如果啟用廣泛檢測，先嘗試廣泛檢測
        if self.ENABLE_BROAD_MARKER_DETECTION:
            if self.has_marker_color(ws, row, col):
                return True

        # 然後嘗試標準的黃色檢測
        return self._has_yellow_highlight_strict(ws, row, col)

    def has_marker_color(self, ws, row, col):
        """廣泛檢測任何可能的標記顏色（不僅限黃色）"""
        try:
            from openpyxl.styles.colors import Color
            cell = ws.cell(row=row, column=col)

            # 檢查填充顏色
            f = cell.fill
            if f:
                for attr in ('start_color', 'end_color', 'fgColor', 'bgColor'):
                    c = getattr(f, attr, None)
                    if c and self._is_marker_color(c):
                        print(f"[DEBUG] ✅ 發現標記填充: row={row}, col={col}, color={c}")
                        return True

            # 檢查字體顏色
            font = cell.font
            if font and hasattr(font, 'color') and font.color:
                if self._is_marker_color(font.color):
                    print(f"[DEBUG] ✅ 發現標記字體: row={row}, col={col}, font_color={font.color}")
                    return True

            return False
        except Exception as e:
            print(f"[DEBUG] 廣泛檢測時出錯: {e}")
            return False

    def _is_marker_color(self, color):
        """判斷顏色是否為標記色（廣泛定義）"""
        try:
            # RGB顏色
            if getattr(color, 'rgb', None):
                rgb = color.rgb
                if not isinstance(rgb, str):
                    return False
                rgb_up = rgb.upper()
                if len(rgb_up) == 8:
                    rgb_up = rgb_up[2:]

                try:
                    r = int(rgb_up[0:2], 16)
                    g = int(rgb_up[2:4], 16)
                    b = int(rgb_up[4:6], 16)

                    # 排除白色和黑色系
                    if r > 240 and g > 240 and b > 240:  # 接近白色
                        return False
                    if r < 15 and g < 15 and b < 15:  # 接近黑色
                        return False

                    # 任何鮮艷或彩色的都視為標記
                    max_val = max(r, g, b)
                    min_val = min(r, g, b)
                    if max_val - min_val > 50:  # 有一定飽和度
                        return True
                except Exception:
                    pass

            # 主題色
            if getattr(color, 'theme', None) is not None:
                theme_id = color.theme
                if theme_id not in {1, 2, 64}:  # 排除白色和黑色主題色
                    return True

            # 索引色
            if getattr(color, 'indexed', None) is not None:
                indexed = color.indexed
                if indexed not in {1, 2, 64}:  # 排除白色和黑色索引色
                    return True

            return False
        except Exception:
            return False

    def _has_yellow_highlight_strict(self, ws, row, col):
        """嚴格的黃色標記檢測（原始邏輯）"""
        try:
            from openpyxl.styles.colors import Color
            cell = ws.cell(row=row, column=col)

            def color_is_yellowish_strict(color: Color) -> bool:
                try:
                    # 1) 直接 RGB
                    if getattr(color, 'rgb', None):
                        rgb = color.rgb
                        if not isinstance(rgb, str):
                            return False
                        rgb_up = rgb.upper()
                        if len(rgb_up) == 8:  # e.g. FFFF00FF (ARGB)
                            rgb_up = rgb_up[2:]
                        # 常見黃系 - 擴展更多黃色調
                        common = {
    'FFFF00',  # 純黃
    'FFD966',  # 淺黃
    'FFF200',  # 亮黃
    'FFEB9C',  # 米黃
    'FFE066',  # 金黃
    'FFD700',  # 金色
    'FFE135',  # 橙黃
    'FFD800',  # 深黃
    'FFE100',  # 檸檬黃
    'FFFF99',  # 淺黃
    'FFFFCC',  # 很淺的黃
    'FFCC00',  # 橙黃
    'FFCC33',  # 橙黃
    'FF9900',  # 橙色
    'FFCC66',  # 淺橙黃
    'FFFF66',  # 淺黃
    'FFCC99',  # 米黃
    'FFE4B5',  # 鹿皮色
    'F0E68C',  # 卡其色
    'FFF8DC',  # 玉米絲色
    'FAFAD2',  # 淡金黃
    'FFEFD5',  # 番木瓜色
    'FFE4C4',  # 薄餅色
    'FFDAB9',  # 桃色
    'FFE4E1',  # 薄霧玫瑰
}
                        if rgb_up in common:
                            return True
                        # 寬鬆黃系：R、G 高，B 低 - 放寬條件以涵蓋更多黃色調
                        try:
                            r = int(rgb_up[0:2], 16)
                            g = int(rgb_up[2:4], 16)
                            b = int(rgb_up[4:6], 16)
                            # 放寬黃色檢測條件，涵蓋更廣泛的黃色調
                            if (r >= 200 and g >= 200 and b <= 150) or (r >= 180 and g >= 180 and b <= 120) or (r >= 240 and g >= 240 and b <= 200):
                                return True
                            # 另外檢查橙黃色系：R 高，G 中等，B 低
                            if r >= 200 and g >= 150 and g <= 220 and b <= 100:
                                return True
                        except Exception:
                            pass
                    # 2) 索引色（Excel Indexed 廣泛涵蓋標記色）
                    if getattr(color, 'indexed', None) is not None:
                        # 擴展索引色範圍，涵蓋更多可能的標記色
                        mark_colors = {3, 4, 5, 6, 7, 8, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64}
                        if color.indexed in mark_colors:
                            return True
                    # 3) 主題色：嘗試根據主題ID和色調估計顏色
                    if getattr(color, 'theme', None) is not None and getattr(color, 'tint', None) is not None:
                        theme_id = color.theme
                        tint = color.tint
                        # Excel主題色映射（廣泛涵蓋所有可能的標記色主題ID）
                        # 根據Excel主題色彩盤，大部分標記色都在這些範圍內
                        theme_bright_colors = set(range(5, 19))  # 5-18: 黃色、綠色、藍色、紫色等鮮艷色彩
                        theme_pastel_colors = set(range(1, 5)) + set(range(19, 23))  # 淺色調

                        if theme_id in theme_bright_colors:
                            # 鮮艷色彩的任何色調都視為標記（包括深色調）
                            return True
                        elif theme_id in theme_pastel_colors:
                            # 淺色調需要較高的tint值
                            if tint > 0.05:  # 進一步降低門檻
                                return True
                except Exception:
                    return False
                return False

            def any_fill_yellow_strict(f) -> bool:
                if not f:
                    return False
                # 檢查不同屬性
                for attr in ('start_color', 'end_color', 'fgColor', 'bgColor'):
                    c = getattr(f, attr, None)
                    if c and color_is_yellowish_strict(c):
                        return True
                return False

            # 檢查填充顏色
            f = cell.fill
            if any_fill_yellow_strict(f):
                print(f"[DEBUG] ✅ 發現黃色填充: row={row}, col={col}, fill={f}")
                return True

            # 檢查字體顏色
            try:
                font = cell.font
                if font and hasattr(font, 'color') and font.color:
                    if color_is_yellowish_strict(font.color):
                        print(f"[DEBUG] ✅ 發現黃色字體: row={row}, col={col}, font_color={font.color}")
                        return True
            except Exception as e:
                print(f"[DEBUG] 檢查字體顏色時出錯: {e}")

            # 調試信息：輸出填充詳情幫助診斷（只輸出關鍵信息）
            try:
                if f and (hasattr(f, 'fgColor') or hasattr(f, 'bgColor')):
                    # 只在發現主題色時輸出詳細信息
                    has_theme = False
                    if hasattr(f, 'fgColor') and hasattr(f.fgColor, 'theme') and f.fgColor.theme:
                        has_theme = True
                    if hasattr(f, 'bgColor') and hasattr(f.bgColor, 'theme') and f.bgColor.theme:
                        has_theme = True

                    if has_theme:
                        print(f"[DEBUG] 🔍 發現主題色填充: row={row}, col={col}")
                        print(f"[DEBUG]    - fgColor theme: {getattr(f.fgColor, 'theme', None)}, tint: {getattr(f.fgColor, 'tint', None)}")
                        print(f"[DEBUG]    - bgColor theme: {getattr(f.bgColor, 'theme', None)}, tint: {getattr(f.bgColor, 'tint', None)}")
            except Exception as e:
                print(f"[DEBUG] 獲取填充詳情時出錯: {e}")

            # 檢查是否有特殊的填充模式（比如網格線或其他視覺標記）
            try:
                if f and hasattr(f, 'patternType') and f.patternType:
                    # 如果有任何填充模式，都視為可能的標記
                    if str(f.patternType).lower() not in ['none', 'solid']:
                        print(f"[DEBUG] 🔍 發現特殊填充模式: row={row}, col={col}, pattern={f.patternType}")
                        # 可以選擇性接受某些模式作為標記
            except Exception as e:
                print(f"[DEBUG] 檢查填充模式時出錯: {e}")

            # 有些檔案會把 0 或數字以條件式上色，OpenPyXL 無法評估，記錄提示以利判斷
            # 這裡僅在偵測失敗時輸出一次簡單說明（避免刷屏）
            return False
        except Exception as e:
            print(f"[DEBUG] Error checking yellow highlight: {e}")
            return False

    def _parse_date_value(self, val, ref_year):
        """將各種日期表示（Excel序號/字串/日期物件）轉為 date。"""
        from datetime import datetime, timedelta, date
        try:
            if isinstance(val, datetime):
                return val.date()
            if isinstance(val, (int, float)):
                base = datetime(1899, 12, 30)
                return (base + timedelta(days=float(val))).date()
            s = str(val).strip()
            if not s:
                return None
            # 嘗試常見格式：1-Aug, 01/08, 01/08/2025, Aug-01, 1 Aug
            try:
                from dateutil.parser import parse
                dt = parse(
    s,
    fuzzy=True,
    dayfirst=False,
    default=datetime(
        ref_year,
        1,
         1))
                return dt.date()
            except Exception:
                # 簡單正則回退
                import re
                m = re.search(
    r"(\d{1,2})[-/ ]([A-Za-z]{3,}|\d{1,2})(?:[-/ ](\d{2,4}))?", s)
                if m:
                    day = int(m.group(1))
                    mon = m.group(2)
                    year = int(m.group(3)) if m.group(3) else ref_year
                    month_map = {
                        'Jan': 1, 'Feb': 2, 'Mar': 3, 'Apr': 4, 'May': 5, 'Jun': 6,
                        'Jul': 7, 'Aug': 8, 'Sep': 9, 'Oct': 10, 'Nov': 11, 'Dec': 12
                    }
                    if mon.isalpha():
                        mon = month_map.get(mon[:3].title())
                    else:
                        mon = int(mon)
                    return datetime(year, mon, day).date()
        except Exception:
            return None
        return None

    def check_file_has_yellow_highlight(
    self, filepath, this_week_start, this_week_end):
        """檢查檔案是否有黃色標記的單元格"""
        try:
            print(f"[DEBUG] 開始檢查檔案: {filepath}")
            wb = openpyxl.load_workbook(filepath, data_only=True)
            print(f"[DEBUG] 📋 文件 {os.path.basename(filepath)} 包含工作表: {', '.join(wb.sheetnames)}")
            for sheet_name in wb.sheetnames:
                print(f"[DEBUG] 🔍 檢查工作表: {sheet_name}")
                ws = wb[sheet_name]

                # 為每個工作表重新初始化日期列集合（因為不同工作表可能有不同的日期列）
                sheet_this_week_columns = set()
                
                # 搜尋所有行，收集所有本週的日期欄位（可能分布在不同行）
                for row in range(1, min(200, ws.max_row + 1)):
                    # 在每一行中尋找本週的日期欄位
                    for col in range(5, 30):  # 擴大搜尋範圍到 E~AD 欄
                        date_cell = ws.cell(row=row, column=col)
                        if date_cell.value:
                            try:
                                from datetime import datetime
                                # 嘗試解析日期
                                if isinstance(date_cell.value, datetime):
                                    cell_date = date_cell.value.date()
                                elif isinstance(date_cell.value, str):
                                    # 嘗試解析字符串日期，如 "1-Aug", "2-Aug" 等
                                    import re
                                    date_match = re.search(
                                        r'(\d+)-(\w+)', str(date_cell.value))
                                    if date_match:
                                        day = int(date_match.group(1))
                                        month_str = date_match.group(2)
                                        # 簡單的月份映射
                                        month_map = {
                                            'Jan': 1, 'Feb': 2, 'Mar': 3, 'Apr': 4, 'May': 5, 'Jun': 6,
                                            'Jul': 7, 'Aug': 8, 'Sep': 9, 'Oct': 10, 'Nov': 11, 'Dec': 12
                                        }
                                        if month_str in month_map:
                                            month = month_map[month_str]
                                            # 根据月份判断年份：如果月份小于当前月份，可能是下一年
                                            current_month = this_week_start.month
                                            if month < current_month:
                                                year = this_week_start.year + 1
                                            else:
                                                year = this_week_start.year
                                            cell_date = datetime(
                                                year, month, day).date()
                                        else:
                                            continue
                                    else:
                                        continue
                                else:
                                    continue

                                # 檢查日期是否在本週範圍內
                                if this_week_start.date() <= cell_date <= this_week_end.date():
                                    sheet_this_week_columns.add(col)
                                    print(
    f"[DEBUG] 找到本週日期欄位: 第{row}行第{col}欄, 日期: {cell_date}")
                            except Exception as e:
                                continue

                if not sheet_this_week_columns:
                    continue

                print(f"[DEBUG] 工作表 {sheet_name} 本週日期欄位總計: {sorted(sheet_this_week_columns)}")

                # 檢查所有本週日期欄位下方的產品行是否有黃色標記
                # 檢查範圍從第1行到最後一行，尋找產品行
                found_yellow_in_sheet = False
                for check_row in range(1, min(200, ws.max_row + 1)):
                    # 檢查是否為產品行（通常有產品名稱）
                    product_name = ws.cell(
                        row=check_row, column=5).value  # E 欄產品名稱
                    if not product_name or str(
                        product_name).strip() == "":
                        continue

                    print(
                        f"[DEBUG] 檢查產品行: {check_row}, 產品: {product_name}")

                    # 檢查所有本週的日期欄位（即使沒有輸入數字，只要標黃就納入）
                    for col in sorted(sheet_this_week_columns):
                        if self.has_yellow_highlight(ws, check_row, col):
                            cell_value = ws.cell(
                                row=check_row, column=col).value
                            print(
                                f"[DEBUG] ✅ 在檔案 {filepath} 工作表 {sheet_name} 找到本週黃色標記 (row={check_row}, col={col}, 值={cell_value})!")
                            found_yellow_in_sheet = True
                            break
                    if found_yellow_in_sheet:
                        break
                
                if found_yellow_in_sheet:
                                wb.close()
                                return True

            wb.close()
            print(f"[DEBUG] ❌ 在檔案 {filepath} 中沒有找到黃色標記")
            return False
        except Exception as e:
            print(
    f"[DEBUG] Error checking yellow highlight in {filepath}: {e}")
            return False

    def _analyze_file_skip_reason(
    self,
    filepath,
    start_of_period,
     end_of_period):
        """分析為何未檢出黃色標記，回傳簡潔原因字串。"""
        import openpyxl
        from datetime import datetime
        try:
            wb = openpyxl.load_workbook(filepath, data_only=True)
            any_week_cols = False
            any_product_rows = False
            any_numeric_under_week = False
            for sheet_name in wb.sheetnames:
                ws = wb[sheet_name]
                if hasattr(ws, 'sheet_state') and ws.sheet_state != "visible":
                    continue
                week_cols = []
                date_row = None
                for row in range(1, min(50, ws.max_row + 1)):
                    for col in range(6, 25):
                        val = ws.cell(row=row, column=col).value
                        d = self._parse_date_value(val, start_of_period.year)
                        if d and start_of_period.date() <= d <= end_of_period.date():
                            week_cols.append(col)
                    if week_cols:
                        date_row = row
                        any_week_cols = True
                        break
                if not week_cols:
                    continue
                # 掃產品列
                for r in range((date_row or 1) + 1,
                               min((date_row or 1) + 80, ws.max_row + 1)):
                    prod = ws.cell(row=r, column=5).value
                    if prod and str(prod).strip() != "":
                        any_product_rows = True
                        for c in week_cols:
                            v = ws.cell(row=r, column=c).value
                            try:
                                if isinstance(
    v, (int, float)) and float(v) != 0:
                                    any_numeric_under_week = True
                                    raise StopIteration
                                if isinstance(v, str) and v.strip() != "":
                                    if v.replace(
    '.', '', 1).isdigit() and float(v) != 0:
                                        any_numeric_under_week = True
                                        raise StopIteration
                            except StopIteration:
                                break
                        if any_numeric_under_week:
                            break
                if any_numeric_under_week:
                    break
        except Exception:
            return "檔案讀取或分析失敗"
        finally:
            try:
                wb.close()
            except Exception:
                pass
        if not any_week_cols:
            return "未偵測到本週日期欄"
        if not any_product_rows:
            return "未找到產品行"
        if not any_numeric_under_week:
            return "本週日期下未發現數量"
        return "存在數量但未標黃"

    def run_automation(
    self,
    source_folder,
    supplier_folder,
    log_callback=None,
     mapping_callback=None):
        from datetime import datetime, timedelta
        import os
        import openpyxl
        import xlwings as xw
        import traceback

        now = datetime.now()
        today = now.date()
        this_monday = today - timedelta(days=today.weekday())
        this_sunday = this_monday + timedelta(days=6)  # 本周日
        start_of_period = datetime.combine(this_monday, datetime.min.time())
        end_of_period = datetime.combine(this_sunday, datetime.max.time())
        save_path = os.path.join(
    source_folder, f"yellow_highlight_order_log_{
        now.strftime('%Y%m%d_%H%M%S')}.txt")
        log_lines = [
            f"🎯 Amendment Order Integration Log\n",
            f"Scan Start Time: {now}\n",
            f"Target Week: {
    start_of_period.strftime('%Y-%m-%d')} to {
        end_of_period.strftime('%Y-%m-%d')}\n"
        ]

        def log(message, include_timestamp=True):
            timestamp = datetime.now().strftime("%H:%M:%S") if include_timestamp else ""
            log_line = f"[{timestamp}] {message}" if include_timestamp else message
            log_lines.append(log_line + "\n")
            if log_callback:
                log_callback(log_line + "\n")

        files = [f for f in os.listdir(source_folder) if f.endswith(
            (".xlsx", ".xls")) and not f.startswith("~$")]
        total_files = len(files)
        if total_files == 0:
            log("未找到Excel文件\nNo Excel files found in source folder. Exiting.")
            return False, "在源文件夹中未找到Excel文件"
        log(f"找到 {total_files} 个Excel文件\nFound {total_files} Excel files")
        log(f"目标周期: {start_of_period.strftime('%Y-%m-%d')} 到 {end_of_period.strftime('%Y-%m-%d')}")
        log(f"🔍 專注於本週訂單，忽略其他週期")

        # 1. 找出所有有黃色標記的 (門市, 廠商) sheet
        supplier_to_outlets = {}  # supplier: set(outlet)
        outlet_to_suppliers = {}  # outlet: set(supplier) - 用于显示每个门市的改单详情
        for filename in files:
            filepath = os.path.join(source_folder, filename)
            print(f"[DEBUG] 🔍 處理文件: {filename}")
            try:
                # 使用修復後的方法檢查檔案是否有本週的黃色標記
                if self.check_file_has_yellow_highlight(
                    filepath, start_of_period, end_of_period):
                    wb = openpyxl.load_workbook(filepath, data_only=True)
                    print(f"[DEBUG] 📋 文件 {filename} 包含工作表: {', '.join(wb.sheetnames)}")
                    found_yellow_in_file = False
                    for sheetname in wb.sheetnames:
                        print(f"[DEBUG] 🔍 檢查工作表: {sheetname}")
                        ws = wb[sheetname]
                        # 跳過隱藏 sheet
                        if hasattr(
    ws, 'sheet_state') and ws.sheet_state != "visible":
                            print(f"[DEBUG] ⚠️ 跳過隱藏工作表: {sheetname}")
                            continue
                        # 直接搜尋所有行，尋找本週的日期和黃色標記（與檔案級檢測同樣的寬鬆範圍）
                        found_yellow_in_sheet = False
                        # 搜尋所有行，收集所有本週的日期欄位（可能分布在不同行）
                        sheet_this_week_columns = set()
                        
                        # 收集本周日期列
                        for row in range(1, min(200, ws.max_row + 1)):
                            # 在每一行中尋找本週的日期欄位
                            for col in range(5, 30):  # E~AD 欄
                                date_cell = ws.cell(row=row, column=col)
                                if date_cell.value:
                                    try:
                                        from datetime import datetime
                                        # 嘗試解析日期
                                        if isinstance(
                                            date_cell.value, datetime):
                                            cell_date = date_cell.value.date()
                                        elif isinstance(date_cell.value, str):
                                            # 嘗試解析字符串日期，如 "1-Aug", "2-Aug" 等
                                            import re
                                            date_match = re.search(
                                                r'(\d+)-(\w+)', str(date_cell.value))
                                            if date_match:
                                                day = int(date_match.group(1))
                                                month_str = date_match.group(2)
                                                # 簡單的月份映射
                                                month_map = {
                                                    'Jan': 1, 'Feb': 2, 'Mar': 3, 'Apr': 4, 'May': 5, 'Jun': 6,
                                                    'Jul': 7, 'Aug': 8, 'Sep': 9, 'Oct': 10, 'Nov': 11, 'Dec': 12
                                                }
                                                if month_str in month_map:
                                                    month = month_map[month_str]
                                                    # 根据月份判断年份：如果月份小于当前月份，可能是下一年
                                                    current_month = start_of_period.month
                                                    if month < current_month:
                                                        year = start_of_period.year + 1
                                                    else:
                                                        year = start_of_period.year
                                                    cell_date = datetime(
                                                        year, month, day).date()
                                                else:
                                                    continue
                                            else:
                                                continue
                                        else:
                                            continue

                                        # 檢查日期是否在本週範圍內
                                        if start_of_period.date() <= cell_date <= end_of_period.date():
                                            sheet_this_week_columns.add(col)
                                            print(
    f"[DEBUG] 📅 找到本週日期: {cell_date} 在列 {col}")
                                        else:
                                            print(
    f"[DEBUG] ⚠️ 跳過非本週日期: {cell_date} 在列 {col}")
                                    except Exception as e:
                                        continue

                        # 如果我們到達這裡，說明已經檢查了所有行
                        # 檢查是否找到了任何本周日期列
                        if not sheet_this_week_columns:
                            print(f"[DEBUG] ❌ 工作表 {sheetname} 未找到任何本週日期欄位")
                            continue

                        print(f"[DEBUG] 工作表 {sheetname} 本週日期欄位總計: {sorted(sheet_this_week_columns)}")

                        # 找到本周日期所在的行，然后只检查该行以下的100行
                        this_week_date_rows = set()
                        for row in range(1, min(200, ws.max_row + 1)):
                            for col in range(5, 30):  # E~AD 欄
                                date_cell = ws.cell(row=row, column=col)
                                if date_cell.value:
                                    try:
                                        from datetime import datetime
                                        # 嘗試解析日期
                                        if isinstance(date_cell.value, datetime):
                                            cell_date = date_cell.value.date()
                                        elif isinstance(date_cell.value, str):
                                            import re
                                            date_match = re.search(r'(\d+)-(\w+)', str(date_cell.value))
                                            if date_match:
                                                day = int(date_match.group(1))
                                                month_str = date_match.group(2)
                                                month_map = {
                                                    'Jan': 1, 'Feb': 2, 'Mar': 3, 'Apr': 4, 'May': 5, 'Jun': 6,
                                                    'Jul': 7, 'Aug': 8, 'Sep': 9, 'Oct': 10, 'Nov': 11, 'Dec': 12
                                                }
                                                if month_str in month_map:
                                                    month = month_map[month_str]
                                                    current_month = start_of_period.month
                                                    if month < current_month:
                                                        year = start_of_period.year + 1
                                                    else:
                                                        year = start_of_period.year
                                                    cell_date = datetime(year, month, day).date()
                                                else:
                                                    continue
                                            else:
                                                continue
                                        else:
                                            continue

                                        # 檢查日期是否在本週範圍內
                                        if start_of_period.date() <= cell_date <= end_of_period.date():
                                            this_week_date_rows.add(row)
                                            print(f"[DEBUG] 📅 找到本週日期行: {row}, 日期: {cell_date}")
                                    except Exception as e:
                                        continue

                        if not this_week_date_rows:
                            print(f"[DEBUG] ❌ 工作表 {sheetname} 未找到任何本週日期行")
                            continue

                        # 找到最早的本周日期行
                        start_row = min(this_week_date_rows)
                        end_row = min(start_row + 100, ws.max_row + 1)
                        print(f"[DEBUG] 檢查範圍: 第{start_row}行到第{end_row}行")

                        # 只檢查本周日期行以下的100行
                        for check_row in range(start_row, end_row):
                                # 檢查是否為產品行（通常有產品名稱）
                            product_name = ws.cell(row=check_row, column=5).value  # E 欄產品名稱
                            if not product_name or str(product_name).strip() == "":
                                    continue

                            print(f"[DEBUG] 檢查產品行: {check_row}, 產品: {product_name}")

                            # 檢查本週的日期欄位（即使沒有輸入數字，只要標黃就納入）
                            for col in sorted(sheet_this_week_columns):
                                if self.has_yellow_highlight(ws, check_row, col):
                                    print(f"[DEBUG] 🟡 在工作表 {sheetname} 第{check_row}行第{col}欄找到黃色標記")
                                    found_yellow_in_sheet = True
                                    found_yellow_in_file = True
                                    break
                            if found_yellow_in_sheet:
                                break

                        if found_yellow_in_sheet:
                            # 正確邏輯：文件名是門市名稱，工作表名是供應商名稱
                            outlet_name = filename.split("_Amendment_")[
                                                         0] if "_Amendment_" in filename else filename
                            supplier_name = sheetname
                            supplier_to_outlets.setdefault(
                                supplier_name, set()).add(filepath)
                            # 记录门市到供应商的映射
                            outlet_to_suppliers.setdefault(
                                outlet_name, set()).add(supplier_name)
                            log(f"✅ {filename} (門市: {outlet_name}) 發現本週黃色標記: {sheetname} (供應商)")
                            print(
    f"[DEBUG] 🔍 詳細信息: 工作表={sheetname}, 門市={outlet_name}, 供應商={supplier_name}")
                            print(f"[DEBUG] 🎯 工作表 {sheetname} 被標記為有黃色標記")
                            # 不要break，继续检查其他工作表，因为一个文件可能有多个供应商的黄色标记
                        else:
                            print(f"[DEBUG] ❌ 工作表 {sheetname} 未發現黃色標記")

                    if found_yellow_in_file:
                        wb.close()
                    else:
                        # 沒有找到黃色標記，跳過此文件
                        reason = self._analyze_file_skip_reason(
                            filepath, start_of_period, end_of_period)
                        print(f"[DEBUG] ❌ 文件 {filename} 沒有黃色標記，原因: {reason}")
                        log(f"⏭️ {filename} 沒有本週黃色標記，跳過（原因：{reason}）")
            except Exception as e:
                print(f"[DEBUG] ❌ 檢查文件 {filename} 時發生錯誤: {e}")
                log(f"❌ 檢查 {filename} 發生錯誤: {e}")
        log("")
        log(f"📊 統計結果:")
        log(f"   - 總檔案數: {len(files)}")
        log(f"   - 有黃色標記的廠商: {len(supplier_to_outlets)}")
        log("")
        if not supplier_to_outlets:
            log("❌ 沒有找到任何有黃色標記的廠商")
            return False, "沒有找到任何有黃色標記的廠商"

        # 添加詳細的供應商和文件列表
        log(f"📋 发现黄色标记的供应商:")
        for supplier, file_paths in supplier_to_outlets.items():
            log(f"   - {supplier}: {len(file_paths)} 个文件")
            for file_path in sorted(file_paths):
                filename = os.path.basename(file_path)
                log(f"     📄 {filename}")
        log("")

        # 添加门市改单详情
        log(f"🏪 门市改单详情:")
        for outlet, suppliers in sorted(outlet_to_suppliers.items()):
            supplier_list = ", ".join(sorted(suppliers))
            log(f"   {outlet} - {supplier_list}")
        log("")

        log(f"📋 準備整合以下廠商:")
        for supplier in supplier_to_outlets:
            log(f"   - {supplier}")
        log("")
        # 2. 以廠商為單位合併所有有黃色標記的門市的該廠商 sheet（用 xlwings 複製 sheet，保留格式/公式）
        supplier_files = []
        for supplier, filelist in supplier_to_outlets.items():
            try:
                # 生成月份-星期格式的文件名
                month_abbr = now.strftime('%b')
                week_in_month = ((now.day - 1) // 7) + 1
                supplier_path = os.path.join(
                    supplier_folder, f"{supplier}_Amendment_{month_abbr}_Week_{week_in_month}.xlsx")
                # 先建立空檔案
                if not os.path.exists(supplier_path):
                    from openpyxl import Workbook
                    wb = Workbook()
                    wb.save(supplier_path)
                app = xw.App(visible=False)
                try:
                    wb_dest = app.books.open(supplier_path)
                    for src_file in filelist:
                        try:
                            wb_src = app.books.open(src_file)
                            if supplier in [sht.name for sht in wb_src.sheets]:
                                sht = wb_src.sheets[supplier]
                                # 從文件名中提取門市名稱
                                filename = os.path.splitext(
                                    os.path.basename(src_file))[0]
                                if "_Amendment_" in filename:
                                    outlet_name = filename.split(
                                        "_Amendment_")[0]
                                else:
                                    outlet_name = filename
                                # 目標工作表名應該是門市名稱
                                dest_sheet_name = outlet_name
                                # 刪除同名分頁（但要確保至少保留一個工作表）
                                sheets_to_delete = []
                                for s in wb_dest.sheets:
                                    if s.name == dest_sheet_name:
                                        sheets_to_delete.append(s)
                                
                                # 只有在有多個工作表時才刪除
                                if len(wb_dest.sheets) > 1:
                                    for s in sheets_to_delete:
                                        s.delete()
                                sht.api.Copy(Before=wb_dest.sheets[0].api)
                                # 檢查新複製的工作表名稱是否衝突，如果衝突則添加後綴
                                new_sheet = wb_dest.sheets[0]
                                original_name = dest_sheet_name
                                counter = 1
                                while any(s.name == dest_sheet_name for s in wb_dest.sheets if s != new_sheet):
                                    dest_sheet_name = f"{original_name}_{counter}"
                                    counter += 1
                                new_sheet.name = dest_sheet_name
                            else:
                                # 如果只有一個工作表，直接複製並重命名
                                sht.api.Copy(Before=wb_dest.sheets[0].api)
                                # 檢查新複製的工作表名稱是否衝突，如果衝突則添加後綴
                                new_sheet = wb_dest.sheets[0]
                                original_name = dest_sheet_name
                                counter = 1
                                while any(s.name == dest_sheet_name for s in wb_dest.sheets if s != new_sheet):
                                    dest_sheet_name = f"{original_name}_{counter}"
                                    counter += 1
                                new_sheet.name = dest_sheet_name
                                log(
    f"    📋 已複製供應商 {supplier} 工作表到門市 {dest_sheet_name} 工作表")
                            wb_src.close()
                        except Exception as e:
                            log(
    f"    ❌ Failed to copy {supplier} in {
        os.path.basename(src_file)}: {
            str(e)}\n{
                traceback.format_exc()}")
                    # 刪除空白的 Sheet（如果存在且有其他工作表）
                    try:
                        if len(wb_dest.sheets) > 1:  # 確保不是唯一的工作表
                            sheets_to_delete = []
                            for sheet in wb_dest.sheets:
                                if sheet.name in ['Sheet', 'Sheet1']:
                                    # 檢查工作表是否真的是空白的
                                    is_empty = True
                                    try:
                                        if sheet.used_range is not None:
                                            # 檢查 used_range 中是否有實際數據
                                            for row in sheet.used_range.rows:
                                                for cell in row:
                                                    if cell.value is not None and str(
                                                        cell.value).strip() != "":
                                                        is_empty = False
                                                        break
                                                if not is_empty:
                                                    break
                                    except:
                                        # 如果檢查失敗，假設不是空白的
                                        is_empty = False

                                    if is_empty:
                                        sheets_to_delete.append(sheet)

                            # 刪除空白工作表
                            for sheet in sheets_to_delete:
                                sheet.delete()
                                log(f"  🗑️ 已刪除空白工作表: {sheet.name}")

                    except Exception as e:
                        # 静默处理删除空白工作表时的错误，不显示错误信息
                        pass

                    wb_dest.save()
                    wb_dest.close()
                    supplier_files.append(os.path.basename(supplier_path))
                    log(f"  ✅ 已整合: {os.path.basename(supplier_path)}")
                finally:
                    app.quit()
            except Exception as e:
                log(f"❌ 整合 {supplier} 發生錯誤: {e}\n{traceback.format_exc()}")
        result_text = f"\n🎯 本週訂單整合完成 / Amendment Order Integration Complete:\n"
        result_text += f"📦 已處理供應商文件: {len(supplier_files)}\n"
        result_text += f"📅 目標週期: {
    this_monday.strftime('%Y-%m-%d')} 到 {
        this_sunday.strftime('%Y-%m-%d')}\n\n"
        result_text += "📋 供應商文件列表:\n" + \
            "\n".join([f"  ✅ {file}" for file in supplier_files])
        log(result_text)
        try:
            with open(save_path, "w", encoding="utf-8") as logfile:
                logfile.writelines(log_lines)
            log(f"\nLog saved at: {save_path}")
            return True, f"Amendment Order 整合完成！\n\n日志文件保存至:\n{save_path}\n\n{result_text}"
        except Exception as e:
            log(f"❌ Failed to write log file: {e}")
            return False, f"Amendment Order 整合完成但日志保存失败:\n{str(e)}"

# ========== 主应用程序 ==========


class SushiExpressApp(ctk.CTk):
    """主应用程序"""

    def __init__(self):
        super().__init__()
        self.title(f"Sushi Express Automation Tool v{VERSION}")
        self.geometry("1400x900")
        self.minsize(1200, 800)
        self.configure(fg_color=DARK_BG)
        self.iconbitmap(resource_path("SELOGO22 - 01.ico"))
        self.protocol("WM_DELETE_WINDOW", self._on_close)
        # 初始化所有用到的 StringVar
        self.download_folder_var = ctk.StringVar()
        self.config_file_var = ctk.StringVar()
        self.checklist_folder_var = ctk.StringVar()
        self.master_config_var = ctk.StringVar()
        self.folder_vars = {}
        self.master_file_var = ctk.StringVar()
        self.output_folder_var = ctk.StringVar()
        self.email_supplier_folder_var = ctk.StringVar()
        self.email_master_config_var = ctk.StringVar()
        self.demerit_file_var = ctk.StringVar()
        self.progress_popup = None
        self.mapping_popup = None
        self.outlet_config_var = ctk.StringVar()
        self.email_dialogs = []
        self.current_function = None
        self.nav_buttons = {}
        self.selected_outlook_account_idx = None
        self.checklist_search_var = ctk.StringVar()
        self._setup_ui()
        self.show_login()

    def _setup_ui(self):
        self.main_container = ctk.CTkFrame(self, fg_color="transparent")
        self.main_container.pack(fill="both", expand=True, padx=20, pady=20)

        # 左側導航欄
        self.nav_frame = ctk.CTkFrame(
            self.main_container,
            fg_color=DARK_PANEL,
            corner_radius=24,
            width=300
        )
        self.nav_frame.pack(side="left", fill="y", padx=(0, 10), pady=10)
        self.nav_frame.pack_propagate(False)

        # 加入 LOGO
        logo_img = load_image(LOGO_PATH, max_size=(220, 80))
        if logo_img:
            logo_label = ctk.CTkLabel(self.nav_frame, image=logo_img, text="")
            logo_label.image = logo_img  # 防止被垃圾回收
            logo_label.pack(pady=(18, 8))

        nav_title = ctk.CTkLabel(
            self.nav_frame,
            text="功能菜单\nFunction Menu",
            font=FONT_TITLE,
            text_color=ACCENT_BLUE,
            justify="center"
        )
        nav_title.pack(pady=20)
        ctk.CTkFrame(
    self.nav_frame,
    height=2,
    fg_color=ACCENT_BLUE).pack(
        fill="x",
        padx=20,
         pady=10)

        # 按鈕容器
        self.button_container = ctk.CTkFrame(
    self.nav_frame, fg_color="transparent")
        self.button_container.pack(fill="both", expand=True, padx=10, pady=10)

        # 右側內容區
        self.content_container = ctk.CTkFrame(
            self.main_container,
            fg_color=DARK_PANEL,
            corner_radius=24
        )
        self.content_container.pack(
    side="right",
    fill="both",
    expand=True,
    padx=10,
     pady=10)
        self.content_container.pack_propagate(False)

        # 右側內容區的標題區域
        self.content_header = ctk.CTkFrame(
    self.content_container, fg_color="transparent")
        self.content_header.pack(fill="x", padx=20, pady=20)

        self.function_title = ctk.CTkLabel(
            self.content_header,
            text="",
            font=FONT_TITLE,
            text_color=ACCENT_BLUE
        )
        self.function_title.pack(side="left")

        self.function_subtitle = ctk.CTkLabel(
            self.content_header,
            text="",
            font=FONT_SUB,
            text_color=TEXT_COLOR
        )
        self.function_subtitle.pack(side="left", padx=20)

        # 右侧内容区的主体
        self.content_body = ctk.CTkFrame(
    self.content_container, fg_color="transparent")
        self.content_body.pack(fill="both", expand=True, padx=20, pady=20)

        # 添加返回主菜单按钮
        back_frame = ctk.CTkFrame(
    self.content_container,
     fg_color="transparent")
        back_frame.pack(fill="x", padx=20, pady=10)
        ctk.CTkButton(
            back_frame,
            text="返回主菜单\nBack to Main Menu",
            command=self.show_main_menu,
            fg_color=ACCENT_PURPLE,
            hover_color=BTN_HOVER
        ).pack(side="right")

    def _on_close(self):
        print("on_close called")
        self.destroy()

    def show_login(self):
        """显示登录界面"""
        for w in self.content_container.winfo_children():
            if w != self.content_header and w != self.content_body:
                w.destroy()

        # 清空内容区
        for w in self.content_body.winfo_children():
            w.destroy()

        # 创建登录界面
        login_frame = ctk.CTkFrame(
            self.content_body,
            fg_color=DARK_PANEL,
            corner_radius=24,
            width=450,
            height=400
        )
        login_frame.place(relx=0.5, rely=0.5, anchor="center")

        self.pwd_entry = ctk.CTkEntry(
            login_frame,
            show="*",
            font=FONT_MID,  # 改成較小字體
            width=300,
            placeholder_text=t("password"),
            fg_color=ENTRY_BG,
            height=45
        )
        self.pwd_entry.pack(pady=(40, 20))
        self.pwd_entry.bind("<Return>", lambda e: self._try_login())

        ctk.CTkButton(
            login_frame,
            text=t("login_btn"),
            command=self._try_login,
            width=200,
            font=FONT_BIGBTN
        ).pack(pady=(0, 20))

        ctk.CTkLabel(
            login_frame,
            text=f"Version {VERSION} | {DEVELOPER}",
            font=FONT_MID,
            text_color="#64748B"
        ).pack(side="bottom", pady=10)

        # 设置标题
        self.function_title.configure(
    text="系统登录\nSystem Login", font=FONT_TITLE)
        self.function_subtitle.configure(
    text="请输入密码進入系统\nPlease enter password to access the system",
     font=FONT_MID)

    def _try_login(self):
        """尝试登录"""
        if self.pwd_entry.get() == PASSWORD:
            self.show_main_menu()
        else:
            messagebox.showerror(t("error"), t("incorrect_pw"))

    def show_main_menu(self):
        # 清空内容区
        for w in self.content_body.winfo_children():
            w.destroy()

        # 设置标题
        self.function_title.configure(text="選擇功能分類\nSelect Function Category")
        self.function_subtitle.configure(
    text="請選擇您要使用的功能分類\nPlease select the function category you want to use")

        # 创建功能选择界面
        self._create_function_category_selection()

        # 清空左侧导航，显示简单的logo和标题
        self._create_simple_navigation()

    def _create_function_category_selection(self):
        """创建功能分类选择界面 - 三列布局"""
        # 主容器 - 减少上下边距
        main_container = ctk.CTkFrame(
    self.content_body, fg_color="transparent")
        main_container.pack(fill="both", expand=True, padx=20, pady=10)

        # 欢迎标题区域 - 减少下边距
        welcome_frame = ctk.CTkFrame(main_container, fg_color="transparent")
        welcome_frame.pack(fill="x", pady=(0, 15))

        welcome_title = ctk.CTkLabel(
            welcome_frame,
            text=t("main_title"),
            font=("Microsoft YaHei", 16, "bold"),  # 稍微缩小字体
            text_color=ACCENT_BLUE,
            justify="center"
        )
        welcome_title.pack(pady=(0, 5))

        # 功能分类容器 - 三列布局，减少上下边距
        categories_container = ctk.CTkFrame(
    main_container, fg_color="transparent")
        categories_container.pack(fill="both", expand=True, pady=10)

        # 左侧 - 订单功能
        left_frame = ctk.CTkFrame(categories_container, fg_color="transparent")
        left_frame.pack(side="left", fill="both", expand=True, padx=(0, 10))

        self._create_ordering_category_card(left_frame)

        # 中间 - 月结功能
        middle_frame = ctk.CTkFrame(categories_container, fg_color="transparent")
        middle_frame.pack(side="left", fill="both", expand=True, padx=(0, 10))

        self._create_monthend_category_card(middle_frame)

        # 右侧 - 数据分析功能
        right_frame = ctk.CTkFrame(categories_container, fg_color="transparent")
        right_frame.pack(side="right", fill="both", expand=True, padx=(10, 0))

        self._create_data_analysis_category_card(right_frame)

        # 底部退出按钮 - 减少上边距
        exit_frame = ctk.CTkFrame(main_container, fg_color="transparent")
        exit_frame.pack(fill="x", pady=(15, 0))  # 减少上边距

        exit_btn = ctk.CTkButton(
            exit_frame,
            text=t("exit_system"),
            command=self._on_close,
            fg_color="#64748b",
            hover_color="#475569",
            font=("Microsoft YaHei", 12, "bold"),  # 稍微缩小字体
            text_color="white",
            width=160,  # 稍微缩小宽度
            height=45,  # 稍微缩小高度
            corner_radius=10
        )
        exit_btn.pack()

    def _create_data_analysis_category_card(self, parent):
        """创建数据分析功能分类卡片"""
        # 卡片容器 - 加大尺寸
        card = ctk.CTkFrame(
            parent,
            fg_color="#7c3aed",
            corner_radius=25,
            border_width=4,
            border_color="#8b5cf6"
        )
        card.pack(fill="both", expand=True, padx=5, pady=5)

        # 图标 - 缩小间距
        icon_label = ctk.CTkLabel(
            card,
            text="📈",
            font=("Microsoft YaHei", 48),  # 稍微缩小图标
            text_color="white"
        )
        icon_label.pack(pady=(20, 8))  # 减少上下边距

        # 标题 - 中英文对照，缩小间距
        title_label = ctk.CTkLabel(
            card,
            text="數據分析\nData Analysis",
            font=("Microsoft YaHei", 20, "bold"),  # 稍微缩小字体
            text_color="white",
            justify="center"
        )
        title_label.pack(pady=(0, 12))  # 减少下边距

        # 功能列表 - 中英文对照，缩小行间距
        features_text = (
            "📊 POS 數據分析\n    POS Data Analysis\n"
            "📈 銷售趨勢分析\n    Sales Trend Analysis\n"
            "💰 成本效益分析\n    Cost-Benefit Analysis\n"
            "📋 報表生成工具\n    Report Generation Tools\n"
            "🔍 數據挖掘功能\n    Data Mining Features"
        )

        features_label = ctk.CTkLabel(
            card,
            text=features_text,
            font=("Microsoft YaHei", 14, "bold"),  # 稍微缩小字体
            text_color="#ffffff",
            justify="center"
        )
        features_label.pack(pady=(0, 15))  # 减少下边距

        # 进入按钮 - 中英文对照，缩小尺寸和间距
        enter_btn = ctk.CTkButton(
            card,
            text="進入數據分析\nEnter Data Analysis",
            command=self._pos_data_analysis,
            fg_color="white",
            hover_color="#f1f5f9",
            font=("Microsoft YaHei", 14, "bold"),  # 稍微缩小字体
            text_color="#7c3aed",
            width=220,  # 缩小宽度
            height=50,  # 缩小高度
            corner_radius=12
        )
        enter_btn.pack(pady=(0, 20))  # 减少下边距

    def _create_ordering_category_card(self, parent):
        """创建订单功能分类卡片"""
        # 卡片容器 - 加大尺寸
        card = ctk.CTkFrame(
            parent,
            fg_color="#1e3a8a",
            corner_radius=25,
            border_width=4,
            border_color="#3b82f6"
        )
        card.pack(fill="both", expand=True, padx=5, pady=5)

        # 图标 - 缩小间距
        icon_label = ctk.CTkLabel(
            card,
            text="📋",
            font=("Microsoft YaHei", 48),  # 稍微缩小图标
            text_color="white"
        )
        icon_label.pack(pady=(20, 8))  # 减少上下边距

        # 标题 - 中英文对照，缩小间距
        title_label = ctk.CTkLabel(
            card,
            text=t("ordering_function"),
            font=("Microsoft YaHei", 20, "bold"),  # 稍微缩小字体
            text_color="white",
            justify="center"
        )
        title_label.pack(pady=(0, 12))  # 减少下边距

        # 功能列表 - 中英文对照，缩小行间距
        features_text = (
            "📧 Outlook訂單下載\n    Outlook Order Download\n"
            "🔄 訂單自動整合\n    Order Automation\n"
            "📋 每週訂單檢查表\n    Weekly Order Checklist\n"
            "📤 發送郵件\n    Send Emails\n"
            "📦 營運用品\n    Operation Supplies"
        )

        features_label = ctk.CTkLabel(
            card,
            text=features_text,
            font=("Microsoft YaHei", 14, "bold"),  # 稍微缩小字体
            text_color="#ffffff",
            justify="center"
        )
        features_label.pack(pady=(0, 15))  # 减少下边距

        # 进入按钮 - 中英文对照，缩小尺寸和间距
        enter_btn = ctk.CTkButton(
            card,
            text="進入訂單功能\nEnter Ordering Function",
            command=self.show_ordering_functions,
            fg_color="white",
            hover_color="#f1f5f9",
            font=("Microsoft YaHei", 14, "bold"),  # 稍微缩小字体
            text_color="#1e3a8a",
            width=220,  # 缩小宽度
            height=50,  # 缩小高度
            corner_radius=12
        )
        enter_btn.pack(pady=(0, 20))  # 减少下边距

    def _create_monthend_category_card(self, parent):
        """创建月结功能分类卡片"""
        # 卡片容器 - 加大尺寸
        card = ctk.CTkFrame(
            parent,
            fg_color="#c2410c",
            corner_radius=25,
            border_width=4,
            border_color="#ea580c"
        )
        card.pack(fill="both", expand=True, padx=5, pady=5)

        # 图标 - 缩小间距
        icon_label = ctk.CTkLabel(
            card,
            text="📊",
            font=("Microsoft YaHei", 48),  # 稍微缩小图标
            text_color="white"
        )
        icon_label.pack(pady=(20, 8))  # 减少上下边距

        # 标题 - 中英文对照，缩小间距
        title_label = ctk.CTkLabel(
            card,
            text=t("monthend_function"),
            font=("Microsoft YaHei", 20, "bold"),  # 稍微缩小字体
            text_color="white",
            justify="center"
        )
        title_label.pack(pady=(0, 12))  # 减少下边距

        # 功能列表 - 中英文对照，缩小行间距
        features_text = (
            "📊 月度銷售報表生成\n    Monthly Sales Report\n"
            "📈 供應商對賬單處理\n    Supplier Statement Processing\n"
            "💰 成本分析與核算\n    Cost Analysis & Accounting\n"
            "📋 庫存盤點整理\n    Inventory Count Organization\n"
            "🔄 自動化月結流程\n    Automated Month-end Process"
        )

        features_label = ctk.CTkLabel(
            card,
            text=features_text,
            font=("Microsoft YaHei", 14, "bold"),  # 稍微缩小字体
            text_color="#ffffff",
            justify="center"
        )
        features_label.pack(pady=(0, 15))  # 减少下边距

        # 进入按钮 - 中英文对照，缩小尺寸和间距
        enter_btn = ctk.CTkButton(
            card,
            text=t("enter_monthend"),
            command=self.show_monthend_functions,
            fg_color="white",
            hover_color="#f1f5f9",
            font=("Microsoft YaHei", 14, "bold"),  # 稍微缩小字体
            text_color="#c2410c",
            width=220,  # 缩小宽度
            height=50,  # 缩小高度
            corner_radius=12
        )
        enter_btn.pack(pady=(0, 20))  # 减少下边距

    def _create_simple_navigation(self):
        """创建简化的导航栏（只显示logo和标题）"""
        for widget in self.button_container.winfo_children():
            widget.destroy()

        # 简单的标题
        simple_title = ctk.CTkLabel(
            self.button_container,
            text=t("function_selection"),
            font=("Microsoft YaHei", 14, "bold"),
            text_color=ACCENT_BLUE,
            justify="center"
        )
        simple_title.pack(pady=50)

    def show_ordering_functions(self):
        """显示订单功能界面"""
        # 设置标题
        self.function_title.configure(text=t("ordering_function_title"))
        self.function_subtitle.configure(
    text="請選擇您需要的訂單功能\nPlease select the ordering function you need")

        # 清空内容区
        for w in self.content_body.winfo_children():
            w.destroy()

        # 创建订单功能选择界面（显示功能按钮）
        self._create_ordering_function_buttons()

        # 创建订单功能导航（左侧显示功能列表）
        self._create_ordering_navigation()

    def show_monthend_functions(self):
        """显示月结功能界面"""
        # 设置标题
        self.function_title.configure(text=t("monthend_function_title"))
        self.function_subtitle.configure(text=t("monthend_related"))

        # 清空内容区
        for w in self.content_body.winfo_children():
            w.destroy()

        # 显示月结功能说明
        self._create_monthend_function_buttons()

        # 创建月结功能导航
        self._create_monthend_navigation()

    def show_data_analysis_functions(self):
        """显示数据分析功能"""
        # 清空内容区
        for w in self.content_body.winfo_children():
            w.destroy()
        self._create_data_analysis_function_buttons()
        self._create_data_analysis_navigation()

    def _create_data_analysis_function_buttons(self):
        """创建数据分析功能按钮"""
        # 标题
        title_label = ctk.CTkLabel(
            self.content_body,
            text="📈 數據分析功能 / Data Analysis Functions",
            font=("Microsoft YaHei", 24, "bold"),
            text_color=ACCENT_BLUE
        )
        title_label.pack(pady=(20, 30))

        # 功能按钮容器
        buttons_frame = ctk.CTkFrame(self.content_body, fg_color="transparent")
        buttons_frame.pack(fill="both", expand=True, padx=50)

        # 第一行按钮
        row1_frame = ctk.CTkFrame(buttons_frame, fg_color="transparent")
        row1_frame.pack(fill="x", pady=10)

        # POS 数据分析
        pos_btn = ctk.CTkButton(
            row1_frame,
            text="📊 POS 數據分析\nPOS Data Analysis",
            command=self._pos_data_analysis,
            font=("Microsoft YaHei", 16, "bold"),
            fg_color=ACCENT_BLUE,
            hover_color=BTN_HOVER,
            width=300,
            height=80,
            corner_radius=15
        )
        pos_btn.pack(side="left", padx=10)

        # 销售趋势分析
        trend_btn = ctk.CTkButton(
            row1_frame,
            text="📈 銷售趨勢分析\nSales Trend Analysis",
            command=self._sales_trend_analysis,
            font=("Microsoft YaHei", 16, "bold"),
            fg_color=ACCENT_GREEN,
            hover_color="#059669",
            width=300,
            height=80,
            corner_radius=15
        )
        trend_btn.pack(side="left", padx=10)

        # 第二行按钮
        row2_frame = ctk.CTkFrame(buttons_frame, fg_color="transparent")
        row2_frame.pack(fill="x", pady=10)

        # 成本效益分析
        cost_btn = ctk.CTkButton(
            row2_frame,
            text="💰 成本效益分析\nCost-Benefit Analysis",
            command=self._cost_benefit_analysis,
            font=("Microsoft YaHei", 16, "bold"),
            fg_color=ACCENT_PURPLE,
            hover_color="#7c3aed",
            width=300,
            height=80,
            corner_radius=15
        )
        cost_btn.pack(side="left", padx=10)

        # 报表生成工具
        report_btn = ctk.CTkButton(
            row2_frame,
            text="📋 報表生成工具\nReport Generation Tools",
            command=self._report_generation,
            font=("Microsoft YaHei", 16, "bold"),
            fg_color=ACCENT_RED,
            hover_color="#dc2626",
            width=300,
            height=80,
            corner_radius=15
        )
        report_btn.pack(side="left", padx=10)

    def _create_data_analysis_navigation(self):
        """创建数据分析导航"""
        nav_frame = ctk.CTkFrame(self.content_body, fg_color="transparent")
        nav_frame.pack(fill="x", pady=20)

        back_btn = ctk.CTkButton(
            nav_frame,
            text="← 返回主選單 / Back to Main Menu",
            command=self._show_main_menu,
            font=("Microsoft YaHei", 14, "bold"),
            fg_color="#64748b",
            hover_color="#475569",
            width=200,
            height=40,
            corner_radius=10
        )
        back_btn.pack(side="left")

    def _pos_data_analysis(self):
        """POS 数据分析功能"""
        try:
            import multiprocessing
            import pos_analysis_tool  # 确保该模块被打包并可直接调用

            # Windows/打包环境下，确保 freeze_support 可用（放这里也可放模块顶层）
            try:
                multiprocessing.freeze_support()
            except Exception:
                pass

            # 用子进程开启 pos_analysis_tool 的 GUI，避免在同一进程里开第二个 Tk mainloop
            p = multiprocessing.Process(
                target=pos_analysis_tool.main,  # 要求 pos_analysis_tool.py 里有 main()
                name="POSAnalysisTool"
            )
            p.daemon = False
            p.start()
            print("POS數據分析工具已啟動 (PID=", p.pid, ")")
        except Exception as e:
            from tkinter import messagebox
            messagebox.showerror("錯誤", f"啟動POS數據分析工具失敗：\n{e}")

    def _sales_trend_analysis(self):
        """销售趋势分析功能"""
        messagebox.showinfo("功能開發中", "銷售趨勢分析功能正在開發中...\nSales Trend Analysis feature is under development...")

    def _cost_benefit_analysis(self):
        """成本效益分析功能"""
        messagebox.showinfo("功能開發中", "成本效益分析功能正在開發中...\nCost-Benefit Analysis feature is under development...")

    def _report_generation(self):
        """报表生成工具功能"""
        messagebox.showinfo("功能開發中", "報表生成工具功能正在開發中...\nReport Generation Tools feature is under development...")

    def _create_ordering_function_buttons(self):
        """创建订单功能按钮界面（右侧内容区显示功能说明）"""
        # 主容器
        content_frame = ctk.CTkFrame(self.content_body, fg_color="transparent")
        content_frame.pack(fill="both", expand=True, padx=50, pady=50)

        # 功能说明文本 - 中英文对照
        description_text = (
            "訂單功能包含日常訂單處理的所有工具\n"
            "Ordering functions include all tools for daily order processing\n\n"
            "請從左側選擇您需要的功能：\n"
            "Please select the function you need from the left sidebar:\n\n"
            "📧 Outlook訂單下載\n    Outlook Order Download - 從郵件下載訂單文件\n\n"
            "🔄 訂單自動整合\n    Order Automation - 自動整理和合併訂單\n\n"
            "📋 每週訂單檢查表\n    Weekly Order Checklist - 生成每週訂單檢查清單\n\n"
            "📤 發送郵件\n    Send Emails - 發送處理完成的訂單\n\n"
            "📦 營運用品\n    Operation Supplies - 管理營運相關用品訂單"
        )

        description_label = ctk.CTkLabel(
            content_frame,
            text=description_text,
            font=("Microsoft YaHei", 14),
            text_color=TEXT_COLOR,
            justify="left"
        )
        description_label.pack(expand=True, pady=50)

    def _create_monthend_function_buttons(self):
        """创建月结功能按钮界面（右侧内容区显示功能说明）"""
        # 主容器
        content_frame = ctk.CTkFrame(self.content_body, fg_color="transparent")
        content_frame.pack(fill="both", expand=True, padx=50, pady=50)

        # 功能说明文本 - 中英文对照
        description_text = (
            "月結功能包含月度結算和報表相關工具\n"
            "Monthend functions include monthly closing and reporting tools\n\n"
            "可用功能：\n"
            "Available features:\n\n"
            "📥 月結文件下載\n    Month-end File Download - 從 Outlook 下載 SOA/Invoice 等月結文件\n\n"
            "即將推出的功能：\n"
            "Coming soon features:\n\n"
            "📊 月度銷售報表生成\n    Monthly Sales Report - 自動生成月度銷售分析報表\n\n"
            "📈 供應商對賬單處理\n    Supplier Statement Processing - 處理和核對供應商月度對賬單\n\n"
            "💰 成本分析與核算\n    Cost Analysis & Accounting - 進行月度成本分析和核算\n\n"
            "📋 庫存盤點整理\n    Inventory Count Organization - 月末庫存盤點數據整理\n\n"
            "🔄 自動化月結流程\n    Automated Month-end Process - 一鍵完成月結相關操作\n\n"
            "這些功能正在開發中，敬請期待！\n"
            "These features are under development, stay tuned!"
        )

        description_label = ctk.CTkLabel(
            content_frame,
            text=description_text,
            font=("Microsoft YaHei", 14),
            text_color=TEXT_COLOR,
            justify="left"
        )
        description_label.pack(expand=True, pady=50)

    def _create_ordering_navigation(self):
        """创建订单功能导航栏（左侧显示功能列表）"""
        for widget in self.button_container.winfo_children():
            widget.destroy()

        # 导航容器
        nav_container = ctk.CTkFrame(
    self.button_container,
     fg_color="transparent")
        nav_container.pack(fill="both", expand=True, pady=10)

        # 当前分类标题
        current_title = ctk.CTkLabel(
            nav_container,
            text=t("ordering_function_title"),
            font=("Microsoft YaHei", 14, "bold"),
            text_color="#3b82f6",
            justify="center"
        )
        current_title.pack(pady=(0, 20))

        # 订单功能列表 - 中英文对照
        ordering_functions = [
            (t("outlook_order_download"), "download_title",
             self.show_download_ui, "#3b82f6"),
            (t("order_automation"), "automation_title",
             self.show_automation_ui, "#10b981"),
            (t("weekly_order_checklist"), "checklist_title",
             self.show_checklist_ui, "#8b5cf6"),
            (t("send_emails"), "send_emails",
             self.show_email_sending_ui, "#ef4444"),
            (t("operation_supplies"), "operation_supplies",
             self.show_operation_supplies_ui, "#f97316")
        ]

        # 初始化按钮字典
        if not hasattr(self, 'nav_buttons'):
            self.nav_buttons = {}

        # 创建订单功能按钮
        self._create_ordering_button(
    nav_container,
    t("outlook_order_download"),
    "download_title",
    self.show_download_ui,
     "#3b82f6")
        self._create_ordering_button(
    nav_container,
    t("order_automation"),
    "automation_title",
    self.show_automation_ui,
     "#10b981")
        self._create_ordering_button(
    nav_container,
    t("weekly_order_checklist"),
    "checklist_title",
    self.show_checklist_ui,
     "#8b5cf6")
        self._create_ordering_button(
    nav_container,
    t("send_emails"),
    "send_emails",
    self.show_email_sending_ui,
     "#ef4444")
        self._create_ordering_button(
    nav_container,
    t("operation_supplies"),
    "operation_supplies",
    self.show_operation_supplies_ui,
     "#f97316")

        # 分隔线
        ctk.CTkFrame(
    nav_container,
    height=2,
    fg_color="#444444").pack(
        fill="x",
        padx=10,
         pady=15)

        # 切换到月结功能按钮
        switch_btn = ctk.CTkButton(
            nav_container,
            text=t("monthend_function_nav"),
            command=self.show_monthend_functions,
            fg_color="#ea580c",
            hover_color="#dc2626",
            font=("Microsoft YaHei", 13, "bold"),  # 从11增加到13
            text_color="white",
            width=220,
            height=45,
            corner_radius=8
        )
        switch_btn.pack(pady=5, padx=5, fill="x")

        # 返回主菜单按钮
        back_btn = ctk.CTkButton(
            nav_container,
            text=t("back_to_main"),
            command=self.show_main_menu,
            fg_color="#64748b",
            hover_color="#475569",
            font=("Microsoft YaHei", 13, "bold"),  # 从11增加到13
            text_color="white",
            width=220,
            height=40,
            corner_radius=8
        )
        back_btn.pack(pady=3, padx=5, fill="x")

        # 退出按钮
        exit_btn = ctk.CTkButton(
            nav_container,
            text=t("exit_system"),
            command=self._on_close,
            fg_color="#64748b",
            hover_color="#475569",
            font=("Microsoft YaHei", 12, "bold"),  # 从10增加到12，并添加bold
            text_color="white",
            width=220,
            height=35,
            corner_radius=8
        )
        exit_btn.pack(pady=(10, 0), padx=5, fill="x")

    def _create_ordering_button(self, parent, text, func_key, command, color):
        """创建订单功能按钮"""
        btn = ctk.CTkButton(
            parent,
            text=text,
            command=command,  # 直接使用命令，不需要包装
            fg_color=DARK_PANEL,
            hover_color=color,
            border_width=2,
            border_color=color,
            font=("Microsoft YaHei", 13, "bold"),  # 从10增加到13
            text_color=TEXT_COLOR,
            width=220,
            height=50,
            corner_radius=8
        )
        btn.pack(pady=4, padx=5, fill="x")
        self.nav_buttons[func_key] = btn

    def _create_monthend_navigation(self):
        """创建月结功能导航栏（左侧显示功能列表）"""
        for widget in self.button_container.winfo_children():
            widget.destroy()

        # 导航容器
        nav_container = ctk.CTkFrame(
    self.button_container,
     fg_color="transparent")
        nav_container.pack(fill="both", expand=True, pady=10)

        # 当前分类标题（與訂單功能一致的樣式）
        current_title = ctk.CTkLabel(
            nav_container,
            text=t("month_end_function"),
            font=("Microsoft YaHei", 14, "bold"),
            text_color=ACCENT_BLUE,
            justify="center"
        )
        current_title.pack(pady=(0, 10))

        # 月結功能列表（包含已啟用與預告）
        monthend_functions = [
            (t("monthend_download"), "monthend_download",
             self.show_monthend_download_ui, "#3b82f6", True),  # 蓝色
            (t("monthly_order_summary"), "monthly_order_summary",
             self.show_monthend_monthly_summary_ui, "#10b981", True),  # 绿色
            (t("supplier_statement"), "supplier_statement",
             self.show_monthend_placeholder, "#dc2626", True),  # 深红色，设置为可用
            (t("monthly_sales_report"), "monthly_sales_report",
             self.show_monthend_placeholder, "#ef4444", False),  # 红色
            (t("cost_analysis"), "cost_analysis",
             self.show_monthend_placeholder, "#b91c1c", False),  # 暗红色
            (t("inventory_count"), "inventory_count",
             self.show_monthend_placeholder, "#991b1b", False),  # 更暗红色
        ]

        for text, func_key, command, color, is_active in monthend_functions:
            if is_active:
                # 已启用的功能 - 使用深色背景 + 彩色边框
                if func_key == "supplier_statement":
                    # 供应商对账单功能需要特殊处理
                    btn = NavigationButton(
                        nav_container,
                        text=text,
                        command=lambda fk=func_key: self._select_monthend_function(
                            fk),
                        fg_color=DARK_PANEL,  # 深色背景
                        anchor="center",
                        border_width=2,       # 2像素边框
                        border_color="#8b5cf6",  # 紫色边框，不使用红色
                        corner_radius=10,
                        font=FONT_BIGBTN,
                        text_color=get_contrast_color(DARK_PANEL),  # 自动计算文字颜色
                        height=45
                    )
                else:
                    btn = NavigationButton(
                        nav_container,
                        text=text,
                        command=lambda c=command: c(),
                        fg_color=DARK_PANEL,  # 深色背景
                        anchor="center",
                        border_width=2,       # 2像素边框
                        border_color=color,   # 彩色边框
                        corner_radius=10,
                        font=FONT_BIGBTN,
                        text_color=get_contrast_color(DARK_PANEL),  # 自动计算文字颜色
                        height=45
                    )
            else:
                # 未开放的功能 - 使用深色背景 + 红色边框
                btn = NavigationButton(
                    nav_container,
                    text=f"{text}\n{t('coming_soon')}",
                    command=lambda c=command: c(),
                    fg_color=DARK_PANEL,  # 深色背景
                    anchor="center",
                    border_width=2,       # 2像素边框
                    border_color="#dc2626",  # 红色边框
                    corner_radius=10,
                    font=FONT_BIGBTN,
                    text_color=get_contrast_color(DARK_PANEL),  # 自动计算文字颜色
                height=45
            )
            btn.pack(fill="x", pady=4, padx=10)

        # 分隔线
        ctk.CTkFrame(
    nav_container,
    height=2,
    fg_color="#444444").pack(
        fill="x",
        padx=10,
         pady=15)

        # 切换到订单功能按钮
        switch_btn = ctk.CTkButton(
            nav_container,
            text=t("ordering_function_title"),
            command=self.show_ordering_functions,
            fg_color="#3b82f6",
            hover_color="#1d4ed8",
            font=("Microsoft YaHei", 13, "bold"),  # 从11增加到13
            text_color="white",
            width=220,
            height=45,
            corner_radius=8
        )
        switch_btn.pack(pady=5, padx=5, fill="x")

        # 返回主菜单按钮
        back_btn = ctk.CTkButton(
            nav_container,
            text=t("back_to_main"),
            command=self.show_main_menu,
            fg_color="#64748b",
            hover_color="#475569",
            font=("Microsoft YaHei", 13, "bold"),  # 从11增加到13
            text_color="white",
            width=220,
            height=40,
            corner_radius=8
        )
        back_btn.pack(pady=3, padx=5, fill="x")

        # 退出按钮
        exit_btn = ctk.CTkButton(
            nav_container,
            text=t("exit_system"),
            command=self._on_close,
            fg_color="#64748b",
            hover_color="#475569",
            font=("Microsoft YaHei", 13, "bold"),  # 从10增加到12，并添加bold
            text_color="white",
            width=220,
            height=35,
            corner_radius=8
        )
        exit_btn.pack(pady=(10, 0), padx=5, fill="x")

    def _select_monthend_function(self, func_key):
        """选择月结功能"""
        if func_key == "supplier_statement":
            # 设置当前功能并显示厂商选择界面
            self.current_function = func_key
            self.show_supplier_selection_ui()
        else:
            # 其他功能使用默认处理
            pass

    def _select_demerit_file(self):
        """选择扣分文件"""
        from tkinter import filedialog
        f = filedialog.askopenfilename(
            title="选择扣分文件 / Select Demerit File",
            filetypes=[("Excel files", "*.xlsx"), ("All files", "*.*")]
        )
        if f:
            self.demerit_file_var.set(f)

    def _run_auto_f5_deduction(self):
        """自动扣分：检查周三12点后的订单"""
        from datetime import datetime, timedelta
        import os
        from tkinter import messagebox
        import pandas as pd
        
        # 检查扣分文件
        demerit_file = self.demerit_file_var.get()
        if not demerit_file:
            messagebox.showwarning("警告", "请先选择扣分文件！")
            return
        
        folder = self.download_folder_var.get()
        if not folder:
            messagebox.showwarning("警告", "请先选择下载文件夹！")
            return
        
        # 检查邮件日志文件 - 智能查找所有可能的文件夹
        today = datetime.now()
        week_no = today.isocalendar()[1]
        possible_paths = []
        
        # 方法1：检查月份-Week格式的文件夹
        for week_offset in range(0, 4):  # 检查当前周和前3周
            check_week = week_no - week_offset
            # 计算对应日期的月份和星期
            check_date = today - timedelta(weeks=week_offset)
            month_name = check_date.strftime('%b').title()  # 确保首字母大写，例如: Aug, Sep
            week_of_month = get_week_of_month(check_date)
            check_path = os.path.join(folder, f"{month_name} - Week {week_of_month}")
            if os.path.exists(check_path):
                possible_paths.append(check_path)
        
        # 方法2：检查Weekly Order/Aug格式的文件夹
        aug_path = os.path.join(folder, "Weekly Order", "Aug")
        if os.path.exists(aug_path):
            possible_paths.append(aug_path)
        
        # 方法3：检查直接在当前文件夹下的邮件日志
        if os.path.exists(os.path.join(folder, "email_bodies_log.txt")):
            possible_paths.append(folder)
        
        # 如果没找到，使用当前周数
        if not possible_paths:
            month_name = today.strftime('%b').title()
            week_of_month = get_week_of_month(today)
            save_path = os.path.join(folder, f"{month_name} - Week {week_of_month}")
            possible_paths = [save_path]
        
        # 查找包含邮件日志的文件夹
        log_file = None
        for path in possible_paths:
            temp_log = os.path.join(path, "email_bodies_log.txt")
            if os.path.exists(temp_log):
                log_file = temp_log
                break
        
        if not log_file:
            # 显示调试信息
            debug_info = f"在以下路径中未找到email_bodies_log.txt：\n"
            for path in possible_paths:
                debug_info += f"- {path}\n"
            debug_info += f"\n请确认邮件日志文件存在！"
            messagebox.showinfo("信息", debug_info)
            return
        
        # 显示找到的日志文件路径（调试信息）
        print(f"[DEBUG] 找到邮件日志文件: {log_file}")
        messagebox.showinfo("调试信息", f"找到邮件日志文件:\n{log_file}")
        
        try:
            # 读取扣分文件，获取已扣分的记录
            demerit_df = pd.read_excel(demerit_file, sheet_name=None)
            outlet_sheets = [sheet for sheet in demerit_df.keys() if sheet not in 
                           ["Point Deduction Overview", "OPS Demerit Point Scoring", "Data - DO NOT EDIT", "Demerit System"]]
            
            # 检查所有门市的已扣分记录
            existing_deductions = set()
            for sheet_name in outlet_sheets:
                if sheet_name in demerit_df:
                    df = demerit_df[sheet_name]
                    if len(df.columns) >= 3:  # 确保有足够的列
                        # 检查Category和Description列
                        for _, row in df.iterrows():
                            if pd.notna(row.iloc[1]) and pd.notna(row.iloc[2]):  # B列和C列
                                category = str(row.iloc[1]).strip()
                                description = str(row.iloc[2]).strip()
                                if category and description:
                                    existing_deductions.add(f"{category}: {description}")
            
            # 读取邮件日志，检查周三12点后的订单
            late_orders = []
            try:
                with open(log_file, "r", encoding="utf-8") as f:
                    content = f.read()
                
                print(f"[DEBUG] 邮件日志内容长度: {len(content)} 字符")
                print(f"[DEBUG] 邮件日志前200字符: {content[:200]}")
                
                # 解析邮件内容
                email_blocks = content.split("——— 邮件")
                # print(f"[DEBUG] 找到 {len(email_blocks)} 个邮件块")
                
                for i, block in enumerate(email_blocks[1:], 1):  # 跳过第一个空块
                    lines = block.strip().splitlines()
                    if len(lines) < 3:
                        continue
                    
                    # 提取邮件时间、主题和发件人
                    subject_line = ""
                    sender_line = ""
                    email_time = None
                    
                    for line in lines:
                        if line.startswith("[主题]"):
                            subject_line = line
                        elif line.startswith("[发件人]"):
                            sender_line = line
                        elif line.startswith("[时间]") or line.startswith("[发送时间]"):
                            # 尝试解析邮件时间
                            try:
                                # 修复：提取完整的时间字符串，包括日期
                                time_str = line.replace("[时间]", "").replace("[发送时间]", "").strip()
                                print(f"[DEBUG] 邮件{i} 时间字符串: '{time_str}'")
                                
                                # 支持多种时间格式
                                for fmt in ["%Y-%m-%d %H:%M:%S", "%Y-%m-%d %H:%M", "%Y-%m-%d", "%d/%m/%Y %H:%M"]:
                                    try:
                                        email_time = datetime.strptime(time_str, fmt)
                                        # print(f"[DEBUG] 邮件{i} 解析成功: {email_time} (格式: {fmt})")
                                        break
                                    except:
                                        continue
                                
                                if not email_time:
                                    print(f"[DEBUG] 邮件{i} 时间解析失败: '{time_str}'")
                            except Exception as e:
                                print(f"[DEBUG] 邮件{i} 时间解析异常: {e}")
                    
                    # 检查邮件时间是否在周三12点后
                    if email_time:
                        # 计算邮件发送时间是否在周三12点后
                        email_weekday = email_time.weekday()  # 0=Monday, 2=Wednesday
                        email_hour = email_time.hour
                        
                        # 检查是否应该排除此邮件（使用与 Weekly Order Downloader 相同的排除逻辑）
                        should_exclude = False
                        if subject_line:
                            subject_lower = subject_line.lower()
                            
                            # 定义排除关键字（与 Weekly Order Downloader 保持一致）
                            exclude_keywords = [
                                'amendment', 'amend', 'ament', 'admentmend', 'adment', 'amendmend', 'amendement',
                                'assets', 'uniform', 'asset', 'uniforms', 'request form', 'outlet assets &', 'outlet assets and',
                                'uniform request', 'assets request', 'assets & uniform', 'assets and uniform',
                                'invoice', 'payment', 'receipt', 'confirmation', 'delivery note',
                                'siahuat', 'siah', 'uat', '思華達', 'siah uat',
                                'monthly', 'month', '月', '月度'
                            ]
                            
                            # 检查主旨是否包含排除关键字
                            has_exclude_keywords = any(keyword in subject_lower for keyword in exclude_keywords)
                            if has_exclude_keywords:
                                should_exclude = True
                                print(f"[DEBUG] 邮件{i} 被排除: 包含排除关键字")
                        
                        if should_exclude:
                            continue  # 跳过这个邮件
                        
                        # 构建完整的订单信息，包含发件人
                        order_info = f"邮件时间: {email_time.strftime('%Y-%m-%d %H:%M')} - {subject_line}"
                        if sender_line:
                            order_info += f" - {sender_line}"
                        
                        if email_weekday == 2 and email_hour >= 12:  # 周三且12点后
                            # 检查是否已经扣过分
                            deduction_key = "Order Lateness: 周三12点后提交订单"
                            if deduction_key not in existing_deductions:
                                late_orders.append(order_info)
                            else:
                                late_orders.append(order_info + " (已扣分)")
                        elif email_weekday == 3:  # 周四的订单
                            print(f"[DEBUG] 邮件{i} 符合条件: 周四")
                            # 检查是否已经扣过分
                            deduction_key = "Order Lateness: 周三12点后提交订单"
                            if deduction_key not in existing_deductions:
                                late_orders.append(order_info)
                            else:
                                late_orders.append(order_info + " (已扣分)")
                        elif email_weekday == 4:  # 周五的订单
                            print(f"[DEBUG] 邮件{i} 符合条件: 周五")
                            # 检查是否已经扣过分
                            deduction_key = "Order Lateness: 周三12点后提交订单"
                            if deduction_key not in existing_deductions:
                                late_orders.append(order_info)
                            else:
                                late_orders.append(order_info + " (已扣分)")
                        elif email_weekday == 5:  # 周六的订单
                            print(f"[DEBUG] 邮件{i} 符合条件: 周六")
                            # 检查是否已经扣过分
                            deduction_key = "Order Lateness: 周三12点后提交订单"
                            if deduction_key not in existing_deductions:
                                late_orders.append(order_info)
                            else:
                                late_orders.append(order_info + " (已扣分)")
                        # 注意：周日(6)、周一(0)、周二(1)的订单不算迟交，因为是新的一周
                        # 只有周三12点后、周四、周五、周六的订单才算迟交
                    
                    # 如果没有时间信息，检查主题中是否包含相关关键词
                    elif not email_time and ("周三" in subject_line or "wednesday" in subject_line.lower() or 
                                           "周四" in subject_line or "thursday" in subject_line.lower() or
                                           "周五" in subject_line or "friday" in subject_line.lower()):
                        
                        # 检查是否应该排除此邮件（使用与 Weekly Order Downloader 相同的排除逻辑）
                        should_exclude = False
                        if subject_line:
                            subject_lower = subject_line.lower()
                            
                            # 定义排除关键字（与 Weekly Order Downloader 保持一致）
                            exclude_keywords = [
                                'amendment', 'amend', 'ament', 'admentmend', 'adment', 'amendmend', 'amendement',
                                'assets', 'uniform', 'asset', 'uniforms', 'request form', 'outlet assets &', 'outlet assets and',
                                'uniform request', 'assets request', 'assets & uniform', 'assets and uniform',
                                'invoice', 'payment', 'receipt', 'confirmation', 'delivery note',
                                'siahuat', 'siah', 'uat', '思華達', 'siah uat',
                                'monthly', 'month', '月', '月度'
                            ]
                            
                            # 检查主旨是否包含排除关键字
                            has_exclude_keywords = any(keyword in subject_lower for keyword in exclude_keywords)
                            if has_exclude_keywords:
                                should_exclude = True
                                print(f"[DEBUG] 邮件{i} 被排除(无时间): 包含排除关键字")
                        
                        if should_exclude:
                            continue  # 跳过这个邮件
                        
                        # 构建订单信息，包含发件人
                        order_info = f"邮件主题(无时间): {subject_line}"
                        if sender_line:
                            order_info += f" - {sender_line}"
                        
                        # 检查是否已经扣过分
                        deduction_key = "Order Lateness: 周三12点后提交订单"
                        if deduction_key not in existing_deductions:
                            late_orders.append(order_info)
                        else:
                            late_orders.append(order_info + " (已扣分)")
            
            except Exception as e:
                messagebox.showerror("错误", f"读取邮件日志失败: {e}")
                return
            
            print(f"[DEBUG] 最终找到的迟交订单数量: {len(late_orders)}")
            for order in late_orders:
                print(f"[DEBUG] 迟交订单: {order}")
            
            # 显示结果并直接显示扣分确认界面
            if late_orders:
                # 统计需要扣分的数量
                need_deduction = [order for order in late_orders if "(已扣分)" not in order]
                if need_deduction:
                    # 直接显示扣分确认界面，不显示中间的信息框
                    self._show_deduction_confirmation_ui(need_deduction, demerit_file, outlet_sheets)
                else:
                    messagebox.showinfo("扣分检查", "所有订单都已扣分。")
            else:
                messagebox.showinfo("扣分检查", "未发现周三12点后的迟交订单。")
                
        except Exception as e:
            messagebox.showerror("错误", f"读取扣分文件失败: {e}")
            return
    
    def _show_deduction_confirmation_ui(self, need_deduction, demerit_file, outlet_sheets):
        """显示扣分确认界面 - 让用户选择要扣分的订单和输入录入人"""
        import tkinter as tk
        from tkinter import messagebox
        from datetime import datetime
        import openpyxl
        
        # 创建扣分确认窗口
        confirmation_window = tk.Toplevel(self)
        confirmation_window.title("扣分确认 / Deduction Confirmation")
        confirmation_window.geometry("1300x900")  # 增加窗口大小
        confirmation_window.configure(bg="#1e293b")  # 使用与主程序相同的深色背景
        
        # 居中显示窗口
        confirmation_window.update_idletasks()
        x = (confirmation_window.winfo_screenwidth() // 2) - (800 // 2)
        y = (confirmation_window.winfo_screenheight() // 2) - (1000 // 2)
        confirmation_window.geometry(f"1300x1000+{x}+{y}")
        
        # 主容器
        main_container = tk.Frame(confirmation_window, bg="#1e293b")
        main_container.pack(expand=True, fill="both", padx=50, pady=40)  # 增加边距
        
        # 标题 - 使用渐变效果
        title_frame = tk.Frame(main_container, bg="#1e293b")
        title_frame.pack(fill="x", pady=(0, 30))
        
        title_label = tk.Label(
            title_frame,
            text="扣分确认 / Deduction Confirmation",
            font=("Microsoft YaHei", 22, "bold"),  # 增大字体
            bg="#1e293b",
            fg="#60a5fa"  # 使用蓝色突出标题
        )
        title_label.pack()
        
        # 副标题
        subtitle_label = tk.Label(
            title_frame,
            text="请选择需要扣分的订单并输入录入人信息",
            font=("Microsoft YaHei", 12),
            bg="#1e293b",
            fg="#94a3b8"
        )
        subtitle_label.pack(pady=(5, 0))
        
        # 录入人输入框 - 美化设计
        entry_person_frame = tk.Frame(main_container, bg="#1e293b")
        entry_person_frame.pack(fill="x", pady=(0, 25))
        
        # 录入人标签
        entry_label = tk.Label(
            entry_person_frame,
            text="录入人 / Entry Person:",
            font=("Microsoft YaHei", 16, "bold"),  # 增大字体
            bg="#1e293b",
            fg="#fbbf24"  # 使用黄色突出
        )
        entry_label.pack(anchor="w", pady=(0, 8))
        
        # 录入人输入框容器
        entry_input_frame = tk.Frame(entry_person_frame, bg="#1e293b")
        entry_input_frame.pack(fill="x")
        
        entry_person_var = tk.StringVar()
        entry_person_entry = tk.Entry(
            entry_input_frame,
            textvariable=entry_person_var,
            font=("Microsoft YaHei", 14),  # 增大字体
            bg="#475569",  # 更深的背景色
            fg="#f8fafc",  # 更亮的文字色
            insertbackground="#fbbf24",  # 光标颜色
            width=45,  # 增加宽度
            relief="flat",  # 扁平化设计
            bd=0  # 无边框
        )
        entry_person_entry.pack(side="left", pady=(0, 0))
        
        # 输入框提示
        entry_hint = tk.Label(
            entry_input_frame,
            text="请输入您的姓名或员工ID",
            font=("Microsoft YaHei", 10),
            bg="#1e293b",
            fg="#64748b"
        )
        entry_hint.pack(side="left", padx=(10, 0), pady=(0, 0))
        
        # 订单选择说明 - 美化设计
        instruction_frame = tk.Frame(main_container, bg="#1e293b")
        instruction_frame.pack(fill="x", pady=(0, 15))
        
        instruction_label = tk.Label(
            instruction_frame,
            text="请选择需要扣分的订单（勾选表示要扣分）：",
            font=("Microsoft YaHei", 14, "bold"),  # 增大字体
            bg="#1e293b",
            fg="#10b981"  # 使用绿色突出
        )
        instruction_label.pack(anchor="w")
        
        # 订单数量显示
        order_count_label = tk.Label(
            instruction_frame,
            text=f"共发现 {len(need_deduction)} 个迟交订单",
            font=("Microsoft YaHei", 11),
            bg="#1e293b",
            fg="#94a3b8"
        )
        order_count_label.pack(anchor="w", pady=(3, 0))
        
        # 创建滚动框架来容纳订单列表 - 美化设计
        list_container = tk.Frame(main_container, bg="#1e293b")
        list_container.pack(fill="both", expand=True, pady=(0, 20))
        
        # 列表标题栏
        list_header = tk.Frame(list_container, bg="#334155", relief="flat")
        list_header.pack(fill="x", pady=(0, 5))
        
        # 标题栏标签
        tk.Label(
            list_header,
            text="订单列表 / Order List",
            font=("Microsoft YaHei", 12, "bold"),
            bg="#334155",
            fg="#f8fafc"
        ).pack(side="left", padx=15, pady=8)
        
        # 滚动区域
        canvas = tk.Canvas(list_container, bg="#1e293b", highlightthickness=0, height=400)
        scrollbar = tk.Scrollbar(list_container, orient="vertical", command=canvas.yview)
        scrollable_frame = tk.Frame(canvas, bg="#1e293b")
        
        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        # 绑定鼠标滚轮事件，修复滚动问题
        def _on_mousewheel(event):
            canvas.yview_scroll(int(-1*(event.delta/120)), "units")
        
        # 绑定滚轮事件到画布
        canvas.bind("<MouseWheel>", _on_mousewheel)
        
        # 绑定滚轮事件到滚动框架
        scrollable_frame.bind("<MouseWheel>", _on_mousewheel)
        
        # 绑定滚轮事件到所有子组件
        def bind_mousewheel_to_children(widget):
            widget.bind("<MouseWheel>", _on_mousewheel)
            for child in widget.winfo_children():
                bind_mousewheel_to_children(child)
        
        bind_mousewheel_to_children(scrollable_frame)
        
        # 订单选择变量
        order_vars = {}
        
        # 从配置文件读取门市映射的函数（用于UI显示）
        def get_outlet_from_order(order_text):
            """从订单文本中提取门市名称，优先根据发件人识别"""
            try:
                # 获取配置文件路径
                config_file = self.config_file_var.get()
                print(f"[DEBUG] 配置文件路径: {config_file}")
                
                if config_file and os.path.exists(config_file):
                    print(f"[DEBUG] 配置文件存在，开始读取...")
                    import pandas as pd
                    # 读取OUTLET工作表
                    df = pd.read_excel(config_file, sheet_name="OUTLET")
                    print(f"[DEBUG] 成功读取OUTLET工作表，共{len(df)}行")
                    
                    # 构建门市映射字典 - 使用有序字典保持优先级
                    from collections import OrderedDict
                    outlet_mapping = OrderedDict()
                    
                    # 第一轮：添加完整名称（最高优先级）
                    for _, row in df.iterrows():
                        short_name = str(row['Short Name']).strip().upper()
                        full_name = str(row['Outlet Full Name']).strip().lower()
                        email_name = str(row['Name in Email']).strip().lower()
                        
                        print(f"[DEBUG] 行数据: Short='{short_name}', Full='{full_name}', Email='{email_name}'")
                        
                        # 只添加有效的完整名称，直接使用Short Name作为值
                        if short_name and short_name != 'nan':
                            if full_name and full_name != 'nan':
                                outlet_mapping[full_name] = short_name
                            if email_name and email_name != 'nan':
                                outlet_mapping[email_name] = short_name
                    
                    # 第二轮：添加单词变体（较低优先级）
                    for _, row in df.iterrows():
                        short_name = str(row['Short Name']).strip().upper()
                        full_name = str(row['Outlet Full Name']).strip().lower()
                        
                        if short_name and short_name != 'nan' and full_name and full_name != 'nan':
                            # 只对完整的门市名称添加单词变体
                            if ' ' in full_name:
                                words = full_name.split()
                                for word in words:
                                    if len(word) >= 3:  # 只添加长度>=3的单词，避免通用词
                                        # 检查这个单词是否已经被更具体的名称使用
                                        if word not in outlet_mapping:
                                            outlet_mapping[word] = short_name
                    
                    # 不再使用硬编码的别名映射，完全依赖配置文件
                    
                    print(f"[DEBUG] 构建的门市映射: {outlet_mapping}")
                    
                    # 优先尝试从发件人识别门市
                    if "[发件人]" in order_text:
                        sender_part = order_text.split("[发件人]")[1].strip()
                        print(f"[DEBUG] 发件人: '{sender_part}'")
                        
                        # 尝试匹配发件人 - 优先匹配更长的名称
                        sender_lower = sender_part.lower()
                        best_match = None
                        best_match_length = 0
                        
                        for key, value in outlet_mapping.items():
                            if key in sender_lower and key != 'nan':
                                if len(key) > best_match_length:
                                    best_match = (key, value)
                                    best_match_length = len(key)
                        
                        if best_match:
                            key, value = best_match
                            print(f"[DEBUG] 发件人匹配成功: '{key}' -> '{value}' (长度: {len(key)})")
                            return value
                    
                    # 如果发件人匹配失败，尝试从主题识别
                    if "[主题]" in order_text:
                        # 处理新格式：提取主题但排除发件人部分
                        if " - [发件人]" in order_text:
                            subject = order_text.split("[主题]")[1].split(" - [发件人]")[0].strip()
                        else:
                            subject = order_text.split("[主题]")[1].strip()
                        
                        print(f"[DEBUG] 主题: '{subject}'")
                        
                        # 将主题转换为小写进行匹配
                        subject_lower = subject.lower()
                        
                        # 尝试匹配门市名称 - 优先匹配更长的名称
                        best_match = None
                        best_match_length = 0
                        
                        for key, value in outlet_mapping.items():
                            if key in subject_lower and key != 'nan':
                                if len(key) > best_match_length:
                                    best_match = (key, value)
                                    best_match_length = len(key)
                        
                        if best_match:
                            key, value = best_match
                            print(f"[DEBUG] 主题匹配成功: '{key}' -> '{value}' (长度: {len(key)})")
                            return value
                
            except Exception as e:
                print(f"[错误] 读取配置文件失败: {e}")
                import traceback
                traceback.print_exc()
            
            # 如果都匹配失败，尝试从发件人提取标识符
            print(f"[DEBUG] 使用备用方案，从发件人提取标识符")
            if "[发件人]" in order_text:
                sender_part = order_text.split("[发件人]")[1].strip()
                print(f"[DEBUG] 备用方案 - 发件人: '{sender_part}'")
                
                # 尝试从发件人名称中提取标识符
                # 移除常见的后缀如 "SMRT", "Mall", "Centre" 等
                sender_clean = sender_part.lower()
                common_suffixes = [' smrt', ' mall', ' centre', ' center', ' plaza', ' point', ' gogo']
                for suffix in common_suffixes:
                    if sender_clean.endswith(suffix):
                        sender_clean = sender_clean[:-len(suffix)].strip()
                        break
                
                # 提取前几个单词的首字母或使用已知映射
                words = sender_clean.split()
                if len(words) >= 2:
                    # 对于多词名称，尝试提取首字母
                    result = ''.join([word[0].upper() for word in words[:2]])
                    print(f"[DEBUG] 备用结果（首字母）: '{result}'")
                    return result
                elif len(words) == 1:
                    # 对于单词名称，使用前3个字符
                    result = words[0][:3].upper()
                    print(f"[DEBUG] 备用结果（前3字符）: '{result}'")
                    return result
            
            # 最后的备用方案：从主题提取
            if "[主题]" in order_text:
                # 处理新格式：提取主题但排除发件人部分
                if " - [发件人]" in order_text:
                    subject = order_text.split("[主题]")[1].split(" - [发件人]")[0].strip()
                else:
                    subject = order_text.split("[主题]")[1].strip()
                
                # 尝试提取门市代码（通常在开头）
                words = subject.split()
                if words:
                    # 查找包含门市代码的单词（通常是第一个或第二个单词）
                    for word in words[:2]:  # 只检查前两个单词
                        clean_word = word.strip('-_').upper()
                        if len(clean_word) >= 2 and len(clean_word) <= 4:  # 门市代码通常是2-4个字符
                            print(f"[DEBUG] 备用结果（主题）: '{clean_word}'")
                            return clean_word
            
            return "UNKNOWN"
        
        # 添加订单选择框 - 美化设计
        for i, order in enumerate(need_deduction):
            # 交替行颜色
            row_color = "#1e293b" if i % 2 == 0 else "#334155"
            
            order_frame = tk.Frame(scrollable_frame, bg=row_color, relief="flat")
            order_frame.pack(fill="x", pady=1)
            
            # 复选框 - 美化
            var = tk.BooleanVar(value=True)  # 默认全部选中
            order_vars[order] = var
            
            checkbox = tk.Checkbutton(
                order_frame,
                variable=var,
                bg=row_color,
                fg="#ffffff",
                selectcolor=row_color,  # 选中时使用行背景色
                activebackground=row_color,
                activeforeground="#ffffff",
                font=("Arial", 14, "bold"),  # 使用Arial字体显示勾选标记
                relief="flat",
                bd=0,
                indicatoron=True,
                cursor="hand2",
                highlightthickness=0  # 移除焦点高亮
            )
            checkbox.pack(side="left", padx=(15, 12), pady=4)  # 适中的边距
            
            # 添加选中状态的视觉反馈
            def update_checkbox_style():
                # 保持简洁，只改变背景色
                checkbox.config(
                    bg=row_color,  # 始终使用行背景色
                    selectcolor=row_color,  # 选中指示器也使用行背景色
                    activebackground=row_color  # 激活时也使用行背景色
                )
            
            # 绑定变量变化事件
            var.trace("w", lambda *args: update_checkbox_style())
            # 初始化样式
            update_checkbox_style()
            
            # 订单信息标签 - 美化
            order_label = tk.Label(
                order_frame,
                text=order,
                font=("Microsoft YaHei", 11),
                bg=row_color,
                fg="#f8fafc",
                anchor="w",
                justify="left"
            )
            order_label.pack(side="left", fill="x", expand=True, padx=(0, 10), pady=8)
            
            # 门市名称标签 - 显示在右侧
            outlet_name = get_outlet_from_order(order)
            outlet_label = tk.Label(
                order_frame,
                text=f"[{outlet_name}]",
                font=("Microsoft YaHei", 11, "bold"),
                bg=row_color,
                fg="#10b981",  # 绿色显示门市名称
                anchor="e",
                justify="right"
            )
            outlet_label.pack(side="right", padx=(0, 15), pady=8)
        
        # 放置滚动组件
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
        
        # 按钮框架 - 美化设计
        button_frame = tk.Frame(main_container, bg="#1e293b")
        button_frame.pack(fill="x", pady=(25, 0))
        
        # 左侧按钮组
        left_buttons = tk.Frame(button_frame, bg="#1e293b")
        left_buttons.pack(side="left")
        
        # 全选/取消全选按钮 - 美化
        select_all_var = tk.BooleanVar(value=True)
        
        def toggle_select_all():
            select_all = select_all_var.get()
            for var in order_vars.values():
                var.set(select_all)
            select_all_var.set(not select_all)
            # 更新按钮文本
            if select_all:
                select_all_btn.config(text="取消全选 / Deselect All")
            else:
                select_all_btn.config(text="全选 / Select All")
        
        select_all_btn = tk.Button(
            left_buttons,
            text="取消全选 / Deselect All",  # 初始状态为全选，所以显示取消全选
            command=toggle_select_all,
            font=("Microsoft YaHei", 12, "bold"),
            bg="#6366f1",  # 使用靛蓝色
            fg="white",
            padx=25,
            pady=10,
            relief="raised",  # 改为凸起效果
            bd=3,  # 增加边框宽度
            cursor="hand2",  # 鼠标悬停时显示手型
            activebackground="#4f46e5",  # 点击时的颜色
            activeforeground="white"  # 点击时的文字颜色
        )
        select_all_btn.pack(side="left", padx=(0, 15))
        
        # 确认扣分按钮
        def confirm_deduction():
            # 获取录入人
            entry_person = entry_person_var.get().strip()
            if not entry_person:
                messagebox.showwarning("警告", "请输入录入人信息！")
                return
            
            # 获取选中的订单
            selected_orders = [order for order, var in order_vars.items() if var.get()]
            if not selected_orders:
                messagebox.showwarning("警告", "请至少选择一个订单进行扣分！")
                return
            
            # 执行扣分
            try:
                wb = openpyxl.load_workbook(demerit_file)
                deduction_count = 0
                
                # 本地门市提取函数
                def extract_outlet_from_subject(subject_or_sender):
                    """从邮件主题或发件人中提取门市名称，使用配置文件映射"""
                    try:
                        # 获取配置文件路径
                        config_file = self.config_file_var.get()
                        if config_file and os.path.exists(config_file):
                            import pandas as pd
                            # 读取OUTLET工作表
                            df = pd.read_excel(config_file, sheet_name="OUTLET")
                            
                            # 构建门市映射字典 - 使用有序字典保持优先级
                            from collections import OrderedDict
                            outlet_mapping = OrderedDict()
                            
                            # 第一轮：添加完整名称（最高优先级）
                            for _, row in df.iterrows():
                                short_name = str(row['Short Name']).strip().upper()
                                full_name = str(row['Outlet Full Name']).strip().lower()
                                email_name = str(row['Name in Email']).strip().lower()
                                
                                # 只添加有效的完整名称，直接使用Short Name作为值
                                if short_name and short_name != 'nan':
                                    if full_name and full_name != 'nan':
                                        outlet_mapping[full_name] = short_name
                                    if email_name and email_name != 'nan':
                                        outlet_mapping[email_name] = short_name
                            
                            # 第二轮：添加单词变体（较低优先级）
                            for _, row in df.iterrows():
                                short_name = str(row['Short Name']).strip().upper()
                                full_name = str(row['Outlet Full Name']).strip().lower()
                                
                                if short_name and short_name != 'nan' and full_name and full_name != 'nan':
                                    # 只对完整的门市名称添加单词变体
                                    if ' ' in full_name:
                                        words = full_name.split()
                                        for word in words:
                                            if len(word) >= 3:  # 只添加长度>=3的单词，避免通用词
                                                # 检查这个单词是否已经被更具体的名称使用
                                                if word not in outlet_mapping:
                                                    outlet_mapping[word] = short_name
                            
                            # 第三轮：添加一些常见的别名映射
                            common_aliases = {
                                'poiz centre': 'TPC',
                                'poiz': 'TPC',
                                'junction 8': 'J8',
                                'j8': 'J8',
                                'paya lebar quarter': 'PLQ',
                                'paya': 'PLQ',
                                'woodlands': 'WL',
                                'woodland': 'WL',
                                'west mall': 'WSM',
                                'west': 'WSM',
                                'toa payoh': 'TPY',
                                'toa': 'TPY',
                                'oasis gogo': 'OAS',
                                'oasis': 'OAS',
                                'canberra plaza': 'CBP',
                                'canberra': 'CBP',
                                'grantral mall': 'GTM',
                                'grantral': 'GTM'
                            }
                            
                            # 添加别名映射，但不要覆盖已有的映射
                            for alias, short_code in common_aliases.items():
                                if alias not in outlet_mapping:
                                    outlet_mapping[alias] = short_code
                            
                            # 尝试匹配 - 优先匹配更长的名称
                            text_lower = subject_or_sender.lower()
                            best_match = None
                            best_match_length = 0
                            
                            for key, value in outlet_mapping.items():
                                if key in text_lower and key != 'nan':
                                    if len(key) > best_match_length:
                                        best_match = (key, value)
                                        best_match_length = len(key)
                            
                            if best_match:
                                key, value = best_match
                                return value
                    
                    except Exception as e:
                        print(f"[错误] 读取配置文件失败: {e}")
                    
                    # 如果都匹配失败，提取第一个单词作为备用
                    words = subject_or_sender.split()
                    if words:
                        first_word = words[0].strip('-_').upper()
                        if len(first_word) >= 2:
                            return first_word
                    
                    return "UNKNOWN"
                
                # 解析选中的订单，提取门市信息和时间
                order_details = []
                for order in selected_orders:
                    # 解析订单信息：邮件时间: 2025-08-20 17:50 - [主题] West mall weekly order week 4 AUGUST 2025 - [发件人] Grantral Mall
                    if "邮件时间:" in order and "[主题]" in order:
                        # 提取时间 - 使用更精确的分割方法
                        temp = order.split("邮件时间:")[1].strip()
                        if " - [主题]" in temp:
                            time_part = temp.split(" - [主题]")[0].strip()
                        else:
                            time_part = temp.split("-")[0].strip()  # 备用方法
                        
                        # 提取主题
                        if " - [发件人]" in order:
                            # 新格式：包含发件人信息
                            subject_part = order.split("[主题]")[1].split(" - [发件人]")[0].strip()
                            sender_part = order.split("[发件人]")[1].strip()
                        else:
                            # 旧格式：只有主题
                            subject_part = order.split("[主题]")[1].strip()
                            sender_part = ""
                        
                        print(f"[DEBUG] 原始订单: {order}")
                        print(f"[DEBUG] 提取的时间: '{time_part}'")
                        print(f"[DEBUG] 提取的主题: '{subject_part}'")
                        print(f"[DEBUG] 提取的发件人: '{sender_part}'")
                        
                        # 优先从发件人提取门市名称，然后才是主题
                        if sender_part:
                            outlet_name = extract_outlet_from_subject(sender_part)
                            print(f"[DEBUG] 从发件人识别门市: {sender_part} → {outlet_name}")
                        else:
                            outlet_name = extract_outlet_from_subject(subject_part)
                            print(f"[DEBUG] 从主题识别门市: {subject_part} → {outlet_name}")
                        
                        order_details.append({
                            'time': time_part,
                            'subject': subject_part,
                            'outlet': outlet_name,
                            'full_order': order
                        })
                
                # 按门市分组扣分
                outlet_deductions = {}
                for detail in order_details:
                    outlet = detail['outlet']
                    if outlet not in outlet_deductions:
                        outlet_deductions[outlet] = []
                    outlet_deductions[outlet].append(detail)
                
                print(f"[DEBUG] 门市分组结果:")
                for outlet, orders in outlet_deductions.items():
                    print(f"  {outlet}: {len(orders)} 个订单")
                
                # 为每个门市添加扣分记录
                for outlet, orders in outlet_deductions.items():
                    # 查找对应的门市工作表
                    sheet_found = False
                    matched_sheet = None
                    
                    print(f"[DEBUG] 为门市 {outlet} 查找工作表...")
                    print(f"[DEBUG] 可用工作表: {outlet_sheets}")
                    
                    # 尝试多种匹配方式
                    best_match = None
                    best_match_score = 0
                    
                    for sheet_name in outlet_sheets:
                        sheet_upper = sheet_name.upper()
                        outlet_upper = outlet.upper()
                        
                        # 1. 精确匹配（最高优先级）
                        if sheet_upper == outlet_upper:
                            best_match = sheet_name
                            best_match_score = 100
                            break
                        
                        # 2. 门市代码包含在工作表名中（中等优先级）
                        elif outlet_upper in sheet_upper:
                            score = len(outlet_upper) / len(sheet_upper) * 50
                            if score > best_match_score:
                                best_match = sheet_name
                                best_match_score = score
                        
                        # 3. 工作表名包含在门市代码中（最低优先级，但要避免错误匹配）
                        elif sheet_upper in outlet_upper:
                            # 只有当工作表名长度 >= 门市代码长度的80%时才考虑
                            if len(sheet_upper) >= len(outlet_upper) * 0.8:
                                score = len(sheet_upper) / len(outlet_upper) * 30
                                if score > best_match_score:
                                    best_match = sheet_name
                                    best_match_score = score
                    
                    if best_match:
                        matched_sheet = best_match
                    
                    if matched_sheet and matched_sheet in wb.sheetnames:
                        sheet_found = True
                        print(f"[DEBUG] 匹配到工作表: {outlet} → {matched_sheet}")
                        ws = wb[matched_sheet]
                        
                        # 找到下一个空行
                        next_row = 3
                        while next_row <= ws.max_row:
                            if (ws[f'A{next_row}'].value is None and 
                                ws[f'B{next_row}'].value is None and 
                                ws[f'C{next_row}'].value is None and
                                ws[f'D{next_row}'].value is None and
                                ws[f'E{next_row}'].value is None and
                                ws[f'F{next_row}'].value is None and
                                ws[f'G{next_row}'].value is None and
                                ws[f'H{next_row}'].value is None):
                                break
                            next_row += 1
                        
                        if next_row > ws.max_row:
                            next_row = ws.max_row + 1
                        
                        # 构建Notes内容：只显示邮件发送的时间
                        time_list = []
                        for order_detail in orders:
                            time_list.append(order_detail['time'])
                        notes_content = f"邮件发送时间: {'; '.join(time_list)}"
                        
                        # 添加扣分记录
                        ws[f'A{next_row}'] = datetime.now().strftime("%Y-%m-%d")
                        ws[f'B{next_row}'] = "Weekly Order"
                        ws[f'C{next_row}'] = "Order Lateness: 周三12点后提交订单"
                        ws[f'D{next_row}'] = entry_person
                        ws[f'E{next_row}'] = 10
                        ws[f'F{next_row}'] = f"{next_row-2}"
                        ws[f'G{next_row}'] = entry_person
                        ws[f'H{next_row}'] = notes_content
                        
                        deduction_count += 1
                    
                    if not sheet_found:
                        print(f"[警告] 未找到门市 {outlet} 对应的工作表")
                
                # 保存文件
                wb.save(demerit_file)
                wb.close()
                
                messagebox.showinfo("扣分成功", 
                                  f"✅ 扣分完成！\n\n"
                                  f"已为 {deduction_count} 个门市添加扣分记录\n"
                                  f"录入人: {entry_person}\n"
                                  f"扣分订单数量: {len(selected_orders)} 个\n\n"
                                  f"扣分记录已保存到文件中。")
                
                confirmation_window.destroy()
                
            except Exception as e:
                messagebox.showerror("扣分失败", f"❌ 扣分失败: {e}\n\n请检查扣分文件是否被其他程序占用。")
                
                # 保存文件
                wb.save(demerit_file)
                wb.close()
                
                messagebox.showinfo("扣分成功", 
                                  f"✅ 扣分完成！\n\n"
                                  f"已为 {deduction_count} 个门市添加扣分记录\n"
                                  f"录入人: {entry_person}\n"
                                  f"扣分订单数量: {len(selected_orders)} 个\n\n"
                                  f"扣分记录已保存到文件中。")
                
                confirmation_window.destroy()
                
            except Exception as e:
                messagebox.showerror("扣分失败", f"❌ 扣分失败: {e}\n\n请检查扣分文件是否被其他程序占用。")
        
        confirm_btn = tk.Button(
            left_buttons,
            text="确认扣分 / Confirm Deduction",
            command=confirm_deduction,
            font=("Microsoft YaHei", 16, "bold"),  # 增大字体
            bg="#dc2626",  # 红色
            fg="white",
            padx=35,
            pady=12,
            relief="raised",  # 改为凸起效果
            bd=4,  # 增加边框宽度
            cursor="hand2",  # 鼠标悬停时显示手型
            activebackground="#b91c1c",  # 点击时的颜色
            activeforeground="white"  # 点击时的文字颜色
        )
        confirm_btn.pack(side="left", padx=(0, 15))
        
        # 右侧按钮
        right_buttons = tk.Frame(button_frame, bg="#1e293b")
        right_buttons.pack(side="right")
        
        # 取消按钮 - 美化
        cancel_btn = tk.Button(
            right_buttons,
            text="取消 / Cancel",
            command=confirmation_window.destroy,
            font=("Microsoft YaHei", 12, "bold"),
            bg="#6b7280",  # 灰色
            fg="white",
            padx=25,
            pady=10,
            relief="raised",  # 改为凸起效果
            bd=3,  # 增加边框宽度
            cursor="hand2",  # 鼠标悬停时显示手型
            activebackground="#4b5563",  # 点击时的颜色
            activeforeground="white"  # 点击时的文字颜色
        )
        cancel_btn.pack()
        
        # 设置焦点到录入人输入框
        entry_person_entry.focus()
    
    def _show_manual_f5_deduction(self):
        """显示手动扣分界面"""
        from tkinter import messagebox
        import tkinter as tk
        import pandas as pd
        from datetime import datetime
        
        # 检查扣分文件
        demerit_file = self.demerit_file_var.get()
        if not demerit_file:
            messagebox.showwarning("警告", "请先选择扣分文件！")
            return
        
        # 创建手动扣分窗口
        deduction_window = tk.Toplevel(self)
        deduction_window.title("手动扣分 / Manual Deduction")
        deduction_window.geometry("1100x900")  # 进一步增加窗口大小
        deduction_window.configure(bg="#1e293b")  # 使用与主程序相同的深色背景
        
        # 居中显示窗口
        deduction_window.update_idletasks()
        x = (deduction_window.winfo_screenwidth() // 2) - (1100 // 2)
        y = (deduction_window.winfo_screenheight() // 2) - (900 // 2)
        deduction_window.geometry(f"1100x900+{x}+{y}")
        
        # 主容器
        main_container = tk.Frame(deduction_window, bg="#1e293b")
        main_container.pack(expand=True, fill="both", padx=60, pady=50)
        
        # 标题
        title_label = tk.Label(
            main_container,
            text="手动扣分系统 / Manual Deduction System",
            font=("Microsoft YaHei", 18, "bold"),  # 从22减小到18
            bg="#1e293b",
            fg="#3b82f6"  # 使用主程序的蓝色
        )
        title_label.pack(pady=(0, 25))  # 从40减小到25
        
        # 门市选择
        outlet_frame = tk.Frame(main_container, bg="#1e293b")
        outlet_frame.pack(pady=12, fill="x")  # 从20减小到12
        
        tk.Label(
            outlet_frame,
            text="选择门市 / Select Outlet:",
            font=("Microsoft YaHei", 13, "bold"),  # 从16减小到13
            bg="#1e293b",
            fg="#e2e8f0"  # 浅色文字
        ).pack(anchor="w")
        
        # 读取扣分文件获取门市列表
        try:
            demerit_df = pd.read_excel(demerit_file, sheet_name=None)
            outlet_sheets = [sheet for sheet in demerit_df.keys() if sheet not in 
                           ["Point Deduction Overview", "OPS Demerit Point Scoring", "Data - DO NOT EDIT", "Demerit System"]]
        except:
            # 如果扣分文件读取失败，从配置文件读取门市列表
            try:
                config_file = self.config_file_var.get()
                if config_file and os.path.exists(config_file):
                    config_df = pd.read_excel(config_file, sheet_name="OUTLET")
                    outlet_sheets = [str(row['Short Name']).strip().upper() for _, row in config_df.iterrows() 
                                   if str(row['Short Name']).strip().upper() != 'NAN']
                else:
                    outlet_sheets = []
            except:
                outlet_sheets = []
        
        outlet_var = tk.StringVar(value=outlet_sheets[0] if outlet_sheets else "")
        outlet_menu = tk.OptionMenu(outlet_frame, outlet_var, *outlet_sheets)
        outlet_menu.config(
            font=("Microsoft YaHei", 12),  # 从14减小到12
            width=35,  # 从40减小到35
            bg="#334155",  # 深色背景
            fg="#e2e8f0",  # 浅色文字
            activebackground="#475569",
            activeforeground="#ffffff",
            relief="flat",
            bd=0
        )
        outlet_menu.pack(pady=6, anchor="w")  # 从10减小到6
        
        # Category选择
        category_frame = tk.Frame(main_container, bg="#1e293b")
        category_frame.pack(pady=12, fill="x")  # 从20减小到12
        
        tk.Label(
            category_frame,
            text="选择类别 / Select Category:",
            font=("Microsoft YaHei", 13, "bold"),  # 从16减小到13
            bg="#1e293b",
            fg="#e2e8f0"
        ).pack(anchor="w")
        
        # 从扣分文件读取可用的Category
        try:
            if "OPS Demerit Point Scoring" in demerit_df:
                scoring_df = demerit_df["OPS Demerit Point Scoring"]
                available_categories = set()
                for _, row in scoring_df.iterrows():
                    if pd.notna(row.iloc[1]):  # B列
                        category = str(row.iloc[1]).strip()
                        if category:
                            available_categories.add(category)
                
                if not available_categories:
                    available_categories = ["Weekly Order", "Weekly Amendment", "Invoice Submission", "Chef Issue", "Operations", "Customer Feedback Issue"]
            else:
                available_categories = ["Weekly Order", "Weekly Amendment", "Invoice Submission", "Chef Issue", "Operations", "Customer Feedback Issue"]
        except:
            available_categories = ["Weekly Order", "Weekly Amendment", "Invoice Submission", "Chef Issue", "Operations", "Customer Feedback Issue"]
        
        category_var = tk.StringVar(value=sorted(available_categories)[0] if available_categories else "")
        category_menu = tk.OptionMenu(category_frame, category_var, *sorted(available_categories))
        category_menu.config(
            font=("Microsoft YaHei", 12),  # 从14减小到12
            width=35,  # 从40减小到35
            bg="#334155",
            fg="#e2e8f0",
            activebackground="#475569",
            activeforeground="#ffffff",
            relief="flat",
            bd=0
        )
        category_menu.pack(pady=6, anchor="w")  # 从10减小到6
        
        # Description选择
        description_frame = tk.Frame(main_container, bg="#1e293b")
        description_frame.pack(pady=12, fill="x")  # 从20减小到12
        
        tk.Label(
            description_frame,
            text="选择描述 / Select Description:",
            font=("Microsoft YaHei", 13, "bold"),  # 从16减小到13
            bg="#1e293b",
            fg="#e2e8f0"
        ).pack(anchor="w")
        
        # 根据选择的Category更新Description选项
        def update_description_options(*args):
            try:
                if "OPS Demerit Point Scoring" in demerit_df:
                    scoring_df = demerit_df["OPS Demerit Point Scoring"]
                    available_descriptions = []
                    
                    # 首先尝试根据Category匹配Description
                    for _, row in scoring_df.iterrows():
                        if pd.notna(row.iloc[1]) and pd.notna(row.iloc[2]):  # B列和C列
                            category = str(row.iloc[1]).strip()
                            description = str(row.iloc[2]).strip()
                            if category == category_var.get() and description:
                                available_descriptions.append(description)
                    
                    # 如果没有找到对应Category的Description，显示所有可用的
                    if not available_descriptions:
                        for _, row in scoring_df.iterrows():
                            if pd.notna(row.iloc[2]):  # C列
                                description = str(row.iloc[2]).strip()
                                if description and description not in available_descriptions:
                                    available_descriptions.append(description)
                    
                    # 如果还是没有，添加默认选项
                    if not available_descriptions:
                        available_descriptions = ["Order Lateness", "Order Wrong Data", "Amendment Lateness", "Other", "Late Submission", "Incorrect Information", "Missing Data", "Quality Issue"]
                else:
                    available_descriptions = ["Order Lateness", "Order Wrong Data", "Amendment Lateness", "Other", "Late Submission", "Incorrect Information", "Missing Data", "Quality Issue"]
                
                # 更新Description菜单
                description_menu['menu'].delete(0, 'end')
                for desc in available_descriptions:
                    description_menu['menu'].add_command(
                        label=desc,
                        command=lambda d=desc: description_var.set(d)
                    )
                if available_descriptions:
                    description_var.set(available_descriptions[0])
                    
            except Exception as e:
                print(f"更新Description选项失败: {e}")
        
        # 绑定Category选择事件
        category_var.trace('w', update_description_options)
        
        description_var = tk.StringVar()
        description_menu = tk.OptionMenu(description_frame, description_var, "")
        description_menu.config(
            font=("Microsoft YaHei", 12),  # 从14减小到12
            width=35,  # 从40减小到35
            bg="#334155",
            fg="#e2e8f0",
            activebackground="#475569",
            activeforeground="#ffffff",
            relief="flat",
            bd=0
        )
        description_menu.pack(pady=6, anchor="w")  # 从10减小到6
        
        # 扣分分数（固定10分）
        score_frame = tk.Frame(main_container, bg="#1e293b")
        score_frame.pack(pady=12, fill="x")  # 从20减小到12
        
        tk.Label(
            score_frame,
            text="扣分分数 / Deduction Score: 10 (固定)",
            font=("Microsoft YaHei", 13, "bold"),  # 从16减小到13
            bg="#1e293b",
            fg="#10b981"  # 绿色显示固定分数
        ).pack(anchor="w")
        
        # 员工ID/姓名
        employee_frame = tk.Frame(main_container, bg="#1e293b")
        employee_frame.pack(pady=12, fill="x")  # 从20减小到12
        
        tk.Label(
            employee_frame,
            text="员工ID/姓名 / Employee ID/Name:",
            font=("Microsoft YaHei", 13, "bold"),  # 从16减小到13
            bg="#1e293b",
            fg="#e2e8f0"
        ).pack(anchor="w")
        
        employee_var = tk.StringVar()
        employee_entry = tk.Entry(
            employee_frame, 
            textvariable=employee_var, 
            font=("Microsoft YaHei", 12),  # 从14减小到12
            width=35,  # 从40减小到35
            bg="#334155",
            fg="#e2e8f0",
            insertbackground="#e2e8f0",
            relief="flat",
            bd=0
        )
        employee_entry.pack(pady=6, anchor="w")  # 从10减小到6
        
        # 备注输入
        note_frame = tk.Frame(main_container, bg="#1e293b")
        note_frame.pack(pady=12, fill="x")  # 从20减小到12
        
        tk.Label(
            note_frame,
            text="备注 / Notes:",
            font=("Microsoft YaHei", 13, "bold"),  # 从16减小到13
            bg="#1e293b",
            fg="#e2e8f0"
        ).pack(anchor="w")
        
        note_text = tk.Text(
            note_frame, 
            height=4,  # 从5减小到4
            width=60,  # 从70减小到60
            font=("Microsoft YaHei", 12),  # 从14减小到12
            bg="#334155",
            fg="#e2e8f0",
            insertbackground="#e2e8f0",
            relief="flat",
            bd=0
        )
        note_text.pack(pady=6, anchor="w")  # 从10减小到6
        
        # 扣分按钮
        def apply_deduction():
            outlet = outlet_var.get()
            category = category_var.get()
            description = description_var.get()
            employee = employee_var.get()
            note = note_text.get("1.0", "end-1c")
            
            if not outlet:
                messagebox.showwarning("警告", "请选择门市！")
                return
            if not category:
                messagebox.showwarning("警告", "请选择类别！")
                return
            if not description:
                messagebox.showwarning("警告", "请选择描述！")
                return
            if not employee.strip():
                messagebox.showwarning("警告", "请输入员工ID/姓名！")
                return
            if not note.strip():
                messagebox.showwarning("警告", "请输入扣分备注！")
                return
            
            try:
                # 读取扣分文件
                demerit_df = pd.read_excel(demerit_file, sheet_name=None)
                
                # 获取门市工作表
                if outlet not in demerit_df:
                    messagebox.showerror("错误", f"找不到门市 {outlet} 的工作表！")
                    return
                
                outlet_df = demerit_df[outlet]
                
                # 准备新数据（固定10分）
                new_data = {
                    'A': datetime.now().strftime("%Y-%m-%d"),  # 日期
                    'B': category,  # Category
                    'C': description,  # Description
                    'D': employee,  # 员工ID/姓名
                    'E': 10,  # 扣分分数（固定10分）
                    'F': f"{len(outlet_df) + 1}",  # 扣分编号
                    'G': "System",  # 录入人
                    'H': note  # 备注
                }
                
                # 使用pandas的append方法添加新行，这样更安全
                new_row_df = pd.DataFrame([new_data])
                outlet_df = pd.concat([outlet_df, new_row_df], ignore_index=True)
                
                # 保存文件 - 使用openpyxl直接操作，保留公式和格式
                try:
                    # 读取现有的Excel文件
                    from openpyxl import load_workbook
                    wb = load_workbook(demerit_file)
                    
                    # 获取或创建工作表
                    if outlet in wb.sheetnames:
                        ws = wb[outlet]
                    else:
                        ws = wb.create_sheet(outlet)
                    
                    # 找到下一个空行 - 从第3行开始查找（跳过标题行）
                    next_row = 3  # 从第3行开始，因为第1-2行是标题
                    
                    # 查找第一个完全空的行
                    while next_row <= ws.max_row:
                        # 检查A列到H列是否都为空
                        if (ws[f'A{next_row}'].value is None and 
                            ws[f'B{next_row}'].value is None and 
                            ws[f'C{next_row}'].value is None and
                            ws[f'D{next_row}'].value is None and
                            ws[f'E{next_row}'].value is None and
                            ws[f'F{next_row}'].value is None and
                            ws[f'G{next_row}'].value is None and
                            ws[f'H{next_row}'].value is None):
                            break
                        next_row += 1
                    
                    # 如果没找到空行，就在最后添加新行
                    if next_row > ws.max_row:
                        next_row = ws.max_row + 1
                    
                    # 写入新数据
                    ws[f'A{next_row}'] = new_data['A']  # 日期
                    ws[f'B{next_row}'] = new_data['B']  # Category
                    ws[f'C{next_row}'] = new_data['C']  # Description
                    ws[f'D{next_row}'] = new_data['D']  # 员工ID/姓名
                    ws[f'E{next_row}'] = new_data['E']  # 扣分分数
                    ws[f'F{next_row}'] = new_data['F']  # 扣分编号
                    ws[f'G{next_row}'] = new_data['G']  # 录入人
                    ws[f'H{next_row}'] = new_data['H']  # 备注
                    
                    # 保存文件
                    wb.save(demerit_file)
                    wb.close()
                    
                except Exception as e:
                    # 如果openpyxl失败，回退到pandas方法
                    print(f"openpyxl保存失败，使用pandas方法: {e}")
                    with pd.ExcelWriter(demerit_file, engine='openpyxl', mode='w') as writer:
                        for sheet_name, df in demerit_df.items():
                            df.to_excel(writer, sheet_name=sheet_name, index=False)
                
                result_text = f"扣分已成功应用：\n\n"
                result_text += f"门市: {outlet}\n"
                result_text += f"类别: {category}\n"
                result_text += f"描述: {description}\n"
                result_text += f"扣分分数: 10\n"
                result_text += f"员工: {employee}\n"
                result_text += f"备注: {note}\n\n"
                result_text += "扣分记录已保存到扣分文件中。"
                
                messagebox.showinfo("扣分成功", result_text)
                deduction_window.destroy()
                
            except Exception as e:
                messagebox.showerror("错误", f"保存扣分记录失败: {e}")
        
        # 按钮容器 - 居中布局
        button_container = tk.Frame(main_container, bg="#1e293b")
        button_container.pack(pady=25, fill="x")  # 从40减小到25
        
        # 按钮框架 - 用于居中按钮
        button_frame = tk.Frame(button_container, bg="#1e293b")
        button_frame.pack(expand=True)
        
        apply_btn = tk.Button(
            button_frame,
            text="应用扣分 / Apply Deduction",
            command=apply_deduction,
            font=("Microsoft YaHei", 14, "bold"),  # 从16减小到14
            bg="#dc2626",  # 红色按钮
            fg="white",
            padx=35,  # 从40减小到35
            pady=12,  # 从15减小到12
            relief="flat",
            bd=0,
            cursor="hand2"
        )
        apply_btn.pack(side="left", padx=(0, 25))  # 从30减小到25
        
        cancel_btn = tk.Button(
            button_frame,
            text="取消 / Cancel",
            command=deduction_window.destroy,
            font=("Microsoft YaHei", 14, "bold"),  # 从16减小到14
            bg="#64748b",  # 灰色按钮
            fg="white",
            padx=35,  # 从40减小到35
            pady=12,  # 从15减小到12
            relief="flat",
            bd=0,
            cursor="hand2"
        )
        cancel_btn.pack(side="left")
        
        # 初始化Description选项
        update_description_options()

    def _select_ordering_function(self, command):
        """选择订单功能"""
        command()

    def _get_hover_color(self, color):
        """获取悬停颜色"""
        hover_colors = {
            "#3b82f6": "#1d4ed8",
            "#10b981": "#059669",
            "#8b5cf6": "#7c3aed",
            "#ef4444": "#dc2626",
            "#f97316": "#ea580c"
        }
        return hover_colors.get(color, color)

    def _create_navigation_buttons(self):
        for widget in self.button_container.winfo_children():
            widget.destroy()
        inner_frame = ctk.CTkFrame(
    self.button_container,
     fg_color="transparent")
        inner_frame.pack(expand=True)

        # 订单功能分类
        ordering_frame = ctk.CTkFrame(inner_frame, fg_color="transparent")
        ordering_frame.pack(fill="x", pady=(0, 20))

        # 订单功能标题
        ordering_title = ctk.CTkLabel(
            ordering_frame,
            text="📋 訂單功能\nOrdering Function",
            font=("Microsoft YaHei", 14, "bold"),
            text_color=ACCENT_BLUE,
            justify="center"
        )
        ordering_title.pack(pady=(0, 10))

        # 订单功能按钮
        ordering_functions = [
            ("download_title", self.show_download_ui, ACCENT_BLUE),
            ("automation_title", self.show_automation_ui, ACCENT_GREEN),
            ("checklist_title", self.show_checklist_ui, ACCENT_PURPLE),
            ("send_emails", self.show_email_sending_ui, ACCENT_RED),
            ("operation_supplies", self.show_operation_supplies_ui, "#F97316")
        ]

        for func_key, command, color in ordering_functions:
            btn = NavigationButton(
                ordering_frame,
                text=t(func_key),
                command=lambda c=command, k=func_key: self._select_function(
                    c, k),
                fg_color=DARK_PANEL,
                anchor="center",
                border_width=2,
                border_color=color,
                corner_radius=10,
                font=FONT_BIGBTN,
                text_color=get_contrast_color(DARK_PANEL),
                height=45
            )
            btn.pack(fill="x", pady=4, padx=10)
            self.nav_buttons[func_key] = btn

        # 月结功能分类
        monthend_frame = ctk.CTkFrame(inner_frame, fg_color="transparent")
        monthend_frame.pack(fill="x", pady=(20, 20))

        # 月结功能标题
        monthend_title = ctk.CTkLabel(
            monthend_frame,
            text="📊 月結功能\nMonthend Closing Function",
            font=("Microsoft YaHei", 14, "bold"),
            text_color="#FF6B35",
            justify="center"
        )
        monthend_title.pack(pady=(0, 10))

        # 月结功能按钮（暂时为占位符）
        monthend_functions = [
            ("monthend_placeholder", self.show_monthend_placeholder, "#FF6B35")
        ]

        for func_key, command, color in monthend_functions:
            btn = NavigationButton(
                monthend_frame,
                text="即將推出\nComing Soon",
                command=command,
                fg_color=DARK_PANEL,
                anchor="center",
                border_width=2,
                border_color=color,
                corner_radius=10,
                font=FONT_BIGBTN,
                text_color="#888888",
                height=45
            )
            btn.pack(fill="x", pady=4, padx=10)
            self.nav_buttons[func_key] = btn

        # 系统功能分类
        system_frame = ctk.CTkFrame(inner_frame, fg_color="transparent")
        system_frame.pack(fill="x", pady=(20, 0))

        # 系统功能按钮
        system_functions = [
            ("theme_selection", self.show_theme_selection, "#8b5cf6"),
            ("exit_system", self._on_close, "#64748B")
        ]

        for func_key, command, color in system_functions:
            btn = NavigationButton(
                system_frame,
                text=t(func_key),
                command=command,
                fg_color=DARK_PANEL,
                anchor="center",
                border_width=2,
                border_color=color,
                corner_radius=10,
                font=FONT_BIGBTN,
                text_color=get_contrast_color(DARK_PANEL),
                height=45
            )
            btn.pack(fill="x", pady=4, padx=10)
            self.nav_buttons[func_key] = btn
        # 用户指南按钮
        help_btn = NavigationButton(
            system_frame,
            text="用户指南\nUser Guide",
            command=self.show_user_guide,
            fg_color=ACCENT_PURPLE,
            anchor="center",
            border_width=2,
            border_color=ACCENT_PURPLE,
            corner_radius=10,
            font=FONT_BIGBTN,
            text_color=get_contrast_color(ACCENT_PURPLE),
            height=45
        )
        help_btn.pack(fill="x", pady=4, padx=10)

    def show_theme_selection(self):
        """显示主题选择界面"""
        # 清空内容区
        for w in self.content_body.winfo_children():
            w.destroy()
        self._create_theme_selection_ui()

    def _create_theme_selection_ui(self):
        """创建主题选择界面"""
        # 主容器
        main_container = ctk.CTkFrame(
            self.content_body, 
            fg_color=get_current_theme().dark_panel,
            corner_radius=30,
            width=1000,
            height=750
        )
        main_container.pack(expand=True, pady=50)
        main_container.pack_propagate(False)

        # 装饰条
        decoration_frame = ctk.CTkFrame(
            main_container,
            fg_color=get_current_theme().accent_blue,
            height=8,
            corner_radius=0
        )
        decoration_frame.pack(fill="x")

        # 标题区域
        title_frame = ctk.CTkFrame(main_container, fg_color="transparent")
        title_frame.pack(fill="x", padx=40, pady=30)

        title_label = ctk.CTkLabel(
            title_frame,
            text="🎨 主題選擇",
            font=("Microsoft YaHei", 36, "bold"),
            text_color=get_current_theme().accent_blue
        )
        title_label.pack(pady=(0, 10))

        subtitle_label = ctk.CTkLabel(
            title_frame,
            text="選擇您喜歡的系統顏色主題",
            font=("Microsoft YaHei", 18),
            text_color=get_current_theme().text_color
        )
        subtitle_label.pack()

        # 主题选择区域
        theme_container = ctk.CTkScrollableFrame(
            main_container,
            fg_color="transparent",
            width=900,
            height=500
        )
        theme_container.pack(fill="both", expand=True, padx=40, pady=20)

        # 创建主题按钮
        self._create_modern_theme_buttons(theme_container)

        # 底部按钮区域
        btn_container = ctk.CTkFrame(main_container, fg_color="transparent")
        btn_container.pack(fill="x", padx=40, pady=20)

        confirm_btn = ctk.CTkButton(
            btn_container,
            text="確認選擇",
            command=self._apply_theme_and_login,
            font=("Microsoft YaHei", 16, "bold"),
            fg_color=get_current_theme().accent_blue,
            hover_color=get_current_theme().btn_hover,
            width=200,
            height=50,
            corner_radius=25
        )
        confirm_btn.pack()

    def _create_modern_theme_buttons(self, parent):
        """创建现代化主题按钮"""
        current_theme = get_current_theme()
        canvas = ctk.CTkCanvas(parent, bg=current_theme.dark_panel, highlightthickness=0)
        canvas.pack(fill="both", expand=True)

        # 创建主题网格
        themes_per_row = 2
        theme_width = 400
        theme_height = 200
        padding = 20

        for i, (theme_key, theme) in enumerate(THEMES.items()):
            row = i // themes_per_row
            col = i % themes_per_row
            
            x = col * (theme_width + padding) + padding
            y = row * (theme_height + padding) + padding
            
            is_selected = theme_key == CURRENT_THEME
            
            # 主题预览卡片
            theme_preview = ctk.CTkFrame(
                parent,
                fg_color=theme.dark_panel,
                corner_radius=20,
                width=theme_width,
                height=theme_height,
                border_width=4 if is_selected else 2,
                border_color=theme.accent_blue if is_selected else theme.dark_panel
            )
            theme_preview.place(x=x, y=y)
            theme_preview.pack_propagate(False)

            # 主题名称
            name_label = ctk.CTkLabel(
                theme_preview,
                text=theme.name,
                font=("Microsoft YaHei", 18, "bold"),
                text_color=theme.text_color
            )
            name_label.pack(pady=20)

            # 主题描述
            desc_label = ctk.CTkLabel(
                theme_preview,
                text=theme.description,
                font=("Microsoft YaHei", 12),
                text_color=theme.text_color,
                wraplength=350
            )
            desc_label.pack(pady=(0, 20))

            # 颜色预览
            color_preview = ctk.CTkFrame(
                theme_preview,
                fg_color="transparent",
                height=60
            )
            color_preview.pack(fill="x", padx=20, pady=(0, 20))

            # 显示主要颜色
            colors = [theme.accent_blue, theme.accent_green, theme.accent_red, theme.accent_purple]
            for j, color in enumerate(colors):
                color_btn = ctk.CTkFrame(
                    color_preview,
                    fg_color=color,
                    width=40,
                    height=40,
                    corner_radius=20
                )
                color_btn.place(x=j * 50, y=10)

            # 选择按钮
            select_btn = ctk.CTkButton(
                theme_preview,
                text="選擇此主題" if not is_selected else "✓ 已選擇",
                command=lambda t=theme_key: self._select_theme(t),
                fg_color=theme.accent_blue if not is_selected else theme.accent_green,
                hover_color=theme.btn_hover,
                font=("Microsoft YaHei", 14, "bold"),
                text_color="white",
                width=150,
                height=35,
                corner_radius=15
            )
            select_btn.pack(pady=(0, 20))

            # 鼠标悬停效果
            def on_enter(e, frame=theme_preview, theme=theme, selected=is_selected, theme_key=theme_key):
                if not selected:
                    frame.configure(border_color=theme.accent_blue, border_width=3)

            def on_leave(e, frame=theme_preview, theme=theme, selected=is_selected, theme_key=theme_key):
                if selected:
                    frame.configure(border_color=theme.accent_blue, border_width=4)
                else:
                    # 对于亮色主题，使用更明显的边框颜色
                    if theme_key == "bright_light":
                        frame.configure(border_color="#cbd5e1", border_width=2)
                    else:
                        frame.configure(border_color=theme.dark_panel, border_width=2)

            theme_preview.bind("<Enter>", on_enter)
            theme_preview.bind("<Leave>", on_leave)

    def _select_theme(self, theme_key):
        """选择主题"""
        global CURRENT_THEME
        CURRENT_THEME = theme_key
        self._create_theme_selection_ui()  # 刷新界面

    def _apply_theme_and_login(self):
        """应用主题并登录"""
        save_theme_config()
        self._apply_theme()
        self._show_main_menu()

    def _apply_theme(self):
        """应用当前主题"""
        theme = get_current_theme()
        
        # 更新全局颜色变量
        global DARK_BG, DARK_PANEL, ACCENT_BLUE, BTN_HOVER, ACCENT_GREEN, ACCENT_RED, ACCENT_PURPLE
        DARK_BG = theme.dark_bg
        DARK_PANEL = theme.dark_panel
        ACCENT_BLUE = theme.accent_blue
        BTN_HOVER = theme.btn_hover
        ACCENT_GREEN = theme.accent_green
        ACCENT_RED = theme.accent_red
        ACCENT_PURPLE = theme.accent_purple

        # 更新主窗口背景
        self.configure(fg_color=DARK_BG)
        
        # 更新导航栏
        if hasattr(self, 'nav_frame'):
            self.nav_frame.configure(fg_color=DARK_PANEL)
        
        # 更新内容区域
        if hasattr(self, 'content_body'):
            self.content_body.configure(fg_color=DARK_BG)
        
        # 更新内容容器
        if hasattr(self, 'content_container'):
            self.content_container.configure(fg_color=DARK_PANEL)
        
        # 更新主题选择器按钮颜色
        if hasattr(self, 'theme_btn'):
            self.theme_btn.configure(
                fg_color=ACCENT_BLUE,
                hover_color=BTN_HOVER
            )
        
        # 如果有渐变主题，应用渐变背景
        if theme.gradient_colors and len(theme.gradient_colors) >= 2:
            self._apply_gradient_background(theme.gradient_colors)
        else:
            self._remove_gradient_background()

    def _apply_gradient_background(self, gradient_colors):
        """应用渐变背景"""
        # 这里可以添加渐变背景的实现
        pass

    def _remove_gradient_background(self):
        """移除渐变背景"""
        # 这里可以添加移除渐变背景的实现
        pass

    def show_monthend_placeholder(self):
        """显示月结功能占位符界面"""
        # 检查当前选中的功能
        if hasattr(
    self,
     'current_function') and self.current_function == 'supplier_statement':
            # 如果是供应商对账单功能，显示厂商选择界面
            self.show_supplier_selection_ui()
        else:
            # 其他功能显示占位符界面
            self._show_general_placeholder()

    def _show_general_placeholder(self):
        """显示通用占位符界面"""
        # 创建占位符界面
        placeholder_frame = ctk.CTkFrame(
    self.content_body, fg_color="transparent")
        placeholder_frame.pack(fill="both", expand=True, padx=50, pady=50)

        # 主要内容容器
        content_frame = ctk.CTkFrame(
    placeholder_frame,
    fg_color=DARK_PANEL,
     corner_radius=20)
        content_frame.pack(fill="both", expand=True, padx=20, pady=20)

        # 图标和标题
        icon_label = ctk.CTkLabel(
            content_frame,
            text="🚧",
            font=("Microsoft YaHei", 64),
            text_color="#FF6B35"
        )
        icon_label.pack(pady=(40, 20))

        title_label = ctk.CTkLabel(
            content_frame,
            text="月結功能開發中\nMonthend Closing Function Under Development",
            font=("Microsoft YaHei", 24, "bold"),
            text_color="#FF6B35",
            justify="center"
        )
        title_label.pack(pady=(0, 30))

        # 功能预览
        preview_text = (
            "即將推出的月結功能將包括：\n"
            "Upcoming Monthend Closing features will include:\n\n"
            "📊 月度銷售報表生成\n"
            "   Monthly Sales Report Generation\n\n"
            "📈 供應商對賬單處理\n"
            "   Supplier Statement Processing\n\n"
            "💰 成本分析與核算\n"
            "   Cost Analysis & Accounting\n\n"
            "📋 庫存盤點整理\n"
            "   Inventory Count Organization\n\n"
            "🔄 自動化月結流程\n"
            "   Automated Month-end Process"
        )

        preview_label = ctk.CTkLabel(
            content_frame,
            text=preview_text,
            font=("Microsoft YaHei", 14),
            text_color=TEXT_COLOR,
            justify="center"
        )
        preview_label.pack(pady=(0, 40))

        # 联系信息
        contact_frame = ctk.CTkFrame(
    content_frame,
    fg_color="#2d2d2d",
     corner_radius=10)
        contact_frame.pack(fill="x", padx=40, pady=(0, 40))

        contact_label = ctk.CTkLabel(
            contact_frame,
            text="如有功能需求建議，請聯繫開發團隊\nFor feature requests, please contact the development team",
            font=("Microsoft YaHei", 12),
            text_color="#cccccc",
            justify="center"
        )
        contact_label.pack(pady=20)

    def show_supplier_selection_ui(self):
        """显示厂商选择界面"""
        # 清空内容区
        for w in self.content_body.winfo_children():
            w.destroy()

        # 设置功能标题
        self.function_title.configure(
    text="🏭 廠商選擇系統\nSupplier Selection System")
        self.function_subtitle.configure(
    text="選擇廠商以進行 SOA 核對\nSelect supplier for SOA reconciliation")

        # 创建厂商选择界面
        self._create_supplier_selection_content(self.content_body)

    def show_soa_reconciliation_ui(self):
        """显示SOA核对界面 - 已弃用，保留用于向后兼容"""
        # 直接跳转到厂商选择界面
        self.show_supplier_selection_ui()

    def show_monthend_download_ui(self):
        """显示月结文件下载界面"""
        # 清空内容区
        for w in self.content_body.winfo_children():
            w.destroy()

        # 设置功能标题
        self.function_title.configure(text="📥 月結文件下載\nMonth-end File Download")
        self.function_subtitle.configure(
    text="從 Outlook 下載 SOA/Invoice 等月結文件\nDownload SOA/Invoice and other month-end files from Outlook")

        # 直接构建月结文件下载界面
        self._create_monthend_download_content(self.content_body)

    def _create_monthend_download_content(self, parent):
        """创建月结下载界面内容"""
        # 创建UI框架
        ui = MonthEndDownloadUI(parent)
        ui.pack(fill="both", expand=True)

        return ui

    def _create_supplier_selection_content(self, parent):
        """创建厂商选择界面内容"""
        # 主容器
        main_frame = ctk.CTkFrame(parent, fg_color="transparent")
        main_frame.pack(fill="both", expand=True, padx=20, pady=20)

        # 标题和说明
        title_frame = ctk.CTkFrame(
    main_frame,
    fg_color=DARK_PANEL,
     corner_radius=12)
        title_frame.pack(fill="x", pady=(0, 20))

        ctk.CTkLabel(
            title_frame,
            text="🏭 選擇廠商進行 SOA 核對\nSelect Supplier for SOA Reconciliation",
            font=("Microsoft YaHei", 18, "bold"),
            text_color=ACCENT_BLUE
        ).pack(pady=20)

        ctk.CTkLabel(
            title_frame,
            text="請選擇您要進行 SOA 核對的廠商\nPlease select the supplier you want to reconcile SOA for",
            font=("Microsoft YaHei", 12),
            text_color="#cccccc"
        ).pack(pady=(0, 20))

        # 厂商选择容器
        suppliers_frame = ctk.CTkFrame(main_frame, fg_color="transparent")
        suppliers_frame.pack(fill="both", expand=True)

        # 厂商按钮网格容器
        grid_frame = ctk.CTkFrame(suppliers_frame, fg_color="transparent")
        grid_frame.pack(expand=True)

        # Siahuat 按钮
        siahuat_btn = ctk.CTkButton(
            grid_frame,
            text="🏢 Siahuat 核對\nSiahuat Reconciliation",
            font=("Microsoft YaHei", 15, "bold"),
            fg_color=ACCENT_BLUE,
            hover_color="#0056b3",
            text_color="white",
            corner_radius=15,
            width=280,
            height=140,
            command=self._open_siahuat_window
        )
        siahuat_btn.grid(row=0, column=0, padx=30, pady=30)

        # Monthend Consolidate 按钮
        monthend_btn = ctk.CTkButton(
            grid_frame,
            text="📊 多廠商月結檢查\nMulti-Vendor Month-End Check",
            font=("Microsoft YaHei", 15, "bold"),
            fg_color=ACCENT_GREEN,
            hover_color="#047857",
            text_color="white",
            corner_radius=15,
            width=280,
            height=140,
            command=self._open_monthend_consolidate_window
        )
        monthend_btn.grid(row=0, column=1, padx=30, pady=30)

        # 底部说明
        info_frame = ctk.CTkFrame(
    main_frame,
    fg_color=DARK_PANEL,
     corner_radius=12)
        info_frame.pack(fill="x", pady=(20, 0))

        ctk.CTkLabel(
            info_frame,
            text="ℹ️ 選擇相應的功能進行 SOA 核對\nSelect the appropriate function for SOA reconciliation",
            font=("Microsoft YaHei", 11),
            text_color="#888888"
        ).pack(pady=15)

    def _open_siahuat_window(self):
        """打开Siahuat专用的SOA核对窗口"""
        # 创建新的弹窗
        siahuat_window = SiahuatSOAWindow(self)
        siahuat_window.grab_set()  # 模态窗口

    def _open_monthend_consolidate_window(self):
        """打开多廠商月結檢查功能窗口"""
        # 创建新的弹窗
        monthend_window = ctk.CTkToplevel(self)
        monthend_window.title("多廠商月結檢查功能 / Multi-Vendor Month-End Check")
        monthend_window.geometry("1600x1000")
        
        # 窗口居中顯示
        monthend_window.update_idletasks()
        x = (monthend_window.winfo_screenwidth() - 1600) // 2
        y = (monthend_window.winfo_screenheight() - 1000) // 2
        monthend_window.geometry(f"1600x1000+{x}+{y}")
        
        monthend_window.grab_set()  # 模态窗口
        
        # 直接創建統一的多廠商月結檢查UI
        vendor_ui = SOAReconciliationUI(monthend_window)
        vendor_ui.pack(fill="both", expand=True)
    
    def _create_vendor_selection_ui(self, parent):
        """創建廠商選擇界面"""
        # 主框架
        main_frame = ctk.CTkFrame(parent, fg_color=DARK_PANEL, corner_radius=20)
        main_frame.pack(fill="both", expand=True, padx=25, pady=(10, 15))
        
        # 標題
        title_frame = ctk.CTkFrame(main_frame, fg_color='transparent')
        title_frame.pack(fill='x', padx=25, pady=(20, 25))
        
        ctk.CTkLabel(
            title_frame,
            text="🌟 月結檢查系統",
            font=("Microsoft YaHei", 22, "bold"),
            text_color=ACCENT_GREEN
        ).pack(anchor='center')
        
        ctk.CTkLabel(
            title_frame,
            text="Month-End Check System",
            font=("Segoe UI", 14),
            text_color=TEXT_COLOR
        ).pack(anchor='center', pady=(5, 0))
        
        # 廠商選擇區域
        vendor_frame = ctk.CTkFrame(main_frame, fg_color='transparent')
        vendor_frame.pack(fill='both', expand=True, padx=25, pady=(0, 20))
        
        ctk.CTkLabel(
            vendor_frame,
            text="請選擇廠商 / Select Vendor",
            font=("Microsoft YaHei", 16, "bold"),
            text_color=TEXT_COLOR
        ).pack(pady=(0, 20))
        
        # 廠商按鈕容器
        button_frame = ctk.CTkFrame(vendor_frame, fg_color='transparent')
        button_frame.pack(expand=True)
        
        # Oriental 按鈕
        oriental_btn = ctk.CTkButton(
            button_frame,
            text="🍜 Oriental\n月結檢查",
            font=("Microsoft YaHei", 16, "bold"),
            fg_color=ACCENT_BLUE,
            hover_color="#1d4ed8",
            text_color="white",
            corner_radius=15,
            width=200,
            height=100,
            command=lambda: self._open_vendor_check_window(parent, "Oriental")
        )
        oriental_btn.pack(side='left', padx=20, pady=20)
        
        # Aries Fresh 按鈕
        aries_btn = ctk.CTkButton(
            button_frame,
            text="🥬 Aries Fresh\n月結檢查",
            font=("Microsoft YaHei", 16, "bold"),
            fg_color=ACCENT_GREEN,
            hover_color="#047857",
            text_color="white",
            corner_radius=15,
            width=200,
            height=100,
            command=lambda: self._open_vendor_check_window(parent, "Aries Fresh")
        )
        aries_btn.pack(side='left', padx=20, pady=20)

    def _open_vendor_check_window(self, parent, vendor):
        """打開統一的多廠商月結檢查窗口"""
        # 清空父窗口
        for widget in parent.winfo_children():
            widget.destroy()
        
        # 創建統一的多廠商月結檢查UI
        vendor_ui = SOAReconciliationUI(parent)
        vendor_ui.pack(fill="both", expand=True)

    def _create_soa_reconciliation_content(self, parent):
        """创建SOA核对界面内容 - 已弃用，保留用于向后兼容"""
        # 创建UI框架
        ui = SOAReconciliationUI(parent)
        ui.pack(fill="both", expand=True)

        return ui

    def _select_function(self, command, func_key):
        """选择功能"""
        # 取消之前选中的按钮
        if hasattr(
    self,
     'current_function') and self.current_function and self.current_function in self.nav_buttons:
            if hasattr(self.nav_buttons[self.current_function], 'deselect'):
                self.nav_buttons[self.current_function].deselect()

        # 选中当前按钮
        if func_key in self.nav_buttons and hasattr(
            self.nav_buttons[func_key], 'select'):
            self.nav_buttons[func_key].select()
        self.current_function = func_key

        # 执行功能
        command()

    def _show_function_ui(self, title_key, subtitle_key, content_callback):
        """显示功能界面"""
        # 清空内容区
        for w in self.content_body.winfo_children():
            w.destroy()

        # 设置标题
        self.function_title.configure(text=title_key)
        # 副標題統一放大
        if isinstance(subtitle_key, tuple):
            text = subtitle_key[0]
        else:
            text = subtitle_key
        self.function_subtitle.configure(text=text, font=FONT_TITLE)

        # 创建内容框架
        content_frame = ctk.CTkFrame(self.content_body, fg_color="transparent")
        content_frame.pack(fill="both", expand=True, padx=20, pady=20)

        # 构建功能UI
        content_callback(content_frame)

    # 下面是各个功能界面的修改，只需要将原来的show_xxx_ui方法改为使用_show_function_ui

    def show_download_ui(self):
        """显示下载界面"""
        # 清空内容区
        for w in self.content_body.winfo_children():
            w.destroy()

        # 设置功能标题
        self.function_title.configure(text=t("download_title"))
        self.function_subtitle.configure(text=t("download_desc"))

        def build(c):
            self.download_folder_var = ctk.StringVar()
            self.config_file_var = ctk.StringVar()

            # 创建表单框架
            form_frame = ctk.CTkFrame(c, fg_color="transparent")
            form_frame.pack(fill="both", expand=True, padx=50, pady=20)

            # 下载文件夹
            row1 = ctk.CTkFrame(form_frame)
            row1.pack(fill="x", pady=15)
            ctk.CTkLabel(
    row1,
    text="下载文件夹\nDownload Folder:",
    font=FONT_MID,
    anchor="w",
    justify="left").pack(
        side="left",
         padx=10)
            ctk.CTkEntry(
    row1,
    textvariable=self.download_folder_var,
    font=FONT_MID,
    state="readonly",
    width=400).pack(
        side="left",
        expand=True,
        fill="x",
         padx=5)
            # 美化的瀏覽按鈕
            browse_btn = ctk.CTkButton(
                row1,
                text="浏览...\nBrowse...",
                font=("Microsoft YaHei", 11, "bold"),
                command=self._select_download_folder,
                corner_radius=8,
                hover_color="#1976d2",
                height=30
            )
            browse_btn.pack(side="left", padx=5)

            # 分店配置文件
            row2 = ctk.CTkFrame(form_frame)
            row2.pack(fill="x", pady=15)
            ctk.CTkLabel(
    row2,
    text="分店配置文件（可选）\nOutlet Config (Optional):",
    font=FONT_MID,
    anchor="w",
    justify="left").pack(
        side="left",
         padx=10)
            ctk.CTkEntry(
    row2,
    textvariable=self.config_file_var,
    font=FONT_MID,
    state="readonly",
    width=400).pack(
        side="left",
        expand=True,
        fill="x",
         padx=5)
            # 美化的瀏覽按鈕
            browse_btn2 = ctk.CTkButton(
                row2,
                text="浏览...\nBrowse...",
                font=("Microsoft YaHei", 11, "bold"),
                command=self._select_config_file,
                corner_radius=8,
                hover_color="#1976d2",
                height=30
            )
            browse_btn2.pack(side="left", padx=5)
            # 下載按鈕區域 - 使用網格佈局
            btn_container = ctk.CTkFrame(c, fg_color="transparent")
            btn_container.pack(pady=30, padx=20)
            
            # 第一行：主要下載功能
            top_row = ctk.CTkFrame(btn_container, fg_color="transparent")
            top_row.pack(fill="x", pady=(0, 15))
            
            # 開始下載按鈕（左）
            GlowButton(
                top_row,
                text="開始下載\nStart Download",
                command=self._run_download,
                glow_color=ACCENT_BLUE,
                width=280,
                height=60
            ).pack(side="left", padx=(0, 15), expand=True, fill="both")

            # Amendment 下載按鈕（右）
            GlowButton(
                top_row,
                text="下載 Amendment\nDownload Amendments",
                command=self._run_download_amendments,
                glow_color="#ef4444",
                width=280,
                height=60
            ).pack(side="left", padx=(0, 0), expand=True, fill="both")
            
            # 第二行：Siahuat 訂單下載（跨越兩列）
            bottom_row = ctk.CTkFrame(btn_container, fg_color="transparent")
            bottom_row.pack(fill="x")
            
            # Siahuat 訂單下載按鈕（跨越整行）
            GlowButton(
                bottom_row,
                text="🏢 下載 Siahuat 訂單\nDownload Siahuat Orders",
                command=self._run_download_siahuat,
                glow_color="#FF6B35",
                width=575,
                height=60
            ).pack(expand=True, fill="x")
            
            # 扣分功能按钮
            f5_frame = ctk.CTkFrame(c, fg_color="transparent")
            f5_frame.pack(fill="both", expand=True, padx=50, pady=20)
            
            # 扣分功能标题
            f5_title = ctk.CTkLabel(
                f5_frame,
                text="扣分功能 / Deduction Function",
                font=("Microsoft YaHei", 16, "bold"),
                text_color="#dc2626"
            )
            f5_title.pack(pady=(0, 15))
            
            # 扣分文件选择 - 与上面的下载文件夹布局完全一致
            demerit_file_frame = ctk.CTkFrame(f5_frame, fg_color="transparent")
            demerit_file_frame.pack(fill="x", pady=15)

            ctk.CTkLabel(
                demerit_file_frame,
                text="扣分文件\nDemerit File:",
                font=FONT_MID,
                anchor="w",
                justify="left"
            ).pack(side="left", padx=10)

            ctk.CTkEntry(
                demerit_file_frame,
                textvariable=self.demerit_file_var,
                font=FONT_MID,
                state="readonly",
                width=400
            ).pack(
                side="left",
                expand=True,
                fill="x",
                padx=5
            )

            demerit_browse_btn = ctk.CTkButton(
                demerit_file_frame,
                text="浏览...\nBrowse...",
                font=("Microsoft YaHei", 11, "bold"),
                command=self._select_demerit_file,
                corner_radius=8,
                hover_color="#1976d2",
                height=30
            )
            demerit_browse_btn.pack(side="left", padx=5)
            
            # F5扣分按钮行 - 居中布局
            f5_btn_frame = ctk.CTkFrame(f5_frame, fg_color="transparent")
            f5_btn_frame.pack(fill="x")
            
            # 按钮容器 - 用于居中按钮
            button_center_frame = ctk.CTkFrame(f5_btn_frame, fg_color="transparent")
            button_center_frame.pack(expand=True)
            
            # 自动扣分按钮（检查周三12点后的订单）
            auto_f5_btn = ctk.CTkButton(
                button_center_frame,
                text="自动扣分\nAuto Deduction\n(检查周三12点后订单)",
                command=self._run_auto_f5_deduction,
                fg_color="#dc2626",
                hover_color="#b91c1c",
                width=300,
                height=50,
                font=("Microsoft YaHei", 12, "bold"),
                text_color="white",
                corner_radius=8
            )
            auto_f5_btn.pack(side="left", padx=(0, 10), pady=5)
            
            # 手动扣分按钮
            manual_f5_btn = ctk.CTkButton(
                button_center_frame,
                text="手动扣分\nManual Deduction",
                command=self._show_manual_f5_deduction,
                fg_color="#ea580c",
                hover_color="#c2410c",
                width=300,
                height=50,
                font=("Microsoft YaHei", 12, "bold"),
                text_color="white",
                corner_radius=8
            )
            manual_f5_btn.pack(side="left", padx=(10, 0), pady=5)
            
            # 确保"查看邮件内容"按钮始终显示，且更大

            def show_extracted_bodies():
                from tkinter import messagebox
                import os
                import tkinter as tk
                folder = self.download_folder_var.get()
                today = datetime.now()
                month_name = today.strftime('%b').title()
                week_of_month = get_week_of_month(today)
                save_path = os.path.join(folder, f"{month_name} - Week {week_of_month}")
                log_file = os.path.join(save_path, "email_bodies_log.txt")
                bodies = getattr(OutlookDownloader, 'extracted_bodies', [])
                if not bodies and os.path.exists(log_file):
                    with open(log_file, "r", encoding="utf-8") as f:
                        content = f.read()
                    bodies = content.split("\n\n——— 邮件 ") if content else []
                    if bodies and not bodies[0].startswith("——— 邮件 "):
                        bodies[0] = "——— 邮件 1 ———\n" + bodies[0]
                    bodies = [
    b if b.startswith("——— 邮件 ") else "——— 邮件 " +
     b for b in bodies]
                if not bodies:
                    messagebox.showinfo("无内容", "请先下载邮件，再查看邮件内容！")
                    return
                # 搜索功能
                win = tk.Toplevel(self)
                win.title("邮件内容提取结果/Extracted Email Bodies")
                win.geometry("900x700")
                search_var = tk.StringVar()

                def filter_bodies(keyword):
                    keyword = keyword.lower().strip()
                    if not keyword:
                        return bodies
                    result = []
                    for b in bodies:
                        if keyword in b.lower():
                            result.append(b)
                    return result
                # 美化顯示
                from tkinter import scrolledtext
                text_widget = scrolledtext.ScrolledText(win, wrap="word", font=(
                    "Microsoft JhengHei", 15), bg="#f1f5f9", fg="#22292f")
                text_widget.pack(
    fill="both",
    expand=True,
    padx=10,
    pady=(
        50,
         10))

                def update_display():
                    filtered = filter_bodies(search_var.get())
                    pretty = []
                    for idx, b in enumerate(filtered, 1):
                        lines = b.split("\n")
                        # 主題/發件人加粗，正文分隔線
                        pretty.append(f"\n{'=' * 40}\n")
                        for l in lines:
                            if l.startswith("[发件人]") or l.startswith("[主题]"):
                                pretty.append(f"{l}\n")
                            elif l.startswith("[内容]"):
                                pretty.append(f"\n{l}\n{'-' * 30}\n")
                            else:
                                pretty.append(f"{l}\n")
                    pretty_text = "".join(pretty)
                    text_widget.delete("1.0", "end")
                    text_widget.insert("1.0", pretty_text)

                def on_search(*args):
                    update_display()
                search_var.trace_add("write", on_search)
                search_entry = tk.Entry(
    win, textvariable=search_var, font=(
        "Microsoft JhengHei", 14))
                search_entry.place(x=10, y=10, width=400, height=32)
                search_entry.insert(0, "输入关键字搜索/Type to search...")

                def on_focus_in(event):
                    if search_entry.get() == "输入关键字搜索/Type to search...":
                        search_entry.delete(0, "end")
                search_entry.bind("<FocusIn>", on_focus_in)
                # 支持复制

                def copy_all():
                    import pyperclip
                    pretty = text_widget.get("1.0", "end-1c")
                    pyperclip.copy(pretty)
                    messagebox.showinfo("复制成功", "已复制全部邮件内容！")
                # 美化 Copy All 按鈕（小巧、圓角、亮綠、hover 深綠、字體適中）

                def on_enter(e):
                    btn.config(bg="#16a34a")

                def on_leave(e):
                    btn.config(bg="#22c55e")
                btn = tk.Button(
                    win,
                    text="复制全部内容\nCopy All",
                    command=copy_all,
                    bg="#22c55e",
                    fg="#fff",
                    font=("Microsoft JhengHei", 16, "bold"),
                    relief="ridge",
                    bd=2,
                    activebackground="#16a34a",
                    activeforeground="#fff",
                    cursor="hand2",
                    highlightthickness=1,
                    highlightbackground="#22d3ee"
                )
                btn.place(x=420, y=10, width=140, height=32)
                btn.bind("<Enter>", on_enter)
                btn.bind("<Leave>", on_leave)
                # 調整正文字體為14
                text_widget.config(font=("Microsoft JhengHei", 14))
                update_display()

        # 清空内容区
        for w in self.content_body.winfo_children():
            w.destroy()

        # 直接构建下载界面
        build(self.content_body)

    def show_checklist_ui(self):
        """显示检查表界面"""
        # 清空内容区
        for w in self.content_body.winfo_children():
            w.destroy()

        # 设置功能标题
        self.function_title.configure(text=t("checklist_title"))
        self.function_subtitle.configure(text=t("checklist_desc"))

        # 直接构建检查表界面
        def build(c):
            self.checklist_folder_var = ctk.StringVar()
            self.master_config_var = ctk.StringVar()

            # 创建表单框架
            form_frame = ctk.CTkFrame(c, fg_color="transparent")
            form_frame.pack(fill="both", expand=True, padx=50, pady=5)
            # 订单文件夹
            row1 = ctk.CTkFrame(form_frame)
            row1.pack(fill="x", pady=5)
            ctk.CTkLabel(
    row1,
    text="訂單文件夾\nOrder Folder:",
    font=FONT_BIGBTN).pack(
        side="left",
         padx=10)
            ctk.CTkEntry(
    row1,
    textvariable=self.checklist_folder_var,
    font=FONT_MID,
    state="readonly",
    width=250).pack(
        side="left",
        expand=True,
        fill="x",
         padx=5)
            checklist_browse_btn = ctk.CTkButton(
                row1,
                text=str(t("browse")),
                font=("Microsoft YaHei", 11, "bold"),
                command=self._select_checklist_folder,
                corner_radius=8,
                hover_color="#1976d2",
                height=30
            )
            checklist_browse_btn.pack(side="left", padx=5)
            # 统一配置文件
            row3 = ctk.CTkFrame(form_frame)
            row3.pack(fill="x", pady=5)
            ctk.CTkLabel(
    row3,
    text="統一配置文件\nMaster Config (Excel):",
    font=FONT_BIGBTN).pack(
        side="left",
         padx=10)
            ctk.CTkEntry(
    row3,
    textvariable=self.master_config_var,
    font=FONT_MID,
    state="readonly",
    width=250).pack(
        side="left",
        expand=True,
        fill="x",
         padx=5)
            checklist_config_browse_btn = ctk.CTkButton(
                row3,
                text="瀏覽...\nBrowse...",
                font=("Microsoft YaHei", 11, "bold"),
                command=lambda: self._select_config_file(
                    self.master_config_var, [("Excel files", "*.xlsx")]),
                corner_radius=8,
                hover_color="#1976d2",
                height=30
            )
            checklist_config_browse_btn.pack(side="left", padx=5)
            # 搜索區（永遠顯示）
            search_frame = ctk.CTkFrame(c, fg_color="transparent")
            search_frame.pack(fill="x", pady=5)
            # 移除搜尋範圍下拉選單
            # if not hasattr(self, 'checklist_search_scope_var'):
            #     self.checklist_search_scope_var = ctk.StringVar(value="全部")
            # scope_options = ["全部", "供應商", "分店"]
            # scope_menu = ctk.CTkOptionMenu(search_frame, variable=self.checklist_search_scope_var, values=scope_options, width=90, font=FONT_MID)
            # scope_menu.pack(side="left", padx=4)
            # Supplier 下拉選單
            if not hasattr(self, 'checklist_supplier_filter_var'):
                self.checklist_supplier_filter_var = ctk.StringVar(value="全部")
            if not hasattr(self, 'checklist_outlet_filter_var'):
                self.checklist_outlet_filter_var = ctk.StringVar(value="全部")

            def get_unique_suppliers():
                return ["全部"] + sorted(list({row["supplier"] for row in getattr(
                    self, '_checklist_table_data', []) if row["supplier"]}))

            def get_unique_outlets():
                return ["全部"] + sorted(list({row["outlet"] for row in getattr(
                    self, '_checklist_table_data', []) if row["outlet"]}))
            ctk.CTkLabel(
    search_frame,
    text="Supplier",
    font=(
        "Microsoft JhengHei",
        16,
        "bold"),
        text_color="#3b82f6").pack(
            side="left",
            padx=(
                0,
                 2))
            self.supplier_menu = ctk.CTkOptionMenu(
                search_frame, variable=self.checklist_supplier_filter_var, values=get_unique_suppliers(), width=140, font=("Microsoft JhengHei", 15, "bold"),
                fg_color="#3b82f6", button_color="#3b82f6", button_hover_color="#2563eb", text_color="#fff", corner_radius=16,
                command=lambda _: self._filter_checklist_table())
            self.supplier_menu.pack(side="left", padx=4)
            ctk.CTkLabel(
    search_frame,
    text="Outlet",
    font=(
        "Microsoft JhengHei",
        16,
        "bold"),
        text_color="#3b82f6").pack(
            side="left",
            padx=(
                10,
                 2))
            self.outlet_menu = ctk.CTkOptionMenu(
                search_frame, variable=self.checklist_outlet_filter_var, values=get_unique_outlets(), width=140, font=("Microsoft JhengHei", 15, "bold"),
                fg_color="#3b82f6", button_color="#3b82f6", button_hover_color="#2563eb", text_color="#fff", corner_radius=16,
                command=lambda _: self._filter_checklist_table())
            self.outlet_menu.pack(side="left", padx=4)
            ctk.CTkLabel(
    search_frame,
    text="搜索/Filter:",
    font=(
        "Microsoft JhengHei",
        15,
        "bold"),
        text_color="#3b82f6").pack(
            side="left",
             padx=6)
            if not hasattr(self, 'checklist_search_var'):
                self.checklist_search_var = ctk.StringVar()
            search_entry = ctk.CTkEntry(
    search_frame,
    textvariable=self.checklist_search_var,
    font=(
        "Microsoft JhengHei",
        14),
        width=180,
        corner_radius=10,
        border_width=2,
         border_color="#3b82f6")
            search_entry.pack(side="left", padx=4)
            search_entry.bind("<KeyRelease>",
     lambda e: self._filter_checklist_table())

            def set_search_keyword(keyword):
                self.checklist_search_var.set(keyword)
                self._filter_checklist_table()
            ctk.CTkButton(
                search_frame, text="Missing", width=90, height=34, font=("Microsoft JhengHei", 15, "bold"),
                fg_color="#2563eb", hover_color="#60a5fa", text_color="#fff", corner_radius=16, border_width=2, border_color="#fff",
                command=lambda: self._search_missing_orders()
            ).pack(side="left", padx=6)
            ctk.CTkButton(
                search_frame, text="Mismatch", width=100, height=34, font=("Microsoft JhengHei", 15, "bold"),
                fg_color="#f59e42", hover_color="#fbbf24", text_color="#fff", corner_radius=16, border_width=2, border_color="#fff",
                command=lambda: set_search_keyword("mismatch")
            ).pack(side="left", padx=6)
            # 新增兩個快速搜尋按鈕
            ctk.CTkButton(
                search_frame, text="X 實際并沒有訂單", width=160, height=34, font=("Microsoft JhengHei", 15, "bold"),
                fg_color="#0ea5e9", hover_color="#38bdf8", text_color="#fff", corner_radius=16, border_width=2, border_color="#fff",
                command=lambda: self._search_crosscheck_email_no_actual()
            ).pack(side="left", padx=6)
            ctk.CTkButton(
                search_frame, text="X Email 并沒有下單", width=170, height=34, font=("Microsoft JhengHei", 15, "bold"),
                fg_color="#10b981", hover_color="#34d399", text_color="#fff", corner_radius=16, border_width=2, border_color="#fff",
                command=lambda: self._search_crosscheck_actual_no_email()
            ).pack(side="left", padx=6)
            # 表格區（永遠顯示，沒資料時顯示空表格）
            table_frame = ctk.CTkFrame(c, fg_color="transparent")
            table_frame.pack(fill="both", expand=True, padx=10, pady=10)
            import tkinter.ttk as ttk
            style = ttk.Style()
            style.theme_use('default')
            style.configure(
    "Custom.Treeview",
    background="#1e293b",
    fieldbackground="#1e293b",
    foreground="#e2e8f0",
    rowheight=28,
    font=(
        "Microsoft JhengHei",
         12))
            style.configure(
    "Custom.Treeview.Heading",
    background="#334155",
    foreground="#60a5fa",
    font=(
        "Microsoft JhengHei",
        13,
         "bold"))
            style.map("Custom.Treeview", background=[('selected', '#334155')])
            if not hasattr(self, 'checklist_table'):
                self.checklist_table = None
            self.checklist_table = ttk.Treeview(
                table_frame,
                columns=("supplier", "outlet", "cover_status", "remark"),
                show="headings",
                height=8,
                style="Custom.Treeview"
            )
            col_labels = [
                ("supplier", "供應商/Supplier"),
                ("outlet", "分店/Outlet"),
                ("cover_status", "覆蓋狀態/Cover"),
                ("remark", "備註/Remark")
            ]
            for col, label in col_labels:
                self.checklist_table.heading(col, text=label)
                self.checklist_table.column(
    col, width=140 if col != "remark" else 300, anchor="center")
            self.checklist_table.pack(fill="both", expand=True)
            self.checklist_table.bind(
    "<Double-1>", self._on_checklist_row_double_click)
            # 複製/匯出按鈕（永遠顯示）
            btn_frame = ctk.CTkFrame(c, fg_color="transparent")
            btn_frame.pack(pady=10)
            btns = [
                ("F5修正扣分\nF5 Fix & Deduct", self._fix_f5_mismatch, "#dc2626"),
                ("查看必要門市\nView Required Outlets",
                 self._show_required_outlets_window, "#8b5cf6"),
                ("交叉檢查\nCross Check", self._run_cross_check_and_update_remarks, "#f59e42"),
            ]
            for txt, cmd, color in btns:
                GlowButton(
                    btn_frame,
                    text=txt,
                    command=cmd,
                    width=90,
                    height=28,
                    glow_color=color
                ).pack(side="left", padx=4, pady=2)
            for col in range(2):
                btn_frame.grid_columnconfigure(col, weight=1)
            # Run Check 按鈕（大、中文在上英文在下，置中，永遠顯示）
            run_btn_frame = ctk.CTkFrame(c, fg_color="transparent")
            run_btn_frame.pack(fill="x", pady=15)
            GlowButton(
                run_btn_frame,
                text="執行檢查\nRun Check",
                command=self._run_enhanced_checklist,
                width=200,
                height=56,
                glow_color="#a78bfa"
            ).pack(anchor="center")
            # 初始化表格數據
            if not hasattr(self, '_checklist_table_data'):
                self._checklist_table_data = []
            self._refresh_checklist_table()

        # 调用build函数构建界面
        build(self.content_body)

    def _run_enhanced_checklist(self):
        folder = self.checklist_folder_var.get()
        master_config = self.master_config_var.get()
        if not folder or not master_config:
            messagebox.showwarning(t("warning"), t("folder_warning"))
            return
        config_mgr = UnifiedConfigManager(master_config)
        checker = EnhancedOrderChecker(config_mgr)
        table = checker.run_checklist(folder, as_table=True)
        self._checklist_table_data = table
        self._refresh_checklist_table()
        # 自动执行交叉检查并直接将结果写入主表的备注，无需额外弹窗
        try:
            result = self._run_cross_check_email_log()
            if result:
                cross_check_data, _email_content = result
                self._update_checklist_remarks(cross_check_data)
        except Exception:
            # 交叉检查失败时不阻断主流程
            pass

    def _refresh_checklist_table(self):
        # 清空表格
        for row in self.checklist_table.get_children():
            self.checklist_table.delete(row)
        # 插入數據
        for row in self._checklist_table_data:
            values = (
    row["supplier"],
    row["outlet"],
    row["cover_status"],
     row["remark"])
            self.checklist_table.insert("", "end", values=values)

    def _filter_checklist_table(self):
        keyword = self.checklist_search_var.get().lower()
        scope = getattr(self, 'checklist_search_scope_var', None)
        scope_val = scope.get() if scope else "全部"
        supplier_val = getattr(self, 'checklist_supplier_filter_var', None)
        supplier_selected = supplier_val.get() if supplier_val else "全部"
        outlet_val = getattr(self, 'checklist_outlet_filter_var', None)
        outlet_selected = outlet_val.get() if outlet_val else "全部"

        def normalize(text):
            import re
            return re.sub(r'[^a-zA-Z0-9]', '', str(text)).lower()
        norm_keyword = normalize(keyword)

        def row_match(row):
            # 供應商/門市下拉選單
            if supplier_selected != "全部" and row["supplier"] != supplier_selected:
                return False
            if outlet_selected != "全部" and row["outlet"] != outlet_selected:
                return False
            # 搜尋範圍
            if not norm_keyword:
                return True
            if scope_val == "全部":
                # 供應商、分店用規範化比對；狀態與備註用小寫包含（保留空白與中文字）
                return (
                    norm_keyword in normalize(row["supplier"]) or
                    norm_keyword in normalize(row["outlet"]) or
                    (keyword in str(row["cover_status"]).lower()) or
                    (keyword in str(row["remark"]).lower())
                )
            elif scope_val == "供應商":
                return norm_keyword in normalize(row["supplier"]) 
            elif scope_val == "分店":
                return norm_keyword in normalize(row["outlet"])
            return True
        filtered = [
    row for row in self._checklist_table_data if row_match(row)]
        for row in self.checklist_table.get_children():
            self.checklist_table.delete(row)
        for row in filtered:
            values = (
    row["supplier"],
    row["outlet"],
    row["cover_status"],
     row["remark"])
            self.checklist_table.insert("", "end", values=values)
        # 動態刷新下拉選單內容
        if hasattr(self, 'supplier_menu'):
            current = self.checklist_supplier_filter_var.get()
            suppliers = ["全部"] + sorted(list({row["supplier"]
                                        for row in self._checklist_table_data if row["supplier"]}))
            self.supplier_menu.configure(values=suppliers)
            if current not in suppliers:
                self.checklist_supplier_filter_var.set("全部")
        if hasattr(self, 'outlet_menu'):
            current = self.checklist_outlet_filter_var.get()
            outlets = ["全部"] + sorted(list({row["outlet"]
                                      for row in self._checklist_table_data if row["outlet"]}))
            self.outlet_menu.configure(values=outlets)
            if current not in outlets:
                self.checklist_outlet_filter_var.set("全部")

    def _copy_checklist_table(self):
        import pyperclip
        rows = ["\t".join(["供应商", "分店", "覆蓋狀態", "備註"])]
        for row in self._checklist_table_data:
            rows.append("\t".join([str(row["supplier"]), str(
                row["outlet"]), str(row["cover_status"]), str(row["remark"])]))
        pyperclip.copy("\n".join(rows))
        messagebox.showinfo("複製成功", "報表已複製到剪貼簿！")

    def _fix_f5_mismatch(self):
        """F5 修正和自動扣分功能"""
        from tkinter import messagebox

        # 檢查是否有 checklist 數據
        if not hasattr(
    self,
     '_checklist_table_data') or not self._checklist_table_data:
            messagebox.showwarning("警告", "請先執行檢查以獲取數據。")
            return

        # 找出所有 mismatch 記錄
        mismatch_records = []
        for record in self._checklist_table_data:
            if "mismatch" in record.get("remark", "").lower():
                mismatch_records.append(record)

        if not mismatch_records:
            messagebox.showinfo("提示", "沒有發現 mismatch 錯誤需要修正。")
            return

        # 打開 F5 修正和自動扣分窗口（包含文件選擇功能）
        F5FixAndDeductWithFileWindow(self, mismatch_records)

    def _on_checklist_row_double_click(self, event):
        item = self.checklist_table.selection()
        if not item:
            return
        values = self.checklist_table.item(item[0], "values")
        supplier = values[0]
        outlet = values[1]
        cover_status = values[2]
        remark = values[3]

        # 檢查是否為 mismatch 錯誤
        if "mismatch" in remark.lower():
            self._show_mismatch_correction_dialog(
                supplier, outlet, cover_status, remark)
        else:
            detail = f"供应商: {supplier}\n分店: {outlet}\n覆蓋狀態: {cover_status}\n備註: {remark}"
            ScrollableMessageBox(self, "详细信息", detail)

    def _show_mismatch_correction_dialog(
    self, supplier, outlet, cover_status, remark):
        """顯示 mismatch 修正對話框"""
        dialog = MismatchCorrectionDialog(
    self, supplier, outlet, cover_status, remark)
        self.wait_window(dialog)

    def show_automation_ui(self):
        """显示自动化界面"""
        # 清空内容区
        for w in self.content_body.winfo_children():
            w.destroy()

        # 设置功能标题
        self.function_title.configure(text=t("automation_title"))
        self.function_subtitle.configure(text=t("automation_desc"))

        def build(c):
            import os
            import traceback
            from datetime import datetime, timedelta
            import openpyxl
            self.folder_vars = {}
            self.master_config_var = ctk.StringVar()

            # 创建表单框架
            form_frame = ctk.CTkFrame(c, fg_color="transparent")
            form_frame.pack(
    side="top",
    fill="x",
    expand=False,
    padx=30,
     pady=10)
            # 只保留一組 Supplier Folder 欄位
            folders = [
                ("source_folder", "來源資料夾\nSource Folder (Weekly Orders)"),
                ("supplier_folder", "供應商文件夾\nSupplier Folder")
            ]
            for key, label in folders:
                row = ctk.CTkFrame(form_frame)
                row.pack(fill="x", pady=8)
                var = ctk.StringVar()
                self.folder_vars[key] = var
                ctk.CTkLabel(
    row,
    text=label,
    font=(
        "Microsoft JhengHei",
        12,
        "bold"),
        anchor="w",
        justify="left").pack(
            side="left",
             padx=8)
                ctk.CTkEntry(
    row,
    textvariable=var,
    font=FONT_MID,
    state="readonly",
    width=400).pack(
        side="left",
        expand=True,
        fill="x",
         padx=5)
                # 美化的瀏覽按鈕
                automation_browse_btn = ctk.CTkButton(
                    row,
                    text="瀏覽...\nBrowse...",
                    font=("Microsoft YaHei", 11, "bold"),
                    command=lambda k=key: self._select_folder(k),
                    corner_radius=8,
                    hover_color="#1976d2",
                    height=30
                )
                automation_browse_btn.pack(side="left", padx=5)
            # 统一配置文件
            row3 = ctk.CTkFrame(form_frame)
            row3.pack(fill="x", pady=8)
            ctk.CTkLabel(
    row3, text="統一配置文件\nMaster Config (Excel):", font=(
        "Microsoft JhengHei", 12, "bold")).pack(
            side="left", padx=8)
            ctk.CTkEntry(
    row3,
    textvariable=self.master_config_var,
    font=FONT_MID,
    state="readonly",
    width=400).pack(
        side="left",
        expand=True,
        fill="x",
         padx=5)
            # 美化的瀏覽按鈕
            automation_config_browse_btn = ctk.CTkButton(
                row3,
                text=t("browse"),
                font=("Microsoft YaHei", 11, "bold"),
                command=lambda: self._select_config_file(
                    self.master_config_var, [("Excel files", "*.xlsx")]),
                corner_radius=8,
                hover_color="#1976d2",
                height=30
            )
            automation_config_browse_btn.pack(side="left", padx=5)
            # 開始自動化按鈕
            btn_frame = ctk.CTkFrame(form_frame, fg_color="transparent")
            btn_frame.pack(pady=(15, 0))

            # 創建水平排列的按鈕容器
            button_row = ctk.CTkFrame(btn_frame, fg_color="transparent")
            button_row.pack(anchor="center")

            # 左邊按鈕：Amendment Order 整合改單
            GlowButton(
                button_row,
                text="整合改單\nAmendment Order",
                command=self._run_yellow_highlighted_automation,
                width=280,
                height=50,
                glow_color="#f59e0b",
                corner_radius=18
            ).pack(side="left", padx=(0, 10))

            # 右邊按鈕：Consolidate Order 整合訂單
            GlowButton(
                button_row,
                text="整合訂單\nConsolidate Order",
                command=self._run_enhanced_automation,
                width=280,
                height=50,
                glow_color="#22c55e",
                corner_radius=18
            ).pack(side="left")
            # ========== 補單區塊（移到上面） ==========
            append_frame = ctk.CTkFrame(
    c, fg_color=DARK_PANEL, corner_radius=16)
            append_frame.pack(
    side="top",
    fill="x",
    expand=False,
    padx=30,
    pady=(
        8,
         0))
            ctk.CTkLabel(
                append_frame,
                text="補加門市訂單\nAppend Outlet Order",
                font=("Microsoft JhengHei", 12, "bold"),
                text_color=ACCENT_BLUE,
                anchor="w",
                justify="left"
            ).pack(anchor="w", padx=8, pady=(8, 3))
            # 選擇要補的門市訂單檔案（可多選）
            self.append_outlet_files_var = ctk.StringVar()
            # ===== 檔案清單顯示區 =====

            def select_append_files():
                from tkinter import filedialog
                files = filedialog.askopenfilenames(
                    title="選擇要補的門市訂單/Select Outlet Order Files",
                    filetypes=[("Excel files", "*.xlsx")]
                )
                if files:
                    # 顯示文件名而不是完整路徑，用分號分隔
                    file_names = [os.path.basename(f) for f in files]
                    self.append_outlet_files_var.set(";".join(file_names))
                    # 保存完整路徑供後續使用
                    self.append_outlet_full_paths = files
            rowa = ctk.CTkFrame(append_frame)
            rowa.pack(fill="x", pady=3)
            ctk.CTkLabel(
    rowa,
    text="選擇要補的門市訂單檔案\nSelect Outlet Order Files:",
    font=(
        "Microsoft JhengHei",
        11)).pack(
            side="left",
             padx=8)
            ctk.CTkEntry(
    rowa,
    textvariable=self.append_outlet_files_var,
    font=FONT_MID,
    state="readonly",
    width=400).pack(
        side="left",
        expand=True,
        fill="x",
         padx=5)
            # 美化的瀏覽按鈕（統一樣式）
            browse_btn_a = ctk.CTkButton(
                rowa,
                text="浏览...\nBrowse...",
                font=("Microsoft YaHei", 11, "bold"),
                command=select_append_files,
                corner_radius=8,
                hover_color="#1976d2",
                height=30
            )
            browse_btn_a.pack(side="left", padx=5)
            # 選擇已整合的Supplier檔案資料夾
            self.append_supplier_folder_var = ctk.StringVar()
            rowb = ctk.CTkFrame(append_frame)
            rowb.pack(fill="x", pady=3)
            ctk.CTkLabel(
    rowb,
    text="選擇已整合的Supplier檔案資料夾\nSelect Supplier Folder:",
    font=(
        "Microsoft JhengHei",
        11)).pack(
            side="left",
             padx=8)
            ctk.CTkEntry(
    rowb,
    textvariable=self.append_supplier_folder_var,
    font=FONT_MID,
    state="readonly",
    width=400).pack(
        side="left",
        expand=True,
        fill="x",
         padx=5)
            # 美化的瀏覽按鈕

            def select_append_supplier_folder():
                from tkinter import filedialog
                folder = filedialog.askdirectory(
    title="選擇已整合的Supplier資料夾/Select Integrated Supplier Folder")
                if folder:
                    self.append_supplier_folder_var.set(folder)
            browse_btn_b = ctk.CTkButton(
                rowb,
                text="浏览...\nBrowse...",
                font=("Microsoft YaHei", 11, "bold"),
                command=select_append_supplier_folder,
                corner_radius=8,
                hover_color="#1976d2",
                height=30
            )
            browse_btn_b.pack(side="left", padx=5)
            # 補單主按鈕（GlowButton 樣式，與 Summary/Automation 一致）
            # 補單主按鈕（GlowButton 樣式，與 Summary/Automation 一致）
            # 全新補單流程：覆蓋整個廠商sheet
            GlowButton(
                append_frame,
                text="補加門市訂單\nAppend Outlet Order",
                command=self.run_new_append_orders,
                width=300,
                height=40,
                glow_color=ACCENT_BLUE,
                corner_radius=18
            ).pack(pady=(8, 0))

            # ========== 產生 Summary 區塊 ==========
            summary_frame = ctk.CTkFrame(
    c, fg_color=DARK_PANEL, corner_radius=16)
            summary_frame.pack(
    side="top",
    fill="x",
    expand=False,
    padx=30,
    pady=(
        8,
         0))
            ctk.CTkLabel(
    summary_frame,
    text="產生 Summary Sheet\nGenerate Summary Sheet",
    font=(
        "Microsoft JhengHei",
        12,
        "bold"),
        text_color=ACCENT_GREEN,
        anchor="w",
        justify="left").pack(
            anchor="w",
            padx=8,
            pady=(
                8,
                 3))
            self.summary_supplier_files_var = ctk.StringVar()

            def select_summary_files():
                from tkinter import filedialog
                files = filedialog.askopenfilenames(
    title="選擇要產生 Summary 的 Supplier 檔案/Select Supplier Files",
    filetypes=[
        ("Excel files",
         "*.xlsx")])
                if files:
                    self.summary_supplier_files_var.set(";".join(files))
            row_sum = ctk.CTkFrame(summary_frame)
            row_sum.pack(fill="x", pady=3)
            ctk.CTkLabel(
    row_sum,
    text="選擇 Supplier 檔案\nSelect Supplier Files:",
    font=(
        "Microsoft JhengHei",
        11)).pack(
            side="left",
             padx=8)
            ctk.CTkEntry(
    row_sum,
    textvariable=self.summary_supplier_files_var,
    font=FONT_MID,
    state="readonly",
    width=400).pack(
        side="left",
        expand=True,
        fill="x",
         padx=5)
            browse_btn_sum = ctk.CTkButton(
                row_sum,
                text="浏览...\nBrowse...",
                font=("Microsoft YaHei", 11, "bold"),
                command=select_summary_files,
                corner_radius=8,
                hover_color="#1976d2",
                height=30
            )
            browse_btn_sum.pack(side="left", padx=5)

            import re
            from dateutil.parser import parse

            def create_supplier_summary(filepath):
                print("[DEBUG] 開始產生 summary (產品名+公式行數量主流程)...")
                import openpyxl
                from openpyxl.styles import Alignment, Font, PatternFill, Border, Side
                from openpyxl.utils import get_column_letter
                from datetime import datetime, timedelta

                # 為了避免外部引用錯誤，我們將使用計算值而不是公式
                print("[DEBUG] 使用計算值方式避免外部引用錯誤...")

                def safe_save_workbook(workbook, file_path):
                    """安全保存工作簿，使用全局安全保存函數"""
                    return safe_save_excel_workbook(workbook, file_path)
                # 取得下週一到下週日日期
                today = datetime.now().date()
                this_monday = today - timedelta(days=today.weekday())
                next_monday = this_monday + timedelta(days=7)
                next_sunday = next_monday + timedelta(days=6)
                week_dates = [(next_monday + timedelta(days=i))
                               for i in range(7)]  # 包含週日
                week_days = [d.strftime('%a') for d in week_dates]
                week_dates_str = [d.strftime('%d-%b') for d in week_dates]
                wb = openpyxl.load_workbook(
    filepath, data_only=True, keep_links=False)
                product_map = {}  # (eng, chi) -> {short: (full, [qtys...])}
                all_outlets = set()
                for sheet in wb.sheetnames:
                    if sheet in ("Sheet", "Summary"):
                        continue
                    ws = wb[sheet]
                    if ws.sheet_state != "visible":
                        continue
                    short_name = sheet
                    full_name = ws["F5"].value if ws["F5"].value else sheet
                    all_outlets.add((short_name, full_name))
                    last_row = ws.max_row
                    row = 1
                    while row <= last_row:
                        val = ws.cell(row=row, column=2).value  # B欄
                        if val and "description" in str(val).strip().lower():
                            date_row_idx = row  # 日期列和 Description 同一行
                            date_cols = list(range(6, 13))  # F~L (包含週日)
                            # 解析日期列
                            date_vals = []
                            for col in date_cols:
                                cell_val = ws.cell(
    row=date_row_idx, column=col).value
                                try:
                                    if isinstance(cell_val, str):
                                        date_val = datetime.strptime(
                                            cell_val.strip(), "%d-%b")
                                        date_val = date_val.replace(
                                            year=next_monday.year)
                                        date_vals.append(date_val.date())
                                    elif isinstance(cell_val, datetime):
                                        date_vals.append(cell_val.date())
                                    else:
                                        date_vals.append(None)
                                except Exception:
                                    date_vals.append(None)
                            print(
    f"[DEBUG] sheet={sheet}, row={row}, date_row_idx={date_row_idx}, date_vals={date_vals}, next_monday={next_monday}, next_sunday={next_sunday}")
                            # 判斷這一區塊是否屬於下週
                            if not any(
    d and next_monday <= d <= next_sunday for d in date_vals):
                                row += 1
                                continue
                            # 產品行從 row+1 開始，直到遇到空白或 sub-total
                            prod_row = row + 1
                            while prod_row <= last_row:
                                eng = ws.cell(row=prod_row, column=2).value
                                chi = ws.cell(row=prod_row, column=3).value
                                if not eng or str(eng).strip() == "" or str(
                                    eng).strip().lower().startswith("="):
                                    break
                                if "sub-total" in str(eng).lower():
                                    prod_row += 1
                                    continue
                                qtys = []
                                # 動態確定這個廠商的日期範圍
                                valid_dates = [
    d for d in date_vals if d and next_monday <= d <= next_sunday]
                                # 預設7天，但根據實際日期調整
                                max_days = len(
                                    valid_dates) if valid_dates else 7

                                for idx, col in enumerate(date_cols):
                                    val = ws.cell(
    row=prod_row, column=col).value
                                    if date_vals[idx] and next_monday <= date_vals[idx] <= next_sunday:
                                        try:
                                            if val is None or (isinstance(
                                                val, str) and val.strip() == ""):
                                                qty = 0.0
                                            else:
                                                qty = float(val)
                                        except Exception:
                                            qty = 0.0
                                        qtys.append(qty)
                                    else:
                                        qtys.append(0.0)

                                # 如果這個廠商只有6天資料，確保qtys陣列長度為6
                                if len(valid_dates) == 6:
                                    qtys = qtys[:6]  # 只保留前6天的資料
                                key = (eng, chi)
                                if key not in product_map:
                                    product_map[key] = {}
                                product_map[key][short_name] = (
                                    full_name, qtys)
                                prod_row += 1
                            row = prod_row
                        else:
                            row += 1
                # 建立 summary sheet ... (後續不變)
                # 建立 summary sheet
                if "Summary" in wb.sheetnames:
                    del wb["Summary"]
                ws_sum = wb.create_sheet("Summary")
                # 樣式
                header_fill = PatternFill("solid", fgColor="B7B7E1")
                date_fill = PatternFill("solid", fgColor="C6E0B4")
                center = Alignment(horizontal="center", vertical="center")
                bold = Font(bold=True)
                thin = Side(border_style="thin", color="000000")
                border = Border(left=thin, right=thin, top=thin, bottom=thin)
                # 寫入每個產品區塊，橫向排列，最多3個一排，超過自動換行
                col_offset = 2
                row_offset = 2
                products = list(product_map.items())
                max_per_row = 3
                for idx, ((eng, chi), outlet_map) in enumerate(products):
                    block_idx = idx % max_per_row
                    block_row = idx // max_per_row
                    start_col = col_offset + block_idx * 9
                    start_row = row_offset + block_row * \
                        (len(all_outlets) + 7)  # 7: 標題+欄+日期+TOTAL+空白
                    # 動態確定這個產品區塊的實際天數
                    actual_days = 7  # 預設7天
                    for short, full in sorted(all_outlets):
                        qtys = outlet_map.get(short, (full, [0] * 7))[1]
                        if qtys and len(qtys) == 6:  # 如果發現有6天的資料
                            actual_days = 6
                            break

                    # 標題合併（根據實際天數調整）
                    merge_end_col = start_col + actual_days + \
                        1  # +1 是因為有 Short Name 和 Full Name 兩欄
                    ws_sum.merge_cells(
    start_row=start_row,
    start_column=start_col,
    end_row=start_row,
     end_column=merge_end_col)
                    ws_sum.cell(
    row=start_row,
    column=start_col,
     value=eng).fill = header_fill
                    ws_sum.cell(
    row=start_row,
    column=start_col,
     value=eng).font = bold
                    ws_sum.cell(
    row=start_row,
    column=start_col,
     value=eng).alignment = center
                    ws_sum.merge_cells(
    start_row=start_row + 1,
    start_column=start_col,
    end_row=start_row + 1,
     end_column=merge_end_col)
                    ws_sum.cell(
    row=start_row + 1,
    column=start_col,
     value=chi).fill = header_fill
                    ws_sum.cell(
    row=start_row + 1,
    column=start_col,
     value=chi).font = bold
                    ws_sum.cell(
    row=start_row + 1,
    column=start_col,
     value=chi).alignment = center
                    # 欄標題
                    ws_sum.cell(
    row=start_row + 2,
    column=start_col,
     value="Short Name").font = bold
                    ws_sum.cell(
    row=start_row + 2,
    column=start_col + 1,
     value="Full Name").font = bold
                    # Full Name 欄寬
                    ws_sum.column_dimensions[get_column_letter(
                        start_col + 1)].width = 34.71
                    # 根據實際天數生成日期標題
                    for i in range(actual_days):
                        c = start_col + 2 + i
                        if i < len(week_days) and i < len(week_dates_str):
                            wd = week_days[i]
                            dt = week_dates_str[i]
                        ws_sum.cell(
    row=start_row + 2,
    column=c,
     value=wd).fill = date_fill
                        ws_sum.cell(
    row=start_row + 3,
    column=c,
     value=dt).fill = date_fill
                        ws_sum.cell(row=start_row + 2, column=c,
                                    value=wd).alignment = center
                        ws_sum.cell(row=start_row + 3, column=c,
                                    value=dt).alignment = center
                    ws_sum.cell(
    row=start_row + 3,
    column=start_col,
     value="").fill = date_fill
                    ws_sum.cell(
    row=start_row + 3,
    column=start_col + 1,
     value="").fill = date_fill
                    # 分店資料（所有分店都列出，沒數量填0）
                    row_idx = start_row + 4
                    for short, full in sorted(all_outlets):
                        qtys = outlet_map.get(
    short, (full, [0] * 7))[1]  # 預設7天
                        if all(q == 0 or q == None for q in qtys):
                            continue  # 跳過全為0的分店
                        ws_sum.cell(row=row_idx, column=start_col, value=short)
                        ws_sum.cell(
    row=row_idx, column=start_col + 1, value=full)
                        for i, qty in enumerate(qtys):
                            ws_sum.cell(
    row=row_idx,
    column=start_col + 2 + i,
    value=(
        qty if qty not in (
            0,
             None) else ''))
                        row_idx += 1
                    # TOTAL 行
                    ws_sum.cell(
    row=row_idx,
    column=start_col,
     value="TOTAL").font = bold
                    # 動態確定這個產品區塊的實際天數
                    actual_days = 7  # 預設7天
                    for short, full in sorted(all_outlets):
                        qtys = outlet_map.get(short, (full, [0] * 7))[1]
                        if qtys and len(qtys) == 6:  # 如果發現有6天的資料
                            actual_days = 6
                            break

                    for i in range(actual_days):  # 根據實際天數
                        # 計算該列的總和，避免使用公式以防止外部引用錯誤
                        total_value = 0
                        for short, full in sorted(all_outlets):
                            qtys = outlet_map.get(short, (full, [0] * 7))[1]
                            if qtys and not all(
    q == 0 or q == None for q in qtys):
                                if i < len(qtys):
                                    qty = qtys[i]
                                    if isinstance(
    qty, (int, float)) and qty > 0:
                                        total_value += qty

                        ws_sum.cell(
    row=row_idx,
    column=start_col + 2 + i,
     value=total_value)
                        ws_sum.cell(
    row=row_idx, column=start_col + 2 + i).font = bold
                        ws_sum.cell(
    row=row_idx,
    column=start_col +
    2 +
     i).alignment = center
                    # 格式化區塊
                    for r in range(start_row, row_idx + 1):
                        for c in range(
    start_col,
     start_col + actual_days + 2):  # +2 是因為有 Short Name 和 Full Name 兩欄
                            ws_sum.cell(row=r, column=c).border = border
                # 使用安全的方法將 Summary 移到第一個位置
                print(f"[DEBUG] 重新排列工作表順序...")
                try:
                    # 獲取所有工作表名稱
                    sheet_names = wb.sheetnames
                    # 移除 Summary 工作表
                    if "Summary" in sheet_names:
                        sheet_names.remove("Summary")
                    # 將 Summary 放在第一位
                    new_order = ["Summary"] + sheet_names
                    
                    # 使用 openpyxl 的安全方法重新排列
                    wb._sheets.sort(key=lambda x: new_order.index(x.title) if x.title in new_order else 999)
                    print(f"[DEBUG] 工作表重新排列完成")
                except Exception as reorder_error:
                    print(f"[DEBUG] 工作表重新排列失敗，繼續保存: {reorder_error}")

                # 總是使用安全保存方法，避免命名範圍問題
                print(f"[DEBUG] 使用安全保存方法避免命名範圍問題...")
                safe_save_workbook(wb, filepath)
                print(f"[DEBUG] 已寫入 Summary sheet: {filepath}")

            def run_generate_summary():
                from tkinter import messagebox
                import traceback
                import tempfile
                import shutil
                import os

                file_list = self.summary_supplier_files_var.get().split(";")
                file_list = [f for f in file_list if f.strip()]
                if not file_list:
                    messagebox.showwarning(
    "未選擇檔案", "請先選擇要產生 Summary 的 Supplier 檔案！")
                    return
                for file_path in file_list:
                    try:
                        print(f"[DEBUG] 嘗試讀取: {file_path}")
                        # xlwings 只能處理未加密的 xlsx
                        # 若加密，先解密到暫存檔
                        tmp_path = None
                        try:
                            create_supplier_summary(file_path)
                        except Exception as e:
                            print(f"[DEBUG] 直接處理失敗，嘗試解密: {e}")
                            try:
                                import msoffcrypto
                            except ImportError:
                                messagebox.showerror(
                                    "缺少解密模組",
                                    "檔案可能已加密且未安裝解密套件。請先安裝 msoffcrypto-tool:\n\n pip install msoffcrypto-tool"
                                )
                                continue
                            try:
                                with open(file_path, "rb") as f:
                                    office_file = msoffcrypto.OfficeFile(f)
                                    office_file.load_key(password="Apple")
                                    with tempfile.NamedTemporaryFile(delete=False, suffix=".xlsx") as tmp:
                                        office_file.decrypt(tmp)
                                        tmp_path = tmp.name
                                create_supplier_summary(tmp_path)
                                # 覆蓋原檔
                                shutil.copyfile(tmp_path, file_path)
                                os.remove(tmp_path)
                            except Exception as de:
                                messagebox.showerror(
    "解密失敗", f"無法解密或處理檔案：{file_path}\n{de}")
                                continue
                        print(f"[DEBUG] 已寫入: {file_path}")
                    except Exception as e:
                        import traceback
                        messagebox.showerror(
    "錯誤", f"處理檔案 {file_path} 時發生錯誤：\n{
        str(e)}\n{
            traceback.format_exc()}")
                        print(f"[DEBUG] 發生錯誤: {e}")
                        continue
                messagebox.showinfo("完成", "Summary 已成功產生並插入到所選檔案！")

            GlowButton(
                summary_frame,
                text="產生 Summary\nGenerate Summary",
                command=run_generate_summary,
                width=300,
                height=40,
                glow_color="#8B5CF6"  # 改為更好看的紫色
            ).pack(pady=(8, 0))

        # 清空内容区
        for w in self.content_body.winfo_children():
            w.destroy()

        # 直接构建自动化界面
        build(self.content_body)

    def _is_valid_date_for_append(
    self,
    cell_value,
    next_week_start,
     next_week_end):
        """检查是否为有效的下周日期（用于补单功能）"""
        try:
            if isinstance(cell_value, (int, float)):
                # Excel日期从1900年1月1日开始计算
                base_date = datetime(1900, 1, 1)
                # 减去2是因为Excel的日期系统有个bug（1900年被认为是闰年）
                parsed = base_date + timedelta(days=int(cell_value) - 2)
                return next_week_start <= parsed.date() <= next_week_end
            elif isinstance(cell_value, str):
                sval = cell_value.strip()
                # 匹配 "18-Aug" 格式
                if re.match(r"^\d{1,2}-[A-Za-z]{3,}$", sval):
                    # 添加当前年份
                    year = next_week_start.year
                    sval = f"{sval}-{year}"
                    parsed = datetime.strptime(sval, "%d-%b-%Y")
                    return next_week_start <= parsed.date() <= next_week_end
                # 匹配 "18-Aug-2025" 格式
                elif re.match(r"^\d{1,2}-[A-Za-z]{3,}-\d{4}$", sval):
                    parsed = datetime.strptime(sval, "%d-%b-%Y")
                    return next_week_start <= parsed.date() <= next_week_end
                # 匹配 "2025-08-18" 格式
                elif re.match(r"^\d{4}-\d{2}-\d{2}$", sval):
                    parsed = datetime.strptime(sval, "%Y-%m-%d")
                    return next_week_start <= parsed.date() <= next_week_end
            return False
        except Exception as e:
            print(f"日期解析失败: {cell_value}, 错误: {e}")
            return False

    def _show_append_results(self, results):
        """显示补单详细结果窗口"""
        # 创建结果窗口
        result_window = ctk.CTkToplevel(self)
        result_window.title("補單結果詳情 / Append Order Results")
        result_window.geometry("800x800")
        result_window.resizable(True, True)
        result_window.attributes('-topmost', True)  # 设置窗口置顶

        # 设置窗口图标
        try:
            result_window.iconbitmap("SELOGO22 - 01.ico")
        except:
            pass

        # 主标题
        title_label = ctk.CTkLabel(
            result_window,
            text="📋 補單結果詳情\nAppend Order Results",
            font=("Microsoft YaHei", 24, "bold"),
            text_color=ACCENT_BLUE,
            justify="center"
        )
        title_label.pack(pady=(20, 10))

        # 下周日期范围
        date_label = ctk.CTkLabel(
            result_window,
            text=f"📅 下周日期范围 / Next Week Range: {results['next_week_range']}",
            font=("Microsoft YaHei", 16),
            text_color="#64748b",
            justify="center"
        )
        date_label.pack(pady=(0, 20))

        # 创建滚动框架
        scroll_frame = ctk.CTkScrollableFrame(
            result_window, width=750, height=400)
        scroll_frame.pack(fill="both", expand=True, padx=20, pady=(0, 20))

        # 显示处理结果
        if results['processed_files']:
            for file_result in results['processed_files']:
                # 文件标题
                file_title = ctk.CTkLabel(
                    scroll_frame,
                    text=f"📁 {file_result['file']}",
                    font=("Microsoft YaHei", 18, "bold"),
                    text_color="#3b82f6",
                    justify="left"
                )
                file_title.pack(anchor="w", pady=(15, 5))

                # 成功处理的供应商
                if file_result['suppliers']:
                    success_label = ctk.CTkLabel(
                        scroll_frame,
                        text="✅ 成功补单的供应商 / Successfully Appended Suppliers:",
                        font=("Microsoft YaHei", 14, "bold"),
                        text_color="#22c55e",
                        justify="left"
                    )
                    success_label.pack(anchor="w", pady=(5, 2))

                    for supplier in file_result['suppliers']:
                        supplier_label = ctk.CTkLabel(
                            scroll_frame,
                            text=f"   • {supplier}",
                            font=("Microsoft YaHei", 12),
                            text_color="#22c55e",
                            justify="left"
                        )
                        supplier_label.pack(anchor="w", padx=20)

                # 跳过的供应商
                if file_result['skipped']:
                    skip_label = ctk.CTkLabel(
                        scroll_frame,
                        text="⏭️ 跳过的供应商（无下周订单）/ Skipped Suppliers (No Next Week Orders):",
                        font=("Microsoft YaHei", 14, "bold"),
                        text_color="#f59e0b",
                        justify="left"
                    )
                    skip_label.pack(anchor="w", pady=(10, 2))

                    for supplier in file_result['skipped']:
                        supplier_label = ctk.CTkLabel(
                            scroll_frame,
                            text=f"   • {supplier}",
                            font=("Microsoft YaHei", 12),
                            text_color="#f59e0b",
                            justify="left"
                        )
                        supplier_label.pack(anchor="w", padx=20)

                # 分隔线
                separator = ctk.CTkFrame(
    scroll_frame, height=2, fg_color="#e2e8f0")
                separator.pack(fill="x", pady=15)

        # 显示错误信息
        if results['errors']:
            error_title = ctk.CTkLabel(
                scroll_frame,
                text="❌ 处理错误 / Processing Errors:",
                font=("Microsoft YaHei", 14, "bold"),
                text_color="#ef4444",
                justify="left"
            )
            error_title.pack(anchor="w", pady=(15, 5))

            for error in results['errors']:
                error_label = ctk.CTkLabel(
                    scroll_frame,
                    text=f"   • {error}",
                    font=("Microsoft YaHei", 12),
                    text_color="#ef4444",
                    justify="left"
                )
                error_label.pack(anchor="w", padx=20)

        # 如果没有处理任何文件
        if not results['processed_files'] and not results['errors']:
            no_result_label = ctk.CTkLabel(
                scroll_frame,
                text="📭 没有处理任何文件 / No files processed",
                font=("Microsoft YaHei", 12),
                text_color="#64748b",
                justify="center"
            )
            no_result_label.pack(pady=50)

        # 统计信息
        total_processed = sum(len(fr['suppliers'])
                              for fr in results['processed_files'])
        total_skipped = sum(len(fr['skipped'])
                            for fr in results['processed_files'])
        total_errors = len(results['errors'])

        stats_frame = ctk.CTkFrame(
    result_window,
    fg_color="#f8fafc",
     corner_radius=10)
        stats_frame.pack(fill="x", padx=20, pady=(0, 20))

        stats_text = f"📊 统计信息 / Statistics:\n"
        stats_text += f"   • 成功补单: {total_processed} 个供应商\n"
        stats_text += f"   • 跳过处理: {total_skipped} 个供应商\n"
        stats_text += f"   • 处理错误: {total_errors} 个\n"
        stats_text += f"   • 处理文件: {len(results['processed_files'])} 个"

        stats_label = ctk.CTkLabel(
            stats_frame,
            text=stats_text,
            font=("Microsoft YaHei", 14),
            text_color="#374151",
            justify="left"
        )
        stats_label.pack(pady=15, padx=15)

        # 按钮框架
        button_frame = ctk.CTkFrame(result_window, fg_color="transparent")
        button_frame.pack(fill="x", padx=20, pady=(0, 20))

        # 关闭按钮
        ctk.CTkButton(
            button_frame,
            text="關閉 / Close",
            command=result_window.destroy,
            fg_color=ACCENT_BLUE,
            font=FONT_MID
        ).pack(side="right")

        # 设置窗口居中
        result_window.update_idletasks()
        x = (result_window.winfo_screenwidth() // 2) - \
             (result_window.winfo_width() // 2)
        y = (result_window.winfo_screenheight() // 2) - \
             (result_window.winfo_height() // 2)
        result_window.geometry(f"+{x}+{y}")

    def run_new_append_orders(self):
        """
        Append Outlet Order (new):
        - For each selected outlet weekly-order file and each vendor sheet inside it,
          if the sheet has next-week orders (>0 in any next-week date column),
          then overwrite the entire vendor sheet in the supplier file.
        - If the supplier file does not exist, create a new file using the same naming
          style as Order Automation: "{Vendor}_Week_{weekNo}.xlsx" inside selected
          supplier folder.
        - 使用 xlwings 避免外部链接引用被标记为 "repaired"
        """
        import os
        from datetime import datetime, timedelta
        from tkinter import messagebox
        from openpyxl import load_workbook, Workbook
        from openpyxl.utils import column_index_from_string
        import re
        from copy import copy as _copy

        # Read inputs from the Append Outlet Order area
        outlet_files_raw = getattr(self, 'append_outlet_files_var', None)
        supplier_folder_var = getattr(self, 'append_supplier_folder_var', None)
        supplier_folder = supplier_folder_var.get().strip() if supplier_folder_var else ''

        # Prefer full paths captured during file selection
        outlet_files_full = list(
    getattr(
        self,
        'append_outlet_full_paths',
         [])) or []
        if not outlet_files_full and outlet_files_raw:
            raw = outlet_files_raw.get().strip()
            if raw:
                outlet_files_full = [p for p in raw.split(';') if p]

        if not outlet_files_full:
            messagebox.showerror(
    '錯誤', '請先選擇門市週單檔案 (Select Outlet Order Files)')
            return
        if not supplier_folder or not os.path.isdir(supplier_folder):
            messagebox.showerror('錯誤', '請選擇正確的供應商資料夾 (Select Supplier Folder)')
            return

        outlet_files = [
    p for p in outlet_files_full if p and os.path.isfile(p)]
        if not outlet_files:
            messagebox.showerror('錯誤', '找不到任何有效的門市週單檔案')
            return

        # Compute next-week range and unified Month_WeekX naming based on next
        # Monday
        today = datetime.now().date()
        next_monday = today + timedelta(days=(7 - today.weekday()))
        next_sunday = next_monday + timedelta(days=6)
        month_abbr = next_monday.strftime('%b')
        week_in_month = ((next_monday.day - 1) // 7) + 1
        name_suffix = f"{month_abbr}_Week_{week_in_month}"

        def parse_date(value, ws_ctx=None):
            if value is None:
                return None
            # datetime or date
            if hasattr(
    value,
    'year') and hasattr(
        value,
        'month') and hasattr(
            value,
             'day'):
                return value.date() if hasattr(value, 'hour') else value
            # Excel serial
            if isinstance(value, (int, float)):
                try:
                    return datetime.fromordinal(
    datetime(
        1900,
        1,
        1).toordinal() +
        int(value) -
         2).date()
                except Exception:
                    return None
            # String date
            if isinstance(value, str):
                s = value.strip()
                # handle simple Excel-like formulas used in headers, e.g.
                # "=+J25+1" or "=J25+1"
                if s.startswith('='):
                    s2 = s.lstrip('=')
                    s2 = s2[1:] if s2.startswith('+') else s2
                    # 1) direct date string after '=' (rare but possible)
                    try:
                        from dateutil.parser import parse as dtparse
                        maybe = dtparse(s2)
                        return maybe.date()
                    except Exception:
                        pass
                    # 2) reference like J25+1 / J25-1
                    m = re.match(r"^([A-Z]+)(\d+)([+\-]\d+)?$", s2)
                    if m:
                        col_letters = m.group(1)
                        row_num = int(m.group(2))
                        offs = int(m.group(3) or 0)
                        try:
                            col_idx = column_index_from_string(col_letters)
                            if ws_ctx is None:
                                return None
                            base_val = ws_ctx.cell(
    row=row_num, column=col_idx).value
                            base_date = parse_date(base_val)
                            if base_date is not None:
                                return base_date + timedelta(days=offs)
                        except Exception:
                            return None
                    # 3) DATE(y,m,d)
                    m = re.match(
    r"^DATE\((\d+)\s*,\s*(\d+)\s*,\s*(\d+)\)$", s2, re.I)
                    if m:
                        try:
                            y, mth, d = int(
    m.group(1)), int(
        m.group(2)), int(
            m.group(3))
                            return datetime(y, mth, d).date()
                        except Exception:
                            return None
                try:
                    from dateutil.parser import parse as dtparse
                    return dtparse(s).date()
                except Exception:
                    return None
            return None

        replaced, created, skipped, errors = [], [], [], []
        results = {
            'processed_files': [],
            'errors': errors,
            'next_week_range': f"{next_monday.strftime('%Y-%m-%d')} 至 {next_sunday.strftime('%Y-%m-%d')}"
        }

        def copy_sheet_fully(src_ws, src_ws_formula, dst_ws):
            """复制工作表，保持完整格式和公式，避免外部链接引用问题"""
            # 直接使用 openpyxl 方法复制，因为 xlwings 在这里不适用
            fallback_copy_sheet_fully(src_ws, src_ws_formula, dst_ws)
        
        def clean_external_links(workbook):
            """清理工作簿中的外部链接引用"""
            try:
                # 移除外部链接
                if hasattr(workbook, '_external_links'):
                    workbook._external_links.clear()
                # 移除外部引用
                if hasattr(workbook, '_external_references'):
                    workbook._external_references.clear()
                # 设置属性来忽略外部链接
                if hasattr(workbook, 'keep_links'):
                    workbook.keep_links = False
            except Exception:
                pass
            return workbook
        
        def fallback_copy_sheet_fully(src_ws, src_ws_formula, dst_ws):
            """回退的 openpyxl 复制方法"""
            from openpyxl.utils.cell import coordinate_to_tuple
            
            # copy cell values/formulas and styles
            for row in src_ws_formula.iter_rows():
                for cell_formula in row:
                    r, c = cell_formula.row, cell_formula.column
                    dst_cell = dst_ws.cell(row=r, column=c)
                    dst_cell.value = cell_formula.value
                    src_cell = src_ws.cell(row=r, column=c)
                    try:
                        if src_cell.font:
                            dst_cell.font = _copy(src_cell.font)
                        if src_cell.fill:
                            dst_cell.fill = _copy(src_cell.fill)
                        if src_cell.border:
                            dst_cell.border = _copy(src_cell.border)
                        if src_cell.alignment:
                            dst_cell.alignment = _copy(src_cell.alignment)
                        if src_cell.number_format:
                            dst_cell.number_format = src_cell.number_format
                    except Exception:
                        pass
            # merged cells
            try:
                for m in src_ws_formula.merged_cells.ranges:
                    dst_ws.merge_cells(str(m))
            except Exception:
                pass
            # column widths and hidden state
            try:
                for col_letter, dim in src_ws.column_dimensions.items():
                    tgt_dim = dst_ws.column_dimensions[col_letter]
                    if getattr(dim, 'width', None) is not None:
                        tgt_dim.width = dim.width
                    if hasattr(dim, 'hidden') and dim.hidden is not None:
                        tgt_dim.hidden = dim.hidden
                    if hasattr(
    dim, 'outlineLevel') and getattr(
        dim, 'outlineLevel', None):
                        tgt_dim.outlineLevel = dim.outlineLevel
            except Exception:
                pass
            # row heights and hidden state
            try:
                for idx, dim in src_ws.row_dimensions.items():
                    tgt = dst_ws.row_dimensions[idx]
                    if getattr(dim, 'height', None) is not None:
                        tgt.height = dim.height
                    if hasattr(dim, 'hidden') and dim.hidden is not None:
                        tgt.hidden = dim.hidden
                    if hasattr(
    dim, 'outlineLevel') and getattr(
        dim, 'outlineLevel', None):
                        tgt_dim.outlineLevel = dim.outlineLevel
            except Exception:
                pass
            # 固定設定凍結窗格為 A9
            try:
                dst_ws.freeze_panes = "A9"
                print(f"[DEBUG] Append: 設定固定凍結窗格 A9")
            except Exception as freeze_error:
                print(f"[DEBUG] Append: 設定凍結窗格失敗: {freeze_error}")
                pass
            try:
                if getattr(
    src_ws,
    'auto_filter',
     None) and src_ws.auto_filter.ref:
                    dst_ws.auto_filter.ref = src_ws.auto_filter.ref
            except Exception:
                pass

        for src_path in outlet_files:
            try:
                # 使用 openpyxl 加载文件，添加多个参数来避免外部链接引用问题
                wb_src = load_workbook(src_path, data_only=True, keep_links=False, read_only=False)
                wb_src_formula = load_workbook(src_path, data_only=False, keep_links=False, read_only=False)
                
                # 清理外部链接引用
                wb_src = clean_external_links(wb_src)
                wb_src_formula = clean_external_links(wb_src_formula)
                src_basename = os.path.basename(src_path)
                # Derive outlet short code from filename, e.g.,
                # "WL_WeeklyOrder_33.xlsx" -> "WL"
                m_code = re.match(
    r"^([A-Za-z0-9]+)[ _-]?WeeklyOrder", src_basename, re.I)
                outlet_code = (m_code.group(1).upper() if m_code else '')
                file_result = {
    'file': src_basename,
    'suppliers': [],
     'skipped': []}
                for vendor in wb_src.sheetnames:
                    ws = wb_src[vendor]
                    ws_form = wb_src_formula[vendor]
                    # skip hidden sheets
                    try:
                        if hasattr(
    ws, 'sheet_state') and ws.sheet_state != 'visible':
                            continue
                    except Exception:
                        pass

                    # 1) Find ALL weekday rows (Mon..Sun) and use each
                    # following row as a candidate date row
                    week_days = {
    'mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun'}
                    max_col = ws.max_column
                    weekday_rows = []
                    for r in range(1, min(400, ws.max_row) + 1):
                        row_vals = [str(ws.cell(row=r, column=c).value or '').strip(
                        ).lower() for c in range(1, min(60, max_col) + 1)]
                        if any('mon' in v for v in row_vals):
                            hits = sum(any(day in v for v in row_vals) for day in [
                                       'mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun'])
                            if hits >= 3:
                                weekday_rows.append(r)
                    if not weekday_rows:
                        skipped.append(f"{vendor} (未找到星期列)")
                        file_result['skipped'].append(f"{vendor} (未找到星期列)")
                        continue

                    # 2) Identify next-week date columns from any candidate
                    # date row
                    next_week_cols = []
                    for wr in weekday_rows:
                        date_row = wr + 1
                        cols = []
                        for c in range(1, max_col + 1):
                            raw = ws.cell(row=date_row, column=c).value
                            d = parse_date(raw, ws)
                            if d is None:
                                raw_formula = ws_form.cell(
                                    row=date_row, column=c).value
                                if isinstance(raw_formula, str):
                                    d = parse_date(raw_formula, ws)
                            if d and next_monday <= d <= next_sunday:
                                cols.append(c)
                        if cols:
                            next_week_cols = cols
                            break
                    if not next_week_cols:
                        skipped.append(f"{vendor} (無下週日期)")
                        file_result['skipped'].append(f"{vendor} (無下週日期)")
                        continue

                    # 3) Verify there is any >0 quantity beneath these columns
                    # (scan a generous range)
                    has_qty = False
                    start_row = min(wr + 2, ws.max_row)  # row after date row
                    for r in range(
    start_row, min(
        ws.max_row, start_row + 120) + 1):
                        for c in next_week_cols:
                            val = ws.cell(row=r, column=c).value
                            try:
                                if float(val) > 0:
                                    has_qty = True
                                    break
                            except Exception:
                                pass
                        if has_qty:
                            break
                    if not has_qty:
                        skipped.append(f"{vendor} (下週列無數量)")
                        file_result['skipped'].append(f"{vendor} (下週列無數量)")
                        continue

                    # 4) Find or create supplier file
                    target_file = None
                    vendor_lower = vendor.lower()
                    for name in os.listdir(supplier_folder):
                        if name.lower().endswith('.xlsx') and vendor_lower in name.lower():
                            target_file = os.path.join(supplier_folder, name)
                            break
                    desired_path = os.path.join(
    supplier_folder, f"{vendor}_{name_suffix}.xlsx")
                    if target_file is None:
                        target_file = desired_path
                        try:
                            wb_new = Workbook()
                            if 'Sheet' in wb_new.sheetnames:
                                del wb_new['Sheet']
                            wb_new.save(target_file)
                            created.append(os.path.basename(target_file))
                        except Exception as ce:
                            errors.append(f"建立檔案失敗 {vendor}: {ce}")
                            continue
                    else:
                        # rename existing file to desired naming if different
                        try:
                            if os.path.normcase(
                                target_file) != os.path.normcase(desired_path):
                                if not os.path.exists(desired_path):
                                    os.replace(target_file, desired_path)
                                target_file = desired_path
                        except Exception:
                            pass

                    # 5) Overwrite entire vendor sheet in target supplier file
                    try:
                        wb_dst = load_workbook(target_file, keep_links=False)
                        # 清理目标工作簿的外部链接引用
                        wb_dst = clean_external_links(wb_dst)
                        # Sheet name should be outlet code (WL, 313, etc.) same
                        # as Order Automation
                        # 如果沒有解析出門市代碼，使用檔案名前綴作為備選
                        if not outlet_code:
                            # 嘗試從檔案名提取更通用的前綴
                            name_parts = src_basename.replace('.xlsx', '').split('_')
                            outlet_code = name_parts[0] if name_parts else 'Outlet'
                        tab_name = outlet_code
                        if tab_name in wb_dst.sheetnames:
                            del wb_dst[tab_name]
                        ws_new = wb_dst.create_sheet(tab_name)
                        copy_sheet_fully(ws, ws_form, ws_new)
                        try:
                            wb_dst.calculation_properties.fullCalcOnLoad = True
                        except Exception:
                            pass
                        # 使用安全儲存方式，避免 Named range 錯誤
                        safe_save_excel_workbook(wb_dst, target_file)
                        replaced.append(f"{vendor} <- {src_basename}")
                        if tab_name != vendor:
                            file_result['suppliers'].append(
                                f"{vendor} → {tab_name} @ {os.path.basename(target_file)}")
                        else:
                            file_result['suppliers'].append(
                                f"{vendor} @ {os.path.basename(target_file)}")
                    except Exception as we:
                        errors.append(f"覆蓋失敗 {vendor}: {we}")
                        file_result['skipped'].append(f"{vendor} (覆蓋失敗)")
                        continue
            except Exception as e:
                errors.append(f"讀取來源失敗 {os.path.basename(src_path)}: {e}")
            finally:
                if file_result['suppliers'] or file_result['skipped']:
                    results['processed_files'].append(file_result)

        # Show beautified results window
        try:
            self._show_append_results(results)
        except Exception:
            # Fallback simple message
            report = []
            report.append(f"成功覆蓋 sheet：{len(replaced)}")
            for it in replaced:
                report.append(f"- {it}")
            if created:
                report.append(f"\n新建檔案：{len(created)}")
                for it in created:
                    report.append(f"- {it}")
            if skipped:
                report.append(f"\n跳過：{len(skipped)}")
                for it in skipped:
                    report.append(f"- {it}")
            if errors:
                report.append(f"\n錯誤：{len(errors)}")
                for it in errors:
                    report.append(f"- {it}")
            messagebox.showinfo('補單完成', "\n".join(report))

    def show_monthend_monthly_summary_ui(self):
        """月結 > 訂單月度彙總：可選多個 Excel 檔案整合數量並輸出"""
        def build(c):
            import os
            import openpyxl
            from openpyxl.styles import Alignment, Font, PatternFill, Border, Side
            from openpyxl.utils import get_column_letter
            from tkinter import messagebox

            # 狀態變數
            self.monthsum_files_var = ctk.StringVar()
            self.monthsum_output_var = ctk.StringVar(
                value=os.path.join(os.path.expanduser('~'), 'Downloads'))
            self.monthsum_config_var = ctk.StringVar()

            # 選檔/選資料夾
            def pick_files():
                from tkinter import filedialog
                files = filedialog.askopenfilenames(
                    title="選擇要整合的訂單檔案", filetypes=[("Excel files", "*.xlsx;*.xlsm")])
                if files:
                    self.monthsum_files_var.set(";".join(files))

            def pick_output_folder():
                from tkinter import filedialog
                d = filedialog.askdirectory()
                if d:
                    self.monthsum_output_var.set(d)

            # 介面
            form = ctk.CTkFrame(c, fg_color=DARK_PANEL, corner_radius=16)
            form.pack(fill="x", padx=30, pady=10)

            row1 = ctk.CTkFrame(form, fg_color='transparent')
            row1.pack(fill='x', pady=6)
            ctk.CTkLabel(
    row1,
    text="選擇多個 Excel 檔案\nSelect multiple Excel files",
    font=FONT_MID).pack(
        side='left',
         padx=8)
            ctk.CTkEntry(
    row1,
    textvariable=self.monthsum_files_var,
    state='readonly').pack(
        side='left',
        fill='x',
        expand=True,
         padx=6)
            ctk.CTkButton(
    row1,
    text='瀏覽...\nBrowse...',
    command=pick_files,
    corner_radius=8,
    hover_color="#1976d2").pack(
        side='left',
         padx=4)

            row2 = ctk.CTkFrame(form, fg_color='transparent')
            row2.pack(fill='x', pady=6)
            ctk.CTkLabel(
    row2,
    text="輸出資料夾\nOutput folder",
    font=FONT_MID).pack(
        side='left',
         padx=8)
            ctk.CTkEntry(
    row2, textvariable=self.monthsum_output_var).pack(
        side='left', fill='x', expand=True, padx=6)
            ctk.CTkButton(
    row2,
    text='選擇...\nChoose...',
    command=pick_output_folder,
    corner_radius=8,
    hover_color="#1976d2").pack(
        side='left',
         padx=4)

            row2b = ctk.CTkFrame(form, fg_color='transparent')
            row2b.pack(fill='x', pady=6)
            ctk.CTkLabel(
    row2b,
    text="配置檔（含 Outlets）\nConfig file (with Outlets)",
    font=FONT_MID).pack(
        side='left',
         padx=8)
            ctk.CTkEntry(
    row2b,
    textvariable=self.monthsum_config_var,
    state='readonly').pack(
        side='left',
        fill='x',
        expand=True,
         padx=6)
            ctk.CTkButton(
    row2b,
    text='瀏覽...\nBrowse...',
    command=lambda: self._select_config_file(
        self.monthsum_config_var,
        [
            ("Excel files",
            "*.xlsx;*.xls")]),
            corner_radius=8,
            hover_color="#1976d2").pack(
                side='left',
                 padx=4)

            # 添加模式选择
            mode_frame = ctk.CTkFrame(form, fg_color='transparent')
            mode_frame.pack(fill='x', pady=6)
            ctk.CTkLabel(
                mode_frame,
                text="選擇模式\nSelect Mode",
                font=FONT_MID).pack(side='left', padx=8)
            
            self.monthsum_mode_var = ctk.StringVar(value="monthly_order")
            ctk.CTkRadioButton(
                mode_frame,
                text="月度訂單彙總\nMonthly Order Summary",
                variable=self.monthsum_mode_var,
                value="monthly_order",
                font=FONT_SMALL).pack(side='left', padx=8)
            ctk.CTkRadioButton(
                mode_frame,
                text="盤點彙總\nStocktake Summary",
                variable=self.monthsum_mode_var,
                value="stocktake",
                font=FONT_SMALL).pack(side='left', padx=8)

            ctk.CTkLabel(
    form,
    text="整合多個檔案，依各日實際訂購日期歸入對應『年-月』，每個產品一個工作表，列出各門市按月份的彙總。\nMerge multiple files. Group orders into Year-Month by actual order dates. One sheet per product with Outlets × Months.",
    text_color=ACCENT_GREEN,
    wraplength=800,
    justify='left').pack(
        anchor='w',
        padx=8,
        pady=(
            0,
             8))

            # 解析與輸出
            def _normalize(s: str) -> str:
                import re
                return re.sub(r"[^a-z0-9]", "", (s or "").lower())

            def _load_outlet_mapping(cfg_path: str):
                mapping = []  # [(short, norm_address)]
                if not cfg_path:
                    return mapping
                try:
                    cfg = UnifiedConfigManager(cfg_path)
                    for o in getattr(cfg, 'outlets', []) or []:
                        short = str(o.get('code') or o.get('short')
                                    or o.get('Short Name') or '').strip()
                        addr = str(o.get('address') or '').strip()
                        if short and addr:
                            mapping.append((short, _normalize(addr)))
                except Exception as e:
                    print('[MonthlySummary] load config failed:', e)
                return mapping

            outlet_mapping_cache = None

            def _match_short_by_address(ws, wb):
                nonlocal outlet_mapping_cache
                if outlet_mapping_cache is None:
                    outlet_mapping_cache = _load_outlet_mapping(
                        self.monthsum_config_var.get())
                # 取報表抬頭區的名稱與地址（F5~F8 常見）
                try:
                    header_vals = [str(ws.cell(row=r, column=6).value or '')
                                       for r in range(4, 9)]
                except Exception:
                    header_vals = []
                header_text = " ".join(v for v in header_vals if v).strip()
                norm_header = _normalize(header_text)
                if not norm_header:
                    return None
                # 最長子字串匹配
                best = None
                best_len = 0
                for short, norm_addr in outlet_mapping_cache:
                    if not norm_addr:
                        continue
                    if norm_addr in norm_header or norm_header in norm_addr:
                        score = len(norm_addr)
                        if score > best_len:
                            best = short
                            best_len = score
                return best

            def parse_one_file(
    path: str,
    acc_by_prod: dict,
    acc_amt_by_prod: dict,
    months_set: set,
     outlets_set: set):
                from datetime import datetime
                wb = openpyxl.load_workbook(path, data_only=True)
                try:
                    for sheet in wb.sheetnames:
                        if sheet in (
    "Sheet",
    "Summary",
    "Data",
    "Raw Sheet",
    "Sales Category",
    "Freshening",
    "Legacy",
     "Unikleen"):
                            continue
                        ws = wb[sheet]
                        last_row = ws.max_row
                        # 先用地址對 config 匹配 short name，找不到再回退用工作表名
                        outlet_short = _match_short_by_address(ws, wb) or sheet
                        outlets_set.add(outlet_short)
                        row = 1
                        while row <= last_row:
                            val = ws.cell(row=row, column=2).value
                            if val and "description" in str(val).lower():
                                date_row_idx = row
                                date_cols = list(range(6, 13))  # F~L
                                # 解析日期
                                date_vals = []
                                for col in date_cols:
                                    cell_val = ws.cell(
    row=date_row_idx, column=col).value
                                    if isinstance(cell_val, str):
                                        try:
                                            # 可能是 "01-Jul"
                                            # 這種，年分以實際當年推估意義不大；這裡只為了取得月日
                                            parsed = datetime.strptime(
                                                cell_val.strip(), "%d-%b")
                                            # 不設定年份，稍後按實際月份處理
                                            date_vals.append(
                                                (None, parsed.month, parsed.day))
                                        except Exception:
                                            date_vals.append(None)
                                    elif isinstance(cell_val, datetime):
                                        date_vals.append(
    (cell_val.year, cell_val.month, cell_val.day))
                                    else:
                                        date_vals.append(None)

                                # 產品行
                                prod_row = row + 1
                                while prod_row <= last_row:
                                    eng = ws.cell(row=prod_row, column=2).value
                                    chi = ws.cell(row=prod_row, column=3).value
                                    if not eng or str(eng).strip() == "" or str(
                                        eng).strip().startswith("="):
                                        break
                                    if "sub-total" in str(eng).lower():
                                        prod_row += 1
                                        continue

                                    # 取得單價（假設價格在第4欄，可能含 $ 符號）
                                    raw_price = ws.cell(
                                        row=prod_row, column=4).value
                                    price = 0.0
                                    try:
                                        if isinstance(raw_price, (int, float)):
                                            price = float(raw_price)
                                        elif isinstance(raw_price, str):
                                            price = float(
    raw_price.replace(
        '$', '').replace(
            ' ', ''))
                                    except Exception:
                                        price = 0.0

                                    # 逐日累加到對應月份（年-月）
                                    for idx, col in enumerate(date_cols):
                                        qv = ws.cell(
    row=prod_row, column=col).value
                                        if qv in (None, ""):
                                            continue
                                        try:
                                            qf = float(qv)
                                        except Exception:
                                            continue
                                        dv = date_vals[idx]
                                        if not dv:
                                            continue
                                        # 推定年月：若缺年，使用文件可能年份資訊不足；採取簡單策略：
                                        # 若工作簿屬性有
                                        # 'Properties.created'，取其年，否則用當前年份
                                        y, m, _ = dv
                                        if y is None:
                                            try:
                                                y = (
    wb.properties.created.year if wb.properties and wb.properties.created else datetime.now().year)
                                            except Exception:
                                                y = datetime.now().year
                                        ym = f"{y:04d}-{m:02d}"
                                        months_set.add(ym)

                                        key = (
    str(eng).strip(), str(chi).strip() if chi else "")
                                        if key not in acc_by_prod:
                                            acc_by_prod[key] = {}
                                        if outlet_short not in acc_by_prod[key]:
                                            acc_by_prod[key][outlet_short] = {}
                                        acc_by_prod[key][outlet_short][ym] = acc_by_prod[key][outlet_short].get(
                                            ym, 0.0) + qf

                                        # 金額彙總
                                        if key not in acc_amt_by_prod:
                                            acc_amt_by_prod[key] = {}
                                        if outlet_short not in acc_amt_by_prod[key]:
                                            acc_amt_by_prod[key][outlet_short] = {
                                                }
                                        acc_amt_by_prod[key][outlet_short][ym] = acc_amt_by_prod[key][outlet_short].get(
                                            ym, 0.0) + (qf * price)
                                    prod_row += 1
                                row = prod_row
                            else:
                                row += 1
                finally:
                    wb.close()

            def parse_stocktake_file(
                path: str,
                acc_by_prod: dict,
                months_set: set,
                outlets_set: set):
                """解析Stocktake文件：从A47-64读取产品名称，F47-F64读取数据"""
                from datetime import datetime
                wb = openpyxl.load_workbook(path, data_only=True)
                try:
                    for sheet in wb.sheetnames:
                        if sheet in ("Sheet", "Summary", "Data", "Raw Sheet", "Sales Category", 
                                   "Image", "Freshening", "Legacy", "Unikleen"):
                            continue
                        
                        ws = wb[sheet]
                        outlet_short = sheet  # 使用sheet名作为店名
                        outlets_set.add(outlet_short)
                        
                        # 智能识别起始行：查找"Dip-Off Distaining Powder"
                        start_row = None
                        for search_row in range(40, 70):  # 在40-70行范围内搜索
                            cell_value = ws.cell(row=search_row, column=1).value
                            if cell_value and "Dip-Off Distaining Powder" in str(cell_value):
                                start_row = search_row
                                break
                        
                        # 如果找不到，使用默认的47行
                        if start_row is None:
                            start_row = 47
                        
                        # 从识别到的起始行开始读取产品数据（读取18行数据）
                        for row in range(start_row, start_row + 18):
                            product_name = ws.cell(row=row, column=1).value  # A列
                            stocktake_qty = ws.cell(row=row, column=6).value  # F列
                            
                            if not product_name or str(product_name).strip() == "":
                                continue
                                
                            try:
                                qty = float(stocktake_qty) if stocktake_qty is not None else 0.0
                            except (ValueError, TypeError):
                                qty = 0.0
                            
                            if qty == 0:
                                continue
                            
                            # 从文件名解析月份
                            filename = os.path.basename(path)
                            month_year = None
                            
                            # 尝试从文件名解析月份
                            import re
                            month_patterns = [
                                r'(\w+)\s*(\d{4})',  # Sep 2025, September 2025
                                r'(\d{1,2})[.-]\s*(\w+)\s*(\d{4})',  # 9-Sep-2025, 9. September 2025
                                r'(\w+)\'(\d{2})',  # Sep'25
                            ]
                            
                            for pattern in month_patterns:
                                match = re.search(pattern, filename, re.IGNORECASE)
                                if match:
                                    try:
                                        if len(match.groups()) == 2:
                                            month_str, year_str = match.groups()
                                            if len(year_str) == 2:
                                                year_str = '20' + year_str
                                            month_year = f"{year_str}-{_parse_month(month_str):02d}"
                                        elif len(match.groups()) == 3:
                                            day, month_str, year_str = match.groups()
                                            month_year = f"{year_str}-{_parse_month(month_str):02d}"
                                        break
                                    except:
                                        continue
                            
                            # 如果无法从文件名解析，使用当前月份
                            if not month_year:
                                now = datetime.now()
                                month_year = f"{now.year:04d}-{now.month:02d}"
                            
                            months_set.add(month_year)
                            
                            # 存储数据
                            key = (str(product_name).strip(), "")
                            if key not in acc_by_prod:
                                acc_by_prod[key] = {}
                            if outlet_short not in acc_by_prod[key]:
                                acc_by_prod[key][outlet_short] = {}
                            acc_by_prod[key][outlet_short][month_year] = acc_by_prod[key][outlet_short].get(month_year, 0.0) + qty
                            
                finally:
                    wb.close()
            
            def _parse_month(month_str):
                """解析月份字符串为数字"""
                month_map = {
                    'jan': 1, 'january': 1,
                    'feb': 2, 'february': 2,
                    'mar': 3, 'march': 3,
                    'apr': 4, 'april': 4,
                    'may': 5,
                    'jun': 6, 'june': 6,
                    'jul': 7, 'july': 7,
                    'aug': 8, 'august': 8,
                    'sep': 9, 'september': 9,
                    'oct': 10, 'october': 10,
                    'nov': 11, 'november': 11,
                    'dec': 12, 'december': 12
                }
                return month_map.get(month_str.lower(), 1)

            def export_summary(
    acc_by_prod: dict,
    acc_amt_by_prod: dict,
    months_sorted: list,
    outlets_sorted: list,
     out_path: str):
                from datetime import datetime
                wb = openpyxl.Workbook()
                # 移除預設工作表，改由第一個產品建立
                if wb.sheetnames:
                    del wb[wb.sheetnames[0]]

                header_fill = PatternFill("solid", fgColor="BDD7EE")
                bold = Font(bold=True)
                center = Alignment(horizontal='center', vertical='center')

                def ym_to_label(ym: str) -> str:
                    y, m = ym.split('-')
                    dt = datetime(int(y), int(m), 1)
                    return dt.strftime('%b-%y')

                # 為每個產品建立一個工作表：列 = 門市，欄 = 月份
                for (
    eng,
    chi) in sorted(
        acc_by_prod.keys(),
         key=lambda x: x[0]):
                    # 工作表名稱限制長度與非法字元
                    raw_name = eng if eng else 'Product'
                    sheet_name = raw_name[:31] if len(
                        raw_name) > 31 else raw_name
                    if sheet_name in wb.sheetnames:
                        base = sheet_name[:28]
                        idx = 1
                        while f"{base}_{idx}" in wb.sheetnames:
                            idx += 1
                        sheet_name = f"{base}_{idx}"
                    ws = wb.create_sheet(sheet_name)

                    # Header
                    ws.cell(row=1, column=1, value='Outlet').font = bold
                    ws.cell(row=1, column=1).fill = header_fill
                    # 月份欄
                    for j, ym in enumerate(months_sorted, start=2):
                        ws.cell(
    row=1, column=j, value=ym_to_label(ym)).font = bold
                        ws.cell(row=1, column=j).alignment = center
                        ws.cell(row=1, column=j).fill = header_fill

                    # 逐門市填值
                    prod_map = acc_by_prod[(eng, chi)]  # {outlet: {ym: qty}}
                    for i, outlet in enumerate(outlets_sorted, start=2):
                        ws.cell(row=i, column=1, value=outlet)
                        ym_map = prod_map.get(outlet, {})
                        for j, ym in enumerate(months_sorted, start=2):
                            val = ym_map.get(ym)
                            if val not in (None, 0):
                                ws.cell(row=i, column=j, value=val)

                # 總表（數量）
                ws_sum_qty = wb.create_sheet('All Products - Qty')
                ws_sum_qty.cell(row=1, column=1, value='Outlet').font = bold
                ws_sum_qty.cell(row=1, column=1).fill = header_fill
                for j, ym in enumerate(months_sorted, start=2):
                    ws_sum_qty.cell(
    row=1, column=j, value=ym_to_label(ym)).font = bold
                    ws_sum_qty.cell(row=1, column=j).alignment = center
                    ws_sum_qty.cell(row=1, column=j).fill = header_fill
                for i, outlet in enumerate(outlets_sorted, start=2):
                    ws_sum_qty.cell(row=i, column=1, value=outlet)
                    for j, ym in enumerate(months_sorted, start=2):
                        total = 0.0
                        for key in acc_by_prod.keys():
                            total += acc_by_prod[key].get(outlet,
                                                          {}).get(ym, 0.0)
                        if total not in (None, 0):
                            ws_sum_qty.cell(row=i, column=j, value=total)

                # 總表（金額）
                ws_sum_amt = wb.create_sheet('All Products - Amount')
                ws_sum_amt.cell(row=1, column=1, value='Outlet').font = bold
                ws_sum_amt.cell(row=1, column=1).fill = header_fill
                for j, ym in enumerate(months_sorted, start=2):
                    ws_sum_amt.cell(
    row=1, column=j, value=ym_to_label(ym)).font = bold
                    ws_sum_amt.cell(row=1, column=j).alignment = center
                    ws_sum_amt.cell(row=1, column=j).fill = header_fill
                for i, outlet in enumerate(outlets_sorted, start=2):
                    ws_sum_amt.cell(row=i, column=1, value=outlet)
                    for j, ym in enumerate(months_sorted, start=2):
                        total_amt = 0.0
                        for key in acc_amt_by_prod.keys():
                            total_amt += acc_amt_by_prod[key].get(
                                outlet, {}).get(ym, 0.0)
                        if total_amt not in (None, 0):
                            ws_sum_amt.cell(row=i, column=j, value=total_amt)

                wb.save(out_path)

            def run_merge():
                files = [
    f for f in self.monthsum_files_var.get().split(';') if f.strip()]
                if not files:
                    messagebox.showwarning('檔案', '請選擇要整合的 Excel 檔案')
                    return
                os.makedirs(self.monthsum_output_var.get(), exist_ok=True)
                acc_by_prod = {}
                acc_amt_by_prod = {}
                months_set = set()
                outlets_set = set()
                
                mode = self.monthsum_mode_var.get()
                
                for fp in files:
                    try:
                        if mode == "stocktake":
                            parse_stocktake_file(fp, acc_by_prod, months_set, outlets_set)
                        else:  # monthly_order
                            parse_one_file(fp, acc_by_prod, acc_amt_by_prod, months_set, outlets_set)
                    except Exception as e:
                        messagebox.showerror('錯誤', f'處理檔案失敗：\n{fp}\n{e}')
                        return
                
                # 根据模式选择输出文件名
                if mode == "stocktake":
                    out_file = os.path.join(self.monthsum_output_var.get(), 'Stocktake_Summary.xlsx')
                else:
                    out_file = os.path.join(self.monthsum_output_var.get(), 'Monthly_Order_Summary.xlsx')
                
                try:
                    # sort months by YYYY-MM
                    months_sorted = sorted(months_set)
                    outlets_sorted = sorted(outlets_set)
                    
                    if mode == "stocktake":
                        # 对于stocktake模式，不需要金额数据
                        export_summary(acc_by_prod, {}, months_sorted, outlets_sorted, out_file)
                    else:
                        export_summary(acc_by_prod, acc_amt_by_prod, months_sorted, outlets_sorted, out_file)
                except Exception as e:
                    messagebox.showerror('錯誤', f'輸出失敗：{e}')
                    return
                messagebox.showinfo('完成', f'已輸出：\n{out_file}')

            try:
                GlowButton(
    form,
    text='開始整合\nMerge',
    command=run_merge,
    width=280,
    height=40,
    glow_color=ACCENT_GREEN,
    corner_radius=18).pack(
        pady=(
            6,
             2))
            except Exception:
                ctk.CTkButton(
    form,
    text='開始整合\nMerge',
    fg_color=ACCENT_GREEN,
    command=run_merge,
    height=36).pack(
        pady=(
            6,
             2))

            # ========== 金額整合（以廠商為主） ==========
            amt_frame = ctk.CTkFrame(c, fg_color=DARK_PANEL, corner_radius=16)
            amt_frame.pack(fill="x", padx=30, pady=10)
            ctk.CTkLabel(
    amt_frame,
    text="整合金額（TTL）－以廠商為主\nMerge Amounts (TTL) by Supplier",
    font=FONT_MID,
    text_color=ACCENT_GREEN).pack(
        anchor='w',
        padx=8,
        pady=(
            10,
             2))
            ctk.CTkLabel(
    amt_frame,
    text="月份將從檔名或路徑解析，例如：Jul'25、September 2024、7. July 2025。\nMonths parsed from filename/path, e.g., Jul'25, September 2024, 7. July 2025.",
    font=(
        "Microsoft JhengHei",
        11),
        text_color="#9CA3AF",
        justify='left',
        wraplength=900).pack(
            anchor='w',
            padx=8,
            pady=(
                0,
                 6))

            self.monthamt_files_var = ctk.StringVar()

            def pick_amt_files():
                from tkinter import filedialog
                files = filedialog.askopenfilenames(
    title="選擇含廠商工作表的彙總檔 (含 TTL 欄)", filetypes=[
        ("Excel files", "*.xlsx;*.xlsm")])
                if files:
                    self.monthamt_files_var.set(";".join(files))

            row_amt = ctk.CTkFrame(amt_frame, fg_color='transparent')
            row_amt.pack(fill='x', pady=6)
            ctk.CTkLabel(
    row_amt,
    text="選擇多個 Excel 檔案\nSelect multiple Excel files",
    font=FONT_MID).pack(
        side='left',
         padx=8)
            ctk.CTkEntry(
    row_amt,
    textvariable=self.monthamt_files_var,
    state='readonly').pack(
        side='left',
        fill='x',
        expand=True,
         padx=6)
            ctk.CTkButton(
    row_amt,
    text='瀏覽...\nBrowse...',
    command=pick_amt_files,
    corner_radius=8,
    hover_color="#1976d2").pack(
        side='left',
         padx=4)

            def parse_month_from_filename(path: str) -> str:
                """從檔名或路徑辨識月份，支援：
                - Jan, January, Jul, July, Sep, Sept, September 等
                - 年份可為 '24 或 2024；支援 ASCII ' 與 Unicode ’
                - 也能匹配像 "7. July 2025" 這種格式
                回傳 YYYY-MM 或 None
                """
                import os
                import re
                text = os.path.normpath(path)
                text = text.replace("\u2019", "'")  # 將 Unicode 右引號正規化
                text_low = text.lower()
                # 月份對照
                month_names = {
                    'jan': 1, 'january': 1,
                    'feb': 2, 'february': 2,
                    'mar': 3, 'march': 3,
                    'apr': 4, 'april': 4,
                    'may': 5,
                    'jun': 6, 'june': 6,
                    'jul': 7, 'july': 7,
                    'aug': 8, 'august': 8,
                    'sep': 9, 'sept': 9, 'september': 9,
                    'oct': 10, 'october': 10,
                    'nov': 11, 'november': 11,
                    'dec': 12, 'december': 12,
                }
                # 建立月名正則（長短皆可）
                month_regex = r"jan(?:uary)?|feb(?:ruary)?|mar(?:ch)?|apr(?:il)?|may|jun(?:e)?|jul(?:y)?|aug(?:ust)?|sep(?:t|tember)?|oct(?:ober)?|nov(?:ember)?|dec(?:ember)?"
                # 先嘗試：<month> [' ]? <year>
                m = re.search(
                    rf"({month_regex})\s*[' ]?\s*(20\d{{2}}|\d{{2}})", text_low)
                if not m:
                    # 次要：<num>. <month> <year>
                    m = re.search(
    rf"\b\d{{1,2}}\.?\s*({month_regex})\s*(20\d{{2}}|\d{{2}})", text_low)
                if not m:
                    return None
                mon_key = m.group(1)
                yr = m.group(2)
                mm = month_names.get(mon_key, None)
                if not mm:
                    return None
                yy = int(yr)
                if yy < 100:
                    yy += 2000
                return f"{yy:04d}-{mm:02d}"

            def find_headers(ws):
                """在前幾十行尋找表頭，回傳 (header_row_idx, col_outlet, col_ttl)
                更寬鬆：支援 'outlet'/'outlets'；'ttl' 或 'total' 皆可。
                """
                max_r = min(40, ws.max_row)
                max_c = min(120, ws.max_column)
                # 逐行掃描，當同一行同時出現 outlet 與 ttl/total 才判定為表頭
                for r in range(1, max_r + 1):
                    outlet_col = None
                    ttl_col = None
                    for cidx in range(1, max_c + 1):
                        val = ws.cell(row=r, column=cidx).value
                        if isinstance(val, str):
                            v = val.strip().lower()
                            if 'outlet' in v:
                                outlet_col = outlet_col or cidx
                            if v == 'ttl' or 'total' in v:
                                ttl_col = ttl_col or cidx
                    if outlet_col and ttl_col:
                        return r, outlet_col, ttl_col
                # 行內未同時找到，嘗試全表內逐字匹配各自欄位
                outlet_pos = None
                ttl_pos = None
                for r in range(1, max_r + 1):
                    for cidx in range(1, max_c + 1):
                        val = ws.cell(row=r, column=cidx).value
                        if isinstance(val, str):
                            v = val.strip().lower()
                            if not outlet_pos and 'outlet' in v:
                                outlet_pos = (r, cidx)
                            if not ttl_pos and (v == 'ttl' or 'total' in v):
                                ttl_pos = (r, cidx)
                    if outlet_pos and ttl_pos:
                        # 使用較大的 row 當 header_row
                        header_row = max(outlet_pos[0], ttl_pos[0])
                        return header_row, outlet_pos[1], ttl_pos[1]
                return None, None, None

            def run_merge_amount():
                from tkinter import messagebox
                files = [
    f for f in self.monthamt_files_var.get().split(';') if f.strip()]
                if not files:
                    messagebox.showwarning('檔案', '請選擇要整合的 Excel 檔案')
                    return
                os.makedirs(self.monthsum_output_var.get(), exist_ok=True)

                # 結構： {supplier: {outlet: {YYYY-MM: amount}}}
                sup_map = {}
                months_set = set()
                supplier_outlets = {}

                import openpyxl
                for fp in files:
                    ym = parse_month_from_filename(fp)
                    if not ym:
                        messagebox.showwarning('檔名', f"無法從檔名解析月份：\n{fp}")
                        continue
                    months_set.add(ym)
                    # 可能檔案被 Excel 鎖定，複製到暫存再讀
                    try:
                        wb = openpyxl.load_workbook(fp, data_only=True)
                        tmp_copied = None
                    except PermissionError:
                        import tempfile
                        import shutil
                        tmp = tempfile.NamedTemporaryFile(
                            delete=False, suffix='.xlsx')
                        tmp.close()
                        shutil.copyfile(fp, tmp.name)
                        wb = openpyxl.load_workbook(tmp.name, data_only=True)
                        tmp_copied = tmp.name
                    try:
                        for sheet in wb.sheetnames:
                            # 常見非供應商工作表可排除
                            if sheet.strip().lower() in ("data", "summary"):
                                continue
                            ws = wb[sheet]
                            header_row, col_outlet, col_ttl = find_headers(ws)
                            if not header_row:
                                continue
                            # 初始化供應商節點
                            sup_map.setdefault(sheet, {})
                            supplier_outlets.setdefault(sheet, set())
                            # 掃描資料列
                            for r in range(header_row + 1, ws.max_row + 1):
                                outlet = ws.cell(
    row=r, column=col_outlet).value
                                if not outlet:
                                    continue
                                outlet = str(outlet).strip()
                                supplier_outlets[sheet].add(outlet)
                                val = ws.cell(row=r, column=col_ttl).value
                                try:
                                    amt = float(val) if val not in (
                                        None, '') else 0.0
                                except Exception:
                                    amt = 0.0
                                if amt == 0:
                                    continue
                                sup_map[sheet].setdefault(outlet, {})
                                sup_map[sheet][outlet][ym] = sup_map[sheet][outlet].get(
                                    ym, 0.0) + amt
                    finally:
                        wb.close()
                        try:
                            if 'tmp_copied' in locals() and tmp_copied:
                                os.remove(tmp_copied)
                        except Exception:
                            pass

                # 輸出
                months_sorted = sorted(months_set)
                out_file = os.path.join(
    self.monthsum_output_var.get(),
     'Monthly_Amount_BySupplier.xlsx')
                wb_out = openpyxl.Workbook()
                # 預設建立 Summary，若後面有建立任何供應商頁再移除
                ws_default = wb_out.active
                ws_default.title = 'Summary'
                from openpyxl.styles import PatternFill, Font, Alignment
                header_fill = PatternFill("solid", fgColor="BDD7EE")
                bold = Font(bold=True)
                center = Alignment(horizontal='center', vertical='center')

                # 每個供應商建立一頁
                created_any = False
                for supplier in sorted(sup_map.keys()):
                    ws = wb_out.create_sheet(supplier[:31])
                    ws.cell(row=1, column=1, value='Outlet').font = bold
                    ws.cell(row=1, column=1).fill = header_fill
                    for j, ym in enumerate(months_sorted, start=2):
                        ws.cell(row=1, column=j, value=ym).font = bold
                        ws.cell(row=1, column=j).alignment = center
                        ws.cell(row=1, column=j).fill = header_fill
                    outlets_sorted = sorted(
                        supplier_outlets.get(supplier, set()))
                    for i, outlet in enumerate(outlets_sorted, start=2):
                        ws.cell(row=i, column=1, value=outlet)
                        ym_map = sup_map[supplier].get(outlet, {})
                        for j, ym in enumerate(months_sorted, start=2):
                            val = ym_map.get(ym)
                            if val not in (None, 0):
                                ws.cell(row=i, column=j, value=val)
                    created_any = True

                # 若沒有任何供應商/資料，保留 Summary 並寫明訊息；否則移除 Summary
                if created_any:
                    wb_out.remove(ws_default)
                else:
                    ws_default.cell(row=1, column=1, value='No data parsed')

                wb_out.save(out_file)
                messagebox.showinfo('完成', f'金額整合已輸出：\n{out_file}')

            try:
                GlowButton(
    amt_frame,
    text='整合金額（以廠商）\nMerge Amounts (by Supplier)',
    command=run_merge_amount,
    width=300,
    height=40,
    glow_color=(
        ACCENT_PURPLE if 'ACCENT_PURPLE' in globals() else ACCENT_BLUE),
        corner_radius=18).pack(
            pady=(
                6,
                 10))
            except Exception:
                ctk.CTkButton(
    amt_frame,
    text='整合金額（以廠商）\nMerge Amounts (by Supplier)',
    fg_color=ACCENT_BLUE,
    command=run_merge_amount,
    height=36).pack(
        pady=(
            6,
             10))

        # 清空内容区
        for w in self.content_body.winfo_children():
            w.destroy()

        # 设置功能标题
        self.function_title.configure(
    text="📊 月結月度彙總\nMonth-end Monthly Order Summary")
        self.function_subtitle.configure(
    text="整合多個檔案，依各日實際訂購日期歸入對應『年-月』\nMerge multiple files by actual order dates into Year-Month groups")

        # 直接构建月结月度汇总界面
        build(self.content_body)

    def show_email_sending_ui(self):
        """显示邮件发送界面"""
        def build(c):
            import os
            self.email_supplier_folder_var = ctk.StringVar()
            self.email_master_config_var = ctk.StringVar()

            # 创建表单框架
            form_frame = ctk.CTkFrame(c, fg_color="transparent")
            form_frame.pack(fill="both", expand=True, padx=30, pady=10)
            # 供应商文件夹
            row1 = ctk.CTkFrame(form_frame)
            row1.pack(fill="x", pady=8)
            ctk.CTkLabel(
    row1, text="供應商文件夾\nSupplier Folder:", font=(
        "Microsoft JhengHei", 12, "bold")).pack(
            side="left", padx=8)
            ctk.CTkEntry(
    row1,
    textvariable=self.email_supplier_folder_var,
    font=FONT_MID,
    state="readonly",
    width=400).pack(
        side="left",
        expand=True,
        fill="x",
         padx=5)
            email_browse_btn = ctk.CTkButton(
                row1,
                text="瀏覽...\nBrowse...",
                font=("Microsoft YaHei", 11, "bold"),
                command=lambda: self._select_folder_var(
                    self.email_supplier_folder_var),
                corner_radius=8,
                hover_color="#1976d2",
                height=30
            )
            email_browse_btn.pack(side="left", padx=5)
            # 统一配置文件
            row2 = ctk.CTkFrame(form_frame)
            row2.pack(fill="x", pady=8)
            ctk.CTkLabel(
    row2, text="統一配置文件\nMaster Config (Excel):", font=(
        "Microsoft JhengHei", 12, "bold")).pack(
            side="left", padx=8)
            ctk.CTkEntry(
    row2,
    textvariable=self.email_master_config_var,
    font=FONT_MID,
    state="readonly",
    width=400).pack(
        side="left",
        expand=True,
        fill="x",
         padx=5)
            browse_btn_email_config = ctk.CTkButton(
                row2,
                text="瀏覽...\nBrowse...",
                font=("Microsoft YaHei", 11, "bold"),
                command=lambda: self._select_config_file(
    self.email_master_config_var, [
        ("Excel files", "*.xlsx")]),
                corner_radius=8,
                hover_color="#1976d2",
                height=30
            )
            browse_btn_email_config.pack(side="left", padx=5)
            # 新增：供應商選擇區域
            supplier_frame = ctk.CTkFrame(form_frame)
            supplier_frame.pack(fill="x", pady=8)
            ctk.CTkLabel(
    supplier_frame,
    text="選擇供應商\nSelect Supplier:",
    font=(
        "Microsoft JhengHei",
        12,
        "bold")).pack(
            side="left",
             padx=8)
            self.supplier_combobox = ctk.CTkComboBox(
    supplier_frame, values=["請先選擇文件夾和配置文件"], state="readonly", width=300)
            self.supplier_combobox.pack(side="left", padx=5)

            # 美化：自訂主旨/Custom Subject 行
            subject_option_frame = ctk.CTkFrame(
    form_frame, fg_color="#232e3c", corner_radius=14, height=48)
            subject_option_frame.pack(fill="x", pady=10, padx=2)
            subject_option_frame.pack_propagate(False)
            # 彩色icon/條
            accent = ctk.CTkLabel(subject_option_frame, text="★", font=(
                "Segoe UI Emoji", 22), text_color="#38bdf8", width=32)
            accent.pack(side="left", padx=(12, 8), pady=0)
            self.use_custom_subject_var = ctk.BooleanVar(value=False)
            custom_subject_checkbox = ctk.CTkCheckBox(
                subject_option_frame,
                text="自訂主旨\nCustom Subject",
                variable=self.use_custom_subject_var,
                font=("Microsoft JhengHei", 14, "bold"),
                width=30,
                height=30,
                border_width=3,
                corner_radius=8,
                fg_color="#2563eb",
                hover_color="#1d4ed8",
                border_color="#60a5fa",
                text_color="#fff",
                checkbox_height=24,
                checkbox_width=24,
                command=lambda: self._toggle_subject_entry()
            )
            custom_subject_checkbox.pack(side="left", padx=(0, 18), pady=0)
            ctk.CTkLabel(
    subject_option_frame,
    text="郵件主旨\nEmail Subject:",
    font=(
        "Microsoft JhengHei",
        14,
        "bold"),
        text_color="#e0e7ef").pack(
            side="left",
            padx=(
                0,
                12),
                 pady=0)
            self.email_subject_var = ctk.StringVar()
            self.email_subject_entry = ctk.CTkEntry(
    subject_option_frame,
    textvariable=self.email_subject_var,
    font=(
        "Microsoft JhengHei",
        14),
        width=520,
        height=32,
        border_width=3,
        corner_radius=10,
        fg_color="#f1f5f9",
        text_color="#222",
        border_color="#38bdf8",
         state="disabled")
            self.email_subject_entry.pack(
    side="left", padx=(
        0, 18), fill="x", expand=True, pady=0)

            def _toggle_subject_entry(self=None):
                if self is None:
                    return
                if self.use_custom_subject_var.get():
                    self.email_subject_entry.configure(
    state="normal", fg_color="#fff", text_color="#222", border_color="#2563eb")
                else:
                    self.email_subject_entry.configure(
    state="disabled",
    fg_color="#f1f5f9",
    text_color="#222",
     border_color="#38bdf8")
            self._toggle_subject_entry = _toggle_subject_entry.__get__(self)

            # 更新供應商列表的函數
            def update_supplier_list():
                folder = self.email_supplier_folder_var.get()
                master_config = self.email_master_config_var.get()
                if not folder or not master_config:
                    self.supplier_combobox.configure(values=["請先選擇文件夾和配置文件"])
                    return

                try:
                    # 讀取配置文件中的供應商
                    wb = load_workbook(master_config, data_only=True)
                    supplier_dict = {}  # 使用 dict 來保存每個供應商的第一個 email
                    if "Suppliers" in wb.sheetnames:
                        ws = wb["Suppliers"]
                        for row in ws.iter_rows(min_row=2, values_only=True):
                            if row and row[0]:
                                supplier = str(row[0]).strip()
                                if supplier not in supplier_dict:  # 只保存每個供應商的第一個 email
                                    supplier_dict[supplier] = str(
                                        row[2]).strip() if len(row) > 2 else ""
                    files = [f for f in os.listdir(folder) if f.endswith(
                        ".xlsx") and not f.startswith("~$")]
                    available_suppliers = []
                    for supplier in supplier_dict:
                        for file in files:
                            # 只要檔名有對應廠商名稱（不限定 _Week_）
                            if supplier in file and supplier not in available_suppliers:
                                available_suppliers.append(supplier)
                    if available_suppliers:
                        self.supplier_combobox.configure(
    values=sorted(available_suppliers))  # 排序顯示
                        self.supplier_combobox.set(available_suppliers[0])
                    else:
                        self.supplier_combobox.configure(
                            values=["沒有找到匹配的供應商文件"])
                except Exception as e:
                    self.supplier_combobox.configure(values=[f"錯誤: {str(e)}"])

            # 綁定文件夾和配置文件變更事件
            self.email_supplier_folder_var.trace(
    "w", lambda *args: update_supplier_list())
            self.email_master_config_var.trace(
    "w", lambda *args: update_supplier_list())

            # 郵件正文body輸入框
            ctk.CTkLabel(
    form_frame,
    text="郵件正文/Email Body:",
    font=(
        "Microsoft JhengHei",
        12,
        "bold")).pack(
            anchor="w",
            padx=10,
            pady=(
                12,
                 0))
            self.email_body_textbox = ctk.CTkTextbox(
    form_frame, height=100, font=(
        "Microsoft JhengHei", 12), wrap="word")
            self.email_body_textbox.pack(fill="x", padx=10, pady=(0, 8))

            # 模板按鈕區域
            template_frame = ctk.CTkFrame(form_frame, fg_color="transparent")
            template_frame.pack(fill="x", padx=10, pady=(0, 8))

            # 一般訂單模板按鈕
            weekly_template_btn = ctk.CTkButton(
                template_frame,
                text="一般訂單模板\nWeekly Order Template",
                command=lambda: self._load_weekly_template(),
                fg_color="#2563eb",
                hover_color="#1d4ed8",
                font=("Microsoft YaHei", 11, "bold"),
                corner_radius=8,
                height=30
            )
            weekly_template_btn.pack(side="left", padx=(0, 8))

            # Amendment 訂單模板按鈕
            amendment_template_btn = ctk.CTkButton(
                template_frame,
                text="Amendment 模板\nAmendment Template",
                command=lambda: self._load_amendment_template(),
                fg_color="#dc2626",
                hover_color="#b91c1c",
                font=("Microsoft YaHei", 11, "bold"),
                corner_radius=8,
                height=30
            )
            amendment_template_btn.pack(side="left")

            # 載入本地body預設 - 優先載入 weekly order 模板
            default_body = "Hi Team,\n\n{month_week} order as attached.\n\nBest Regards,"

            # 優先嘗試載入 weekly order 模板
            weekly_template_path = "weekly_order_template.txt"
            legacy_body_path = "email_body.txt"  # 保持向後兼容

            saved_body = None

            # 首先嘗試載入 weekly order 模板
            if os.path.exists(weekly_template_path):
                try:
                    with open(weekly_template_path, "r", encoding="utf-8") as f:
                        saved_body = f.read()
                except Exception:
                    pass

            # 如果沒有 weekly order 模板，嘗試載入舊的 email_body.txt
            if saved_body is None and os.path.exists(legacy_body_path):
                try:
                    with open(legacy_body_path, "r", encoding="utf-8") as f:
                        saved_body = f.read()
                except Exception:
                    pass

            # 如果成功載入了模板，替換變數並顯示
            if saved_body is not None:
                try:
                    # 替換模板中的變數
                    from datetime import datetime, timedelta
                    now = datetime.now()
                    # 計算下周的日期
                    days_until_next_monday = (7 - now.weekday()) % 7
                    if days_until_next_monday == 0:
                        days_until_next_monday = 7
                    next_monday = now + timedelta(days=days_until_next_monday)
                    month_name = next_monday.strftime("%B")
                    week_of_month = get_week_of_month(next_monday)
                    month_week = f"{month_name} - Week {week_of_month}"

                    # 替換模板中的變數
                    saved_body = saved_body.replace("{month_week}", month_week)

                    self.email_body_textbox.delete("1.0", "end")
                    self.email_body_textbox.insert("1.0", saved_body)
                except Exception:
                    # 如果替換變數失敗，使用默認模板
                    self.email_body_textbox.insert("1.0", default_body)
            else:
                # 如果沒有找到任何模板文件，使用默認模板
                self.email_body_textbox.insert("1.0", default_body)
            # 保存按鈕功能

            def save_body():
                body = self.email_body_textbox.get("1.0", "end-1c")

                # 創建保存選項對話框
                save_dialog = ctk.CTkToplevel(self)
                save_dialog.title("保存郵件模板 / Save Email Template")
                save_dialog.geometry("500x300")
                save_dialog.attributes('-topmost', True)
                save_dialog.resizable(False, False)

                # 標題
                ctk.CTkLabel(save_dialog,
                           text="選擇要保存的模板類型\nSelect Template Type to Save",
                           font=("Microsoft YaHei", 16, "bold"),
                           text_color="#2563eb").pack(pady=20)

                # 按鈕框架
                btn_frame = ctk.CTkFrame(save_dialog, fg_color="transparent")
                btn_frame.pack(pady=20, fill="x", padx=40)

                def save_weekly_template():
                    try:
                        with open("weekly_order_template.txt", "w", encoding="utf-8") as f:
                            f.write(body)
                        # 創建置頂成功提示
                        success_window = ctk.CTkToplevel()
                        success_window.title("保存成功 / Save Success")
                        success_window.geometry("400x150")
                        success_window.attributes('-topmost', True)
                        success_window.resizable(False, False)

                        ctk.CTkLabel(success_window,
                                   text="✅ Weekly Order 模板已保存！\n✅ Weekly Order template saved!",
                                   font=("Microsoft YaHei", 14, "bold"),
                                   text_color="#10b981").pack(pady=20)

                        def close_success():
                            success_window.destroy()
                            save_dialog.destroy()

                        ctk.CTkButton(success_window,
                                    text="確定 / OK",
                                    command=close_success,
                                    fg_color="#10b981",
                                    hover_color="#059669").pack(pady=10)

                        success_window.after(3000, close_success)

                    except Exception as e:
                        error_window = ctk.CTkToplevel()
                        error_window.title("保存失敗 / Save Failed")
                        error_window.geometry("400x150")
                        error_window.attributes('-topmost', True)
                        error_window.resizable(False, False)

                        ctk.CTkLabel(error_window,
                                   text=f"❌ 保存失敗: {
    str(e)}\n❌ Save failed: {
        str(e)}",
                                   font=("Microsoft YaHei", 12),
                                   text_color="#ef4444").pack(pady=20)

                        ctk.CTkButton(error_window,
                                    text="確定 / OK",
                                    command=error_window.destroy,
                                    fg_color="#ef4444").pack(pady=10)

                def save_amendment_template():
                    try:
                        with open("amendment_order_template.txt", "w", encoding="utf-8") as f:
                            f.write(body)
                        # 創建置頂成功提示
                        success_window = ctk.CTkToplevel()
                        success_window.title("保存成功 / Save Success")
                        success_window.geometry("400x150")
                        success_window.attributes('-topmost', True)
                        success_window.resizable(False, False)

                        ctk.CTkLabel(success_window,
                                   text="✅ Amendment Order 模板已保存！\n✅ Amendment Order template saved!",
                                   font=("Microsoft YaHei", 14, "bold"),
                                   text_color="#10b981").pack(pady=20)

                        def close_success():
                            success_window.destroy()
                            save_dialog.destroy()

                        ctk.CTkButton(success_window,
                                    text="確定 / OK",
                                    command=close_success,
                                    fg_color="#10b981",
                                    hover_color="#059669").pack(pady=10)

                        success_window.after(3000, close_success)

                    except Exception as e:
                        error_window = ctk.CTkToplevel()
                        error_window.title("保存失敗 / Save Failed")
                        error_window.geometry("400x150")
                        error_window.attributes('-topmost', True)
                        error_window.resizable(False, False)

                        ctk.CTkLabel(error_window,
                                   text=f"❌ 保存失敗: {
    str(e)}\n❌ Save failed: {
        str(e)}",
                                   font=("Microsoft YaHei", 12),
                                   text_color="#ef4444").pack(pady=20)

                        ctk.CTkButton(error_window,
                                    text="確定 / OK",
                                    command=error_window.destroy,
                                    fg_color="#ef4444").pack(pady=10)

                # Weekly Order 保存按鈕
                weekly_btn = ctk.CTkButton(
                    btn_frame,
                    text="📧 保存為 Weekly Order 模板\n📧 Save as Weekly Order Template",
                    command=save_weekly_template,
                    fg_color="#2563eb",
                    hover_color="#1d4ed8",
                    font=("Microsoft YaHei", 12, "bold"),
                    height=60,
                    corner_radius=10
                )
                weekly_btn.pack(pady=10, fill="x")

                # Amendment Order 保存按鈕
                amendment_btn = ctk.CTkButton(
                    btn_frame,
                    text="🔄 保存為 Amendment Order 模板\n🔄 Save as Amendment Order Template",
                    command=save_amendment_template,
                    fg_color="#dc2626",
                    hover_color="#b91c1c",
                    font=("Microsoft YaHei", 12, "bold"),
                    height=60,
                    corner_radius=10
                )
                amendment_btn.pack(pady=10, fill="x")

                # 取消按鈕
                cancel_btn = ctk.CTkButton(
                    btn_frame,
                    text="取消 / Cancel",
                    command=save_dialog.destroy,
                    fg_color="#6b7280",
                    hover_color="#4b5563",
                    font=("Microsoft YaHei", 12),
                    height=40,
                    corner_radius=10
                )
                cancel_btn.pack(pady=(20, 0), fill="x")

            # 美化的保存按鈕
            save_btn = ctk.CTkButton(
                form_frame,
                text="保存郵件模板/Save Email Template",
                command=save_body,
                fg_color=ACCENT_GREEN,
                hover_color=BTN_HOVER,
                font=("Microsoft YaHei", 11, "bold"),
                corner_radius=10,
                height=30
            )
            save_btn.pack(anchor="e", padx=10, pady=(0, 8))

            # 預覽和發送按鈕
            btn_frame = ctk.CTkFrame(c, fg_color="transparent")
            btn_frame.pack(pady=15, fill="x", padx=20)
            btn_frame.grid_columnconfigure(0, weight=1)
            btn_frame.grid_columnconfigure(1, weight=1)
            # 讓按鈕自適應寬度，並在視窗窄時自動換行
            send_btn = GlowButton(
                btn_frame,
                text="單獨發送\nSend Individual",
                command=self._preview_supplier_email,
                width=200,
                height=40,
                glow_color=ACCENT_BLUE
            )
            send_btn.grid(row=0, column=0, padx=8, pady=3, sticky="ew")
            dir_btn = GlowButton(
                btn_frame,
                text="發送目錄\nEmail Directory",
                command=self._show_email_directory,
                width=200,
                height=40,
                glow_color=ACCENT_RED
            )
            dir_btn.grid(row=0, column=1, padx=8, pady=3, sticky="ew")

            # 確保按鈕在窗口縮小時也能顯示
            def on_configure(event):
                # 當窗口大小改變時，確保按鈕可見
                if event.width < 600:  # 如果窗口太窄
                    send_btn.grid(row=0, column=0, padx=5, pady=3, sticky="ew")
                    dir_btn.grid(row=1, column=0, padx=5, pady=3, sticky="ew")
                else:
                    send_btn.grid(row=0, column=0, padx=8, pady=3, sticky="ew")
                    dir_btn.grid(row=0, column=1, padx=8, pady=3, sticky="ew")

            # 綁定窗口大小改變事件
            c.bind("<Configure>", on_configure)

        # 清空内容区
        for w in self.content_body.winfo_children():
            w.destroy()

        # 设置功能标题
        self.function_title.configure(text=t("send_emails"))
        self.function_subtitle.configure(
    text="选择供应商文件夹并发送邮件\nSelect supplier folder and send emails")

        # 直接构建邮件发送界面
        build(self.content_body)

    def _load_weekly_template(self):
        """載入一般訂單模板"""
        from datetime import datetime, timedelta
        now = datetime.now()

        # 計算下周的日期
        # 找到下週一：如果今天是週一，下週一就是今天+7天；否則找到下一個週一
        days_until_next_monday = (7 - now.weekday()) % 7
        if days_until_next_monday == 0:
            days_until_next_monday = 7  # 如果今天是週一，下週一就是7天後
        next_monday = now + timedelta(days=days_until_next_monday)

        # 使用下周一的月份和週數
        month_name = next_monday.strftime("%B")
        week_of_month = get_week_of_month(next_monday)

        # 嘗試從保存的模板文件中讀取
        template_path = "weekly_order_template.txt"
        if os.path.exists(template_path):
            try:
                with open(template_path, "r", encoding="utf-8") as f:
                    weekly_template = f.read()
                # 替換模板中的變數
                month_week = f"{month_name} - Week {week_of_month}"
                weekly_template = weekly_template.replace(
                    "{month_week}", month_week)
            except Exception:
                # 如果讀取失敗，使用默認模板
                weekly_template = f"Hi Team,\n\n{month_name} - Week {week_of_month} order as attached.\n\nBest Regards,"
        else:
            # 如果文件不存在，使用默認模板
            weekly_template = f"Hi Team,\n\n{month_name} - Week {week_of_month} order as attached.\n\nBest Regards,"

        # 更新郵件正文
        self.email_body_textbox.delete("1.0", "end")
        self.email_body_textbox.insert("1.0", weekly_template)

        # 更新主旨（如果啟用了自訂主旨）
        if self.use_custom_subject_var.get():
            subject_template = f"Sushi Express Weekly Order - {{Supplier}} - {month_name} - Week {week_of_month}"
            self.email_subject_var.set(subject_template)

    def _load_amendment_template(self):
        """載入 Amendment 訂單模板"""
        from datetime import datetime
        now = datetime.now()
        month_name = now.strftime("%B")
        week_of_month = get_week_of_month(now)

        # 嘗試從保存的模板文件中讀取
        template_path = "amendment_order_template.txt"
        if os.path.exists(template_path):
            try:
                with open(template_path, "r", encoding="utf-8") as f:
                    amendment_template = f.read()
                # 替換模板中的變數（如果有的話）
                month_week = f"{month_name} - Week {week_of_month}"
                amendment_template = amendment_template.replace(
                    "{month_week}", month_week)
            except Exception:
                # 如果讀取失敗，使用默認模板
                amendment_template = f"Hi Team,\n\nAmendment order as attached.\n\nBest Regards,"
        else:
            # 如果文件不存在，使用默認模板
            amendment_template = f"Hi Team,\n\nAmendment order as attached.\n\nBest Regards,"

        # 更新郵件正文
        self.email_body_textbox.delete("1.0", "end")
        self.email_body_textbox.insert("1.0", amendment_template)

        # 更新主旨（如果啟用了自訂主旨）
        if self.use_custom_subject_var.get():
            subject_template = f"Sushi Express Amendment Order - {{Supplier}}"
            self.email_subject_var.set(subject_template)

    def _preview_supplier_email(self):
        """預覽選定供應商的郵件內容"""
        import os
        folder = self.email_supplier_folder_var.get()
        master_config = self.email_master_config_var.get()
        selected_supplier = self.supplier_combobox.get()

        if not folder or not master_config:
            messagebox.showwarning(t("warning"), t("folder_warning"))
            return

        if not selected_supplier or selected_supplier in [
            "請先選擇文件夾和配置文件", "沒有找到匹配的供應商文件"]:
            messagebox.showwarning("警告", "請先選擇供應商")
            return

        files = [f for f in os.listdir(folder) if f.endswith(
            ".xlsx") and not f.startswith("~$")]
        
        # 查找供应商的所有相关文件
        matched_files = find_all_supplier_files(selected_supplier, files)
        if not matched_files:
            messagebox.showerror("錯誤", f"找不到 {selected_supplier} 的對應文件")
            return
        
        # 如果只有一个文件，使用原来的逻辑
        if len(matched_files) == 1:
            supplier_file = os.path.join(folder, matched_files[0])
            attachment_info = f"附件/Attachment: {matched_files[0]}"
        else:
            # 多个文件的情况
            supplier_file = [os.path.join(folder, f) for f in matched_files]
            attachment_info = f"附件/Attachments ({len(matched_files)} 個):\n" + "\n".join([f"• {f}" for f in matched_files])

        # 獲取郵件內容
        body = self.email_body_textbox.get("1.0", "end-1c")
        config_mgr = UnifiedConfigManager(master_config)
        email_sender = EmailSender(config_mgr)

        to_emails, cc_emails = email_sender.get_to_cc_emails(
            selected_supplier, master_config)
        from datetime import datetime, timedelta
        now = datetime.now()

        # 計算下周的日期
        days_until_next_monday = (7 - now.weekday()) % 7
        if days_until_next_monday == 0:
            days_until_next_monday = 7
        next_monday = now + timedelta(days=days_until_next_monday)

        # 使用下周一的月份和週數
        month_name = next_monday.strftime("%B")
        week_of_month = get_week_of_month(next_monday)

        # 處理郵件正文中的變數替換
        body = body.replace("{month_week}",
     f"{month_name} - Week {week_of_month}")

        # 處理主旨
        subject = ""
        if self.use_custom_subject_var.get():
            custom_subject = self.email_subject_var.get().strip()
            if custom_subject:
                # 替換主旨中的變數
                subject = custom_subject.replace(
    "{week_no}",
    str(week_of_month)).replace(
        "{Supplier}",
        selected_supplier).replace(
            "{Month}",
            month_name).replace(
                "{Week}",
                str(week_of_month)).replace(
                    "{month_week}",
                     f"{month_name} - Week {week_of_month}")
            else:
                subject = f"Sushi Express Weekly Order - {selected_supplier} - {month_name} - Week {week_of_month}"
        else:
            # 根據 body 內容判斷是 Amendment 還是 Weekly Order
            if "Amendment order" in body:
                subject = f"Sushi Express Amendment Order - {selected_supplier}"
            else:
                subject = f"Sushi Express Weekly Order - {selected_supplier} - {month_name} - Week {week_of_month}"

        self.email_subject_var.set(
    subject if self.use_custom_subject_var.get() else "")

        # 創建預覽窗口
        preview_window = ctk.CTkToplevel(self)
        preview_window.title(f"郵件預覽 - {selected_supplier}")
        preview_window.geometry("600x500")
        preview_window.resizable(True, True)
        preview_window.attributes('-topmost', True)  # 設置視窗置頂
        preview_window.focus_force()  # 強制聚焦

        # 郵件信息
        info_frame = ctk.CTkFrame(preview_window)
        info_frame.pack(fill="x", padx=10, pady=10)

        ctk.CTkLabel(
    info_frame,
    text=f"供應商/Supplier: {selected_supplier}",
    font=FONT_MID).pack(
        anchor="w",
        padx=10,
         pady=5)
        ctk.CTkLabel(
    info_frame,
    text=f"主旨/Subject: {subject}",
    font=FONT_MID,
    wraplength=500).pack(
        anchor="w",
        padx=10,
         pady=5)

        # 收件人郵箱顯示
        to_emails_text = ", ".join(to_emails) if to_emails else "無"
        to_label = ctk.CTkLabel(
    info_frame,
    text=f"收件人/To: {to_emails_text}",
    font=FONT_MID,
     wraplength=500)
        to_label.pack(anchor="w", padx=10, pady=5)

        ctk.CTkLabel(
    info_frame,
    text=attachment_info,
    font=FONT_MID).pack(
        anchor="w",
        padx=10,
         pady=5)

        # 郵件正文預覽（可編輯）
        ctk.CTkLabel(
    preview_window,
    text="郵件正文/Email Body (可編輯):",
    font=FONT_MID).pack(
        anchor="w",
        padx=10,
        pady=(
            10,
             0))
        body_textbox = ctk.CTkTextbox(
    preview_window,
    height=200,
    font=FONT_MID,
     wrap="word")
        body_textbox.pack(fill="both", expand=True, padx=10, pady=10)
        body_textbox.insert("1.0", body)

        # 按鈕區域
        btn_frame = ctk.CTkFrame(preview_window)
        btn_frame.pack(fill="x", padx=10, pady=10)

        def send_this_email():
            # 發送這封郵件（使用編輯後的內容）
            edited_body = body_textbox.get("1.0", "end-1c")
            from datetime import datetime, timedelta
            now = datetime.now()

            # 計算下周的日期（與模板邏輯一致）
            days_until_next_monday = (7 - now.weekday()) % 7
            if days_until_next_monday == 0:
                days_until_next_monday = 7
            next_monday = now + timedelta(days=days_until_next_monday)

            # 使用下周一的月份和週數
            month_name = next_monday.strftime("%B")
            week_of_month = get_week_of_month(next_monday)
            month_week = f"{month_name} - Week {week_of_month}"

            # 處理郵件正文中的變數替換
            edited_body = edited_body.replace("{month_week}", month_week)

            # 處理主旨中的變數替換
            final_subject = subject.replace(
    "{month_week}", month_week).replace(
        "{Supplier}", selected_supplier)

            mail = email_sender.send_email(
                to_emails, cc_emails, selected_supplier, edited_body,
                attachment_path=supplier_file,
                account_idx=self.selected_outlook_account_idx,
                subject=final_subject
            )
            if isinstance(mail, tuple):
                messagebox.showerror("Error", mail[1])
                return
            if not mail:
                messagebox.showerror("Error", f"无法创建邮件: {selected_supplier}")
                return
            # 直接發送，不顯示 Outlook 視窗
            try:
                mail.Send()
                show_topmost_success(
    self,
    "發送成功 / Send Success",
     f"郵件已直接發送給 {selected_supplier}\nEmail sent successfully to {selected_supplier}")
                preview_window.destroy()
            except Exception as e:
                messagebox.showerror("發送失敗", f"發送郵件時發生錯誤: {str(e)}")

        # 美化的發送按鈕
        send_btn = ctk.CTkButton(
            btn_frame,
            text="發送此郵件/Send This Email",
            command=send_this_email,
            fg_color=ACCENT_RED,
            font=("Microsoft YaHei", 12, "bold"),
            corner_radius=10,
            hover_color="#d32f2f",
            height=35
        )
        send_btn.pack(side="right", padx=5)

        # 美化的關閉按鈕
        close_btn = ctk.CTkButton(
            btn_frame,
            text="關閉/Close",
            command=preview_window.destroy,
            font=("Microsoft YaHei", 12, "bold"),
            corner_radius=10,
            hover_color="#1976d2",
            height=35
        )
        close_btn.pack(side="right", padx=5)

    def _show_email_directory(self):
        """顯示郵件發送目錄"""
        import os

        folder = self.email_supplier_folder_var.get()
        master_config = self.email_master_config_var.get()

        if not folder or not master_config:
            messagebox.showwarning(t("warning"), t("folder_warning"))
            return

        def destroy_window():
            """正確清理視窗及其子元件"""
            try:
                # 先清理所有行框架
                for row_frame, _ in row_frames:
                    for widget in row_frame.winfo_children():
                        widget.destroy()
                    row_frame.destroy()
                row_frames.clear()

                # 清理其他框架和元件
                for widget in scroll_frame.winfo_children():
                    widget.destroy()
                scroll_frame.destroy()

                for widget in table_frame.winfo_children():
                    widget.destroy()
                table_frame.destroy()

                for widget in batch_frame.winfo_children():
                    widget.destroy()
                batch_frame.destroy()

                # 最後銷毀視窗
                directory_window.destroy()
            except Exception as e:
                print(f"Error during window cleanup: {e}")
                # 如果清理過程出錯，強制關閉視窗
                try:
                    directory_window.destroy()
                except:
                    pass

        # 獲取所有可用的供應商和文件
        files = [f for f in os.listdir(folder) if f.endswith(
            ".xlsx") and not f.startswith("~$")]
        print(f"[DEBUG] 找到的 Excel 文件: {files}")  # 调试信息
        master_config_path = self.email_master_config_var.get()
        config_mgr = UnifiedConfigManager(master_config_path)
        email_sender = EmailSender(config_mgr)

        # 讀取配置文件中的供應商，使用 dict 來去重複
        wb = load_workbook(master_config_path, data_only=True)
        supplier_dict = {}  # 使用 dict 來保存每個供應商的第一個 email
        if "Suppliers" in wb.sheetnames:
            ws = wb["Suppliers"]
            seen_suppliers = set()  # 使用 set 來記錄已處理的供應商
            for row in ws.iter_rows(min_row=2, values_only=True):
                if row and row[0]:
                    supplier = str(row[0]).strip()
                    # 标准化供应商名称（去除多余空格，转换为小写进行比较）
                    supplier_normalized = supplier.lower().strip()
                    if supplier_normalized not in seen_suppliers:  # 只處理每個供應商的第一個 email
                        seen_suppliers.add(supplier_normalized)
                        to_emails, cc_emails = email_sender.get_to_cc_emails(
                            supplier, master_config_path)
                        supplier_dict[supplier] = {
                            'to_emails': to_emails,
                            'cc_emails': cc_emails
                        }
                        print(f"[DEBUG] 添加供应商: {supplier}")  # 调试信息
                    else:
                        print(f"[DEBUG] 跳过重复供应商: {supplier}")  # 调试信息

        # 創建目錄窗口
        directory_window = ctk.CTkToplevel(self)
        directory_window.title("郵件發送目錄 / Email Directory")
        directory_window.geometry("1200x800")  # 加大視窗尺寸
        directory_window.resizable(True, True)
        directory_window.attributes('-topmost', True)  # 設置視窗置頂
        directory_window.focus_force()  # 強制聚焦

        # 標題
        title_label = ctk.CTkLabel(
    directory_window,
    text="供應商郵件發送目錄\nSupplier Email Directory",
     font=FONT_TITLE)
        title_label.pack(pady=10)

        # 創建表格框架
        table_frame = ctk.CTkFrame(directory_window)
        table_frame.pack(fill="both", expand=True, padx=20, pady=10)

        # 表格標題（增加間距和背景色）
        header_frame = ctk.CTkFrame(table_frame, fg_color=ACCENT_BLUE)
        header_frame.pack(fill="x", padx=10, pady=10)

        ctk.CTkLabel(
    header_frame,
    text="供應商/Supplier",
    font=FONT_MID,
    width=150,
    text_color="#ffffff").pack(
        side="left",
         padx=5)
        ctk.CTkLabel(
    header_frame,
    text="收件人/To",
    font=FONT_MID,
    width=400,
    text_color="#ffffff").pack(
        side="left",
         padx=5)
        ctk.CTkLabel(
    header_frame,
    text="附件/Attachment",
    font=FONT_MID,
    width=250,
    text_color="#ffffff").pack(
        side="left",
         padx=5)
        ctk.CTkLabel(
    header_frame,
    text="操作/Action",
    font=FONT_MID,
    width=100,
    text_color="#ffffff").pack(
        side="left",
         padx=5)

        # 搜尋框架
        search_frame = ctk.CTkFrame(table_frame)
        search_frame.pack(fill="x", padx=10, pady=5)

        ctk.CTkLabel(
    search_frame,
    text="搜尋供應商 / Search Supplier:",
    font=FONT_MID).pack(
        side="left",
         padx=5)
        search_var = ctk.StringVar()
        search_entry = ctk.CTkEntry(
    search_frame, textvariable=search_var, width=300)
        search_entry.pack(side="left", padx=5)

        # 滾動框架
        scroll_frame = ctk.CTkScrollableFrame(table_frame)
        scroll_frame.pack(fill="both", expand=True, padx=10, pady=5)

        # 儲存所有行框架的引用，用於搜尋過濾
        row_frames = []
        email_list = []
        supplier_check_vars = {}  # 新增：每個供應商的勾選狀態
        sent_status = {}  # 新增：記錄已發送狀態

        def filter_rows(*args):
            """根據搜尋文字過濾行"""
            search_text = search_var.get().lower()
            visible_count = 0
            for row_frame, supplier_name in row_frames:
                if search_text in supplier_name.lower():
                    row_frame.pack(fill="x", padx=5, pady=5)
                    visible_count += 1
                else:
                    row_frame.pack_forget()
            # 更新總結信息
            summary_label.configure(
    text=f"總共找到 {supplier_count} 個供應商，顯示 {visible_count} 個")

        # 綁定搜尋事件
        search_var.trace("w", filter_rows)

        # 總結信息標籤（需要在 filter_rows 函數之前定義）
        summary_label = ctk.CTkLabel(
            directory_window, text=f"總共找到 0 個供應商可以發送郵件", font=FONT_MID)
        summary_label.pack(pady=10)
        
        # 初始化供應商計數器
        supplier_count = 0

        # 只處理每個供應商一次
        processed_suppliers = set()  # 使用 set 來記錄已處理的供應商
        print(f"[DEBUG] 供應商字典: {list(supplier_dict.keys())}")  # 调试信息
        
        for supplier in supplier_dict:
            if supplier in processed_suppliers:
                continue
            processed_suppliers.add(supplier)

            # 查找供应商的所有相关文件
            matched_files = find_all_supplier_files(supplier, files)
            print(f"[DEBUG] 供應商 {supplier} 找到的文件: {matched_files}")  # 调试信息
            if matched_files:
                print(f"[DEBUG] 供應商 {supplier} 有匹配文件，開始創建 UI")  # 调试信息
                to_emails = supplier_dict[supplier]['to_emails']
                cc_emails = supplier_dict[supplier]['cc_emails']

                row_frame = ctk.CTkFrame(scroll_frame)
                row_frames.append((row_frame, supplier))
                row_frame.pack(fill="x", padx=5, pady=5)
                print(f"[DEBUG] 供應商 {supplier} 的 row_frame 已創建並 pack")  # 调试信息

                var = ctk.BooleanVar(value=True)
                supplier_check_vars[supplier] = var
                check_btn = ctk.CTkCheckBox(
    row_frame, variable=var, text="", width=24)
                check_btn.pack(side="left", padx=5)
                supplier_label = ctk.CTkLabel(
    row_frame, text=supplier, font=FONT_MID, width=150)
                supplier_label.pack(side="left", padx=5)
                to_emails_text = ", ".join(to_emails) if to_emails else "無"
                to_label = ctk.CTkLabel(
    row_frame,
    text=to_emails_text,
    font=FONT_MID,
    width=400,
     wraplength=380)
                to_label.pack(side="left", padx=5)
                
                # 显示附件信息
                if len(matched_files) == 1:
                    attachment_text = matched_files[0]
                else:
                    # 显示具体的文件名列表
                    attachment_text = f"{len(matched_files)} 個文件:\n" + "\n".join([f"• {f}" for f in matched_files])
                
                attachment_label = ctk.CTkLabel(
                    row_frame, text=attachment_text, font=FONT_MID, width=250, wraplength=200)
                attachment_label.pack(side="left", padx=5)
                status_label = ctk.CTkLabel(
    row_frame, text="", font=FONT_MID, width=40)
                status_label.pack(side="left", padx=5)
                sent_status[supplier] = status_label

                def create_send_function(supplier, to_emails, cc_emails, attachment_files):
                    def send_email():
                        body = self.email_body_textbox.get("1.0", "end-1c")
                        from datetime import datetime, timedelta
                        today = datetime.now().date()
                        this_monday = today - timedelta(days=today.weekday())
                        next_monday = this_monday + timedelta(days=7)
                        target_date = next_monday
                        month_name = target_date.strftime("%B")
                        week_of_month = get_week_of_month(target_date)
                        month_week = f"{month_name} - Week {week_of_month}"
                        body_filled = body.replace("{month_week}", month_week)

                        # 處理 subject - 檢查是否使用自定義 subject
                        if self.use_custom_subject_var.get():
                            # 使用自定義 subject
                            custom_subject = self.email_subject_var.get().strip()
                            if custom_subject:
                                # 替換自定義 subject 中的變數
                                subject = custom_subject.replace(
    "{Supplier}",
    supplier).replace(
        "{Month}",
        month_name).replace(
            "{Week}",
            str(week_of_month)).replace(
                "{month_week}",
                 month_week)
                            else:
                                # 如果自定義 subject 為空，使用預設 Weekly Order
                                subject = f"Sushi Express Weekly Order - {supplier} - {month_name} - Week {week_of_month}"
                        else:
                            # 根據 body 內容判斷是 Amendment 還是 Weekly Order
                            if "Amendment order" in body:
                                subject = f"Sushi Express Amendment Order - {supplier}"
                            else:
                                subject = f"Sushi Express Weekly Order - {supplier} - {month_name} - Week {week_of_month}"

                        # 創建 EmailSender 實例
                        master_config_path = self.email_master_config_var.get()
                        config_mgr = UnifiedConfigManager(master_config_path)
                        email_sender = EmailSender(config_mgr)
                        
                        # 處理多個附件文件
                        attachment_paths = [os.path.join(folder, f) for f in attachment_files]
                        mail = email_sender.send_email(
                            to_emails, cc_emails, supplier, body_filled,
                            attachment_path=attachment_paths[0] if len(attachment_paths) == 1 else attachment_paths,
                            account_idx=self.selected_outlook_account_idx,
                            subject=subject
                        )
                        if isinstance(mail, tuple):
                            # 創建置頂的錯誤提示窗口
                            error_window = ctk.CTkToplevel()
                            error_window.title("郵件創建失敗 / Mail Creation Failed")
                            error_window.geometry("400x150")
                            error_window.attributes('-topmost', True)  # 置頂顯示
                            error_window.resizable(False, False)

                            # 錯誤訊息
                            ctk.CTkLabel(error_window,
                                       text=f"❌ 郵件創建失敗: {
    mail[1]}\n❌ Mail creation failed: {
        mail[1]}",
                                       font=("Microsoft YaHei", 12),
                                       text_color="#ef4444").pack(pady=20)

                            # 確定按鈕
                            def close_error():
                                error_window.destroy()

                            ctk.CTkButton(error_window,
                                        text="確定 / OK",
                                        command=close_error,
                                        fg_color="#ef4444",
                                        hover_color="#dc2626",
                                        font=("Microsoft YaHei", 12, "bold")).pack(pady=10)

                            # 安全更新狀態標籤
                            try:
                                status_label = sent_status.get(supplier)
                                if status_label and status_label.winfo_exists():
                                    status_label.configure(
                                        text="✗", text_color=ACCENT_RED)
                            except:
                                pass
                            return
                        if not mail:
                            # 創建置頂的錯誤提示窗口
                            error_window = ctk.CTkToplevel()
                            error_window.title("郵件創建失敗 / Mail Creation Failed")
                            error_window.geometry("400x150")
                            error_window.attributes('-topmost', True)  # 置頂顯示
                            error_window.resizable(False, False)

                            # 錯誤訊息
                            ctk.CTkLabel(error_window,
                                       text=f"❌ 無法創建郵件: {supplier}\n❌ Cannot create mail: {supplier}",
                                       font=("Microsoft YaHei", 12),
                                       text_color="#ef4444").pack(pady=20)

                            # 確定按鈕
                            def close_error():
                                error_window.destroy()

                            ctk.CTkButton(error_window,
                                        text="確定 / OK",
                                        command=close_error,
                                        fg_color="#ef4444",
                                        hover_color="#dc2626",
                                        font=("Microsoft YaHei", 12, "bold")).pack(pady=10)

                            # 安全更新狀態標籤
                            try:
                                status_label = sent_status.get(supplier)
                                if status_label and status_label.winfo_exists():
                                    status_label.configure(
                                        text="✗", text_color=ACCENT_RED)
                            except:
                                pass
                            return
                        try:
                            mail.Send()
                            show_topmost_success(
    self,
    "發送成功 / Send Success",
     f"郵件已成功發送給 {supplier}\nEmail sent successfully to {supplier}")

                            # 安全更新狀態標籤
                            try:
                                status_label = sent_status.get(supplier)
                                if status_label and status_label.winfo_exists():
                                    status_label.configure(
                                        text="✔", text_color=ACCENT_GREEN)
                            except:
                                pass

                            # 自動取消勾選
                            try:
                                if supplier in supplier_check_vars:
                                    supplier_check_vars[supplier].set(False)
                            except:
                                pass

                        except Exception as e:
                            # 創建置頂的錯誤提示窗口
                            error_window = ctk.CTkToplevel()
                            error_window.title("發送失敗 / Send Failed")
                            error_window.geometry("400x150")
                            error_window.attributes('-topmost', True)  # 置頂顯示
                            error_window.resizable(False, False)

                            # 錯誤訊息
                            ctk.CTkLabel(error_window,
                                       text=f"❌ 發送失敗: {
    str(e)}\n❌ Send failed: {
        str(e)}",
                                       font=("Microsoft YaHei", 12),
                                       text_color="#ef4444").pack(pady=20)

                            # 確定按鈕
                            def close_error():
                                error_window.destroy()

                            ctk.CTkButton(error_window,
                                        text="確定 / OK",
                                        command=close_error,
                                        fg_color="#ef4444",
                                        hover_color="#dc2626",
                                        font=("Microsoft YaHei", 12, "bold")).pack(pady=10)

                            status_label = sent_status.get(supplier)
                            if status_label:
                                status_label.configure(
                                    text="✗", text_color=ACCENT_RED)
                    return send_email

                # 創建發送按鈕
                print(f"[DEBUG] 正在為 {supplier} 創建發送按鈕")  # 调试信息
                send_btn = ctk.CTkButton(
                    row_frame,
                    text="發送/Send",
                    command=create_send_function(
                        supplier, to_emails, cc_emails, matched_files),
                    width=80,
                    height=30,
                    fg_color=ACCENT_RED,
                    font=("Microsoft YaHei", 11, "bold"),
                    corner_radius=8,
                    hover_color="#d32f2f"
                )
                send_btn.pack(side="right", padx=5)
                print(f"[DEBUG] {supplier} 的發送按鈕已創建並 pack")  # 调试信息
                
                email_list.append({
                    'supplier': supplier,
                    'to_emails': to_emails,
                    'cc_emails': cc_emails,
                    'attachments': matched_files  # 改为复数形式
                })
                supplier_count += 1
                
                # 即時更新總結信息
                summary_label.configure(text=f"總共找到 {supplier_count} 個供應商可以發送郵件")
        # 批量發送按鈕
        batch_frame = ctk.CTkFrame(directory_window)
        batch_frame.pack(fill="x", padx=20, pady=10)

        def batch_send_selected():
            import threading
            import time
            from tkinter import messagebox
            
            # 检查是否有重复的供应商选择
            selected_suppliers = [s for s, v in supplier_check_vars.items() if v.get()]
            if not selected_suppliers:
                messagebox.showwarning("未選擇", "請先勾選要發送的供應商！")
                return
            
            # 检查是否有重复的供应商名称
            selected_suppliers_normalized = [s.lower().strip() for s in selected_suppliers]
            if len(selected_suppliers_normalized) != len(set(selected_suppliers_normalized)):
                messagebox.showwarning("重複選擇", "檢測到重複的供應商選擇，請檢查後重新選擇！")
                return
            
            # 显示美化的确认对话框
            def on_confirm_dialog(result):
                if not result:
                    return
                # 继续执行邮件发送逻辑
                self._send_emails_to_suppliers(selected_suppliers, directory_window, sent_status, email_list)
            
            # 创建并显示美化的确认对话框
            confirm_dialog = EmailSendConfirmationDialog(
                directory_window, 
                selected_suppliers, 
                on_confirm_dialog
            )
            return
        
        # 新增「發送勾選」按鈕
        send_selected_btn = ctk.CTkButton(
            batch_frame,
            text="發送勾選郵件\nSend Selected",
            command=batch_send_selected,
            width=200,
            height=50,
            fg_color=ACCENT_GREEN,
            font=("Microsoft YaHei", 12, "bold"),
            corner_radius=10,
            hover_color="#059669"
        )
        send_selected_btn.pack(side="right", padx=10)
    
    def _send_emails_to_suppliers(self, selected_suppliers, directory_window, sent_status=None, email_list=None):
        """发送邮件给选中的供应商"""
        import threading
        import time
        from tkinter import messagebox
        
        folder = self.email_supplier_folder_var.get()
        master_config = self.email_master_config_var.get()
        
        if not folder or not master_config:
            messagebox.showwarning("未選擇", "請先選擇供應商文件夾和主配置文件！")
            return
        
        # 如果沒有傳入 email_list，則重新生成（向後兼容）
        if email_list is None:
            email_list = []
            # 創建 EmailSender 實例
            config_mgr = UnifiedConfigManager(master_config)
            email_sender = EmailSender(config_mgr)
            
            # 扫描文件夹获取邮件列表
            for file in os.listdir(folder):
                if file.endswith('.xlsx') and not file.startswith('~'):
                    supplier_name = file.replace('.xlsx', '')
                    to_emails, cc_emails = email_sender.get_to_cc_emails(supplier_name, master_config)
                    if to_emails:
                        email_list.append({
                            'supplier': supplier_name,
                            'to_emails': to_emails,
                            'cc_emails': cc_emails,
                            'attachments': [file]
                        })
        
        # 彈出進度視窗
        progress_win = ctk.CTkToplevel(directory_window)
        progress_win.title("郵件發送進度/Email Send Progress")
        progress_win.geometry("600x600")
        progress_win.attributes('-topmost', True)  # 設置置頂
        progress_win.resizable(True, True)
        # 移除 focus_force() 避免 TclError
        ctk.CTkLabel(
            progress_win,
            text="郵件發送進度",
            font=FONT_TITLE
        ).pack(pady=10)
        
        progress_frame = ctk.CTkScrollableFrame(progress_win)
        progress_frame.pack(fill="both", expand=True, padx=10, pady=10)
        
        progress_labels = {}
        for supplier in selected_suppliers:
            lbl = ctk.CTkLabel(
                progress_frame,
                text=f"{supplier} ...",
                font=FONT_MID
            )
            lbl.pack(anchor="w", pady=2)
            progress_labels[supplier] = lbl

        def send_all():
            success_suppliers = []
            failed_suppliers = []
            
            print(f"[DEBUG] 開始發送郵件，選中的供應商: {selected_suppliers}")
            print(f"[DEBUG] 可用的郵件列表: {[e['supplier'] for e in email_list]}")

            for idx, supplier in enumerate(selected_suppliers):
                print(f"[DEBUG] 處理供應商: {supplier}")
                entry = next(
                    (e for e in email_list if e['supplier'] == supplier), None
                )
                if not entry:
                    print(f"[DEBUG] 找不到供應商 {supplier} 的郵件資料")
                    progress_labels[supplier].configure(
                        text=f"{supplier} - 檔案/郵件資料缺失", 
                        text_color=ACCENT_RED
                    )
                    failed_suppliers.append(f"{supplier} - 檔案/郵件資料缺失")
                    continue
                
                print(f"[DEBUG] 找到供應商 {supplier} 的郵件資料: {entry}")
                try:
                    body = self.email_body_textbox.get("1.0", "end-1c")
                    from datetime import datetime, timedelta
                    today = datetime.now().date()
                    this_monday = today - timedelta(days=today.weekday())
                    next_monday = this_monday + timedelta(days=7)
                    target_date = next_monday
                    month_name = target_date.strftime("%B")
                    week_of_month = get_week_of_month(target_date)
                    month_week = f"{month_name} - Week {week_of_month}"
                    body_filled = body.replace("{month_week}", month_week)

                    # 處理 subject - 檢查是否使用自定義 subject
                    if self.use_custom_subject_var.get():
                        # 使用自定義 subject
                        custom_subject = self.email_subject_var.get().strip()
                        if custom_subject:
                            # 替換自定義 subject 中的變數
                            subject = custom_subject.replace(
                                "{Supplier}",
                                supplier
                            ).replace(
                                "{Month}",
                                month_name
                            ).replace(
                                "{Week}",
                                str(week_of_month)
                            ).replace(
                                "{month_week}",
                                month_week
                            )
                        else:
                            # 如果自定義 subject 為空，使用預設 Weekly Order
                            subject = f"Sushi Express Weekly Order - {supplier} - {month_name} - Week {week_of_month}"
                    else:
                        # 根據 body 內容判斷是 Amendment 還是 Weekly Order
                        if "Amendment order" in body:
                            subject = f"Sushi Express Amendment Order - {supplier}"
                        else:
                            subject = f"Sushi Express Weekly Order - {supplier} - {month_name} - Week {week_of_month}"
                    
                    # 創建 EmailSender 實例
                    master_config_path = self.email_master_config_var.get()
                    config_mgr = UnifiedConfigManager(master_config_path)
                    email_sender = EmailSender(config_mgr)
                    
                    # 处理附件路径
                    if len(entry['attachments']) == 1:
                        # 单个文件
                        attachment_path = os.path.join(folder, entry['attachments'][0])
                    else:
                        # 多个文件
                        attachment_path = [os.path.join(folder, f) for f in entry['attachments']]
                    
                    mail = email_sender.send_email(
                        entry['to_emails'], entry['cc_emails'], supplier, body_filled,
                        attachment_path=attachment_path,
                        account_idx=self.selected_outlook_account_idx,
                        subject=subject
                    )
                    if isinstance(mail, tuple) or not mail:
                        error_msg = mail[1] if isinstance(
                            mail, tuple) else "發送失敗"
                        progress_labels[supplier].configure(
                            text=f"{supplier} ✗ {error_msg}", 
                            text_color=ACCENT_RED
                        )
                        if sent_status and supplier in sent_status:
                            sent_status[supplier].configure(
                                text="✗", 
                                text_color=ACCENT_RED
                            )
                        failed_suppliers.append(
                            f"{supplier} - {error_msg}"
                        )
                        continue
                    try:
                        # 检查是否已经发送过
                        if supplier in success_suppliers:
                            progress_labels[supplier].configure(
                                text=f"{supplier} ⚠️ 已發送過，跳過", 
                                text_color=ACCENT_ORANGE
                            )
                            continue
                        
                        mail.Send()
                        progress_labels[supplier].configure(
                            text=f"{supplier} ✔ 已發送", 
                            text_color=ACCENT_GREEN
                        )
                        if sent_status and supplier in sent_status:
                            sent_status[supplier].configure(
                                text="✔", 
                                text_color=ACCENT_GREEN
                            )
                        success_suppliers.append(supplier)
                    except Exception as e:
                        progress_labels[supplier].configure(
                            text=f"{supplier} ✗ {str(e)}", 
                            text_color=ACCENT_RED
                        )
                        if sent_status and supplier in sent_status:
                            sent_status[supplier].configure(
                                text="✗", 
                                text_color=ACCENT_RED
                            )
                        failed_suppliers.append(f"{supplier} - {str(e)}")
                except Exception as e:
                    progress_labels[supplier].configure(
                        text=f"{supplier} ✗ {str(e)}", 
                        text_color=ACCENT_RED
                    )
                    if sent_status and supplier in sent_status:
                        sent_status[supplier].configure(
                            text="✗", 
                            text_color=ACCENT_RED
                        )
                    failed_suppliers.append(f"{supplier} - {str(e)}")
                time.sleep(2)  # 緩衝 2 秒

            # 發送完成後顯示結果並自動關閉
            def show_result_and_close():
                # 清空進度標籤，顯示結果摘要
                for supplier in selected_suppliers:
                    progress_labels[supplier].pack_forget()

                # 顯示結果摘要
                ctk.CTkLabel(
                    progress_frame,
                    text="📧 發送完成！",
                    font=FONT_TITLE,
                    text_color=ACCENT_GREEN
                ).pack(pady=10)

                if success_suppliers:
                    success_text = f"✅ 成功發送 ({len(success_suppliers)} 個):\n" + "\n".join(
                        [f"• {s}" for s in success_suppliers]
                    )
                    ctk.CTkLabel(
                        progress_frame,
                        text=success_text,
                        font=FONT_MID,
                        text_color=ACCENT_GREEN
                    ).pack(pady=5)

                if failed_suppliers:
                    failed_text = f"❌ 發送失敗 ({len(failed_suppliers)} 個):\n" + "\n".join(
                        [f"• {s}" for s in failed_suppliers]
                    )
                    ctk.CTkLabel(
                        progress_frame,
                        text=failed_text,
                        font=FONT_MID,
                        text_color=ACCENT_RED
                    ).pack(pady=5)

                # 5秒後自動關閉
                def safe_destroy():
                    try:
                        if progress_win.winfo_exists():
                            progress_win.destroy()
                    except:
                        pass
                progress_win.after(5000, safe_destroy)

            # 在主線程中執行UI更新
            progress_win.after(0, show_result_and_close)

        threading.Thread(target=send_all).start()

    def _show_batch_result(
    self,
    success_count,
    failed_count,
     failed_suppliers):
        """顯示批量發送結果"""
        from tkinter import messagebox

        result_window = ctk.CTkToplevel(self)
        result_window.title("批量發送結果 / Batch Send Result")
        result_window.geometry("500x400")
        result_window.resizable(True, True)
        result_window.attributes('-topmost', True)  # 設置視窗置頂
        result_window.focus_force()  # 強制聚焦

        # 標題
        title_label = ctk.CTkLabel(
    result_window,
    text="批量發送結果\nBatch Send Result",
     font=FONT_TITLE)
        title_label.pack(pady=10)

        # 結果摘要
        summary_frame = ctk.CTkFrame(result_window)
        summary_frame.pack(fill="x", padx=20, pady=10)

        ctk.CTkLabel(summary_frame, text=f"成功發送: {success_count} 個供應商",
                    font=FONT_MID, text_color=ACCENT_GREEN).pack(anchor="w", padx=10, pady=5)
        ctk.CTkLabel(summary_frame, text=f"發送失敗: {failed_count} 個供應商",
                    font=FONT_MID, text_color=ACCENT_RED).pack(anchor="w", padx=10, pady=5)

        # 失敗詳情
        if failed_suppliers:
            ctk.CTkLabel(
    result_window,
    text="失敗詳情 / Failed Details:",
    font=FONT_MID).pack(
        anchor="w",
        padx=20,
        pady=(
            10,
             0))

            # 滾動框架顯示失敗詳情
            scroll_frame = ctk.CTkScrollableFrame(result_window)
            scroll_frame.pack(fill="both", expand=True, padx=20, pady=10)

            for supplier in failed_suppliers:
                ctk.CTkLabel(scroll_frame, text=f"• {supplier}",
                            font=FONT_MID, text_color=ACCENT_RED).pack(anchor="w", padx=10, pady=2)

        # 美化的關閉按鈕
        close_btn = ctk.CTkButton(
            result_window,
            text="關閉/Close",
            command=result_window.destroy,
            font=("Microsoft YaHei", 12, "bold"),
            corner_radius=10,
            hover_color="#1976d2",
            height=35
        )
        close_btn.pack(pady=10)

    def _send_supplier_emails(self):
        import os
        folder = self.email_supplier_folder_var.get()
        master_config = self.email_master_config_var.get()
        if not folder or not master_config:
            messagebox.showwarning(t("warning"), t("folder_warning"))
            return
        # 選擇Outlook帳號（只選一次）
        if self.selected_outlook_account_idx is None:
            try:
                import win32com.client
                import pythoncom

                # 初始化 COM 組件
                pythoncom.CoInitialize()

                outlook = win32com.client.Dispatch(
                    "Outlook.Application").GetNamespace("MAPI")
                accounts = [
    outlook.Folders.Item(
        i +
        1) for i in range(
            outlook.Folders.Count)]
                account_names = [acct.Name for acct in accounts]
                # 使用美化的帳號選擇對話框
                idx = show_outlook_account_selector(self, account_names)
                if idx is None:
                    messagebox.showwarning(
    "取消/Cancelled", "未選擇帳號，已取消發送/No account selected, sending cancelled.")
                    return
                self.selected_outlook_account_idx = idx
            except Exception as e:
                messagebox.showerror(
    "錯誤/Error", f"獲取Outlook帳號失敗/Failed to get Outlook accounts: {e}")
            return
        # 取得body內容，並保存到本地
        body = self.email_body_textbox.get("1.0", "end-1c")
        try:
            with open("email_body.txt", "w", encoding="utf-8") as f:
                f.write(body)
        except Exception:
            pass
        # 檢查是否有選定的供應商
        selected_supplier = getattr(self, 'supplier_combobox', None)
        if selected_supplier:
            selected_supplier_name = selected_supplier.get()
            if selected_supplier_name and selected_supplier_name not in [
                "請先選擇文件夾和配置文件", "沒有找到匹配的供應商文件"]:
                files = [f for f in os.listdir(folder) if f.endswith(
                    ".xlsx") and not f.startswith("~$")]
                config_mgr = UnifiedConfigManager(master_config)
                email_sender = EmailSender(config_mgr)
                matched_file = find_supplier_file(
                    selected_supplier_name, files)
                if not matched_file:
                    messagebox.showerror(
    "錯誤", f"找不到 {selected_supplier_name} 的對應文件")
                    return
                supplier_file = os.path.join(folder, matched_file)
                to_emails, cc_emails = email_sender.get_to_cc_emails(
                    selected_supplier_name, master_config)
                from datetime import datetime
                now = datetime.now()
                week_no = now.isocalendar()[1]
                body_filled = body.replace("{week_no}", str(week_no))
                subject = f"Sushi Express Weekly Order - {selected_supplier_name} - {
    now.strftime('%B')} - Week {week_no}"
                mail = email_sender.send_email(
                    to_emails, cc_emails, selected_supplier_name, body_filled,
                    attachment_path=supplier_file,
                    account_idx=self.selected_outlook_account_idx,
                    subject=subject
                )
                if isinstance(mail, tuple):
                    messagebox.showerror("Error", mail[1])
                    return
                if not mail:
                    messagebox.showerror(
    "Error", f"无法创建邮件: {selected_supplier_name}")
                    return
                show_topmost_success(
    self,
    "發送成功 / Send Success",
     f"郵件已發送給 {selected_supplier_name}\nEmail sent successfully to {selected_supplier_name}")
                return

        # 如果沒有選定供應商，則發送給所有供應商（原有邏輯）
        files = [f for f in os.listdir(folder) if f.endswith(
            ".xlsx") and not f.startswith("~$")]
        config_mgr = UnifiedConfigManager(master_config)
        email_sender = EmailSender(config_mgr)
        supplier_names = set()
        wb = load_workbook(master_config, data_only=True)
        if "Suppliers" in wb.sheetnames:
            ws = wb["Suppliers"]
            for row in ws.iter_rows(min_row=2, values_only=True):
                if row and row[0]:
                    supplier_names.add(str(row[0]).strip())
        from datetime import datetime
        email_list = []
        matched_files = set()
        for sname in supplier_names:
            matched_file = find_supplier_file(sname, files)
            if not matched_file:
                continue
            matched_files.add(matched_file)
            supplier_file = os.path.join(folder, matched_file)
            to_emails, cc_emails = email_sender.get_to_cc_emails(
                sname, master_config)
            now = datetime.now()
            week_no = now.isocalendar()[1]
            body_filled = body.replace("{week_no}", str(week_no))
            subject = f"Sushi Express Weekly Order - {sname} - {
    now.strftime('%B')} - Week {week_no}"
            mail = email_sender.send_email(
                to_emails, cc_emails, sname, body_filled,
                attachment_path=supplier_file,
                account_idx=self.selected_outlook_account_idx,
                subject=subject
            )
            if isinstance(mail, tuple):
                messagebox.showerror("Error", mail[1])
                continue
            if not mail:
                messagebox.showerror("Error", f"无法创建邮件: {sname}")
                continue
            email_list.append((mail, sname, supplier_file))
        unmatched_files = [f for f in files if f not in matched_files]
        if unmatched_files:
            messagebox.showwarning(
    "未配對檔案",
    f"以下檔案未配對到任何Supplier，未發送郵件：\n" +
     "\n".join(unmatched_files))
        for mail, matched_supplier, supplier_file in email_list:
            def on_confirm(success, msg, ms=matched_supplier):
                if success:
                    show_topmost_success(
    self,
    "發送成功 / Send Success",
     f"{ms} 郵件已發送！\n{ms} Email sent successfully!")
                else:
                    messagebox.showinfo("已取消/Cancelled", f"{ms} 郵件未發送。")
            EmailConfirmationDialog(
    self,
    mail,
    matched_supplier,
    "-",
    supplier_file,
     on_confirm)

    def show_operation_supplies_ui(self):
        """显示运营用品界面 - 美化版本"""
        def build(c):
            self.summary_file_var = ctk.StringVar()
            self.config_file_var = ctk.StringVar()
            self.output_folder_var = ctk.StringVar()

            # 主容器 - 紧凑布局
            main_container = ctk.CTkFrame(c, fg_color="transparent")
            main_container.pack(fill="both", expand=True, padx=15, pady=10)
            
            # 文件选择卡片
            file_card = ctk.CTkFrame(main_container, fg_color=DARK_PANEL, corner_radius=15)
            file_card.pack(fill="x", pady=(0, 15))

            # 创建表单框架
            form_frame = ctk.CTkFrame(file_card, fg_color="transparent")
            form_frame.pack(fill="x", padx=20, pady=15)

            # 汇总文件选择 - 美化版本
            row1 = ctk.CTkFrame(form_frame, fg_color="transparent")
            row1.pack(fill="x", pady=8)
            
            # 文件图标和标签
            file_label_frame = ctk.CTkFrame(row1, fg_color="transparent")
            file_label_frame.pack(side="left", padx=(0, 15))
            
            file_icon = ctk.CTkLabel(
                file_label_frame,
                text="📊",
                font=("Microsoft YaHei", 20)
            )
            file_icon.pack(side="left", padx=(0, 8))
            
            file_label = ctk.CTkLabel(
                file_label_frame,
                text="选择汇总文件\nSelect Summary File",
                font=("Microsoft YaHei", 12, "bold"),
                text_color=TEXT_COLOR
            )
            file_label.pack(side="left")
            
            # 输入框和按钮容器
            input_frame = ctk.CTkFrame(row1, fg_color="transparent")
            input_frame.pack(side="right", fill="x", expand=True)
            
            # 输入框
            file_entry = ctk.CTkEntry(
                input_frame,
                textvariable=self.summary_file_var,
                font=("Microsoft YaHei", 11),
    state="readonly",
                placeholder_text="点击浏览选择汇总文件...",
                height=35,
                corner_radius=8
            )
            file_entry.pack(side="left", fill="x", expand=True, padx=(0, 10))
            
            # 浏览按钮
            browse_btn1 = ctk.CTkButton(
                input_frame,
                text="瀏覽...\nBrowse...",
                font=("Microsoft YaHei", 10, "bold"),
                command=self._select_summary_file,
                width=100,
                height=35,
                corner_radius=8,
                fg_color=ACCENT_BLUE,
                hover_color="#1976d2"
            )
            browse_btn1.pack(side="right")

            # 配置文件选择 - 美化版本
            row2 = ctk.CTkFrame(form_frame, fg_color="transparent")
            row2.pack(fill="x", pady=8)
            
            # 文件图标和标签
            config_label_frame = ctk.CTkFrame(row2, fg_color="transparent")
            config_label_frame.pack(side="left", padx=(0, 15))
            
            config_icon = ctk.CTkLabel(
                config_label_frame,
                text="⚙️",
                font=("Microsoft YaHei", 20)
            )
            config_icon.pack(side="left", padx=(0, 8))
            
            config_label = ctk.CTkLabel(
                config_label_frame,
                text="选择配置文件\nSelect Config File",
                font=("Microsoft YaHei", 12, "bold"),
                text_color=TEXT_COLOR
            )
            config_label.pack(side="left")
            
            # 输入框和按钮容器
            config_input_frame = ctk.CTkFrame(row2, fg_color="transparent")
            config_input_frame.pack(side="right", fill="x", expand=True)
            
            # 输入框
            config_entry = ctk.CTkEntry(
                config_input_frame,
                textvariable=self.config_file_var,
                font=("Microsoft YaHei", 11),
                state="readonly",
                placeholder_text="点击浏览选择配置文件...",
                height=35,
                corner_radius=8
            )
            config_entry.pack(side="left", fill="x", expand=True, padx=(0, 10))
            
            # 浏览按钮
            browse_btn2 = ctk.CTkButton(
                config_input_frame,
                text="瀏覽...\nBrowse...",
                font=("Microsoft YaHei", 10, "bold"),
                command=self._select_config_file,
                width=100,
                height=35,
                corner_radius=8,
                fg_color=ACCENT_BLUE,
                hover_color="#1976d2"
            )
            browse_btn2.pack(side="right")

            # 输出文件夹选择 - 美化版本
            row3 = ctk.CTkFrame(form_frame, fg_color="transparent")
            row3.pack(fill="x", pady=8)
            
            # 文件图标和标签
            folder_label_frame = ctk.CTkFrame(row3, fg_color="transparent")
            folder_label_frame.pack(side="left", padx=(0, 15))
            
            folder_icon = ctk.CTkLabel(
                folder_label_frame,
                text="📁",
                font=("Microsoft YaHei", 20)
            )
            folder_icon.pack(side="left", padx=(0, 8))
            
            folder_label = ctk.CTkLabel(
                folder_label_frame,
                text="选择输出文件夹\nSelect Output Folder",
                font=("Microsoft YaHei", 12, "bold"),
                text_color=TEXT_COLOR
            )
            folder_label.pack(side="left")
            
            # 输入框和按钮容器
            folder_input_frame = ctk.CTkFrame(row3, fg_color="transparent")
            folder_input_frame.pack(side="right", fill="x", expand=True)
            
            # 输入框
            folder_entry = ctk.CTkEntry(
                folder_input_frame,
                textvariable=self.output_folder_var,
                font=("Microsoft YaHei", 11),
                state="readonly",
                placeholder_text="点击浏览选择输出文件夹...",
                height=35,
                corner_radius=8
            )
            folder_entry.pack(side="left", fill="x", expand=True, padx=(0, 10))
            
            # 浏览按钮
            browse_btn3 = ctk.CTkButton(
                folder_input_frame,
                text="瀏覽...\nBrowse...",
                font=("Microsoft YaHei", 10, "bold"),
                command=self._select_output_folder,
                width=100,
                height=35,
                corner_radius=8,
                fg_color=ACCENT_BLUE,
                hover_color="#1976d2"
            )
            browse_btn3.pack(side="right")

            # 搜索和过滤卡片
            search_card = ctk.CTkFrame(main_container, fg_color=DARK_PANEL, corner_radius=15)
            search_card.pack(fill="x", pady=(0, 15))
            
            # 搜索和过滤框架
            search_frame = ctk.CTkFrame(search_card, fg_color="transparent")
            search_frame.pack(fill="x", padx=20, pady=15)
            
            # 过滤器行 - 重新布局
            filter_row = ctk.CTkFrame(search_frame, fg_color="transparent")
            filter_row.pack(fill="x", pady=5)
            
            # 供应商过滤器
            supplier_frame = ctk.CTkFrame(filter_row, fg_color="transparent")
            supplier_frame.pack(side="left", padx=(0, 20))
            
            supplier_icon = ctk.CTkLabel(
                supplier_frame,
                text="🏢",
                font=("Microsoft YaHei", 14)
            )
            supplier_icon.pack(side="left", padx=(0, 8))
            
            supplier_label = ctk.CTkLabel(
                supplier_frame,
                text="供应商 / Supplier:",
                font=("Microsoft YaHei", 11, "bold"),
                text_color=TEXT_COLOR
            )
            supplier_label.pack(side="left", padx=(0, 10))
            
            self.operation_supplier_filter_var = ctk.StringVar(value="全部")
            supplier_combo = ctk.CTkComboBox(
                supplier_frame,
                values=["全部", "Freshening", "Legacy", "Unikleen"],
                variable=self.operation_supplier_filter_var,
                font=("Microsoft YaHei", 10),
                width=120,
                height=30,
                corner_radius=6,
                command=self._filter_treeview_results
            )
            supplier_combo.pack(side="left")
            
            # 门市过滤器
            outlet_frame = ctk.CTkFrame(filter_row, fg_color="transparent")
            outlet_frame.pack(side="left", padx=(0, 20))
            
            outlet_icon = ctk.CTkLabel(
                outlet_frame,
                text="🏪",
                font=("Microsoft YaHei", 14)
            )
            outlet_icon.pack(side="left", padx=(0, 8))
            
            outlet_label = ctk.CTkLabel(
                outlet_frame,
                text="门市 / Outlet:",
                font=("Microsoft YaHei", 11, "bold"),
                text_color=TEXT_COLOR
            )
            outlet_label.pack(side="left", padx=(0, 10))
            
            self.operation_outlet_filter_var = ctk.StringVar(value="全部")
            outlet_combo = ctk.CTkComboBox(
                outlet_frame,
                values=["全部"],
                variable=self.operation_outlet_filter_var,
                font=("Microsoft YaHei", 10),
                width=120,
                height=30,
                corner_radius=6,
                command=self._filter_treeview_results
            )
            outlet_combo.pack(side="left")
            
            # 搜索框 - 移到门市右侧
            search_frame_inline = ctk.CTkFrame(filter_row, fg_color="transparent")
            search_frame_inline.pack(side="left", padx=(20, 0))
            
            search_icon = ctk.CTkLabel(
                search_frame_inline,
                text="🔍",
                font=("Microsoft YaHei", 14)
            )
            search_icon.pack(side="left", padx=(0, 8))
            
            search_label = ctk.CTkLabel(
                search_frame_inline,
                text="搜索 / Search:",
                font=("Microsoft YaHei", 11, "bold"),
                text_color=TEXT_COLOR
            )
            search_label.pack(side="left", padx=(0, 10))
            
            self.operation_search_var = ctk.StringVar()
            search_entry = ctk.CTkEntry(
                search_frame_inline,
                textvariable=self.operation_search_var,
                placeholder_text="输入关键词...",
                font=("Microsoft YaHei", 10),
                height=30,
                corner_radius=6,
                width=200
            )
            search_entry.pack(side="left")
            search_entry.bind("<KeyRelease>", self._filter_treeview_results)
            
            # 结果展示卡片
            results_card = ctk.CTkFrame(main_container, fg_color=DARK_PANEL, corner_radius=15)
            results_card.pack(fill="x", pady=(0, 10))
            
            # 结果展示框架
            table_frame = ctk.CTkFrame(results_card, fg_color="transparent")
            table_frame.pack(fill="x", padx=20, pady=15)
            
            # 创建TreeView容器
            treeview_container = ctk.CTkFrame(table_frame, fg_color="transparent")
            treeview_container.pack(fill="x")
            
            # 创建TreeView
            columns = ("outlet", "product", "supplier", "output_file", "match_status")
            col_labels = ("门市/Outlet", "产品/Product", "供应商/Supplier", "输出文件/Output File", "匹配状态/Match Status")
            
            # 创建样式
            style = ttk.Style()
            style.theme_use("clam")
            style.configure("Custom.Treeview.Heading", 
                          font=("Microsoft YaHei", 10, "bold"),
                          background="#2b2b2b",
                          foreground="white",
                          fieldbackground="#2b2b2b")
            style.configure("Custom.Treeview", 
                          font=("Microsoft YaHei", 10),
                          background="#1e1e1e",
                          foreground="white",
                          fieldbackground="#1e1e1e",
                          rowheight=30)
            style.map("Custom.Treeview", 
                     background=[('selected', '#3b82f6')],
                     foreground=[('selected', 'white')])
            
            self.result_treeview = ttk.Treeview(
                treeview_container,
                columns=columns,
                show="headings",
                style="Custom.Treeview",
                height=8
            )
            
            # 设置列标题和宽度
            for i, (col, label) in enumerate(zip(columns, col_labels)):
                self.result_treeview.heading(col, text=label)
                if col == "outlet":
                    self.result_treeview.column(col, width=120, anchor="center")
                elif col == "product":
                    self.result_treeview.column(col, width=250, anchor="w")
                elif col == "supplier":
                    self.result_treeview.column(col, width=100, anchor="center")
                elif col == "output_file":
                    self.result_treeview.column(col, width=200, anchor="w")
                elif col == "match_status":
                    self.result_treeview.column(col, width=120, anchor="center")
            
            # 添加滚动条
            scrollbar = ttk.Scrollbar(treeview_container, orient="vertical", command=self.result_treeview.yview)
            self.result_treeview.configure(yscrollcommand=scrollbar.set)
            
            # 布局
            self.result_treeview.pack(side="left", fill="x", expand=True)
            scrollbar.pack(side="right", fill="y")
            
            # 初始化数据
            self._treeview_data = []
            self.result_treeview.insert("", "end", values=("等待处理...", "", "", "", "等待中"))
            
            # 按钮框架 - 确保可见
            button_frame = ctk.CTkFrame(main_container, fg_color="transparent")
            button_frame.pack(fill="x", pady=10, side="bottom")
            
            # 开始处理按钮 - 确保可见
            process_btn = ctk.CTkButton(
                button_frame,
                text="🚀 开始处理\nStart Processing",
                command=self._run_new_operation_supplies_with_treeview,
                width=300,
                height=60,
                fg_color="#F97316",
                hover_color="#EA580C",
                font=("Microsoft YaHei", 18, "bold"),
                corner_radius=12,
                border_width=2,
                border_color="#EA580C"
            )
            process_btn.pack(anchor="center", pady=5)

        # 清空内容区
        for w in self.content_body.winfo_children():
            w.destroy()

        # 设置功能标题
        self.function_title.configure(text=t("operation_supplies"))
        self.function_subtitle.configure(
    text="处理运营用品月订单\nProcess monthly operation supplies orders")

        # 直接构建运营用品界面
        build(self.content_body)

    def _select_summary_file(self):
        """选择汇总文件"""
        f = filedialog.askopenfilename(
    title="选择汇总文件/Select Summary File", filetypes=[
        ("Excel Files", "*.xlsx;*.xls;*.xlsm"),
        ("Excel Workbook", "*.xlsx"),
        ("Excel Macro-Enabled", "*.xlsm"),
        ("Excel 97-2003", "*.xls"),
        ("All Files", "*.*")])
        if f: self.summary_file_var.set(f)

    def _select_config_file(self):
        """选择配置文件"""
        f = filedialog.askopenfilename(
    title="选择配置文件/Select Config File",
    filetypes=[
        ("Excel",
         "*.xlsx;*.xls")])
        if f: self.config_file_var.set(f)

    def _select_output_folder(self):
        """选择输出文件夹"""
        f = filedialog.askdirectory(title=t("select_folder"))
        if f: self.output_folder_var.set(f)
    
    def _on_supplier_change(self, choice):
        """供应商选择改变时的回调函数"""
        if choice == "all":
            print("🎯 选择处理所有供应商")
        else:
            print(f"🎯 选择只处理 {choice} 供应商")

    def _run_new_operation_supplies_with_treeview(self):
        """运行新的运营用品处理 - 带TreeView显示"""
        print("🚀 开始处理按钮被点击")
        
        try:
            summary_file = self.summary_file_var.get()
            config_file = self.config_file_var.get()
            output_folder = self.output_folder_var.get()
            
            print(f"📁 文件路径检查:")
            print(f"  Summary: {summary_file}")
            print(f"  Config: {config_file}")
            print(f"  Output: {output_folder}")
            
            if not summary_file or not config_file or not output_folder:
                messagebox.showwarning(
                    "警告/Warning",
         "请选择所有必需的文件和文件夹！\nPlease select all required files and folders!")
                return
            
            print("✅ 文件路径检查通过，开始处理...")
        except Exception as e:
            print(f"❌ 按钮点击处理失败: {str(e)}")
            messagebox.showerror("错误", f"处理失败: {str(e)}")
            return

        # 清空TreeView
        for item in self.result_treeview.get_children():
            self.result_treeview.delete(item)
        self._treeview_data = []
        
        # 显示处理中状态
        self.result_treeview.insert("", "end", values=("处理中...", "", "", "", "处理中"))
        
        def update_treeview(results):
            """更新TreeView显示结果"""
            # 清空现有数据
            for item in self.result_treeview.get_children():
                self.result_treeview.delete(item)
            self._treeview_data = []
            
            # 添加新数据
            for result in results:
                outlet_name = result.get('outlet_name', '')
                product = result.get('product', '')
                supplier = result.get('supplier', '')
                output_file = result.get('output_file', '')
                match_status = result.get('match_status', '')
                
                self.result_treeview.insert("", "end", values=(
                    outlet_name, product, supplier, output_file, match_status
                ))
                self._treeview_data.append({
                    'outlet_name': outlet_name,
                    'product': product,
                    'supplier': supplier,
                    'output_file': output_file,
                    'match_status': match_status
                })
            
            # 更新过滤器选项
            self._update_filter_options()
        
        def log_callback(message):
            """日志回调"""
            print(f"Operation Supplies: {message}")
        
        # 在后台线程中运行处理
        def run_processing():
            try:
                print("🔄 开始后台处理...")
                # 使用新的处理方法
                results = self._process_operation_supplies_new_format(
                    summary_file, config_file, output_folder, update_treeview
                )
                print("✅ 后台处理完成")
            except Exception as e:
                print(f"❌ 后台处理失败: {str(e)}")
                import traceback
                traceback.print_exc()
                self.after(0, lambda: messagebox.showerror("错误", f"处理失败: {str(e)}"))
        
        print("🚀 启动后台线程...")
        threading.Thread(target=run_processing, daemon=True).start()
    
    def _process_operation_supplies_new_format(self, summary_file, config_file, output_folder, update_callback):
        """新的运营用品处理方法 - 使用现有订单模板，从Summary Sheet读取数据"""
        try:
            import pandas as pd
            from datetime import datetime, timedelta
            import os
            import openpyxl
            from openpyxl.utils import get_column_letter
            
            # 1. 读取Summary Sheet数据
            print("📖 读取Summary Sheet数据...")
            print(f"📁 文件路径: {summary_file}")
            
            # 检查文件是否存在
            if not os.path.exists(summary_file):
                raise FileNotFoundError(f"Summary文件不存在: {summary_file}")
            
            # 使用openpyxl读取Excel文件，保留模板格式
            try:
                wb = openpyxl.load_workbook(summary_file, data_only=False)
                print(f"📋 可用的工作表: {wb.sheetnames}")
                
                # 读取Summary工作表
                if "Summary" in wb.sheetnames:
                    summary_ws = wb["Summary"]
                else:
                    print("⚠️ 没有找到Summary工作表，使用第一个工作表")
                    summary_ws = wb.worksheets[0]
                
                # 将Summary数据转换为DataFrame
                summary_data = []
                for row in summary_ws.iter_rows(min_row=2, values_only=True):  # 跳过标题行
                    if any(cell for cell in row):  # 跳过空行
                        summary_data.append(row)
                
                # 动态获取列数
                if summary_data:
                    max_cols = max(len(row) for row in summary_data)
                    print(f"📊 检测到最大列数: {max_cols}")
                    
                    # 创建列名
                    columns = ['Out', 'Suppli', 'Description', 'Chinese', 'PRI', 'Q']
                    # 如果列数不够，添加额外的列
                    while len(columns) < max_cols:
                        columns.append(f'Extra_{len(columns)}')
                    
                    # 创建DataFrame
                    summary_df = pd.DataFrame(summary_data, columns=columns[:max_cols])
                    print(f"📊 实际使用的列数: {len(summary_df.columns)}")
                else:
                    # 如果没有数据，创建空的DataFrame
                    summary_df = pd.DataFrame(columns=['Out', 'Suppli', 'Description', 'Chinese', 'PRI', 'Q'])
                print(f"📊 Summary Sheet行数: {len(summary_df)}")
                print(f"📊 Summary Sheet列数: {len(summary_df.columns)}")
                
            except Exception as e:
                print(f"❌ 读取Summary文件失败: {str(e)}")
                raise e
            
            # 2. 读取Config文件的门市信息
            print("📖 读取门市配置信息...")
            print(f"📁 Config文件路径: {config_file}")
            
            if not os.path.exists(config_file):
                raise FileNotFoundError(f"Config文件不存在: {config_file}")
            
            try:
                # 使用openpyxl读取Config文件
                config_wb = openpyxl.load_workbook(config_file, data_only=False)
                print(f"📋 Config文件工作表: {config_wb.sheetnames}")
                
                if "OUTLET" in config_wb.sheetnames:
                    config_ws = config_wb["OUTLET"]
                else:
                    print("⚠️ 没有找到OUTLET工作表，使用第一个工作表")
                    config_ws = config_wb.worksheets[0]
                
                # 将Config数据转换为DataFrame
                config_data = []
                for row in config_ws.iter_rows(min_row=2, values_only=True):  # 跳过标题行
                    if any(cell for cell in row):  # 跳过空行
                        config_data.append(row)
                
                # 动态获取列数
                if config_data:
                    max_cols = max(len(row) for row in config_data)
                    print(f"📊 Config检测到最大列数: {max_cols}")
                    
                    # 创建列名
                    columns = ['Short Name', 'Outlet Full Name', 'Email', 'Address', 'Name in Email', 'Freshening Delivery Date', 'Monthend Code']
                    # 如果列数不够，添加额外的列
                    while len(columns) < max_cols:
                        columns.append(f'Extra_{len(columns)}')
                    
                    # 创建DataFrame
                    config_df = pd.DataFrame(config_data, columns=columns[:max_cols])
                    print(f"📊 Config实际使用的列数: {len(config_df.columns)}")
                else:
                    # 如果没有数据，创建空的DataFrame
                    config_df = pd.DataFrame(columns=['Short Name', 'Outlet Full Name', 'Email', 'Address', 'Name in Email', 'Freshening Delivery Date', 'Monthend Code'])
                
                print(f"📊 Config文件行数: {len(config_df)}")
                print(f"📊 Config文件列数: {len(config_df.columns)}")
                print(f"📊 Config列名: {list(config_df.columns)}")
                
            except Exception as e:
                print(f"❌ 读取Config文件失败: {str(e)}")
                raise e
            
            outlet_config = {}
            
            # 根据实际Config结构映射列
            # Config Sheet: Short Name, Outlet Full Name, Email, Address, Name in Email, Freshening Delivery Date, Monthend Code
            short_name_col = 'Short Name' if 'Short Name' in config_df.columns else None
            full_name_col = 'Outlet Full Name' if 'Outlet Full Name' in config_df.columns else None
            address_col = 'Address' if 'Address' in config_df.columns else None
            delivery_date_col = 'Freshening Delivery Date' if 'Freshening Delivery Date' in config_df.columns else None
            
            print(f"🔍 Config列映射: 简称={short_name_col}, 全名={full_name_col}, 地址={address_col}, 配送日期={delivery_date_col}")
            
            for idx, row in config_df.iterrows():
                try:
                    if short_name_col and full_name_col:
                        short_name = str(row[short_name_col]).strip()
                        full_name = str(row[full_name_col]).strip()
                        address = str(row[address_col]).strip() if address_col else ""
                        delivery_date = str(row[delivery_date_col]).strip() if delivery_date_col else ""
                    else:
                        # 使用位置索引作为备选
                        short_name = str(row.iloc[0]).strip() if len(row) > 0 else ""
                        full_name = str(row.iloc[1]).strip() if len(row) > 1 else ""
                        address = str(row.iloc[3]).strip() if len(row) > 3 else ""
                        delivery_date = str(row.iloc[5]).strip() if len(row) > 5 else ""
                    
                    if short_name and short_name != 'nan' and full_name and full_name != 'nan':
                        outlet_config[short_name] = {
                            'full_name': full_name,
                            'address': address,
                            'delivery_date': delivery_date
                        }
                        print(f"✅ 添加门市配置: {short_name} -> {full_name} (配送: {delivery_date})")
                except Exception as e:
                    print(f"⚠️ 处理第{idx}行配置时出错: {str(e)}")
                    continue
            
            print(f"✅ 读取到 {len(outlet_config)} 个门市配置")
            
            # 3. 按供应商分组处理，使用现有模板
            suppliers = ['Freshening', 'Legacy', 'Unikleen']
            all_results = []
            
            print(f"📊 Summary数据列名: {list(summary_df.columns)}")
            print(f"📊 Summary数据示例: {summary_df.head()}")
            
            for supplier in suppliers:
                print(f"🏭 处理 {supplier} 供应商...")
                
                # 获取该供应商相关的数据
                supplier_data = summary_df[summary_df['Suppli'] == supplier]
                print(f"📊 {supplier} 数据行数: {len(supplier_data)}")
                
                if len(supplier_data) == 0:
                    print(f"⚠️ {supplier} 没有数据，跳过")
                    continue
                
                # 按门市分组
                outlet_groups = {}
                for idx, row in supplier_data.iterrows():
                    outlet_name = str(row['Out']).strip()
                    if outlet_name and outlet_name != 'nan':
                        if outlet_name not in outlet_groups:
                            outlet_groups[outlet_name] = []
                        outlet_groups[outlet_name].append(row)
                
                print(f"📊 {supplier} 找到 {len(outlet_groups)} 个门市的数据")
                
                # 为每个门市创建订单文件
                for outlet_name, outlet_data in outlet_groups.items():
                    print(f"🏪 创建门市 {outlet_name} 的 {supplier} 订单...")
                    
                    # 复制供应商模板
                    template_ws = wb[supplier]  # 使用现有的供应商模板
                    new_wb = openpyxl.Workbook()
                    new_ws = new_wb.active
                    
                    # 复制模板内容
                    for row in template_ws.iter_rows():
                        for cell in row:
                            new_cell = new_ws[cell.coordinate]
                            new_cell.value = cell.value
                            if cell.has_style:
                                new_cell.font = cell.font
                                new_cell.border = cell.border
                                new_cell.fill = cell.fill
                                new_cell.number_format = cell.number_format
                                new_cell.protection = cell.protection
                                new_cell.alignment = cell.alignment
                    
                    # 填写门市信息
                    if outlet_name in outlet_config:
                        config = outlet_config[outlet_name]
                        # F5: 门市全名
                        new_ws['F5'] = config['full_name']
                        # F6: 地址
                        new_ws['F6'] = config['address']
                        
                        # F8: 配送日期 (只有Freshening需要)
                        if supplier == 'Freshening':
                            delivery_date = self._calculate_freshening_delivery_date(config['delivery_date'])
                            new_ws['F8'] = delivery_date
                    
                    # 填写产品数据到F-K列 (星期一-星期六)
                    # 找到产品数据行 (从第10行开始)
                    product_row = 10
                    for data_row in outlet_data:
                        # 查找匹配的产品行
                        for row_num in range(10, 30):  # 假设产品数据在10-30行
                            if new_ws[f'B{row_num}'].value and str(new_ws[f'B{row_num}'].value).strip():
                                # 检查产品名称是否匹配
                                template_product = str(new_ws[f'B{row_num}'].value).strip()
                                summary_product = str(data_row['Description']).strip()
                                
                                if self._is_product_match(template_product, summary_product):
                                    # 填写数量到F-K列 (星期一-星期六)
                                    quantity = data_row['Q']
                                    if quantity and quantity > 0:
                                        # 根据配送日期选择列
                                        if supplier == 'Freshening':
                                            # Freshening: 根据配送日期选择列
                                            delivery_col = self._get_delivery_column_for_freshening(config['delivery_date'])
                                        else:
                                            # Legacy和Unikleen: 使用第一列 (星期一)
                                            delivery_col = 'F'
                                        
                                        new_ws[f'{delivery_col}{row_num}'] = quantity
                                        print(f"✅ 填写 {summary_product}: {quantity} 到 {delivery_col}{row_num}")
                                    break
                    
                    # 保存门市订单文件
                    output_file = os.path.join(output_folder, f"{supplier}_{outlet_name}_{datetime.now().strftime('%Y%m%d')}.xlsx")
                    new_wb.save(output_file)
                    print(f"✅ 保存 {supplier} {outlet_name} 文件: {output_file}")
                    
                    # 记录结果
                    all_results.append({
                        'outlet_name': outlet_name,
                        'product': f"{len(outlet_data)} 个产品",
                        'supplier': supplier,
                        'output_file': f"{supplier}_{outlet_name}_{datetime.now().strftime('%Y%m%d')}.xlsx",
                        'match_status': '成功'
                    })
            
            # 更新TreeView
            if update_callback:
                update_callback(all_results)
            
            return all_results
            
        except Exception as e:
            print(f"❌ 处理失败: {str(e)}")
            raise e
    
    def _calculate_freshening_delivery_date(self, delivery_schedule):
        """计算Freshening配送日期 - 智能判断下个月日期"""
        try:
            from datetime import datetime, timedelta
            import calendar
            
            # 解析配送时间表 (例如: "SAT/WED", "FRI/TUE", "THU/MON")
            if not delivery_schedule or delivery_schedule == 'nan':
                return "未设置配送日期"
            
            # 计算下个月1号
            today = datetime.now()
            if today.month == 12:
                next_month = today.replace(year=today.year + 1, month=1, day=1)
            else:
                next_month = today.replace(month=today.month + 1, day=1)
            
            # 星期几映射
            day_mapping = {
                'MON': 0, 'TUE': 1, 'WED': 2, 'THU': 3, 'FRI': 4, 'SAT': 5, 'SUN': 6
            }
            
            # 解析配送日期
            days = delivery_schedule.split('/')
            if len(days) >= 2:
                day1, day2 = days[0].strip(), days[1].strip()
                
                # 找到下个月第一个配送日期
                for day in [day1, day2]:
                    if day in day_mapping:
                        target_weekday = day_mapping[day]
                        
                        # 从下个月1号开始找第一个匹配的星期几
                        current_date = next_month
                        while current_date.weekday() != target_weekday:
                            current_date += timedelta(days=1)
                        
                        return current_date.strftime('%Y-%m-%d (%A)')
            
            return f"下个月1号: {next_month.strftime('%Y-%m-%d')}"
            
        except Exception as e:
            print(f"⚠️ 计算配送日期失败: {str(e)}")
            return "日期计算错误"
    
    def _is_product_match(self, template_product, summary_product):
        """检查产品是否匹配"""
        try:
            # 简单的字符串匹配
            template_lower = template_product.lower()
            summary_lower = summary_product.lower()
            
            # 检查关键词匹配
            keywords = summary_lower.split()
            for keyword in keywords:
                if len(keyword) > 3 and keyword in template_lower:
                    return True
            
            # 检查完全匹配
            if template_lower == summary_lower:
                return True
            
            return False
        except:
            return False
    
    def _get_delivery_column_for_freshening(self, delivery_schedule):
        """根据Freshening配送时间表获取配送列"""
        try:
            # 解析配送时间表 (例如: "SAT/WED", "FRI/TUE", "THU/MON")
            if not delivery_schedule or delivery_schedule == 'nan':
                return 'F'  # 默认星期一
            
            days = delivery_schedule.split('/')
            if len(days) >= 1:
                day = days[0].strip()
                # 星期几到列的映射 (F-K对应星期一-星期六)
                day_to_col = {
                    'MON': 'F', 'TUE': 'G', 'WED': 'H', 'THU': 'I', 'FRI': 'J', 'SAT': 'K'
                }
                return day_to_col.get(day, 'F')
            
            return 'F'  # 默认星期一
        except:
            return 'F'  # 默认星期一
    
    def _update_filter_options(self):
        """更新过滤器选项"""
        # 更新供应商选项
        suppliers = set()
        outlets = set()
        
        for item in self._treeview_data:
            if item.get('supplier'):
                suppliers.add(item['supplier'])
            if item.get('outlet_name'):
                outlets.add(item['outlet_name'])
        
        # 更新供应商下拉框
        supplier_values = ["全部"] + sorted(list(suppliers))
        # 这里需要找到供应商下拉框并更新其values
        
        # 更新门市下拉框
        outlet_values = ["全部"] + sorted(list(outlets))
        # 这里需要找到门市下拉框并更新其values
    
    def _filter_treeview_results(self, event=None):
        """过滤TreeView结果"""
        search_term = self.operation_search_var.get().lower()
        supplier_filter = self.operation_supplier_filter_var.get()
        outlet_filter = self.operation_outlet_filter_var.get()
        
        # 清空TreeView
        for item in self.result_treeview.get_children():
            self.result_treeview.delete(item)
        
        # 过滤数据
        filtered_data = []
        for item in self._treeview_data:
            # 搜索过滤
            if search_term:
                searchable_text = f"{item.get('outlet_name', '')} {item.get('product', '')} {item.get('supplier', '')}".lower()
                if search_term not in searchable_text:
                    continue
            
            # 供应商过滤
            if supplier_filter != "全部" and item.get('supplier') != supplier_filter:
                continue
            
            # 门市过滤
            if outlet_filter != "全部" and item.get('outlet_name') != outlet_filter:
                continue
            
            filtered_data.append(item)
        
        # 显示过滤后的数据
        for item in filtered_data:
            self.result_treeview.insert("", "end", values=(
                item.get('outlet_name', ''),
                item.get('product', ''),
                item.get('supplier', ''),
                item.get('output_file', ''),
                item.get('match_status', '')
            ))

    def _thread_task(self, fn, show_message=True):
        """线程任务 - 在後台線程中執行"""
        import threading

        def run_in_thread():
            try:
                result = fn()
                if show_message:
                    self.after(
    0, lambda: messagebox.showinfo(
        t("success"), result))
            except Exception as e:
                error_msg = str(e)
                self.after(
    0, lambda: messagebox.showerror(
        t("error"), f"操作失败: {error_msg}"))

        # 在後台線程中執行任務
        thread = threading.Thread(target=run_in_thread, daemon=True)
        thread.start()

    def _select_download_folder(self):
        f = filedialog.askdirectory(title=t("select_folder"))
        if f:
            self.download_folder_var.set(f)

    def _select_checklist_folder(self):
        f = filedialog.askdirectory(title=t("select_folder"))
        if f:
            self.checklist_folder_var.set(f)

    def _run_download(self):
        """執行下載"""
        folder = self.download_folder_var.get()
        config_file = self.config_file_var.get()
        if not folder:
            messagebox.showwarning("警告", "請選擇下載資料夾！")
            return

        # 在主線程中選擇帳號
        try:
            import win32com.client
            import pythoncom

            # 初始化 COM 組件
            pythoncom.CoInitialize()

            outlook = win32com.client.Dispatch(
                "Outlook.Application").GetNamespace("MAPI")
            accounts = [
    outlook.Folders.Item(
        i +
        1) for i in range(
            outlook.Folders.Count)]
            account_names = [acct.Name for acct in accounts]

            # 使用對話框選擇帳號
            selected_account_idx = show_outlook_account_selector(
                self, account_names)
            if selected_account_idx is None:
                return  # 用戶取消

        except Exception as e:
            messagebox.showerror("錯誤", f"獲取 Outlook 帳號失敗: {e}")
            return

        # 計算下載日期範圍
        from datetime import datetime, timedelta
        today = datetime.now()
        days_since_last_friday = (today.weekday() - 4) % 7 or 7
        start_of_period = (
    today -
    timedelta(
        days=days_since_last_friday)).replace(
            hour=0,
            minute=0,
            second=0,
             microsecond=0)
        end_of_period = today.replace(
    hour=23, minute=59, second=59, microsecond=999999)
        start_date = start_of_period.strftime("%Y-%m-%d")
        end_date = end_of_period.strftime("%Y-%m-%d")

        # 創建進度彈窗，顯示日期範圍
        p = ProgressPopup(self, "下載中...", start_date, end_date, 0)
        self.progress_popup = p

        def log_callback(message):
            # 每個消息後面添加空行
            p.log(message + "\n")
            print(message)  # 同時輸出到控制台

        self._thread_task(
            lambda: OutlookDownloader.download_weekly_orders(
                folder, config_file, selected_account_idx,  # 使用選擇的帳號
                callback=log_callback, progress_popup=p
            ),
            show_message=False
        )

    def _run_download_amendments(self):
        """執行 Amendment 下載"""
        folder = self.download_folder_var.get()
        config_file = self.config_file_var.get()
        if not folder:
            messagebox.showwarning("警告", "請選擇下載資料夾！")
            return

        # 在主線程中選擇帳號
        try:
            import win32com.client
            import pythoncom

            # 初始化 COM 組件
            pythoncom.CoInitialize()

            outlook = win32com.client.Dispatch(
                "Outlook.Application").GetNamespace("MAPI")
            accounts = [
    outlook.Folders.Item(
        i +
        1) for i in range(
            outlook.Folders.Count)]
            account_names = [acct.Name for acct in accounts]

            # 使用對話框選擇帳號
            selected_account_idx = show_outlook_account_selector(
                self, account_names)
            if selected_account_idx is None:
                return  # 用戶取消

        except Exception as e:
            messagebox.showerror("錯誤", f"獲取 Outlook 帳號失敗: {e}")
            return

        # 計算下載日期範圍
        from datetime import datetime, timedelta
        today = datetime.now()
        days_since_last_friday = (today.weekday() - 4) % 7 or 7
        start_of_period = (
    today -
    timedelta(
        days=days_since_last_friday)).replace(
            hour=0,
            minute=0,
            second=0,
             microsecond=0)
        end_of_period = today.replace(
    hour=23, minute=59, second=59, microsecond=999999)
        start_date = start_of_period.strftime("%Y-%m-%d")
        end_date = end_of_period.strftime("%Y-%m-%d")

        # 創建進度彈窗，顯示日期範圍
        p = ProgressPopup(self, "下載 Amendment 中...", start_date, end_date, 0)
        self.progress_popup = p

        def log_callback(message):
            # 每個消息後面添加空行
            p.log(message + "\n")
            print(message)  # 同時輸出到控制台

        self._thread_task(
            lambda: OutlookDownloader.download_amendment_orders(
                folder, config_file, selected_account_idx,  # 使用選擇的帳號
                callback=log_callback, progress_popup=p
            ),
            show_message=False
        )

    def _run_download_siahuat(self):
        """執行 Siahuat 訂單下載 - 從本月1號開始"""
        folder = self.download_folder_var.get()
        config_file = self.config_file_var.get()
        if not folder:
            messagebox.showwarning("警告", "請選擇下載資料夾！")
            return

        # 在主線程中選擇帳號
        try:
            import win32com.client
            import pythoncom

            # 初始化 COM 組件
            pythoncom.CoInitialize()

            outlook = win32com.client.Dispatch(
                "Outlook.Application").GetNamespace("MAPI")
            accounts = [
                outlook.Folders.Item(
                    i +
                    1) for i in range(
                        outlook.Folders.Count)]
            account_names = [acct.Name for acct in accounts]

            # 使用對話框選擇帳號
            selected_account_idx = show_outlook_account_selector(
                self, account_names)
            if selected_account_idx is None:
                return  # 用戶取消

        except Exception as e:
            messagebox.showerror("錯誤", f"獲取 Outlook 帳號失敗: {e}")
            return

        # 設置 Siahuat 特定的日期範圍：本月1號到今天
        from datetime import datetime
        today = datetime.now()
        start_of_month = today.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
        end_of_period = today.replace(hour=23, minute=59, second=59, microsecond=999999)
        start_date = start_of_month.strftime("%Y-%m-%d")
        end_date = end_of_period.strftime("%Y-%m-%d")

        # 創建進度彈窗，顯示日期範圍
        p = ProgressPopup(self, "下載 Siahuat 訂單中...", start_date, end_date, 0)
        self.progress_popup = p

        def log_callback(message):
            # 每個消息後面添加空行
            p.log(message + "\n")
            print(message)  # 同時輸出到控制台

        self._thread_task(
            lambda: OutlookDownloader.download_siahuat_orders(
                folder, config_file, selected_account_idx,  # 使用選擇的帳號
                callback=log_callback, progress_popup=p
            ),
            show_message=False
        )

    def _run_enhanced_automation(self):
        source = self.folder_vars.get("source_folder", ctk.StringVar()).get()
        supplier = self.folder_vars.get(
    "supplier_folder", ctk.StringVar()).get()
        master_config = self.master_config_var.get()
        if not source or not supplier or not master_config:
            messagebox.showwarning(t("warning"), t("folder_warning"))
            return
        p = ProgressPopup(self, t("processing"))
        self.progress_popup = p
        def logcb(m): p.log(m)
        config_mgr = UnifiedConfigManager(master_config)
        auto = EnhancedOrderAutomation(config_mgr)
        import threading

        def run_and_show_count():
            result = auto.run_automation(
    source, supplier, log_callback=logcb)[1]
            # 統計已整理分店數量
            import re
            outlet_count = 0
            for line in result.splitlines():
                m = re.match(r"- (.+)_Week", line)
                if m:
                    outlet_count += 1
            # 在 popup 下方顯示
            if hasattr(p, 'outlet_count_label') and p.outlet_count_label:
                p.outlet_count_label.configure(
    text=f"🏪 已整理分店數量: {outlet_count} 間", text_color="#10b981")
            else:
                import customtkinter as ctk
                p.outlet_count_label = ctk.CTkLabel(
                    p,
                    text=f"🏪 已整理分店數量: {outlet_count} 間",
                    font=("Microsoft JhengHei", 18, "bold"),
                    text_color="#10b981"
                )
                p.outlet_count_label.pack(pady=(0, 10))
        threading.Thread(target=run_and_show_count).start()

    def _run_yellow_highlighted_automation(self):
        """只整合有黃色標記的訂單"""
        source = self.folder_vars.get("source_folder", ctk.StringVar()).get()
        supplier = self.folder_vars.get(
    "supplier_folder", ctk.StringVar()).get()
        master_config = self.master_config_var.get()
        if not source or not supplier or not master_config:
            messagebox.showwarning(t("warning"), t("folder_warning"))
            return

        p = ProgressPopup(self, "處理黃色標記訂單中...")
        self.progress_popup = p
        def logcb(m): p.log(m)

        config_mgr = UnifiedConfigManager(master_config)
        auto = YellowHighlightedOrderAutomation(config_mgr)

        import threading

        def run_and_show_count():
            result = auto.run_automation(
    source, supplier, log_callback=logcb)[1]
            # 統計已整理分店數量
            import re
            outlet_count = 0
            for line in result.splitlines():
                m = re.match(r"- (.+)_Week", line)
                if m:
                    outlet_count += 1
            # 在 popup 下方顯示
            if hasattr(p, 'outlet_count_label') and p.outlet_count_label:
                p.outlet_count_label.configure(
    text=f"🏪 已整理分店數量: {outlet_count} 間", text_color="#f59e0b")
            else:
                import customtkinter as ctk
                p.outlet_count_label = ctk.CTkLabel(
                    p,
                    text=f"🏪 已整理分店數量: {outlet_count} 間",
                    font=("Microsoft JhengHei", 18, "bold"),
                    text_color="#f59e0b"
                )
                p.outlet_count_label.pack(pady=(0, 10))
        threading.Thread(target=run_and_show_count).start()

    def _select_config_file(self, var=None, filetypes=None):
        f = filedialog.askopenfilename(
    title=t("select_folder"), filetypes=filetypes or [
        ("Excel files", "*.xlsx;*.xls")])
        if f:
            if var:
                var.set(f)
            else:
                self.config_file_var.set(f)

    def _select_folder(self, key):
        f = filedialog.askdirectory(title=t("select_folder"))
        if f:
            self.folder_vars[key].set(f)

    def _select_folder_var(self, var):
        f = filedialog.askdirectory(title=t("select_folder"))
        if f:
            var.set(f)

    def _show_required_outlets_window(self):
        import pandas as pd
        import tkinter.ttk as ttk
        master_config = self.master_config_var.get()
        df_req = pd.read_excel(
    master_config,
     sheet_name="Supplier Requirements")
        config_suppliers = set(
            str(row[0]).strip() for _, row in df_req.iterrows() if str(row[0]).strip())

        win = ctk.CTkToplevel(self)
        win.title("必要門市清單/Required Outlets List")
        win.geometry("800x500")
        ctk.CTkLabel(
    win,
    text="📋 供應商/Supplier        ❗缺漏分店/Missing Outlets",
    font=FONT_BIGBTN).pack(
        pady=10)
        frame = ctk.CTkFrame(win)
        frame.pack(fill="both", expand=True, padx=10, pady=10)
        tree = ttk.Treeview(
    frame,
    columns=(
        "supplier",
        "missing"),
        show="headings",
         height=16)
        tree.heading("supplier", text="📋 供應商/Supplier")
        tree.heading("missing", text="❗缺漏分店/Missing Outlets")
        tree.column("supplier", width=180, anchor="center")
        tree.column("missing", width=600, anchor="w")

        # 1. 分組整理 missing outlet，只針對 config supplier
        missing_by_supplier = {}
        for row in getattr(self, '_checklist_table_data', []):
            if row.get("cover_status") == "❌":
                supplier = str(row.get("supplier", "")).strip()
                outlet = str(row.get("outlet", "")).strip()
                if supplier in config_suppliers:
                    if supplier not in missing_by_supplier:
                        missing_by_supplier[supplier] = []
                    missing_by_supplier[supplier].append(outlet)

        # 2. 顯示
        for supplier in config_suppliers:
            if supplier in missing_by_supplier:
                tree.insert(
    "", "end", values=(
        supplier, ", ".join(
            missing_by_supplier[supplier])))
        tree.pack(fill="both", expand=True)

        # 若沒有任何缺漏
        if not any(missing_by_supplier.values()):
            tree.insert("", "end", values=("✔ All covered", ""))

        # 複製按鈕
        def copy_selected():
            items = tree.selection()
            if not items:
                return
            import pyperclip
            rows = []
            for item in items:
                vals = tree.item(item, "values")
                rows.append("\t".join(vals))
            pyperclip.copy("\n".join(rows))
            messagebox.showinfo(
    "複製成功/Copy Success",
     "已複製到剪貼簿！/Copied to clipboard!")
        ctk.CTkButton(
    win,
    text="複製所選/Copy Selected",
    command=copy_selected).pack(
        pady=5)

    def show_user_guide(self):
        """显示用户指南"""
        try:
            guide_path = resource_path("UserGuide.txt")
            if os.path.exists(guide_path):
                with open(guide_path, "r", encoding="utf-8") as f:
                    content = f.read()
                ScrollableMessageBox(self, "用户指南", content)
            else:
                messagebox.showwarning("指南缺失", "用户指南文件未找到")
        except Exception as e:
            messagebox.showerror("错误", f"无法加载用户指南: {str(e)}")

    def _run_cross_check_email_log(self):
        import os
        import re
        import pandas as pd
        import customtkinter as ctk
        folder = self.checklist_folder_var.get()
        table = getattr(self, '_checklist_table_data', [])
        config_path = self.master_config_var.get()
        
        # 使用智能查找逻辑查找 email_bodies_log.txt
        today = datetime.now()
        week_no = today.isocalendar()[1]
        possible_paths = []
        
        # 方法1：检查月份-Week格式的文件夹
        for week_offset in range(0, 4):  # 检查当前周和前3周
            check_week = week_no - week_offset
            # 计算对应日期的月份和星期
            check_date = today - timedelta(weeks=week_offset)
            month_name = check_date.strftime('%b').title()  # 确保首字母大写，例如: Aug, Sep
            week_of_month = get_week_of_month(check_date)
            check_path = os.path.join(folder, f"{month_name} - Week {week_of_month}")
            if os.path.exists(check_path):
                possible_paths.append(check_path)
        
        # 方法2：检查Weekly Order/Aug格式的文件夹
        aug_path = os.path.join(folder, "Weekly Order", "Aug")
        if os.path.exists(aug_path):
            possible_paths.append(aug_path)
        
        # 方法3：检查直接在当前文件夹下的邮件日志
        if os.path.exists(os.path.join(folder, "email_bodies_log.txt")):
            possible_paths.append(folder)
        
        # 方法4：检查上级文件夹中的邮件日志（针对 Supplier Order 子文件夹的情况）
        parent_folder = os.path.dirname(folder)
        if parent_folder and os.path.exists(os.path.join(parent_folder, "email_bodies_log.txt")):
            possible_paths.append(parent_folder)
        
        # 查找包含邮件日志的文件夹
        email_log_path = None
        for path in possible_paths:
            temp_log = os.path.join(path, "email_bodies_log.txt")
            if os.path.exists(temp_log):
                email_log_path = temp_log
                break
        
        if not email_log_path:
            from tkinter import messagebox
            debug_info = f"在以下路径中未找到email_bodies_log.txt：\n"
            debug_info += f"当前日期: {today.strftime('%Y-%m-%d')}\n"
            debug_info += f"当前周数: {week_no}\n"
            debug_info += f"Checklist文件夹: {folder}\n\n"
            debug_info += f"检查的路径:\n"
            for i, path in enumerate(possible_paths, 1):
                debug_info += f"{i}. {path}\n"
            debug_info += f"\n请确认:\n"
            debug_info += f"1. 是否已经使用 'outlet order download' 下载了邮件？\n"
            debug_info += f"2. 下载的文件夹是否与 checklist 文件夹相同？\n"
            debug_info += f"3. 邮件日志文件是否存在于上述路径中？"
            messagebox.showinfo(
    "交叉檢查結果\nCross Check Result",
     f"找不到 email_bodies_log.txt！\nEmail log not found!\n\n{debug_info}")
            return
        # 1. 讀取 OUTLET mapping
        outlet_map = {}
        unknown_records = []  # 收集 unknown 郵件資訊
        if os.path.exists(config_path):
            try:
                df = pd.read_excel(config_path, sheet_name=None)
                outlet_df = None
                for key in df.keys():
                    if key.strip().lower() in ["outlets", "outlet"]:
                        outlet_df = df[key]
                        break
                if outlet_df is not None:
                    for _, row in outlet_df.iterrows():
                        short = str(
    row[0]).strip().upper() if pd.notna(
        row[0]) else ''
                        full = str(row[1]).strip() if pd.notna(row[1]) else ''
                        email = str(
    row[2]).strip().lower() if pd.notna(
        row[2]) else ''
                        # 支援 Alias/Keyword 欄（第4欄或第5欄，允許多個逗號分隔）
                        alias_col = None
                        for idx in range(3, len(row)):
                            colname = str(
    outlet_df.columns[idx]).strip().lower()
                            if colname in ["alias", "keyword", "別名", "關鍵字"]:
                                alias_col = idx
                                break
                        aliases = []
                        if alias_col is not None and pd.notna(row[alias_col]):
                            aliases = [
    a.strip() for a in str(
        row[alias_col]).split(",") if a.strip()]
                        # 建立 mapping
                        for key in [short, full, email] + aliases:
                            k = key.strip().lower().replace(" ", "")
                            if k:
                                outlet_map[k] = short
            except Exception as e:
                print(f"[DEBUG] 讀 config 出錯: {e}")

        def normalize_name(name):
            if not name:
                return ""
            import re
            name = re.sub(r'\(.*?\)', '', name)
            name = re.sub(r'update', '', name, flags=re.IGNORECASE)
            name = re.sub(r'[^a-zA-Z0-9]', '', name)
            return name.strip().upper()
        
        def normalize_supplier_name(name):
            """标准化供应商名称，处理变体"""
            if not name:
                return ""
            
            # 转换为小写并去除多余空格
            name = name.strip().lower()
            
            # 处理常见的供应商名称变体
            replacements = {
                'super q (chawanmushi)': 'super q (chawan)',
                'super q chawanmushi': 'super q (chawan)',
                'super q chawan': 'super q (chawan)',
                'super q(chawan)': 'super q (chawan)',
                'super q (chawanmushi)': 'super q (chawan)',
                'chawanmushi': 'super q (chawan)',
            }
            
            # 应用替换
            for variant, standard in replacements.items():
                if variant in name:
                    name = name.replace(variant, standard)
            
            return name.strip()

        def is_supplier_match(s1, s2):
            # 标准化处理：移除数字前缀，转换为大写，移除多余空格
            def clean_name(name):
                # 移除数字前缀（如 "1, CHANG CHENG" -> "CHANG CHENG"）
                name = re.sub(r'^\d+[,.\s]*', '', name).strip()
                # 移除公司后缀（如 "PTE LTD", "LTD", "INC" 等）
                name = re.sub(r'\s+(PTE\s+LTD|LTD|INC|CORP|COMPANY|CO\.?)\s*$', '', name, flags=re.IGNORECASE)
                # 移除括号及其内容（如 "Perfect Choice (Chawan)" -> "Perfect Choice"）
                name = re.sub(r'\s*\([^)]*\)\s*', '', name)
                # 移除多余空格，转换为大写
                name = re.sub(r'\s+', ' ', name.strip().upper())
                return name
            
            # 首先使用供应商名称标准化
            s1_normalized = normalize_supplier_name(s1)
            s2_normalized = normalize_supplier_name(s2)
            
            # 如果标准化后相同，直接返回True
            if s1_normalized.lower() == s2_normalized.lower():
                print(f"[DEBUG] ✓ 供应商标准化匹配: '{s1}' -> '{s1_normalized}' == '{s2}' -> '{s2_normalized}'")
                return True
            
            # 然后使用原有的clean_name逻辑
            n1, n2 = clean_name(s1), clean_name(s2)
            
            # 完全匹配
            if n1 == n2:
                return True
            
            # 子字符串匹配（包含关系）
            if n1 in n2 or n2 in n1:
                return True
            
            # 模糊匹配：检查是否有至少3个连续字符相同
            def has_common_substring(str1, str2, min_length=3):
                """检查两个字符串是否有至少min_length个连续字符相同"""
                if len(str1) < min_length or len(str2) < min_length:
                    return False
                
                # 检查str1的每个子串是否在str2中
                for i in range(len(str1) - min_length + 1):
                    substring = str1[i:i + min_length]
                    if substring in str2:
                        return True
                
                # 检查str2的每个子串是否在str1中
                for i in range(len(str2) - min_length + 1):
                    substring = str2[i:i + min_length]
                    if substring in str1:
                        return True
                
                return False
            
            # 使用更严格的模糊匹配
            # 只有当清理后的名称长度相似时才进行模糊匹配
            if len(n1) >= 6 and len(n2) >= 6:  # 至少6个字符才进行模糊匹配
                if has_common_substring(n1, n2, 4):  # 至少4个字符匹配
                    # 额外检查：确保匹配的部分占总长度的合理比例
                    common_length = 0
                    for i in range(len(n1) - 3):
                        substring = n1[i:i + 4]
                        if substring in n2:
                            common_length = max(common_length, len(substring))
                    
                    if common_length >= 4 and common_length >= min(len(n1), len(n2)) * 0.6:
                        return True
            
            # 检查前4个字符匹配（保持原有逻辑）
            if len(n1) >= 4 and len(n2) >= 4:
                if n1[:4] == n2[:4]:
                    return True
            
            return False

        def is_cover_status_ok(status):
            return any(x in status for x in ['✔', '✓'])
        # ===== Outlet mapping 與新版比對 function =====
        short_to_full = {}
        full_to_short = {}
        email_name_to_short = {}
        outlet_all_names = set()
        # 修正 master_config 未定义为 config_path
        if os.path.exists(config_path):
            try:
                df = pd.read_excel(config_path, sheet_name=None)
                outlet_df = None
                for key in df.keys():
                    if key.strip().lower() == "outlet":
                        outlet_df = df[key]
                        break
                if outlet_df is not None:
                    for _, row in outlet_df.iterrows():
                        short = str(row.get("Short Name", "")).strip()
                        full = str(row.get("Outlet Full Name", "")).strip()
                        email_name = str(row.get("Name in Email", "")).strip()
                        n_short = normalize_name(short)
                        n_full = normalize_name(full)
                        n_email = normalize_name(email_name)
                        if short:
                            short_to_full[n_short] = full
                            outlet_all_names.add(n_short)
                        if full:
                            full_to_short[n_full] = short
                            outlet_all_names.add(n_full)
                        if email_name:
                            email_name_to_short[n_email] = short
                            outlet_all_names.add(n_email)
            except Exception as e:
                print("Outlet mapping read error:", e)

        def is_outlet_match(req_outlet, ordered_outlet):
            n_req = normalize_name(req_outlet)
            n_ordered = normalize_name(ordered_outlet)
            # 三者任兩個 normalize 後有 match 就 True
            if n_req and n_ordered and n_req == n_ordered:
                return True
            if n_req in outlet_all_names or n_ordered in outlet_all_names:
                return True
            for n in outlet_all_names:
                if n == n_req or n == n_ordered:
                    return True
            return False
        # 2. 解析 email log
        with open(email_log_path, "r", encoding="utf-8") as f:
            content = f.read()
        
        # 调试：显示邮件内容
        print(f"[DEBUG] 邮件内容前500字符:")
        print(content[:500])
        print(f"[DEBUG] 邮件内容总长度: {len(content)} 字符")
        
        outlet_results = {}
        import re
        
        # 尝试不同的分割符
        split_patterns = [
            r"——— ?邮件 ?\d+ ?———",  # 原格式
            r"——— ?郵件 ?\d+ ?———",  # 繁体
            r"———邮件\d+———",        # 无空格
            r"———郵件\d+———",        # 繁体无空格
        ]
        
        blocks = []
        used_pattern = None
        for pattern in split_patterns:
            if re.search(pattern, content):
                blocks = re.split(pattern, content)
                used_pattern = pattern
                print(f"[DEBUG] 使用分割符: {pattern}, 找到 {len(blocks)} 个邮件块")
                break
        
        if not blocks:
            print("[DEBUG] 未找到标准分割符，尝试按段落分割")
            blocks = content.split("\n\n")
        
        print(f"[DEBUG] 总共 {len(blocks)} 个邮件块")
        for i, block in enumerate(blocks):
            print(f"\n--- 邮件块 {i} ---")
            lines = [l.strip() for l in block.strip().splitlines() if l.strip()]
            if not lines or len(lines) < 2:
                print(f"  跳过邮件块 {i}：行数不足")
                continue
            
            print(f"  邮件块 {i} 内容预览:")
            print(f"  {lines[:3]}...")  # 显示前3行
            
            outlet_raw = ""
            for l in lines:
                m = re.match(r"\[发件人\](.+)", l)
                if m:
                    outlet_raw = m.group(1).strip()
                    break
                # 也尝试繁体格式
                m2 = re.match(r"\[發件人\](.+)", l)
                if m2:
                    outlet_raw = m2.group(1).strip()
                    break
            
            if not outlet_raw:
                print(f"  跳过邮件块 {i}：未找到发件人")
                continue
            
            print(f"  找到门市: {outlet_raw}")
            
            # 使用与下载逻辑完全一致的门市匹配
            def find_outlet_using_download_logic(sender_name, config_path):
                """使用 OUTLET sheet（含表头）将邮箱/名称映射为 Short Code 与 Full Name"""
                if not os.path.exists(config_path):
                    return sender_name, sender_name
                try:
                    sheets = pd.read_excel(config_path, sheet_name=None)
                    outlet_df = None
                    for name, df in sheets.items():
                        if str(name).strip().lower() == "outlet":
                            outlet_df = df
                            break
                    if outlet_df is None:
                        # 兼容无 sheet 名时的单表
                        outlet_df = next(iter(sheets.values()))

                    # 规范列名
                    cols = {c.strip().lower(): c for c in outlet_df.columns if isinstance(c, str)}
                    c_short = cols.get("short name") or cols.get("short") or list(outlet_df.columns)[0]
                    c_full = cols.get("outlet full name") or cols.get("full name") or list(outlet_df.columns)[1]
                    c_email = cols.get("email") or list(outlet_df.columns)[2]
                    c_name_in_email = cols.get("name in email") or cols.get("name") or (list(outlet_df.columns)[4] if len(outlet_df.columns) > 4 else c_full)

                    email_to_short = {}
                    name_to_short = {}
                    fullname_to_short = {}
                    short_to_full = {}
                    def norm(s):
                        return re.sub(r"\s+", "", str(s).strip().lower()) if isinstance(s, str) else ""
                    for _, r in outlet_df.iterrows():
                        short = str(r.get(c_short, '')).strip()
                        full = str(r.get(c_full, '')).strip()
                        email = str(r.get(c_email, '')).strip().lower()
                        name_in_email = str(r.get(c_name_in_email, '')).strip().lower()
                        if short:
                            if email:
                                email_to_short[email] = short
                            if name_in_email:
                                name_to_short[name_in_email] = short
                            if full:
                                fullname_to_short[norm(full)] = short
                            short_to_full[short] = full or short

                    sender_lower = sender_name.strip().lower()
                    sender_norm = norm(sender_name)
                    if sender_lower in email_to_short:
                        s = email_to_short[sender_lower]
                        return s, short_to_full.get(s, s)
                    if sender_lower in name_to_short:
                        s = name_to_short[sender_lower]
                        return s, short_to_full.get(s, s)
                    # 模糊包含：Name in Email 或 Full Name 出現在 sender 或其相反包含
                    for k, s in name_to_short.items():
                        kn = norm(k)
                        if kn and (kn in sender_norm or sender_norm in kn):
                            return s, short_to_full.get(s, s)
                    for k, s in fullname_to_short.items():
                        if k and (k in sender_norm or sender_norm in k):
                            return s, short_to_full.get(s, s)
                    return sender_name, sender_name
                except Exception as e:
                    print(f"    ✗ 匹配门市时出错: {e}")
                    return sender_name, sender_name
            
            # 使用与下载逻辑一致的匹配
            if outlet_raw:
                outlet_short, outlet_full = find_outlet_using_download_logic(outlet_raw, config_path)
                # 使用門市簡稱（如 SKG/HGM）以與主表一致
                outlet = outlet_short or outlet_full or ""
            else:
                outlet = ""
            
            # 使用Short Name作为门市标识（与checklist保持一致）
            display_outlet = outlet_short if outlet_short else outlet_full
            
            # 智能供应商解析逻辑
            def is_valid_supplier_name(text):
                """判断是否为有效的供应商名称"""
                text = text.strip()
                if not text or len(text) < 2:
                    return False
                
                # 排除明显不是供应商的内容
                exclude_patterns = [
                    # 问候语和礼貌用语
                    r'^(hi|hello|dear|good\s+(morning|afternoon|day|evening))',
                    r'(please|kindly|thank\s+you|thanks|regards|best\s+regards)',
                    r'(see\s+attached|please\s+see|attached\s+file)',
                    
                    # 日期和时间格式
                    r'^\d{1,2}[/-]\d{1,2}[/-]\d{2,4}',
                    r'^\d{4}[/-]\d{1,2}[/-]\d{1,2}',
                    r'^\d{1,2}:\d{2}',
                    
                    # 邮件相关
                    r'^(from|to|subject|date):',
                    r'@\w+\.\w+',  # 邮箱地址
                    r'http[s]?://',  # 网址
                    r'www\.',
                    
                    # 说明性文字
                    r'(supplier|suppliers)\s+as\s+below',
                    r'delivery\s+as\s+below',
                    r'as\s+below',
                    r'below:',
                    r'order\s+form',
                    r'weekly\s+order',
                    
                    # 符号和数字
                    r'^[\d\s\-_.,()]+$',
                ]
                
                text_lower = text.lower()
                for pattern in exclude_patterns:
                    if re.search(pattern, text_lower):
                        return False
                
                # 必须包含字母
                if not re.search(r'[a-zA-Z]', text):
                    return False
                
                # 字母数量至少占50%
                alpha_count = len([c for c in text if c.isalpha()])
                if alpha_count < len(text) * 0.5:
                    return False
                
                return True
            
            def extract_suppliers_from_text(lines):
                """从文本行中提取供应商名称"""
                suppliers = []
                in_content_section = False
                
                print(f"  开始智能解析供应商，总共 {len(lines)} 行:")
                
                for i, line in enumerate(lines):
                    print(f"    行 {i+1}: '{line}'")
                    
                    # 检查是否进入内容区域
                    if "[内容]" in line or "[內容]" in line:
                        in_content_section = True
                        print(f"      -> 进入内容区域")
                        continue
                    
                    if in_content_section:
                        line = line.strip()
                        if not line or line.startswith("[") or line.startswith("———"):
                            print(f"      -> 跳过空行或标题: {line}")
                            continue
                        
                        # 检查是否为有效供应商名称
                        if is_valid_supplier_name(line):
                            # 处理数字格式：1) supplier, 2) supplier 或 1. supplier, 2. supplier
                            m1 = re.match(r"\d+\)\s*(.+)", line)
                            m2 = re.match(r"\d+\.\s*(.+)", line)
                            
                            if m1:
                                supplier_name = m1.group(1).strip()
                                if is_valid_supplier_name(supplier_name):
                                    # 使用供应商名称标准化
                                    normalized_name = normalize_supplier_name(supplier_name)
                                    suppliers.append(normalized_name)
                                    print(f"      -> ✓ 添加数字格式供应商: {supplier_name} -> {normalized_name}")
                                else:
                                    print(f"      -> ✗ 跳过无效数字格式: {supplier_name}")
                            elif m2:
                                supplier_name = m2.group(1).strip()
                                if is_valid_supplier_name(supplier_name):
                                    # 使用供应商名称标准化
                                    normalized_name = normalize_supplier_name(supplier_name)
                                    suppliers.append(normalized_name)
                                    print(f"      -> ✓ 添加数字格式供应商: {supplier_name} -> {normalized_name}")
                                else:
                                    print(f"      -> ✗ 跳过无效数字格式: {supplier_name}")
                            else:
                                # 直接的供应商名称
                                normalized_name = normalize_supplier_name(line)
                                suppliers.append(normalized_name)
                                print(f"      -> ✓ 添加直接供应商: {line} -> {normalized_name}")
                        else:
                            print(f"      -> ✗ 跳过无效内容: {line}")
                
                return suppliers
            
            # 使用智能解析
            claimed = extract_suppliers_from_text(lines)
            
            # 如果智能解析没有找到供应商，尝试简单解析
            if not claimed:
                print(f"  -> 智能解析未找到供应商，尝试简单解析:")
                for i, line in enumerate(lines):
                    m = re.match(r"\d+\.\s*(.+)", line)
                    if m:
                        supplier_name = m.group(1).strip()
                        if is_valid_supplier_name(supplier_name):
                            claimed.append(supplier_name)
                            print(f"    行 {i+1}: ✓ 添加简单格式供应商: {supplier_name}")
                        else:
                            print(f"    行 {i+1}: ✗ 跳过无效简单格式: {supplier_name}")
            
            print(f"  -> 最终解析到供应商: {claimed}")
            found = set()
            for row in table:
                row_outlet_norm = normalize_name(row["outlet"])
                # outlet 比對加強：允許 substring/前4碼
                outlet_match = is_outlet_match(row["outlet"], outlet_full)
                for s in claimed:
                    supplier_match = is_supplier_match(row["supplier"], s)
                    cover_ok = is_cover_status_ok(row["cover_status"])
                    print(
    f"[DEBUG] 比對: supplier: {
        normalize_name(
            row['supplier'])} <-> {
                normalize_name(s)} | outlet: {
                    row['outlet']} <-> {outlet_full} | outlet_match: {outlet_match} | cover: {
                        row['cover_status']} => {cover_ok}")
                    if outlet_full and outlet_match and supplier_match and cover_ok:
                        found.add(s)
            if claimed:  # 只有当找到供应商时才添加结果
                outlet_results[display_outlet] = []
                for supplier in claimed:
                    if supplier in found:
                        outlet_results[display_outlet].append((supplier, True))
                    else:
                        outlet_results[display_outlet].append((supplier, False))
                print(f"  最终结果: {outlet_full} -> {len(claimed)} 个供应商")
            else:
                print(f"  跳过 {outlet_full}：未找到供应商")
        
        print(f"\n[DEBUG] 最终解析结果:")
        print(f"总共解析到 {len(outlet_results)} 个门市")
        print(f"Checklist中的门市总数: {len(set(row['outlet'] for row in table))}")
        print(f"Checklist中的门市: {sorted(set(row['outlet'] for row in table))}")
        
        for outlet, suppliers in outlet_results.items():
            print(f"  {outlet}: {len(suppliers)} 个供应商")
            for supplier, status in suppliers:
                print(f"    {supplier}: {'✓' if status else '✗'}")
        
        print(f"\n[DEBUG] 逐一核对结果:")
        for outlet, suppliers in outlet_results.items():
            print(f"\n--- 门市: {outlet} ---")
            print(f"邮件中的供应商: {[s for s, _ in suppliers]}")
            
            # 查找checklist中对应的门市
            checklist_suppliers = []
            for row in table:
                if row["outlet"] == outlet and row["cover_status"] == "✔️":
                    checklist_suppliers.append(row["supplier"])
            
            print(f"Checklist中的供应商: {checklist_suppliers}")
            
            # 详细对比
            email_suppliers_set = set([s for s, _ in suppliers])
            checklist_suppliers_set = set(checklist_suppliers)
            
            # print(f"邮件有但Checklist无: {email_suppliers_set - checklist_suppliers_set}")
            # print(f"Checklist有但邮件无: {checklist_suppliers_set - email_suppliers_set}")
            # print(f"共同供应商: {email_suppliers_set & checklist_suppliers_set}")
        # 创建用户想要的表格格式：门市 | email 下單 | 實際訂單 | 狀態
        # 收集所有门市（包括邮件中和checklist中的）
        all_outlets = set()
        
        # 从邮件中收集门市
        for outlet in outlet_results.keys():
            all_outlets.add(outlet)
        
        # 从checklist中收集门市
        for row in table:
            all_outlets.add(row["outlet"])
        
        print(f"[DEBUG] 所有门市总数: {len(all_outlets)}")
        print(f"[DEBUG] 邮件中的门市: {len(outlet_results)}")
        print(f"[DEBUG] Checklist中的门市: {len(set(row['outlet'] for row in table))}")
        
        # 创建门市名称映射，解决 short name 和 full name 不一致的问题
        def normalize_outlet_name_for_matching(name):
            """标准化门市名称用于匹配"""
            if not name:
                return ""
            
            # 移除常见前缀
            name = re.sub(r'^sushi\s+express\s*', '', name, flags=re.IGNORECASE)
            name = name.strip()
            
            # 移除常见后缀
            name = re.sub(r'\s*mall\s*$', '', name, flags=re.IGNORECASE)
            name = re.sub(r'\s*square\s*$', '', name, flags=re.IGNORECASE)
            name = re.sub(r'\s*centre\s*$', '', name, flags=re.IGNORECASE)
            name = re.sub(r'\s*center\s*$', '', name, flags=re.IGNORECASE)
            
            # 统一空格和特殊字符
            name = re.sub(r'\s+', ' ', name.strip())
            
            # 转换为小写进行比较
            return name.lower()
        
        # 创建门市映射表：标准名称 -> (邮件中的名称, checklist中的名称)
        outlet_mapping = {}
        
        # 收集所有门市名称
        for outlet in all_outlets:
            normalized = normalize_outlet_name_for_matching(outlet)
            if normalized not in outlet_mapping:
                outlet_mapping[normalized] = {'email': None, 'checklist': None}
            
            # 判断这个outlet来自邮件还是checklist
            if outlet in outlet_results:
                outlet_mapping[normalized]['email'] = outlet
            else:
                outlet_mapping[normalized]['checklist'] = outlet
        
        # 处理checklist中的outlet
        for row in table:
            outlet = row["outlet"]
            normalized = normalize_outlet_name_for_matching(outlet)
            if normalized not in outlet_mapping:
                outlet_mapping[normalized] = {'email': None, 'checklist': None}
            outlet_mapping[normalized]['checklist'] = outlet
        
        print(f"\n[DEBUG] 门市映射表:")
        for norm_name, mapping in outlet_mapping.items():
            print(f"  '{norm_name}': email='{mapping['email']}', checklist='{mapping['checklist']}'")
        
        # print(f"\n[DEBUG] 邮件中的门市详情:")
        # for outlet, suppliers in outlet_results.items():
        #     print(f"  '{outlet}': {len(suppliers)} 个供应商")
        
        print(f"\n[DEBUG] Checklist中的门市详情:")
        checklist_outlets = {}
        for row in table:
            outlet = row["outlet"]
            if outlet not in checklist_outlets:
                checklist_outlets[outlet] = []
            if row["cover_status"] == "✔️":
                checklist_outlets[outlet].append(row["supplier"])
        
        for outlet, suppliers in checklist_outlets.items():
            print(f"  '{outlet}': {len(suppliers)} 个供应商")
        
        # 根据config创建门市映射表，使用Short Name和Outlet Full Name
        def create_outlet_mapping_from_config(config_path):
            """根据config创建门市映射表"""
            outlet_mapping = {}  # short_name -> full_name
            email_to_short = {}  # email -> short_name
            name_to_short = {}   # name_in_email -> short_name
            
            if config_path and os.path.exists(config_path):
                try:
                    df = pd.read_excel(config_path)
                    for _, row in df.iterrows():
                        short_name = str(row.iloc[0]).strip() if len(row) > 0 and not pd.isna(row.iloc[0]) else ''
                        full_name = str(row.iloc[1]).strip() if len(row) > 1 and not pd.isna(row.iloc[1]) else ''
                        email = str(row.iloc[2]).strip().lower() if len(row) > 2 and not pd.isna(row.iloc[2]) else ''
                        name_in_email = str(row.iloc[4]).strip().lower() if len(row) > 4 and not pd.isna(row.iloc[4]) else ''
                        
                        if short_name and full_name:
                            outlet_mapping[short_name] = full_name
                        
                        if email and short_name:
                            email_to_short[email] = short_name
                        
                        if name_in_email and short_name:
                            name_to_short[name_in_email] = short_name
                            
                except Exception as e:
                    print(f"[DEBUG] 读取config失败: {e}")
            
            return outlet_mapping, email_to_short, name_to_short
        
        # 创建config映射表
        config_outlet_mapping, config_email_to_short, config_name_to_short = create_outlet_mapping_from_config(config_path)
        
        print(f"\n[DEBUG] Config门市映射:")
        for short_name, full_name in config_outlet_mapping.items():
            print(f"  '{short_name}' -> '{full_name}'")
        
        # print(f"\n[DEBUG] Email映射数量: {len(config_email_to_short)}")
        # print(f"[DEBUG] Name映射数量: {len(config_name_to_short)}")
        
        # 创建详细的对比表格（按供应商级别）
        table_data = []
        
        # 收集所有供应商
        all_suppliers = set()
        
        # 从邮件中收集供应商
        email_suppliers_by_outlet = {}
        for outlet, suppliers in outlet_results.items():
            email_suppliers_by_outlet[outlet] = [supplier for supplier, _ in suppliers]
            all_suppliers.update(email_suppliers_by_outlet[outlet])
        
        # 从checklist中收集供应商
        checklist_suppliers_by_outlet = {}
        for row in table:
            if row["cover_status"] == "✔️":
                outlet = row["outlet"]
                supplier = row["supplier"]
                if outlet not in checklist_suppliers_by_outlet:
                    checklist_suppliers_by_outlet[outlet] = []
                checklist_suppliers_by_outlet[outlet].append(supplier)
                all_suppliers.add(supplier)
        
        # 为每个门市创建对比表格
        for outlet in sorted(set(list(email_suppliers_by_outlet.keys()) + list(checklist_suppliers_by_outlet.keys()))):
            email_suppliers = email_suppliers_by_outlet.get(outlet, [])
            checklist_suppliers = checklist_suppliers_by_outlet.get(outlet, [])
            
            # print(f"\n[DEBUG] 处理门市: {outlet}")
            # print(f"  邮件供应商: {email_suppliers}")
            # print(f"  实际供应商: {checklist_suppliers}")
            
            # 显示清理后的名称用于调试
            def clean_name_for_debug(name):
                name = re.sub(r'^\d+[,.\s]*', '', name).strip()
                name = re.sub(r'\s+(PTE\s+LTD|LTD|INC|CORP|COMPANY|CO\.?)\s*$', '', name, flags=re.IGNORECASE)
                name = re.sub(r'\s*\([^)]*\)\s*', '', name)
                name = re.sub(r'\s+', ' ', name.strip().upper())
                return name
            
            # print(f"  邮件供应商(清理后): {[clean_name_for_debug(s) for s in email_suppliers]}")
            # print(f"  实际供应商(清理后): {[clean_name_for_debug(s) for s in checklist_suppliers]}")
            
            # 创建匹配映射
            matched_pairs = set()  # (email_supplier, actual_supplier) 配对
            unmatched_email = set(email_suppliers)
            unmatched_actual = set(checklist_suppliers)
            
            # 智能匹配：检查每个邮件供应商是否匹配任何实际供应商
            for email_supplier in email_suppliers:
                best_match = None
                for actual_supplier in checklist_suppliers:
                    if is_supplier_match(email_supplier, actual_supplier):
                        # 选择最佳匹配（优先选择完全匹配或更长的匹配）
                        if best_match is None or len(actual_supplier) > len(best_match):
                            best_match = actual_supplier
                
                if best_match:
                    matched_pairs.add((email_supplier, best_match))
                    unmatched_email.discard(email_supplier)
                    unmatched_actual.discard(best_match)
                    # print(f"  ✓ 匹配: '{email_supplier}' <-> '{best_match}'")
            
            # 添加匹配的行
            for email_supplier, actual_supplier in matched_pairs:
                table_data.append((
                    outlet,
                    email_supplier,
                    actual_supplier,
                    "✓"
                ))
            
            # 添加未匹配的邮件供应商
            for email_supplier in unmatched_email:
                table_data.append((
                    outlet,
                    email_supplier,
                    "X",
                    "X 實際并沒有訂單"
                ))
                # print(f"  ✗ 邮件有但实际没有: '{email_supplier}'")
            
            # 添加未匹配的实际供应商
            for actual_supplier in unmatched_actual:
                table_data.append((
                    outlet,
                    "X",
                    actual_supplier,
                    "X Email 并沒有下單"
                ))
                print(f"  ✗ 实际有但邮件没有: '{actual_supplier}'")

        class CrossCheckResultTable(ctk.CTkToplevel):
            def __init__(self, master, table_data):
                super().__init__(master)
                self.title("交叉檢查結果\nCross Check Result")
                self.geometry("1000x600")
                self.search_var = ctk.StringVar()
                ctk.CTkLabel(
                    self, text="搜尋門市\nSearch Outlet").pack(pady=(10, 0))
                search_entry = ctk.CTkEntry(self, textvariable=self.search_var)
                search_entry.pack(fill="x", padx=10)
                search_entry.bind("<KeyRelease>", self.update_filter)
                import tkinter as tk
                from tkinter import ttk
                frame = ctk.CTkFrame(self)
                frame.pack(fill="both", expand=True, padx=10, pady=10)
                columns = ("outlet", "email_order", "actual_order", "status")
                self.tree = ttk.Treeview(
                    frame, columns=columns, show="headings", height=25)
                self.tree.heading("outlet", text="Outlet")
                self.tree.heading("email_order", text="Email 下單")
                self.tree.heading("actual_order", text="實際訂單")
                self.tree.heading("status", text="狀態")
                self.tree.column("outlet", width=150)
                self.tree.column("email_order", width=300)
                self.tree.column("actual_order", width=300)
                self.tree.column("status", width=150)
                self.tree.pack(fill="both", expand=True)
                vsb = ttk.Scrollbar(
                    frame, orient="vertical", command=self.tree.yview)
                self.tree.configure(yscroll=vsb.set)
                vsb.pack(side="right", fill="y")
                self.full_data = table_data
                self.update_table(self.full_data)
                ctk.CTkButton(
                    self,
                    text="關閉\nClose",
                    command=self.destroy).pack(pady=10)

            def update_table(self, data):
                for row in self.tree.get_children():
                    self.tree.delete(row)
                for outlet, email_order, actual_order, status in data:
                    self.tree.insert("", "end", values=(outlet, email_order, actual_order, status))

            def update_filter(self, event=None):
                keyword = self.search_var.get().lower()
                filtered = [row for row in self.full_data if keyword in row[0].lower()]
                self.update_table(filtered)
        
        # 添加查看原始邮件内容的按钮
        class CrossCheckResultTable(ctk.CTkToplevel):
            def __init__(self, master, table_data, email_content=None):
                super().__init__(master)
                self.title("交叉檢查結果\nCross Check Result")
                self.geometry("1000x600")
                
                # 添加按钮框架
                button_frame = ctk.CTkFrame(self)
                button_frame.pack(fill="x", padx=10, pady=(10, 0))
                
                # 查看原始邮件内容按钮
                if email_content:
                    view_email_btn = ctk.CTkButton(
                        button_frame,
                        text="查看原始邮件内容\nView Original Email Content",
                        command=lambda: self.show_email_content(email_content),
                        width=200,
                        height=30
                    )
                    view_email_btn.pack(side="left", padx=5)
                
                self.search_var = ctk.StringVar()
                ctk.CTkLabel(
                    self, text="搜尋門市\nSearch Outlet").pack(pady=(10, 0))
                search_entry = ctk.CTkEntry(self, textvariable=self.search_var)
                search_entry.pack(fill="x", padx=10)
                search_entry.bind("<KeyRelease>", self.update_filter)
                import tkinter as tk
                from tkinter import ttk
                frame = ctk.CTkFrame(self)
                frame.pack(fill="both", expand=True, padx=10, pady=10)
                columns = ("outlet", "email_order", "actual_order", "status")
                self.tree = ttk.Treeview(
                    frame, columns=columns, show="headings", height=25)
                self.tree.heading("outlet", text="Outlet")
                self.tree.heading("email_order", text="Email 下單")
                self.tree.heading("actual_order", text="實際訂單")
                self.tree.heading("status", text="狀態")
                self.tree.column("outlet", width=150)
                self.tree.column("email_order", width=300)
                self.tree.column("actual_order", width=300)
                self.tree.column("status", width=150)
                self.tree.pack(fill="both", expand=True)
                vsb = ttk.Scrollbar(
                    frame, orient="vertical", command=self.tree.yview)
                self.tree.configure(yscroll=vsb.set)
                vsb.pack(side="right", fill="y")
                self.full_data = table_data
                self.update_table(self.full_data)
                ctk.CTkButton(
                    self,
                    text="關閉\nClose",
                    command=self.destroy).pack(pady=10)

            def update_table(self, data):
                for row in self.tree.get_children():
                    self.tree.delete(row)
                for outlet, email_order, actual_order, status in data:
                    self.tree.insert("", "end", values=(outlet, email_order, actual_order, status))

            def update_filter(self, event=None):
                keyword = self.search_var.get().lower()
                filtered = [row for row in self.full_data if keyword in row[0].lower()]
                self.update_table(filtered)
            
            def show_email_content(self, email_content):
                """显示原始邮件内容"""
                email_window = ctk.CTkToplevel(self)
                email_window.title("原始邮件内容\nOriginal Email Content")
                email_window.geometry("800x600")
                
                # 创建文本框
                import tkinter as tk
                from tkinter import scrolledtext
                text_widget = scrolledtext.ScrolledText(
                    email_window, 
                    wrap='word', 
                    font=('Consolas', 10),
                    bg='#2b2b2b',
                    fg='white'
                )
                text_widget.pack(fill="both", expand=True, padx=10, pady=10)
                text_widget.insert('1.0', email_content)
                text_widget.config(state='disabled')
                
                # 添加关闭按钮
                ctk.CTkButton(
                    email_window,
                    text="關閉\nClose",
                    command=email_window.destroy
                ).pack(pady=10)
        
        # 返回table_data供主窗口使用
        return table_data, content

    def _run_cross_check_and_update_remarks(self):
        """运行交叉检查并更新备注列"""
        try:
            # 运行交叉检查
            cross_check_data, email_content = self._run_cross_check_email_log()
            
            # 更新主表格的备注列
            self._update_checklist_remarks(cross_check_data)
            
            # 显示交叉检查结果窗口
            self._show_cross_check_results(cross_check_data, email_content)
            
        except Exception as e:
            from tkinter import messagebox
            messagebox.showerror("错误", f"交叉检查失败: {str(e)}")

    def _update_checklist_remarks(self, cross_check_data):
        """根据交叉检查结果更新主表格的备注列"""
        # 获取当前表格数据
        if not hasattr(self, '_checklist_table_data') or not self._checklist_table_data:
            return
        
        # 创建交叉检查结果的查找字典
        cross_check_dict = {}
        # 记录“邮件声称下单但实际没有”的条目，用于后续新增行
        unmatched_email_entries = []  # [(outlet, supplier, status)]
        for row in cross_check_data:
            outlet = row[0]  # 门市（應為簡稱，如 SKG/HGM）
            email_supplier = row[1]
            actual_supplier = row[2]
            status = row[3]  # 狀態
            
            # 1) 郵件聲稱下單但實際沒有
            if "X 實際并沒有訂單" in status or "X 实际并没有订单" in status:
                key = f"{outlet}_{email_supplier}"
                cross_check_dict[key] = status
                unmatched_email_entries.append((outlet, email_supplier, status))
            # 2) 實際有但郵件沒有（這時候應該以『實際供應商』為鍵來更新主表備註）
            elif "X Email 并沒有下單" in status or "X Email 并没有下单" in status:
                key = f"{outlet}_{actual_supplier}"
                cross_check_dict[key] = status
        
        # 更新主表格数据
        updated_count = 0
        for row in self._checklist_table_data:
            outlet = row.get("outlet", "")
            supplier = row.get("supplier", "")
            key = f"{outlet}_{supplier}"
            
            if key in cross_check_dict:
                # 更新备注列
                existing_remark = row.get("remark", "")
                new_remark = cross_check_dict[key]
                
                # 如果备注列已经有内容，用分号分隔
                if existing_remark:
                    row["remark"] = f"{existing_remark}; {new_remark}"
                else:
                    row["remark"] = new_remark
                
                updated_count += 1
        
        # 将“邮件声称下单但实际没有”的缺失组合加入主表（cover_status 标记为 X）
        # 仅在主表中不存在相同 outlet+supplier 时添加
        existing_keys = {f"{r.get('outlet','')}_{r.get('supplier','')}" for r in self._checklist_table_data}
        added_count = 0
        for outlet, supplier, status in unmatched_email_entries:
            key = f"{outlet}_{supplier}"
            if key not in existing_keys:
                self._checklist_table_data.append({
                    "supplier": supplier,
                    "outlet": outlet,
                    "cover_status": "X",
                    "remark": status
                })
                added_count += 1
        
        # 刷新表格显示
        self._refresh_checklist_table()
        
        # 显示更新结果
        if updated_count > 0:
            from tkinter import messagebox
            messagebox.showinfo("更新完成", f"已更新/新增 {updated_count + added_count} 条记录（新增 {added_count} 条缺失項）")

    def _show_cross_check_results(self, table_data, email_content):
        """显示交叉检查结果窗口"""
        import customtkinter as ctk
        
        class CrossCheckResultTable(ctk.CTkToplevel):
            def __init__(self, master, table_data, email_content=None):
                super().__init__(master)
                self.title("交叉檢查結果\nCross Check Result")
                self.geometry("1000x600")
                
                # 添加按钮框架
                button_frame = ctk.CTkFrame(self)
                button_frame.pack(fill="x", padx=10, pady=(10, 0))
                
                # 查看原始邮件内容按钮
                ctk.CTkButton(
                    button_frame,
                    text="查看原始邮件内容\nView Raw Email Content",
                    command=lambda: self._show_email_content(email_content)
                ).pack(side="left", padx=(0, 10))
                
                # 搜索框
                search_frame = ctk.CTkFrame(button_frame)
                search_frame.pack(side="right", fill="x", expand=True)
                
                ctk.CTkLabel(search_frame, text="搜尋門市\nSearch Outlet:").pack(side="left", padx=(10, 5))
                self.search_var = ctk.StringVar()
                search_entry = ctk.CTkEntry(search_frame, textvariable=self.search_var)
                search_entry.pack(side="left", fill="x", expand=True, padx=(0, 10))
                search_entry.bind("<KeyRelease>", self.update_filter)
                
                # 创建表格
                self.full_data = table_data
                self.tree = ctk.CTkFrame(self)
                self.tree.pack(fill="both", expand=True, padx=10, pady=10)
                
                # 使用tkinter的Treeview
                import tkinter as tk
                from tkinter import ttk
                
                self.treeview = ttk.Treeview(self.tree, columns=("Outlet", "Email下單", "實際訂單", "狀態"), show="headings")
                self.treeview.heading("Outlet", text="門市\nOutlet")
                self.treeview.heading("Email下單", text="Email下單\nEmail Order")
                self.treeview.heading("實際訂單", text="實際訂單\nActual Order")
                self.treeview.heading("狀態", text="狀態\nStatus")
                
                # 设置列宽
                self.treeview.column("Outlet", width=100)
                self.treeview.column("Email下單", width=200)
                self.treeview.column("實際訂單", width=200)
                self.treeview.column("狀態", width=150)
                
                # 滚动条
                scrollbar = ttk.Scrollbar(self.tree, orient="vertical", command=self.treeview.yview)
                self.treeview.configure(yscrollcommand=scrollbar.set)
                
                self.treeview.pack(side="left", fill="both", expand=True)
                scrollbar.pack(side="right", fill="y")
                
                self.update_table(table_data)
            
            def update_filter(self, event=None):
                keyword = self.search_var.get().lower()
                filtered = [row for row in self.full_data if keyword in row[0].lower()]
                self.update_table(filtered)
            
            def update_table(self, data):
                # 清空现有数据
                for item in self.treeview.get_children():
                    self.treeview.delete(item)
                
                # 添加新数据
                for row in data:
                    self.treeview.insert("", "end", values=row)
            
            def _show_email_content(self, content):
                if not content:
                    return
                
                email_window = ctk.CTkToplevel(self)
                email_window.title("原始邮件内容\nRaw Email Content")
                email_window.geometry("800x600")
                
                import tkinter as tk
                from tkinter import scrolledtext
                
                text_widget = scrolledtext.ScrolledText(email_window, wrap=tk.WORD)
                text_widget.pack(fill="both", expand=True, padx=10, pady=10)
                text_widget.insert("1.0", content)
                text_widget.config(state="disabled")
                
                ctk.CTkButton(
                    email_window,
                    text="關閉\nClose",
                    command=email_window.destroy
                ).pack(pady=10)
        
        CrossCheckResultTable(self, table_data, email_content)

    def _search_missing_orders(self):
        """快速搜尋 'Missing'（缺漏分店）"""
        self.checklist_search_var.set("Missing")
        self._filter_checklist_table()

    def _search_crosscheck_email_no_actual(self):
        """快速搜尋 'X 實際并沒有訂單' 交叉檢查結果"""
        # 與備註一致的關鍵字
        self.checklist_search_var.set("X 實際并沒有訂單")
        self._filter_checklist_table()

    def _search_crosscheck_actual_no_email(self):
        """快速搜尋 'X Email 并沒有下單' 交叉檢查結果"""
        # 與備註一致的關鍵字
        self.checklist_search_var.set("X Email 并沒有下單")
        self._filter_checklist_table()

    def show_download_summary(self, start_date, end_date, outlet_count):
        # 清空內容區
        for w in self.content_body.winfo_children():
            w.destroy()
        frame = ctk.CTkFrame(
    self.content_body,
    fg_color="#1e293b",
     corner_radius=18)
        frame.pack(fill="both", expand=True, padx=60, pady=60)
        ctk.CTkLabel(
            frame,
            text=f"📅 抓取日期範圍\n{start_date} ~ {end_date}",
            font=("Microsoft JhengHei", 24, "bold"),
            text_color="#3b82f6"
        ).pack(pady=(30, 10))
        ctk.CTkFrame(
    frame,
    height=2,
    fg_color="#60a5fa").pack(
        fill="x",
        padx=20,
         pady=10)
        ctk.CTkLabel(
            frame,
            text=f"🏪 已下載分店數量\n{outlet_count} 間",
            font=("Microsoft JhengHei", 28, "bold"),
            text_color="#10b981"
        ).pack(pady=(10, 30))

# ========== Outlook下载器 ==========


class OutlookDownloader:
    """Outlook订单下载器"""

    @staticmethod
    def get_smtp_address(msg):
        """取得郵件的 SMTP 格式寄件人，強化 fallback，支援 Exchange 郵件"""
        try:
            if hasattr(
    msg,
     "SenderEmailType") and msg.SenderEmailType == "SMTP":
                return str(msg.SenderEmailAddress).lower().strip()
            if hasattr(
    msg,
    "Sender") and hasattr(
        msg.Sender,
         "GetExchangeUser"):
                try:
                    ex_user = msg.Sender.GetExchangeUser()
                    if ex_user and hasattr(ex_user, "PrimarySmtpAddress"):
                        smtp = str(ex_user.PrimarySmtpAddress).lower().strip()
                        if smtp:
                            return smtp
                except Exception:
                    pass
            # 新增：用 MAPI 屬性抓 SMTP
            try:
                mapi = msg.Sender
                smtp = mapi.PropertyAccessor.GetProperty(
                    "http://schemas.microsoft.com/mapi/proptag/0x39FE001E")
                if smtp:
                    return str(smtp).lower().strip()
            except Exception:
                pass
            # fallback: 直接用 SenderEmailAddress（即使是 EX）
            if hasattr(msg, "SenderEmailAddress"):
                email_addr = str(msg.SenderEmailAddress).lower().strip()
                if email_addr:
                    return email_addr
            # fallback: 直接用 SenderName
            if hasattr(msg, "SenderName"):
                return str(msg.SenderName).lower().strip()
        except Exception:
            pass
        return ""

    @staticmethod
    def get_time_range():
        """獲取時間範圍：從上一周星期五到今天"""
        from datetime import datetime, timedelta

        today = datetime.now()
        # 無論今天是星期幾，都回推到上一周的星期五
        days_since_last_friday = (today.weekday() - 4) % 7 + 7
        start_of_period = (
    today -
    timedelta(
        days=days_since_last_friday)).replace(
            hour=0,
            minute=0,
            second=0,
             microsecond=0)
        end_of_period = today.replace(
    hour=23, minute=59, second=59, microsecond=999999)

        return start_of_period, end_of_period, today.isocalendar()[1]

    @staticmethod
    def get_outlook_account(account_idx=None):
        """獲取 Outlook 帳號"""
        import win32com.client
        import pythoncom

        # 初始化 COM 組件
        pythoncom.CoInitialize()

        outlook = win32com.client.Dispatch("Outlook.Application")
        namespace = outlook.GetNamespace("MAPI")
        accounts = [
    namespace.Folders.Item(
        i +
        1) for i in range(
            namespace.Folders.Count)]

        if account_idx is None:
            account_names = [acct.Name for acct in accounts]
            idx = show_outlook_account_selector(None, account_names)
            if idx is None:
                return None
            account_idx = idx

        return accounts[account_idx]

    @staticmethod
    def get_inbox(account, callback=None):
        """獲取收件匣，嘗試不同名稱"""
        inbox_names = ["Inbox", "收件匣", "收件箱"]

        for inbox_name in inbox_names:
            try:
                inbox = account.Folders(inbox_name)
                if callback:
                    callback(f"✅ 成功訪問收件匣: {inbox_name}")
                return inbox
            except:
                continue

        # 如果找不到收件匣，列出可用文件夾
        available_folders = []
        try:
            for i in range(account.Folders.Count):
                folder = account.Folders.Item(i + 1)
                available_folders.append(folder.Name)
        except:
            pass

        error_msg = f"❌ 無法找到收件匣在帳號 '{account.Name}' 中"
        if available_folders:
            error_msg += f"\n可用文件夾: {', '.join(available_folders)}"

        if callback:
            callback(error_msg)
        return None

    @staticmethod
    def load_config(config_file):
        """載入配置文件"""
        if not config_file or not os.path.exists(config_file):
            return set(), {}

        try:
            import pandas as pd
            df = pd.read_excel(config_file)

            config_emails = set()
            email_to_short = {}

            for _, row in df.iterrows():
                # 假設第3列是郵箱，第1列是短名稱
                email = str(row.iloc[2]).strip().lower() if len(
                    row) > 2 and not pd.isna(row.iloc[2]) else ''
                short_name = str(row.iloc[0]).strip() if len(
                    row) > 0 and not pd.isna(row.iloc[0]) else ''

                if email and short_name:
                    config_emails.add(email)
                    email_to_short[email] = short_name

            return config_emails, email_to_short
        except Exception as e:
            return set(), {}

    @staticmethod
    def search_messages_in_folder(
    folder,
    start_time,
    end_time,
    subject_keywords,
    config_emails=None,
     callback=None):
        """在指定文件夾中搜尋符合條件的郵件"""
        messages = []

        try:
            items = folder.Items
            items.Sort("[ReceivedTime]", True)

            # 過濾時間範圍 - 使用正確的 Outlook 日期格式
            try:
                # 嘗試使用 Outlook 的日期格式
                start_str = start_time.strftime('%m/%d/%Y')
                end_str = end_time.strftime('%m/%d/%Y')
                filter_str = f"[ReceivedTime] >= '{start_str}' AND [ReceivedTime] <= '{end_str}'"
                filtered_messages = items.Restrict(filter_str)

                if callback:
                    callback(f"🔍 使用過濾條件: {filter_str}")
                    callback(f"📊 時間過濾後找到 {filtered_messages.Count} 封郵件")

            except Exception as e:
                if callback:
                    callback(f"⚠️ Restrict 過濾失敗，改用手動過濾: {e}")

                # 如果 Restrict 失敗，使用手動過濾（只檢查最近的郵件）
                filtered_messages = []
                count = 0
                max_check = 500  # 只檢查最近 500 封郵件以提高效率

                for msg in items:
                    if count >= max_check:
                        break
                    count += 1

                    try:
                        received = getattr(msg, 'ReceivedTime', None)
                        if received:
                            # 處理時區問題
                            if hasattr(
    received, 'tzinfo') and received.tzinfo is not None:
                                received_naive = received.replace(tzinfo=None)
                            else:
                                received_naive = received

                            # 檢查是否在時間範圍內
                            if start_time <= received_naive <= end_time:
                                filtered_messages.append(msg)
                    except:
                        continue

                if callback:
                    callback(f"📊 手動過濾後找到 {len(filtered_messages)} 封郵件")

            # 遍歷過濾後的郵件（可能是 Outlook 集合或 Python 列表）
            try:
                # 檢查是否是 Outlook 集合
                if hasattr(filtered_messages, 'Count'):
                    message_count = filtered_messages.Count
                    message_iter = filtered_messages
                else:
                    message_count = len(filtered_messages)
                    message_iter = filtered_messages

                if callback:
                    callback(f"🔍 開始檢查 {message_count} 封郵件的主題和附件...")

                checked_count = 0
                found_count = 0

                for msg in message_iter:
                    try:
                        checked_count += 1

                        # 檢查郵件主題
                        subject = getattr(msg, 'Subject', '').lower()
                        if not any(
    keyword in subject for keyword in subject_keywords):
                            continue

                        # 檢查發件人
                        sender_email = OutlookDownloader.get_sender_email(msg)
                        if not sender_email:
                            continue

                        # 檢查是否在配置文件中（如果有配置文件的話）
                        if config_emails and len(config_emails) > 0:
                            if not any(
    email in sender_email for email in config_emails):
                                continue

                        # 檢查是否有 Excel 附件
                        has_excel = False
                        for attachment in msg.Attachments:
                            if attachment.FileName.lower().endswith(('.xlsx', '.xls')):
                                has_excel = True
                                break

                        if has_excel:
                            messages.append(msg)
                            found_count += 1
                            if callback and found_count <= 3:  # 只報告前3個
                                callback(
    f"  ✅ 找到: {
        getattr(
            msg,
            'Subject',
             'No Subject')}")

                    except Exception as e:
                        continue

                if callback:
                    callback(f"📧 找到 {found_count} 封符合條件的郵件")

            except Exception as e:
                if callback:
                    callback(f"❌ 遍歷郵件時發生錯誤: {e}")
                return []

        except Exception as e:
            if callback:
                callback(f"❌ 搜尋文件夾 {folder.Name} 時發生錯誤: {e}")

        return messages

    @classmethod
    def download_weekly_orders(
    cls,
    destination_folder,
    config_file=None,
    account_idx=None,
    callback=None,
     progress_popup=None):
        import win32com.client
        import pythoncom
        from datetime import datetime, timedelta
        import os
        import re
        import pandas as pd
        import hashlib
        import sys

        # 初始化 COM 組件
        pythoncom.CoInitialize()
        # 取得今天日期
        today = datetime.now()
        week_no = today.isocalendar()[1]

        # ====== 正確回推到上週五 ======
        # today.weekday(): 0=Mon, 4=Fri, 6=Sun
        days_since_last_friday = (today.weekday() - 4) % 7 or 7
        start_of_period = (
    today -
    timedelta(
        days=days_since_last_friday)).replace(
            hour=0,
            minute=0,
            second=0,
             microsecond=0)
        end_of_period = today.replace(
    hour=23, minute=59, second=59, microsecond=999999)

        # 生成月份-星期格式的文件夹名称
        # 使用下週一的日期來計算文件夾名稱，與訂單自動化邏輯保持一致
        next_monday = today + timedelta(days=(7 - today.weekday()))
        month_name = next_monday.strftime('%b').title()  # 确保首字母大写，例如: Aug, Sep
        week_of_month = get_week_of_month(next_monday)
        folder_name = f"{month_name} - Week {week_of_month}"
        
        save_path = os.path.join(destination_folder, folder_name)
        os.makedirs(save_path, exist_ok=True)

        # 創建 Supplier Order 子文件夾
        supplier_order_path = os.path.join(
    save_path, f"Supplier Order - Week {week_no}")
        os.makedirs(supplier_order_path, exist_ok=True)

        if callback:
            callback(f"📁 已創建文件夾: {folder_name}")
            callback(f"📁 已創建子文件夾: Supplier Order - Week {week_no}")

        # ====== 檢查已下載檔案記錄 ======
        downloaded_log_file = os.path.join(
    save_path, "downloaded_files_log.txt")
        downloaded_files = set()
        if os.path.exists(downloaded_log_file):
            try:
                with open(downloaded_log_file, 'r', encoding='utf-8') as f:
                    for line in f:
                        line = line.strip()
                        if line:
                            downloaded_files.add(line)
                if callback:
                    callback(f"📋 已載入 {len(downloaded_files)} 個已下載檔案記錄")
            except Exception as e:
                if callback:
                    callback(f"⚠️ 載入已下載記錄失敗: {e}")

        def save_downloaded_file_info(
    filename,
    sender_email,
    subject,
     received_time):
            """記錄已下載的檔案資訊"""
            try:
                with open(downloaded_log_file, 'a', encoding='utf-8') as f:
                    file_info = f"{filename}|{sender_email}|{subject}|{received_time}"
                    f.write(file_info + "\n")
                    downloaded_files.add(file_info)
            except Exception as e:
                if callback:
                    callback(f"⚠️ 記錄下載資訊失敗: {e}")

        def is_file_already_downloaded(
    filename,
    sender_email,
    subject,
     received_time):
            """檢查檔案是否已經下載過"""
            file_info = f"{filename}|{sender_email}|{subject}|{received_time}"
            return file_info in downloaded_files

        def get_latest_order_for_outlet(short_name, messages_list):
            """獲取指定門市的最新訂單郵件"""
            latest_msg = None
            latest_time = None
            
            for msg in messages_list:
                try:
                    attachments = msg.Attachments
                    subject = getattr(msg, 'Subject', '') or ''
                    received_time = getattr(msg, 'ReceivedTime', None)
                    
                    if attachments.Count == 0:
                        continue
                    
                    # 檢查郵件主旨是否為 Weekly Order
                    subject_lower = subject.lower()
                    
                    # 定義 Weekly Order 的關鍵字
                    weekly_order_keywords = [
                        'weekly order', 'weekly ordering', 'weeklyorder', 'weeklyordering',
                        'weeky order', 'weeky ordering',
                        'weekly', 'weeky',
                        'order', 'ordering',
                        'order form', 'ordering form'
                    ]
                    
                    # 定義要排除的關鍵字
                    exclude_keywords = [
                        'amendment', 'amend', 'ament', 'admentmend', 'adment', 'amendmend', 'amendement',
                        'assets', 'uniform', 'asset', 'uniforms', 'request form', 'outlet assets &', 'outlet assets and',
                        'uniform request', 'assets request', 'assets & uniform', 'assets and uniform',
                        'invoice', 'payment', 'receipt', 'confirmation', 'delivery note',
                        'siahuat', 'siah', 'uat', '思華達', 'siah uat',
                        'monthly', 'month', '月', '月度'
                    ]
                    
                    # 檢查主旨是否包含 Weekly Order 關鍵字
                    has_weekly_order = any(
    keyword in subject_lower for keyword in weekly_order_keywords)
                    
                    # 檢查主旨是否包含排除關鍵字
                    has_exclude_keywords = any(
    keyword in subject_lower for keyword in exclude_keywords)
                    
                    # 特別檢查Amendment相關關鍵字
                    amendment_keywords = [
    'amendment',
    'amend',
    'ament',
    'admentmend',
    'adment',
    'amendmend',
     'amendement']
                    has_amendment = any(
    keyword in subject_lower for keyword in amendment_keywords)
                    
                    # 如果主旨包含Amendment關鍵字，跳過
                    if has_amendment:
                        continue
                    
                    # 如果主旨不包含任何訂單相關關鍵字，或包含其他排除關鍵字，則跳過
                    if not has_weekly_order or has_exclude_keywords:
                        # 但是如果有Excel附件，我們還是要檢查附件名稱
                        excel_attachments_for_check = []
                        for att in attachments:
                            filename = att.FileName
                            name_lower = filename.lower()
                            if name_lower.endswith(
                                '.xlsx') or name_lower.endswith('.xls'):
                                # 特別檢查附件名稱是否包含Amendment關鍵字
                                att_has_amendment = any(
    keyword in name_lower for keyword in amendment_keywords)
                                if att_has_amendment:
                                    continue
                                
                                # 檢查附件名稱是否包含訂單關鍵字
                                att_has_order = any(
    keyword in name_lower for keyword in weekly_order_keywords)
                                att_has_exclude = any(
    keyword in name_lower for keyword in exclude_keywords)
                                
                                if att_has_order and not att_has_exclude:
                                    excel_attachments_for_check.append(att)
                        
                        # 如果主旨和附件都不符合條件，才跳過
                        if not excel_attachments_for_check:
                            continue
                    
                    # 檢查是否有符合條件的 Excel 附件
                    excel_attachments = []
                    for att in attachments:
                        filename = att.FileName
                        name_lower = filename.lower()
                        
                        # 檢查是否為 Excel 文件
                        if name_lower.endswith(
                            '.xlsx') or name_lower.endswith('.xls'):
                            # 特別檢查附件名稱是否包含Amendment關鍵字
                            filename_has_amendment = any(
    keyword in name_lower for keyword in amendment_keywords)
                            if filename_has_amendment:
                                continue
                            
                            # 檢查附件名稱是否包含其他排除關鍵字
                            filename_has_exclude = any(
    keyword in name_lower for keyword in exclude_keywords)
                            
                            # 如果附件包含排除關鍵字，跳過
                            if filename_has_exclude:
                                continue
                            
                            # 如果附件沒有排除關鍵字，就接受
                            excel_attachments.append(att)
                    
                    # 如果沒有 Excel 附件，繼續下一封郵件
                    if not excel_attachments:
                        continue
                    
                    # 找到有效的訂單郵件，檢查是否是最新的
                    if latest_time is None or received_time > latest_time:
                        latest_msg = msg
                        latest_time = received_time
                        
                except Exception:
                    continue
            
            return latest_msg

        # ===== 讀 config，建立 email -> short_name 映射 =====
        email_to_short = {}  # email(lowercase) -> short_name
        name_to_short = {}   # name(lowercase)  -> short_name
        if config_file and os.path.exists(config_file):
            try:
                df = pd.read_excel(config_file)
                for _, row in df.iterrows():
                    email = str(row.iloc[2]).strip().lower() if len(
                        row) > 2 and not pd.isna(row.iloc[2]) else ''
                    short_name = str(row.iloc[0]).strip() if len(
                        row) > 0 and not pd.isna(row.iloc[0]) else ''
                    name_in_email = str(row.iloc[4]).strip().lower() if len(
                        row) > 4 and not pd.isna(row.iloc[4]) else ''
                    if email and short_name:
                        email_to_short[email] = short_name
                    if name_in_email and short_name:
                        name_to_short[name_in_email] = short_name
            except Exception as e:
                pass

        # 選擇帳號
        outlook = win32com.client.Dispatch(
            "Outlook.Application").GetNamespace("MAPI")
        accounts = [
    outlook.Folders.Item(
        i +
        1) for i in range(
            outlook.Folders.Count)]
        if account_idx is None:
            from tkinter import simpledialog
            account_names = [acct.Name for acct in accounts]
            # 嘗試找到主視窗
            import tkinter as tk
            main_window = None
            for w in tk._default_root.winfo_children():
                if hasattr(w, 'attributes'):
                    main_window = w
                    break

            # 確保主視窗在最頂層
            if main_window:
                main_window.attributes('-topmost', True)
                main_window.lift()  # 提升到最頂層
                main_window.focus_force()  # 強制獲得焦點

            idx = simpledialog.askinteger(
                t("select_account"),
                "\n".join([f"[{i}] {name}" for i, name in enumerate(
                    account_names)]) + "\n" + t("enter_index"),
                minvalue=0, maxvalue=len(account_names) - 1,
                parent=main_window if main_window else None
            )

            # 恢復主視窗設置
            if main_window:
                main_window.attributes('-topmost', False)

            if idx is None:
                # if callback:
                #     callback("❌ 未選擇帳號，已取消下載")
                return
            account_idx = idx
        account_folder = accounts[account_idx]
        # 遞迴抓取所有子資料夾的郵件

        def collect_messages_from_subfolders(folder):
            all_messages = []
            try:
                if hasattr(
    folder,
     'DefaultItemType') and folder.DefaultItemType == 0:
                    print(f"[DEBUG] Scanning folder: {folder.Name}")
                    items = folder.Items
                    items.Sort("[ReceivedTime]", True)
                    count = 0
                    for msg in items:
                        try:
                            if msg.Class == 43:
                                received = getattr(msg, 'ReceivedTime', None)
                                subject = getattr(msg, 'Subject', '')
                                if received:
                                    # 若 received 有 tzinfo，轉成 naive
                                    if hasattr(
    received, 'tzinfo') and received.tzinfo is not None:
                                        received_naive = received.replace(
                                            tzinfo=None)
                                    else:
                                        received_naive = received
                                    if start_of_period <= received_naive <= end_of_period:
                                        print(
    f"[DEBUG] Message: ReceivedTime={received}, Subject={subject}")
                                        all_messages.append(msg)
                                        count += 1
                        except Exception as e:
                            print(
    f"[DEBUG] Error reading message in {
        folder.Name}: {e}")
                    print(
    f"[DEBUG] Folder '{
        folder.Name}' matched messages: {count}")
            except Exception as e:
                print(
    f"[DEBUG] Exception in collect_messages_from_subfolders: {e} (Folder: {
        getattr(
            folder,
            'Name',
             '')})")
            for sub in folder.Folders:
                all_messages.extend(collect_messages_from_subfolders(sub))
            return all_messages
        messages = collect_messages_from_subfolders(account_folder)
        if callback:
            callback(f"📬 取得郵件數量（限制上週五起，含所有子資料夾）: {len(messages)}")
            callback("🔍 開始處理所有郵件，尋找最新的 Weekly Order...")
            callback("💡 系統會自動跳過包含 'amendment'、'amend'、'ament' 等關鍵字的郵件和附件")
            callback("💡 對於同一家門市，系統會下載最新的訂單並自動刪除舊的訂單文件")
            callback("💡 確保您始終擁有每家門市的最新訂單")
            callback("")  # 添加空行

        # 只保留 config 裡 email/name 的最新一封郵件
        latest_msg_by_sender = {}
        for msg in messages:
            try:
                sender_email = cls.get_smtp_address(msg).strip().lower()
                sender_name = getattr(msg, "SenderName", "").strip().lower()
                key = None
                if sender_email in email_to_short:
                    key = sender_email
                elif sender_name in name_to_short:
                    key = sender_name
                if not key:
                    continue
                if key not in latest_msg_by_sender or msg.ReceivedTime > latest_msg_by_sender[
                    key].ReceivedTime:
                    latest_msg_by_sender[key] = msg
            except Exception:
                continue
        # 為每個門市收集所有郵件，按時間排序
        all_messages_by_sender = {}
        for msg in messages:
            try:
                sender_email = cls.get_smtp_address(msg).strip().lower()
                sender_name = getattr(msg, "SenderName", "").strip().lower()
                key = None
                if sender_email in email_to_short:
                    key = sender_email
                elif sender_name in name_to_short:
                    key = sender_name
                if not key:
                    continue
                if key not in all_messages_by_sender:
                    all_messages_by_sender[key] = []
                all_messages_by_sender[key].append(msg)
            except Exception:
                continue
        # 按時間排序每個門市的郵件
        for key in all_messages_by_sender:
            all_messages_by_sender[key].sort(
    key=lambda x: x.ReceivedTime, reverse=True)
        downloaded = 0
        skipped = 0
        amendment_skipped = 0  # 新增：統計跳過的 Amendment 數量
        manual_confirmed = 0
        downloaded_short_names = set()
        downloaded_emails = set()  # 新增：統計有下載 weekly order 的 email
        selected_messages = {}     # 新增：實際成功下載檔案所對應的郵件（僅記錄本次保存的）
        # ===== 新的下載邏輯：讀取所有郵件，下載最新的訂單 =====
        for key, messages_list in all_messages_by_sender.items():
            try:
                # 先找 short_name
                if key in email_to_short:
                    short_name = email_to_short[key]
                elif key in name_to_short:
                    short_name = name_to_short[key]
                else:
                    continue

                # 獲取該門市的最新訂單郵件
                latest_msg = get_latest_order_for_outlet(short_name, messages_list)
                
                if latest_msg is None:
                    # 沒有找到有效的訂單郵件
                    skipped += 1
                    continue

                # 處理最新的訂單郵件
                attachments = latest_msg.Attachments
                subject = getattr(latest_msg, 'Subject', '') or ''
                received_time = getattr(latest_msg, 'ReceivedTime', None)

                # 檢查是否有符合條件的 Excel 附件
                excel_attachments = []
                for att in attachments:
                    filename = att.FileName
                    name_lower = filename.lower()

                    # 檢查是否為 Excel 文件
                    if name_lower.endswith(
                        '.xlsx') or name_lower.endswith('.xls'):
                        # 特別檢查附件名稱是否包含Amendment關鍵字
                        amendment_keywords = [
    'amendment',
    'amend',
    'ament',
    'admentmend',
    'adment',
    'amendmend',
     'amendement']
                        filename_has_amendment = any(
    keyword in name_lower for keyword in amendment_keywords)
                        if filename_has_amendment:
                            amendment_skipped += 1
                            if callback:
                                callback(
    f"⏩ 跳過 Amendment 附件: {filename} (from {key})")
                                callback("")  # 添加空行
                            continue

                        # 檢查附件名稱是否包含其他排除關鍵字
                        exclude_keywords = [
                            'assets', 'uniform', 'asset', 'uniforms', 'request form', 'outlet assets &', 'outlet assets and',
                            'uniform request', 'assets request', 'assets & uniform', 'assets and uniform',
                            'invoice', 'payment', 'receipt', 'confirmation', 'delivery note',
                            'siahuat', 'siah', 'uat', '思華達', 'siah uat',
                            'monthly', 'month', '月', '月度'
                        ]
                        filename_has_exclude = any(
    keyword in name_lower for keyword in exclude_keywords)

                        # 如果附件包含排除關鍵字，跳過
                        if filename_has_exclude:
                            if callback:
                                callback(
    f"⏩ 跳過非 Weekly Order 附件: {filename}")
                                callback("")  # 添加空行
                            continue

                        # 如果附件沒有排除關鍵字，就接受
                        excel_attachments.append(att)

                # 如果沒有 Excel 附件，跳過
                if not excel_attachments:
                    skipped += 1
                    continue

                # 下載第一個 Excel 附件
                att = excel_attachments[0]
                filename = att.FileName
                save_filename = f"{short_name}_WeeklyOrder_{week_no}.xlsx"
                full_path = os.path.join(save_path, save_filename)

                # 檢查是否已經下載過相同的郵件
                sender_email = cls.get_smtp_address(latest_msg).strip().lower()
                subject = getattr(latest_msg, 'Subject', '') or ''
                received_time_str = received_time.strftime(
                    '%Y-%m-%d %H:%M:%S') if hasattr(received_time, 'strftime') else ''

                if is_file_already_downloaded(
    filename, sender_email, subject, received_time_str):
                    if callback:
                        callback(f"⏩ 跳過已下載檔案: {filename} (from {key})")
                    continue

                # 檢查是否已存在該門市的訂單文件，如果存在則刪除舊的
                old_file_deleted = False
                if os.path.exists(full_path):
                    try:
                        os.remove(full_path)
                        old_file_deleted = True
                        if callback:
                            callback(f"🗑️ 已刪除舊文件: {save_filename}")
                    except Exception as e:
                        if callback:
                            callback(f"⚠️ 無法刪除舊文件 {full_path}: {e}")

                # 下載新文件
                att.SaveAsFile(full_path)

                # 記錄下載資訊
                save_downloaded_file_info(
    filename, sender_email, subject, received_time_str)

                print(f"[DEBUG] Downloaded from sender_email: {key}")
                downloaded_emails.add(key)
                downloaded += 1
                downloaded_short_names.add(short_name)
                # 記錄此次實際使用的郵件
                selected_messages[key] = latest_msg
                
                if progress_popup:
                    progress_popup.update_outlet_count(
                        len(downloaded_short_names))
                
                if callback:
                    if old_file_deleted:
                        callback(f"✅ {short_name}: {filename} (已更新)")
                    else:
                        callback(f"✅ {short_name}: {filename}")

            except Exception as e:
                if callback:
                    callback(f"❌ Failed to process a message: {e}")
                skipped += 1
        config_short_names = set(email_to_short.values())

        # 備援匹配功能已移除 - 只依賴發件人匹配

        # 檢查哪些門市已經有文件存在（不管是本次下載還是之前下載的）
        existing_files = set()
        for short_name in config_short_names:
            file_path = os.path.join(
    save_path, f"{short_name}_WeeklyOrder_{week_no}.xlsx")
            if os.path.exists(file_path):
                existing_files.add(short_name)

        # 真正未下載的是那些完全沒有文件的門市
        not_downloaded = config_short_names - existing_files

        summary = (
            f"\n=== Download Summary ===\n"
            f"Downloaded (auto): {downloaded}\n"
            f"Amendment Skipped: {amendment_skipped}\n"
            f"Skipped: {skipped}\n"
            f"Saved to: {save_path}\n"
            f"\n=== 檔案下載結果 ===\n"
            f"已下載: {
    ', '.join(
        sorted(existing_files)) if existing_files else '無'}\n"
            f"未下載: {
    ', '.join(
        sorted(not_downloaded)) if not_downloaded else '無'}\n"
            f"跳過 Amendment: {amendment_skipped} 個"
        )
        if callback:
            callback(summary)
        # 額外：呼叫主畫面美化顯示
        try:
            # 取得抓取日期範圍
            start_date = start_of_period.strftime("%Y-%m-%d")
            end_date = end_of_period.strftime("%Y-%m-%d")
            outlet_count = len(downloaded_short_names)
            # 嘗試取得 app 實例並顯示
            import tkinter as tk
            for w in tk._default_root.winfo_children():
                if hasattr(w, 'show_download_summary'):
                    w.show_download_summary(start_date, end_date, outlet_count)
                    break
        except Exception:
            pass

        # ====== 下載邏輯結束後，整理本次實際下載所用郵件的 body ======
        bodies = []
        signature_keywords = [
            'best regards', 'regards', 'thanks', 'thank you', 'cheers', 'sincerely', '此致', '敬礼', '祝好', '謝謝', '感謝', '致敬', '敬上', '顺祝商祺', '顺颂时祺', '顺颂商祺', '顺致敬意', 'With regards', 'Yours faithfully', 'Yours sincerely', 'Yours truly', 'Kind regards', 'BR', '敬請', '順頌']
        import re
        for idx, msg in enumerate(selected_messages.values(), 1):
            try:
                sender = getattr(msg, 'SenderName', '')
                subject = getattr(msg, 'Subject', '')
                body = getattr(msg, 'Body', '') or ''
                
                # 获取邮件发送时间
                try:
                    received_time = getattr(msg, 'ReceivedTime', None)
                    if received_time:
                        # 转换Outlook时间格式为Python datetime
                        if hasattr(received_time, 'year'):
                            email_time = received_time
                        else:
                            # 如果是COM时间对象，转换为Python datetime
                            email_time = datetime.fromtimestamp(received_time.timestamp())
                        time_str = email_time.strftime('%Y-%m-%d %H:%M:%S')
                    else:
                        time_str = "未知时间"
                except:
                    time_str = "未知时间"
                
                body_lines = body.splitlines()
                cut_idx = len(body_lines)
                for i, line in enumerate(body_lines):
                    l = line.strip().lower()
                    if any(kw in l for kw in signature_keywords):
                        cut_idx = i
                        break
                clean_body = '\n'.join(body_lines[:cut_idx]).strip()
                if not clean_body:
                    clean_body = "(无正文)"
                pretty = f"——— 邮件 {idx} ———\n[发件人] {sender}\n[主题] {subject}\n[时间] {time_str}\n[内容]\n" + clean_body
                bodies.append(pretty)
            except Exception:
                continue
        cls.extracted_bodies = bodies
        # 自動寫出 email_bodies_log.txt（僅包含本次成功下載的郵件）
        try:
            log_file = os.path.join(save_path, "email_bodies_log.txt")
            with open(log_file, "w", encoding="utf-8") as f:
                f.write("\n\n".join(bodies))
        except Exception as e:
            pass

        print("[DEBUG] config_file:", config_file)
        print("[DEBUG] save_path:", save_path)
        print("[DEBUG] email_to_short:", email_to_short)
        print("[DEBUG] messages count:", len(messages))
        for msg in messages:
            try:
                sender_email = cls.get_smtp_address(msg).strip().lower()
                if not sender_email:
                    print("[DEBUG] msg.Sender:", getattr(msg, "Sender", None))
                    print(
    "[DEBUG] msg.SenderName:", getattr(
        msg, "SenderName", None))
                    print(
    "[DEBUG] msg.SenderEmailAddress:", getattr(
        msg, "SenderEmailAddress", None))
                    print(
    "[DEBUG] msg.SenderEmailType:", getattr(
        msg, "SenderEmailType", None))
                print("[DEBUG] sender_email:", sender_email)
            except Exception as e:
                print("[DEBUG] error getting sender_email:", e)
        # 在流程結束時自動關閉console（僅限exe且有console時）
        if getattr(
    sys,
    'frozen',
     False) and sys.stdout and sys.stdout.isatty():
            import time
            print(
                "[DEBUG] Download process finished. Console will close in 5 seconds...")
            time.sleep(5)
            sys.exit(0)

        print(
    "[DEBUG] All sender_email with weekly order downloaded:",
     list(downloaded_emails))

    @classmethod
    def download_amendment_orders(
    cls,
    destination_folder,
    config_file=None,
    account_idx=None,
    callback=None,
     progress_popup=None):
        """專門下載 Amendment 訂單"""
        import win32com.client
        import pythoncom
        from datetime import datetime, timedelta
        import os
        import re
        import pandas as pd

        # 初始化 COM 組件
        pythoncom.CoInitialize()

        # 取得今天日期
        today = datetime.now()
        week_no = today.isocalendar()[1]

        # ====== Amendment 使用與 Weekly Order 相同的時間範圍 (上週五到今天) ======
        # today.weekday(): 0=Mon, 1=Tue, 2=Wed, 3=Thu, 4=Fri, 5=Sat, 6=Sun
        # Amendment 應該和 Weekly Order 使用相同的搜尋範圍：從上週五開始
        days_since_last_friday = (today.weekday() - 4) % 7 or 7
        start_of_period = (
    today -
    timedelta(
        days=days_since_last_friday)).replace(
            hour=0,
            minute=0,
            second=0,
             microsecond=0)
        end_of_period = today.replace(
    hour=23, minute=59, second=59, microsecond=999999)

        if callback:
            callback(
    f"📅 Amendment 搜尋時間範圍: 從上週五 {
        start_of_period.strftime('%Y-%m-%d')} 到今天 {
            end_of_period.strftime('%Y-%m-%d')}")

        # 生成月份-星期格式的 Amendment 文件夹名称
        # 使用下週一的日期來計算文件夾名稱，與訂單自動化邏輯保持一致
        next_monday = today + timedelta(days=(7 - today.weekday()))
        month_name = next_monday.strftime('%b').title()  # 确保首字母大写，例如: Aug, Sep
        week_of_month = get_week_of_month(next_monday)
        amendment_folder_name = f"{month_name} - Week {week_of_month}_Amendment"
        
        save_path = os.path.join(
    destination_folder, amendment_folder_name)
        os.makedirs(save_path, exist_ok=True)

        # 創建 Supplier Order 子文件夾
        supplier_order_path = os.path.join(
    save_path, f"Supplier Order - Week {week_no}")
        os.makedirs(supplier_order_path, exist_ok=True)

        if callback:
            callback(f"📁 已創建文件夾: {amendment_folder_name}")
            callback(f"📁 已創建子文件夾: Supplier Order - Week {week_no}")

        # ====== 檢查已下載檔案記錄 ======
        downloaded_log_file = os.path.join(
    save_path, "downloaded_amendment_log.txt")
        downloaded_files = set()
        if os.path.exists(downloaded_log_file):
            try:
                with open(downloaded_log_file, 'r', encoding='utf-8') as f:
                    for line in f:
                        line = line.strip()
                        if line:
                            downloaded_files.add(line)
                if callback:
                    callback(
    f"📋 已載入 {
        len(downloaded_files)} 個已下載 Amendment 檔案記錄")
            except Exception as e:
                if callback:
                    callback(f"⚠️ 載入已下載 Amendment 記錄失敗: {e}")

        def save_downloaded_amendment_info(
    filename, sender_email, subject, received_time):
            """記錄已下載的 Amendment 檔案資訊"""
            try:
                with open(downloaded_log_file, 'a', encoding='utf-8') as f:
                    file_info = f"{filename}|{sender_email}|{subject}|{received_time}"
                    f.write(file_info + "\n")
                    downloaded_files.add(file_info)
            except Exception as e:
                if callback:
                    callback(f"⚠️ 記錄 Amendment 下載資訊失敗: {e}")

        def is_amendment_already_downloaded(
    filename, sender_email, subject, received_time):
            """檢查 Amendment 檔案是否已經下載過"""
            file_info = f"{filename}|{sender_email}|{subject}|{received_time}"
            return file_info in downloaded_files

        # ===== 讀 config，建立 email -> short_name 映射 =====
        email_to_short = {}  # email(lowercase) -> short_name
        name_to_short = {}   # name(lowercase)  -> short_name
        if config_file and os.path.exists(config_file):
            try:
                df = pd.read_excel(config_file)
                for _, row in df.iterrows():
                    email = str(row.iloc[2]).strip().lower() if len(
                        row) > 2 and not pd.isna(row.iloc[2]) else ''
                    short_name = str(row.iloc[0]).strip() if len(
                        row) > 0 and not pd.isna(row.iloc[0]) else ''
                    name_in_email = str(row.iloc[4]).strip().lower() if len(
                        row) > 4 and not pd.isna(row.iloc[4]) else ''
                    if email and short_name:
                        email_to_short[email] = short_name
                    if name_in_email and short_name:
                        name_to_short[name_in_email] = short_name
            except Exception as e:
                pass

        # 選擇帳號
        outlook = win32com.client.Dispatch(
            "Outlook.Application").GetNamespace("MAPI")
        accounts = [
    outlook.Folders.Item(
        i +
        1) for i in range(
            outlook.Folders.Count)]
        if account_idx is None:
            account_names = [acct.Name for acct in accounts]
            # 使用美化的帳號選擇對話框
            idx = show_outlook_account_selector(None, account_names)

            if idx is None:
                return
            account_idx = idx
        account_folder = accounts[account_idx]

        # 遞迴抓取所有子資料夾的郵件
        def collect_messages_from_subfolders(folder):
            all_messages = []
            try:
                if hasattr(
    folder,
     'DefaultItemType') and folder.DefaultItemType == 0:
                    items = folder.Items
                    items.Sort("[ReceivedTime]", True)
                    count = 0
                    for msg in items:
                        try:
                            if msg.Class == 43:
                                received = getattr(msg, 'ReceivedTime', None)
                                subject = getattr(msg, 'Subject', '')
                                if received:
                                    if hasattr(
    received, 'tzinfo') and received.tzinfo is not None:
                                        received_naive = received.replace(
                                            tzinfo=None)
                                    else:
                                        received_naive = received
                                    if start_of_period <= received_naive <= end_of_period:
                                        all_messages.append(msg)
                                        count += 1
                        except Exception as e:
                            pass
            except Exception as e:
                pass
            for sub in folder.Folders:
                all_messages.extend(collect_messages_from_subfolders(sub))
            return all_messages

        messages = collect_messages_from_subfolders(account_folder)
        if callback:
            callback(f"📬 取得郵件數量（Amendment 模式）: {len(messages)}")

        # 為每個門市收集所有郵件，按時間排序
        all_messages_by_sender = {}
        for msg in messages:
            try:
                sender_email = cls.get_smtp_address(msg).strip().lower()
                sender_name = getattr(msg, "SenderName", "").strip().lower()
                key = None
                if sender_email in email_to_short:
                    key = sender_email
                elif sender_name in name_to_short:
                    key = sender_name
                if not key:
                    continue
                if key not in all_messages_by_sender:
                    all_messages_by_sender[key] = []
                all_messages_by_sender[key].append(msg)
            except Exception:
                continue

        # 按時間排序每個門市的郵件
        for key in all_messages_by_sender:
            all_messages_by_sender[key].sort(
    key=lambda x: x.ReceivedTime, reverse=True)

        downloaded = 0
        skipped = 0
        downloaded_short_names = set()

        # ===== Amendment 下載邏輯 =====
        for key, messages_list in all_messages_by_sender.items():
            try:
                # 先找 short_name
                if key in email_to_short:
                    short_name = email_to_short[key]
                elif key in name_to_short:
                    short_name = name_to_short[key]
                else:
                    continue
                amendment_found = False

                # 遍歷該門市的所有郵件，按時間順序（從新到舊）
                for msg in messages_list:
                    attachments = msg.Attachments
                    if attachments.Count == 0:
                        continue

                    # 檢查是否有 Amendment Excel 附件
                    amendment_attachments = []
                    for att in attachments:
                        filename = att.FileName
                        name_lower = filename.lower()
                        # 檢查是否為 Excel 文件且包含 amendment 關鍵字
                        if name_lower.endswith(
                            '.xlsx') or name_lower.endswith('.xls'):
                            # 只搜尋 amendment 相關關鍵字，排除 weekly order
                            amendment_keywords = [
                                'amendment', 'amend', 'ament', 'admentmend', 'adment', 'amendmend', 'amendement'
                            ]
                            if any(
    keyword in name_lower for keyword in amendment_keywords):
                                amendment_attachments.append(att)

                    # 檢查郵件主旨是否包含 amendment
                    subject = getattr(msg, 'Subject', '') or ''
                    subject_lower = subject.lower()
                    # 只搜尋 amendment 相關關鍵字，排除 weekly order
                    amendment_keywords = [
                        'amendment', 'amend', 'ament', 'admentmend', 'adment', 'amendmend', 'amendement'
                    ]
                    is_amendment_subject = any(
    keyword in subject_lower for keyword in amendment_keywords)

                    # 如果沒有 Amendment 附件且主旨也不是 Amendment，繼續下一封郵件
                    if not amendment_attachments and not is_amendment_subject:
                        continue

                    # 找到 Amendment 附件，下載第一個
                    if amendment_attachments:
                        att = amendment_attachments[0]
                        filename = att.FileName
                        save_filename = f"{short_name}_Amendment_{month_name}_{week_of_month}.xlsx"
                        full_path = os.path.join(save_path, save_filename)

                        # 檢查是否已經下載過相同的郵件
                        sender_email = cls.get_smtp_address(msg).strip().lower()
                        subject = getattr(msg, 'Subject', '') or ''
                        received_time = getattr(msg, 'ReceivedTime', None)
                        received_time_str = received_time.strftime('%Y-%m-%d %H:%M:%S') if hasattr(received_time, 'strftime') else ''

                        if is_amendment_already_downloaded(filename, sender_email, subject, received_time_str):
                            if callback:
                                callback(f"⏩ 跳過已下載 Amendment: {filename} (from {key})")
                            continue

                        # 檢查是否已存在該門市的 Amendment 文件，如果存在則刪除舊的
                        old_file_deleted = False
                        if os.path.exists(full_path):
                            try:
                                os.remove(full_path)
                                old_file_deleted = True
                                if callback:
                                    callback(f"🗑️ 已刪除舊的 Amendment 文件: {save_filename}")
                            except Exception as e:
                                if callback:
                                    callback(f"⚠️ 無法刪除舊的 Amendment 文件 {full_path}: {e}")

                        # 下載新文件
                        att.SaveAsFile(full_path)

                        # 記錄下載資訊
                        save_downloaded_amendment_info(filename, sender_email, subject, received_time_str)

                        downloaded += 1
                        downloaded_short_names.add(short_name)
                        amendment_found = True
                        if progress_popup:
                            progress_popup.update_outlet_count(len(downloaded_short_names))
                        if callback:
                            if old_file_deleted:
                                callback(f"✅ {short_name}: {filename} (已更新 Amendment)")
                            else:
                                callback(f"✅ {short_name}: {filename} (Amendment)")
                        break  # 找到 Amendment 附件後跳出循環

                    # 如果主旨包含 amendment 但沒有 amendment 附件，下載第一個 Excel 附件
                    elif is_amendment_subject:
                        excel_attachments = []
                        for att in attachments:
                            filename = att.FileName
                            name_lower = filename.lower()
                            if name_lower.endswith(
                                '.xlsx') or name_lower.endswith('.xls'):
                                excel_attachments.append(att)

                        if excel_attachments:
                            att = excel_attachments[0]
                            filename = att.FileName
                            save_filename = f"{short_name}_Amendment_{month_name}_{week_of_month}.xlsx"
                            full_path = os.path.join(save_path, save_filename)

                            # 檢查是否已經下載過相同的郵件
                            sender_email = cls.get_smtp_address(msg).strip().lower()
                            subject = getattr(msg, 'Subject', '') or ''
                            received_time = getattr(msg, 'ReceivedTime', None)
                            received_time_str = received_time.strftime('%Y-%m-%d %H:%M:%S') if hasattr(received_time, 'strftime') else ''

                            if is_amendment_already_downloaded(filename, sender_email, subject, received_time_str):
                                if callback:
                                    callback(f"⏩ 跳過已下載 Amendment: {filename} (from {key})")
                                continue

                            # 檢查是否已存在該門市的 Amendment 文件，如果存在則刪除舊的
                            old_file_deleted = False
                            if os.path.exists(full_path):
                                try:
                                    os.remove(full_path)
                                    old_file_deleted = True
                                    if callback:
                                        callback(f"🗑️ 已刪除舊的 Amendment 文件: {save_filename}")
                                except Exception as e:
                                    if callback:
                                        callback(f"⚠️ 無法刪除舊的 Amendment 文件 {full_path}: {e}")

                        # 下載新文件
                        att.SaveAsFile(full_path)

                        # 記錄下載資訊
                        save_downloaded_amendment_info(filename, sender_email, subject, received_time_str)

                        downloaded += 1
                        downloaded_short_names.add(short_name)
                        amendment_found = True
                        if progress_popup:
                            progress_popup.update_outlet_count(len(downloaded_short_names))
                        if callback:
                            if old_file_deleted:
                                callback(f"✅ {short_name}: {filename} (已更新 Amendment)")
                            else:
                                callback(f"✅ {short_name}: {filename} (Amendment)")
                        break  # 找到 Amendment 附件後跳出循環

                # 如果該門市的所有郵件都沒有找到 Amendment，記錄跳過
                if not amendment_found:
                    if callback:
                        callback(f"⏩ 跳過 {key} - 沒有找到 Amendment 檔案")
                    skipped += 1

            except Exception as e:
                if callback:
                    callback(f"❌ Failed to process Amendment message: {e}")
                skipped += 1

        config_short_names = set(email_to_short.values())
        not_downloaded = config_short_names - downloaded_short_names
        summary = (
            f"\n=== Amendment Download Summary ===\n"
            f"Downloaded Amendment: {downloaded}\n"
            f"Skipped: {skipped}\n"
            f"Saved to: {save_path}\n"
            f"\n=== Amendment 檔案下載結果 ===\n"
            f"已下載: {
    ', '.join(
        sorted(downloaded_short_names)) if downloaded_short_names else '無'}\n"
            f"未下載: {
    ', '.join(
        sorted(not_downloaded)) if not_downloaded else '無'}"
        )
        if callback:
            callback(summary)

    @classmethod
    def download_siahuat_orders(
        cls,
        destination_folder,
        config_file=None,
        account_idx=None,
        callback=None,
        progress_popup=None):
        """專門下載 Siahuat 訂單 - 從本月1號開始"""
        import win32com.client
        import pythoncom
        from datetime import datetime
        import os
        import re
        import pandas as pd

        # 初始化 COM 組件
        pythoncom.CoInitialize()

        # 取得今天日期
        today = datetime.now()
        month_no = today.month
        year = today.year

        # ====== Siahuat 專用時間範圍：從本月1號到今天 ======
        start_of_month = today.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
        end_of_period = today.replace(hour=23, minute=59, second=59, microsecond=999999)

        if callback:
            callback(f"📅 Siahuat 搜尋時間範圍: 從本月1號 {start_of_month.strftime('%Y-%m-%d')} 到今天 {end_of_period.strftime('%Y-%m-%d')}")

        save_path = os.path.join(destination_folder, f"Siahuat_Orders_{year}_{month_no:02d}")
        os.makedirs(save_path, exist_ok=True)

        if callback:
            callback(f"📁 已創建文件夾: Siahuat_Orders_{year}_{month_no:02d}")

        # ====== 檢查已下載檔案記錄 ======
        downloaded_log_file = os.path.join(save_path, "downloaded_siahuat_log.txt")
        downloaded_files = set()
        if os.path.exists(downloaded_log_file):
            with open(downloaded_log_file, 'r', encoding='utf-8') as f:
                downloaded_files = set(line.strip() for line in f if line.strip())

        try:
            outlook = win32com.client.Dispatch("Outlook.Application").GetNamespace("MAPI")
            accounts = [outlook.Folders.Item(i + 1) for i in range(outlook.Folders.Count)]

            if account_idx >= len(accounts):
                if callback:
                    callback(f"❌ 帳號索引 {account_idx} 超出範圍")
                return

            account = accounts[account_idx]
            if callback:
                callback(f"📧 使用帳號: {account.Name}")

            # ====== 讀取 config 文件中的 email address ======
            config_emails = set()
            email_to_short = {}
            
            if config_file and os.path.exists(config_file):
                try:
                    import pandas as pd
                    df = pd.read_excel(config_file)
                    
                    for _, row in df.iterrows():
                        # 假設第3列是郵箱，第1列是短名稱
                        email = str(row.iloc[2]).strip().lower() if len(row) > 2 and not pd.isna(row.iloc[2]) else ''
                        short_name = str(row.iloc[0]).strip() if len(row) > 0 and not pd.isna(row.iloc[0]) else ''
                        
                        if email and short_name:
                            config_emails.add(email)
                            email_to_short[email] = short_name
                            
                    if callback:
                        callback(f"📋 從配置文件載入了 {len(config_emails)} 個郵箱地址")
                except Exception as e:
                    if callback:
                        callback(f"❌ 讀取配置文件失敗: {e}")
                    return
            else:
                if callback:
                    callback("❌ 未提供配置文件或文件不存在")
                return

            # ====== 搜尋 Siahuat 相關郵件 ======
            all_messages_by_sender = {}

            # 定義 Siahuat 相關的搜尋關鍵詞
            siahuat_keywords = ['siahuat', 'siah', 'uat', '訂單', 'order']

            def search_folder_for_siahuat(folder, level=0):
                """遞歸搜尋資料夾中的 Siahuat 相關郵件"""
                indent = "  " * level
                try:
                    if callback:
                        callback(f"{indent}🔍 搜尋資料夾: {folder.Name}")

                    # 搜尋郵件
                    items = folder.Items
                    items.Sort("[ReceivedTime]", True)

                    found_count = 0
                    for item in items:
                        try:
                            received = getattr(item, 'ReceivedTime', None)
                            subject = getattr(item, 'Subject', '') or ''
                            body = getattr(item, 'Body', '') or ''

                            if not received:
                                continue

                            # 轉換時區
                            if hasattr(received, 'tzinfo') and received.tzinfo is not None:
                                received_naive = received.replace(tzinfo=None)
                            else:
                                received_naive = received

                            # 檢查是否在本月日期範圍內
                            if start_of_month <= received_naive <= end_of_period:
                                # 檢查是否包含 Siahuat 關鍵詞
                                content_to_check = (subject + ' ' + body).lower()
                                if any(keyword in content_to_check for keyword in siahuat_keywords):
                                    sender_email = cls.get_smtp_address(item)
                                    if sender_email:
                                        sender_email = sender_email.strip().lower()
                                        
                                        # 檢查發送者是否在 config 文件中
                                        if config_emails and not any(config_email in sender_email for config_email in config_emails):
                                            continue
                                        
                                        if sender_email not in all_messages_by_sender:
                                            all_messages_by_sender[sender_email] = []
                                        all_messages_by_sender[sender_email].append(item)
                                        found_count += 1

                        except Exception as e:
                            continue

                    if found_count > 0 and callback:
                        callback(f"{indent}  ✅ 找到 {found_count} 封 Siahuat 相關郵件")

                    # 遞歸搜尋子資料夾
                    for subfolder in folder.Folders:
                        search_folder_for_siahuat(subfolder, level + 1)

                except Exception as e:
                    if callback:
                        callback(f"{indent}❌ 搜尋資料夾 {folder.Name} 時發生錯誤: {e}")

            # 從收件匣開始搜尋
            inbox = account.Folders("Inbox")
            search_folder_for_siahuat(inbox)

            if callback:
                callback(f"📊 總共找到 {len(all_messages_by_sender)} 個發送者的 Siahuat 相關郵件")

            # ====== 下載附件 ======
            downloaded = 0
            skipped = 0
            total_senders = len(all_messages_by_sender)

            for sender_idx, (sender_email, messages_list) in enumerate(all_messages_by_sender.items(), 1):
                if callback:
                    callback(f"📧 處理發送者 {sender_idx}/{total_senders}: {sender_email}")

                # 按時間排序，最新的在前
                messages_list.sort(key=lambda x: getattr(x, 'ReceivedTime', datetime.min), reverse=True)

                for msg_idx, msg in enumerate(messages_list):
                    try:
                        subject = getattr(msg, 'Subject', '') or ''
                        received_time = getattr(msg, 'ReceivedTime', None)
                        attachments = msg.Attachments

                        if attachments.Count == 0:
                            continue

                        if callback:
                            callback(f"  📎 檢查郵件: {subject}")

                        # 下載所有附件
                        for att_idx in range(attachments.Count):
                            try:
                                att = attachments.Item(att_idx + 1)
                                filename = att.FileName

                                # 檢查是否已下載
                                file_id = f"{sender_email}_{filename}_{received_time.strftime('%Y%m%d_%H%M%S') if received_time else 'unknown'}"
                                if file_id in downloaded_files:
                                    skipped += 1
                                    continue

                                # 創建新檔名
                                timestamp = received_time.strftime('%Y%m%d_%H%M%S') if received_time else 'unknown'
                                clean_sender = re.sub(r'[<>:"/\\|?*]', '_', sender_email)
                                file_ext = os.path.splitext(filename)[1]
                                new_filename = f"Siahuat_{clean_sender}_{timestamp}_{filename}"

                                save_file = os.path.join(save_path, new_filename)
                                att.SaveAsFile(save_file)

                                # 記錄下載
                                with open(downloaded_log_file, 'a', encoding='utf-8') as f:
                                    f.write(file_id + '\n')
                                downloaded_files.add(file_id)

                                downloaded += 1
                                if callback:
                                    callback(f"    ✅ 下載: {new_filename}")

                            except Exception as e:
                                if callback:
                                    callback(f"    ❌ 下載附件失敗: {e}")
                                skipped += 1

                    except Exception as e:
                        if callback:
                            callback(f"  ❌ 處理郵件失敗: {e}")
                        skipped += 1

            # ====== 總結 ======
            summary = f"""
🎉 Siahuat 訂單下載完成！

📊 下載統計:
• 📅 搜尋期間: {start_of_month.strftime('%Y-%m-%d')} 到 {end_of_period.strftime('%Y-%m-%d')}
• 📧 發送者數量: {total_senders}
• ✅ 成功下載: {downloaded} 個檔案
• ⏩ 跳過重複: {skipped} 個檔案
• 📁 保存位置: {save_path}
"""

            if callback:
                callback(summary)

        except Exception as e:
            error_msg = f"❌ Siahuat 訂單下載失敗: {str(e)}"
            if callback:
                callback(error_msg)
            print(error_msg)

    @classmethod
    def _collect_messages(cls, folder, start_date, end_date, allowed_senders):
        """遍歷所有子資料夾，收集本週所有郵件（只保留 config 裡的 sender）"""
        messages = []
        try:
            items = folder.Items
            items.Sort("[ReceivedTime]", True)
            for msg in items:
                try:
                    received = getattr(msg, 'ReceivedTime', None)
                    msg_class = getattr(msg, 'Class', None)
                    subject = getattr(msg, 'Subject', '')
                    sender_type = getattr(msg, 'SenderEmailType', '')
                    sender_addr = getattr(msg, 'SenderEmailAddress', '')
                    primary_smtp = ''
                    if sender_type == 'EX':
                        try:
                            ex_user = msg.Sender.GetExchangeUser()
                            if ex_user and hasattr(
                                ex_user, 'PrimarySmtpAddress'):
                                primary_smtp = str(
    ex_user.PrimarySmtpAddress).lower()
                        except Exception as e:
                            print(
    f"[DEBUG] Error getting PrimarySmtpAddress: {e}")
                    if received:
                        if hasattr(received,
     'tzinfo') and received.tzinfo is not None:
                            received_naive = received.replace(tzinfo=None)
                        else:
                            received_naive = received
                        if start_date <= received_naive <= end_date:
                            sender_email = clean_email(
                                cls.get_smtp_sender(msg))
                            print(
    f"[DEBUG] 收件日: {received_naive}, 主旨: {subject}, SenderEmailType: {sender_type}, SenderEmailAddress: {sender_addr}, PrimarySmtpAddress: {primary_smtp}, 比對用 sender_email: {sender_email}, msg_class: {msg_class}")
                            if allowed_senders and sender_email in allowed_senders:
                                if msg_class == 43:
                                    messages.append(msg)
                except Exception as e:
                    print(f"[DEBUG] Error reading message: {e}")
        except Exception as e:
            print(f"[DEBUG] Error accessing folder {folder.Name}: {e}")
        for sub in folder.Folders:
            messages.extend(
    cls._collect_messages(
        sub,
        start_date,
        end_date,
         allowed_senders))
        return messages

    @classmethod
    def _download_attachments(
    cls,
    messages,
    save_path,
    email_to_outlet=None,
     week_no=None):
        result = {
            "downloaded": 0,
            "skipped": 0,
            "matched_outlets": [],
            "unmatched_emails": set()
        }
        allowed_senders = set(
    email_to_outlet.keys()) if email_to_outlet else set()
        for msg in messages:
            try:
                sender_email = clean_email(cls.get_smtp_address(msg))
                subject = getattr(msg, "Subject", "") or ""
                attachments = msg.Attachments
                short_name = email_to_outlet.get(sender_email, "")
                if not short_name:
                    result['unmatched_emails'].add(sender_email)
                    continue
                for att in attachments:
                    filename = att.FileName
                    name_lower = filename.lower()
                    subject_lower = subject.lower()
                    # 多重關鍵字判斷
                    is_weekly = any(
                        kw in subject_lower or kw in name_lower
                        for kw in ["weekly order", "order form", "ordering"]
                    )
                    if is_weekly:
                        new_filename = f"{short_name}_WeeklyOrder-Week{week_no}{
    os.path.splitext(filename)[1]}"
                        save_file = os.path.join(save_path, new_filename)
                        att.SaveAsFile(save_file)
                        print(f"✅ Downloaded: {save_file}")
                        result['downloaded'] += 1
                        result['matched_outlets'].append(short_name)
                    else:
                        result['skipped'] += 1
            except Exception as e:
                print(f"Error downloading attachment: {e}")
                result['skipped'] += 1
        return result

    extracted_bodies = []


# ====== 月結文件下載功能 ======
INVALID_FS_CHARS = r"<>:\\|?*\""  # for Windows


def _sanitize_filename(name: str) -> str:
    """Remove invalid characters and trim length."""
    cleaned = ''.join('_' if ch in INVALID_FS_CHARS else ch for ch in name)
    cleaned = re.sub(r"\s+", " ", cleaned).strip()
    return cleaned[:240]  # keep some room for extension


def _safe_save_path(folder: str, filename: str) -> str:
    base, ext = os.path.splitext(filename)
    path = os.path.join(folder, filename)
    i = 1
    while os.path.exists(path):
        path = os.path.join(folder, f"{base} ({i}){ext}")
        i += 1
    return path


class MonthEndDownloader:
    """Core logic for Outlook SOA/Invoice downloading with filters."""

    DEFAULT_ATTACH_KEYWORDS = [
        'soa', 'statement', 'statement of account', 'invoice', 'inv', 'tax invoice',
    ]
    DEFAULT_EXTS = ['pdf', 'xlsx', 'xls', 'docx']

    def __init__(self, parent):
        self.parent = parent
        self.pdf_merger = None  # PDF合并器
        self.merge_pdfs = True  # 是否合并PDF
        self.merge_by_supplier = True  # 是否按供应商创建子文件夹

    # ---- Outlook helpers ----
    def _select_outlook_account(self) -> Optional[int]:
        try:
            import win32com.client
            import pythoncom

            # 初始化 COM 組件
            pythoncom.CoInitialize()

            mapi = win32com.client.Dispatch(
                "Outlook.Application").GetNamespace("MAPI")
            accounts = [
    mapi.Folders.Item(
        i +
        1).Name for i in range(
            mapi.Folders.Count)]
        except Exception as e:
            messagebox.showerror("Outlook", f"無法讀取 Outlook 帳號：{e}")
            return None
        if not accounts:
            messagebox.showwarning("Outlook", "未發現任何 Outlook 帳號")
            return None
        if show_outlook_account_selector:
            return show_outlook_account_selector(self.parent, accounts)
        # fallback: pick first
        return 0

    def _resolve_folder(self, mapi, account_idx: int, folder_path: str):
        root = mapi.Folders.Item(account_idx + 1)
        if not folder_path:
            return root.Folders['Inbox']
        cur = root
        for part in folder_path.split('/'):
            part = part.strip()
            if not part:
                continue
            cur = cur.Folders[part]
        return cur

    def _get_all_folders(self, mapi, account_idx: int):
        """獲取所有資料夾"""
        root = mapi.Folders.Item(account_idx + 1)
        folders = []

        def collect_folders(folder, path=""):
            try:
                current_path = f"{path}/{folder.Name}" if path else folder.Name
                folders.append((current_path, folder))

                # 遞迴搜尋子資料夾
                for i in range(folder.Folders.Count):
                    try:
                        subfolder = folder.Folders.Item(i + 1)
                        collect_folders(subfolder, current_path)
                    except Exception:
                        continue
            except Exception:
                pass

        collect_folders(root)
        return folders

    def _build_restrict(self, start_date: datetime, end_date: datetime) -> str:
        # ReceivedTime inclusive range
        # Use 24-hour clock for better compatibility
        start_str = start_date.strftime('%m/%d/%Y %H:%M')
        end_str = end_date.strftime('%m/%d/%Y %H:%M')

        # 添加调试信息
        print(f"🔍 构建Outlook查询条件:")
        print(f"   开始日期: {start_date} -> {start_str}")
        print(f"   结束日期: {end_date} -> {end_str}")

        return f"[ReceivedTime] >= '{start_str}' AND [ReceivedTime] <= '{end_str}'"

    # ---- Matching rules ----
    def _split_filter_tokens(self, text: str) -> List[str]:
        if not text:
            return []
        # separators: ; , whitespace, newlines
        tokens = re.split(r"[;,\s\n\r]+", text)
        return [t.strip() for t in tokens if t.strip()]

    def _match_email(self, item, email_filters: List[str]) -> bool:
        if not email_filters:
            return True  # 如果没有过滤条件，接受所有邮件
        # Sender match only (common case). Could be extended to To/CC if
        # needed.
        try:
            sender = (item.SenderEmailAddress or '').lower()
        except Exception:
            sender = ''
        for token in email_filters:
            if token.lower() in sender:
                return True
        return False

    def _match_content(self,
    item,
    content_filters: List[str],
    scope: Tuple[bool,
     bool]) -> bool:
        if not content_filters:
            return True
        check_subj, check_body = scope
        subj = (item.Subject or '') if check_subj else ''
        body = (item.Body or '') if check_body else ''
        haystack = f"{subj}\n{body}".lower()
        return any(tok.lower() in haystack for tok in content_filters)

    def _match_attachment(
    self,
    att,
    name_filters: List[str],
     ext_whitelist: List[str]) -> bool:
        try:
            fname = att.FileName or ''
        except Exception:
            fname = ''
        if not fname:
            return False
        ext_ok = True
        if ext_whitelist:
            ext = os.path.splitext(fname)[1].lstrip('.').lower()
            ext_ok = ext in {e.lower() for e in ext_whitelist}
        name_ok = True
        if name_filters:
            low = fname.lower()
            name_ok = any(k in low for k in [k.lower() for k in name_filters])
        return ext_ok and name_ok

    def _match_attachment_simple(self, att, ext_whitelist: List[str]) -> bool:
        """簡化的附件匹配：只檢查副檔名"""
        try:
            fname = att.FileName or ''
        except Exception:
            fname = ''
        if not fname:
            return False

        # 只檢查副檔名
        if ext_whitelist:
            ext = os.path.splitext(fname)[1].lstrip('.').lower()
            return ext in {e.lower() for e in ext_whitelist}

        # 如果沒有副檔名限制，接受所有附件
        return True

    def _merge_pdfs_by_name(self, save_dir: str, logger) -> int:
        """合并同名PDF文件"""
        try:
            # 按文件名分组PDF
            pdf_groups = {}
            for filename in os.listdir(save_dir):
                if filename.lower().endswith('.pdf'):
                    # 提取基础文件名（去掉时间戳和发件人前缀）
                    base_name = self._extract_base_filename(filename)
                    if base_name not in pdf_groups:
                        pdf_groups[base_name] = []
                    pdf_groups[base_name].append(filename)

            merged_count = 0
            for base_name, files in pdf_groups.items():
                if len(files) > 1:
                    # 有多个同名文件，需要合并
                    try:
                        merged_path = os.path.join(
    save_dir, f"{base_name}_merged.pdf")
                        self._merge_pdf_files(
    save_dir, files, merged_path, logger)

                        # 删除原始文件
                        for file in files:
                            os.remove(os.path.join(save_dir, file))

                        merged_count += 1
                        logger(f"   📎 已合并 {len(files)} 个同名PDF: {base_name}")
                    except Exception as e:
                        logger(f"   ⚠️ 合并PDF失败 {base_name}: {e}")

            return merged_count
        except Exception as e:
            logger(f"   ⚠️ PDF合并处理失败: {e}")
            return 0

    def _merge_pdfs_by_similar_names(self, save_dir: str, logger) -> int:
        """基于相似名称合并PDF文件（更智能的合并策略）"""
        try:
            # 获取所有PDF文件
            pdf_files = [f for f in os.listdir(
                save_dir) if f.lower().endswith('.pdf')]
            if len(pdf_files) < 2:
                return 0

            # 按相似性分组
            groups = []
            processed = set()

            for i, file1 in enumerate(pdf_files):
                if file1 in processed:
                    continue

                current_group = [file1]
                processed.add(file1)

                # 寻找相似的文件
                for j, file2 in enumerate(pdf_files[i + 1:], i + 1):
                    if file2 in processed:
                        continue

                    # 检查是否应该合并
                    if self._should_merge_files(file1, file2):
                        current_group.append(file2)
                        processed.add(file2)

                if len(current_group) > 1:
                    groups.append(current_group)

            # 合并每个组
            merged_count = 0
            for group in groups:
                try:
                    # 生成合并后的文件名
                    base_name = self._generate_merged_filename(group)
                    merged_path = os.path.join(
    save_dir, f"{base_name}_merged.pdf")

                    # 合并PDF文件
                    self._merge_pdf_files(save_dir, group, merged_path, logger)

                    # 删除原始文件
                    for file in group:
                        os.remove(os.path.join(save_dir, file))

                    merged_count += 1
                    logger(f"   📎 已合并 {len(group)} 个相似PDF: {base_name}")

                except Exception as e:
                    logger(f"   ⚠️ 合并PDF组失败: {e}")

            return merged_count

        except Exception as e:
            logger(f"   ⚠️ 智能PDF合并失败: {e}")
            return 0

    def _extract_base_filename(self, filename: str) -> str:
        """提取PDF文件的基础名称，改进版本"""
        try:
            # 移除文件扩展名
            name_without_ext = os.path.splitext(filename)[0]

            # 尝试多种文件名格式
            # 格式1: YYYYMMDD - Sender - Subject - filename
            parts = name_without_ext.split(' - ')
            if len(parts) >= 4:
                base_name = parts[3]  # 返回原始文件名部分
                # 移除可能的重复标识符 (1), (2) 等
                if '(' in base_name and ')' in base_name:
                    base_name = base_name.split('(')[0].strip()
                return base_name

            # 格式2: YYYYMMDD - Sender - Subject
            elif len(parts) >= 3:
                # 如果没有原始文件名，使用主题作为基础名称
                subject = parts[2]
                # 清理主题名称，移除特殊字符
                subject = re.sub(r'[<>:"/\\|?*]', '_', subject)
                return subject[:50]  # 限制长度

            # 格式3: 其他格式，尝试提取有意义的部分
            else:
                # 查找可能的订单号或发票号模式
                # 常见的订单号模式：数字+字母组合
                order_pattern = r'[A-Z]{2,}\d{3,}|[A-Z]\d{4,}|\d{3,}[A-Z]{2,}'
                match = re.search(order_pattern, name_without_ext)
                if match:
                    return match.group()

                # 如果没有找到订单号，返回清理后的文件名
                clean_name = re.sub(r'[<>:"/\\|?*]', '_', name_without_ext)
                return clean_name[:50]

        except Exception as e:
            print(f"提取基础文件名失败: {e}")
            # 如果提取失败，返回原始文件名（去掉扩展名）
            return os.path.splitext(filename)[0]

    def _merge_pdf_files(
    self,
    save_dir: str,
    pdf_files: List[str],
    output_path: str,
     logger):
        """合并多个PDF文件"""
        try:
            # 尝试使用PyPDF2
            try:
                from PyPDF2 import PdfMerger
                merger = PdfMerger()

                for pdf_file in sorted(pdf_files):  # 按文件名排序
                    file_path = os.path.join(save_dir, pdf_file)
                    merger.append(file_path)

                merger.write(output_path)
                merger.close()
                logger(f"   📎 使用PyPDF2合并PDF成功")

            except ImportError:
                # 如果没有PyPDF2，尝试使用pdfrw
                try:
                    from pdfrw import PdfReader, PdfWriter
                    writer = PdfWriter()

                    for pdf_file in sorted(pdf_files):
                        file_path = os.path.join(save_dir, pdf_file)
                        reader = PdfReader(file_path)
                        writer.addpages(reader.pages)

                    writer.write(output_path)
                    logger(f"   📎 使用pdfrw合并PDF成功")

                except ImportError:
                    # 如果都没有，使用系统命令
                    logger(f"   ⚠️ 未找到PDF合并库，尝试使用系统命令")
                    self._merge_pdfs_system_command(
    save_dir, pdf_files, output_path, logger)

        except Exception as e:
            logger(f"   ⚠️ PDF合并失败: {e}")
            raise

    def _merge_pdfs_system_command(
    self,
    save_dir: str,
    pdf_files: List[str],
    output_path: str,
     logger):
        """使用系统命令合并PDF（Windows）"""
        try:
            import subprocess

            # 尝试使用pdftk（如果安装了）
            try:
                cmd = ['pdftk']
                for pdf_file in sorted(pdf_files):
                    file_path = os.path.join(save_dir, pdf_file)
                    cmd.extend([file_path, 'cat'])
                cmd.append(output_path)

                result = subprocess.run(cmd, capture_output=True, text=True)
                if result.returncode == 0:
                    logger(f"   📎 使用pdftk合并PDF成功")
                    return
            except FileNotFoundError:
                pass

            # 如果没有pdftk，尝试使用PowerShell
            try:
                # 简化版本：复制第一个文件作为合并结果
                import shutil
                first_file = os.path.join(save_dir, sorted(pdf_files)[0])
                shutil.copy2(first_file, output_path)
                logger(f"   📎 使用文件复制作为PDF合并替代方案")

            except Exception as e:
                logger(f"   ⚠️ 系统命令PDF合并失败: {e}")
                # 最后方案：复制第一个文件
                import shutil
                first_file = os.path.join(save_dir, sorted(pdf_files)[0])
                shutil.copy2(first_file, output_path)
                logger(f"   📎 使用文件复制作为PDF合并替代方案")

        except Exception as e:
            logger(f"   ⚠️ 系统命令PDF合并失败: {e}")
            raise

    def _create_supplier_subfolder(
    self,
    save_dir: str,
     supplier_name: str) -> str:
        """为供应商创建子文件夹"""
        try:
            # 清理供应商名称，确保文件夹名有效
            safe_name = "".join(
    c for c in supplier_name if c.isalnum() or c in (
        ' ', '-', '_')).rstrip()
            safe_name = safe_name.replace(' ', '_')

            supplier_dir = os.path.join(save_dir, safe_name)
            os.makedirs(supplier_dir, exist_ok=True)
            return supplier_dir
        except Exception as e:
            print(f"创建供应商子文件夹失败: {e}")
            return save_dir

    def _find_supplier_name(self, sender_email: str) -> str:
        """根据发件人邮箱查找供应商名称"""
        try:
            # 从UI获取供应商列表
            if hasattr(self.parent, 'suppliers') and self.parent.suppliers:
                for supplier in self.parent.suppliers:
                    if supplier.get(
    'email', '').lower() == sender_email.lower():
                        return supplier.get('name', '')

            # 如果没有找到，尝试从邮箱域名推断
            if '@' in sender_email:
                domain = sender_email.split('@')[1].lower()
                # 常见的供应商域名映射
                domain_mapping = {
                    'freshening.com': 'Freshening',
                    'legacy.com': 'Legacy',
                    'unikleen.com': 'Unikleen',
                    # 可以添加更多映射
                }
                return domain_mapping.get(domain, '')

            return ''
        except Exception as e:
            print(f"查找供应商名称失败: {e}")
            return ''

    def _should_merge_files(self, file1: str, file2: str) -> bool:
        """判断两个文件是否应该合并 - 改进版本"""
        try:
            # 提取基础信息
            info1 = self._extract_file_info(file1)
            info2 = self._extract_file_info(file2)

            # 策略1: 相同的原始文件名（去掉重复标识符）
            if info1['original_name'] and info2['original_name']:
                # 清理文件名，移除 (1), (2), (3) 等重复标识符
                clean_name1 = re.sub(
    r'\s*\(\d+\)\s*$', '', info1['original_name'])
                clean_name2 = re.sub(
    r'\s*\(\d+\)\s*$', '', info2['original_name'])
                if clean_name1.lower() == clean_name2.lower():
                    return True

            # 策略2: 相同的主题（订单号/发票号）
            if info1['subject'] and info2['subject']:
                if info1['subject'].lower() == info2['subject'].lower():
                    return True

            # 策略3: 相同的发件人 + 包含相同订单号的主题
            if (info1['sender'] and info2['sender'] and
                info1['sender'].lower() == info2['sender'].lower()):

                # 检查主题是否包含相同的订单号或发票号
                subject1 = info1['subject'] or ''
                subject2 = info2['subject'] or ''

                # 查找订单号模式 - 改进版本
                # 支持更多订单号格式：INV-SH250603959, SH250603959, 250603959 等
                order_patterns = [
                    r'[A-Z]{2,}-\d{6,}',  # INV-SH250603959
                    r'[A-Z]{2,}\d{6,}',   # SH250603959
                    r'\d{6,}',             # 250603959
                    r'[A-Z]{2,}\d{3,}',   # SH250603
                    r'\d{3,}[A-Z]{2,}'    # 250603SH
                ]

                for pattern in order_patterns:
                    orders1 = re.findall(pattern, subject1.upper())
                    orders2 = re.findall(pattern, subject2.upper())

                    if orders1 and orders2:
                        # 检查是否有相同的订单号
                        for order1 in orders1:
                            for order2 in orders2:
                                if order1 == order2:
                                    return True

            # 策略4: 文件名相似度检查
            similarity = self._calculate_filename_similarity(file1, file2)
            if similarity > 0.8:  # 提高相似度阈值到80%
                return True

            return False

        except Exception as e:
            print(f"检查文件合并条件失败: {e}")
            return False

    def _extract_file_info(self, filename: str) -> dict:
        """提取文件的详细信息"""
        try:
            name_without_ext = os.path.splitext(filename)[0]
            parts = name_without_ext.split(' - ')

            info = {
                'timestamp': parts[0] if len(parts) > 0 else '',
                'sender': parts[1] if len(parts) > 1 else '',
                'subject': parts[2] if len(parts) > 2 else '',
                'original_name': parts[3] if len(parts) > 3 else ''
            }

            return info

        except Exception as e:
            print(f"提取文件信息失败: {e}")
            return {
                'timestamp': '',
                'sender': '',
                'subject': '',
                'original_name': ''
            }

    def _calculate_filename_similarity(self, file1: str, file2: str) -> float:
        """计算两个文件名的相似度"""
        try:
            # 简单的字符串相似度计算
            name1 = os.path.splitext(file1)[0].lower()
            name2 = os.path.splitext(file2)[0].lower()

            # 移除时间戳和发件人信息，只比较主题和原始文件名
            parts1 = name1.split(' - ')
            parts2 = name2.split(' - ')

            # 提取主题和原始文件名
            subject1 = parts1[2] if len(parts1) > 2 else ''
            subject2 = parts2[2] if len(parts2) > 2 else ''

            original1 = parts1[3] if len(parts1) > 3 else ''
            original2 = parts2[3] if len(parts2) > 3 else ''

            # 计算相似度
            total_chars = max(len(subject1), len(subject2)) + \
                              max(len(original1), len(original2))
            if total_chars == 0:
                return 0.0

            # 使用编辑距离计算相似度
            def levenshtein_distance(s1, s2):
                if len(s1) < len(s2):
                    return levenshtein_distance(s2, s1)

                if len(s2) == 0:
                    return len(s1)

                previous_row = list(range(len(s2) + 1))
                for i, c1 in enumerate(s1):
                    current_row = [i + 1]
                    for j, c2 in enumerate(s2):
                        insertions = previous_row[j + 1] + 1
                        deletions = current_row[j] + 1
                        substitutions = previous_row[j] + (c1 != c2)
                        current_row.append(
                            min(insertions, deletions, substitutions))
                    previous_row = current_row

                return previous_row[-1]

            # 计算主题和原始文件名的编辑距离
            subject_distance = levenshtein_distance(subject1, subject2)
            original_distance = levenshtein_distance(original1, original2)

            # 计算相似度
            subject_similarity = 1 - (subject_distance / max(len(subject1), len(
                subject2))) if max(len(subject1), len(subject2)) > 0 else 1.0
            original_similarity = 1 - (original_distance / max(len(original1), len(
                original2))) if max(len(original1), len(original2)) > 0 else 1.0

            # 加权平均
            total_similarity = (
    subject_similarity *
    0.6 +
    original_similarity *
     0.4)

            return total_similarity

        except Exception as e:
            print(f"计算文件名相似度失败: {e}")
            return 0.0

    def _generate_merged_filename(self, file_group: List[str]) -> str:
        """为合并后的文件生成合适的文件名"""
        try:
            if not file_group:
                return "merged"

            # 提取第一个文件的信息作为基础
            first_file = file_group[0]
            info = self._extract_file_info(first_file)

            # 生成合并后的文件名
            if info['subject']:
                base_name = info['subject']
            elif info['original_name']:
                base_name = info['original_name']
            else:
                base_name = "merged_document"

            # 清理文件名
            base_name = re.sub(r'[<>:"/\\|?*]', '_', base_name)
            base_name = base_name[:50]  # 限制长度

            return base_name

        except Exception as e:
            print(f"生成合并文件名失败: {e}")
            return "merged_document"

    def _generate_download_log(self, save_dir: str, logger):
        """生成下载日志文件，记录所有下载的PDF文件"""
        try:
            log_file_path = os.path.join(
    save_dir, f"download_log_{
        datetime.now().strftime('%Y%m%d_%H%M%S')}.txt")

            with open(log_file_path, 'w', encoding='utf-8') as f:
                f.write("=" * 80 + "\n")
                f.write("PDF 下载日志 / PDF Download Log\n")
                f.write("=" * 80 + "\n")
                f.write(
                    f"下载时间 / Download Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                f.write(f"下载目录 / Download Directory: {save_dir}\n")
                f.write("=" * 80 + "\n\n")

                # 记录主文件夹中的文件
                f.write("📁 主文件夹文件 / Main Folder Files:\n")
                f.write("-" * 50 + "\n")
                main_files = [f for f in os.listdir(
                    save_dir) if f.lower().endswith('.pdf')]
                if main_files:
                    for file in sorted(main_files):
                        file_path = os.path.join(save_dir, file)
                        file_size = os.path.getsize(file_path)
                        f.write(f"📎 {file} ({file_size:,} bytes)\n")
                else:
                    f.write("无PDF文件 / No PDF files\n")
                f.write("\n")

                # 记录供应商子文件夹中的文件
                if self.merge_by_supplier:
                    for item in os.listdir(save_dir):
                        item_path = os.path.join(save_dir, item)
                        if os.path.isdir(item_path):
                            f.write(
    f"📁 供应商子文件夹 / Supplier Subfolder: {item}\n")
                            f.write("-" * 50 + "\n")
                            sub_files = [
    f for f in os.listdir(item_path) if f.lower().endswith('.pdf')]
                            if sub_files:
                                for file in sorted(sub_files):
                                    file_path = os.path.join(item_path, file)
                                    file_size = os.path.getsize(file_path)
                                    f.write(
                                        f"📎 {file} ({file_size:,} bytes)\n")
                            else:
                                f.write("无PDF文件 / No PDF files\n")
                            f.write("\n")

                # 统计信息
                total_files = len(main_files)
                if self.merge_by_supplier:
                    for item in os.listdir(save_dir):
                        item_path = os.path.join(save_dir, item)
                        if os.path.isdir(item_path):
                            sub_files = [
    f for f in os.listdir(item_path) if f.lower().endswith('.pdf')]
                            total_files += len(sub_files)

                f.write("=" * 80 + "\n")
                f.write(f"总计 / Total: {total_files} 个PDF文件 / PDF files\n")
                f.write("=" * 80 + "\n")

            logger(f"📝 下载日志已生成: {log_file_path}")

        except Exception as e:
            logger(f"⚠️ 生成下载日志失败: {e}")

    def _extract_order_number(self, subject: str, filename: str) -> str:
        """从主题和文件名中提取订单号"""
        try:
            # 优先从文件名中提取
            if filename:
                # 支持多种订单号格式
                order_patterns = [
                    r'[A-Z]{2,}-\d{6,}',  # INV-SH250603959
                    r'[A-Z]{2,}\d{6,}',   # SH250603959
                    r'\d{6,}',             # 250603959
                    r'[A-Z]{2,}\d{3,}',   # SH250603
                    r'\d{3,}[A-Z]{2,}'    # 250603SH
                ]

                for pattern in order_patterns:
                    match = re.search(pattern, filename.upper())
                    if match:
                        return match.group()

            # 如果文件名中没有，从主题中提取
            if subject:
                for pattern in order_patterns:
                    match = re.search(pattern, subject.upper())
                    if match:
                        return match.group()

            return ""

        except Exception as e:
            print(f"提取订单号失败: {e}")
            return ""

    # ---- Public ops ----
    def preview(self, params, logger) -> Tuple[int, int]:
        return self._scan(params, logger, save=False)

    def download(self, params, logger) -> Tuple[int, int]:
        return self._scan(params, logger, save=True)

    def _scan(self, params, logger, save: bool) -> Tuple[int, int]:
        """Scan Outlook and optionally save matching attachments.
        Returns: (matched_emails, saved_attachments)
        """
        # unpack
        start_date: datetime = params['start_date']
        end_date: datetime = params['end_date']
        save_dir: str = params['save_dir']
        email_filter_text: str = params['email_filters']
        content_filter_text: str = params['content_filters']
        content_scope_subj: bool = params['scope_subj']
        content_scope_body: bool = params['scope_body']
        attach_use_defaults: bool = params['attach_use_defaults']
        attach_extra_keywords: str = params['attach_extra_keywords']
        ext_whitelist_text: str = params['ext_whitelist']
        account_idx: Optional[int] = params.get('account_idx')

        email_filters = self._split_filter_tokens(email_filter_text)
        content_filters = [*self._split_filter_tokens(content_filter_text)]
        if attach_use_defaults:
            content_filters = list(
                {*content_filters, *self.DEFAULT_ATTACH_KEYWORDS})
        ext_whitelist = [e.strip().lower() for e in ext_whitelist_text.split(
            ',') if e.strip()] or self.DEFAULT_EXTS

        # 顯示過濾條件
        logger(f"🔍 過濾條件：")
        if email_filters:
            logger(f"   📧 郵件過濾：{email_filters}")
        else:
            logger(f"   📧 郵件過濾：無（下載所有郵件）")
        logger(f"   📎 檔案類型：{ext_whitelist}")
        logger(
            f"   📅 日期範圍：{start_date.strftime('%Y-%m-%d')} 到 {end_date.strftime('%Y-%m-%d')}")
        logger("")

        # Outlook connect
        try:
            import win32com.client
            import pythoncom

            # 初始化 COM 組件
            pythoncom.CoInitialize()

            outlook = win32com.client.Dispatch("Outlook.Application")
            mapi = outlook.GetNamespace("MAPI")
        except Exception as e:
            messagebox.showerror("Outlook", f"Outlook 初始化失敗：{e}")
            return (0, 0)

        if account_idx is None:
            account_idx = self._select_outlook_account()
            if account_idx is None:
                return (0, 0)

        # 獲取所有資料夾
        try:
            all_folders = self._get_all_folders(mapi, account_idx)
            logger(f"📁 找到 {len(all_folders)} 個資料夾")
        except Exception as e:
            messagebox.showerror("Outlook", f"無法獲取資料夾列表：{e}")
            return (0, 0)

        # Restrict by ReceivedTime
        restr = self._build_restrict(start_date, end_date)

        all_messages = []
        for folder_path, folder in all_folders:
            try:
                # 檢查是否為郵件資料夾
                if hasattr(folder, 'DefaultItemType'):
                    default_item_type = folder.DefaultItemType
                    # 0 = olMailItem (郵件), 1 = olAppointmentItem (約會), 2 =
                    # olContactItem (聯絡人), 3 = olTaskItem (工作)
                    if default_item_type != 0:  # 不是郵件資料夾，跳過
                        continue

                items = folder.Items
                items.IncludeRecurrences = True
                items.Sort("[ReceivedTime]", True)
                restricted = items.Restrict(restr)

                # 收集符合條件的郵件
                for i in range(1, restricted.Count + 1):
                    try:
                        msg = restricted.Item(i)
                        all_messages.append((msg, folder_path))
                    except Exception:
                        continue

            except Exception as e:
                logger(f"⚠️ 處理資料夾 {folder_path} 時發生錯誤：{e}")
                continue

        matched_mails = 0
        saved_atts = 0

        total = len(all_messages)
        logger(f"📥 符合日期的郵件：{total} 封")
        logger(f"🔍 開始處理郵件...\n")

        processed_count = 0
        for msg, folder_path in all_messages:
            processed_count += 1
            if processed_count % 100 == 0:  # 每處理100封郵件顯示一次進度
                logger(f"📊 已處理 {processed_count}/{total} 封郵件...")
            try:
                # Skip meeting items, etc.
                cls_name = getattr(msg, 'MessageClass', '')
                if not str(cls_name).startswith('IPM.Note'):
                    continue

                # 檢查郵件過濾條件
                sender_email = getattr(msg, 'SenderEmailAddress', '') or ''
                subject = msg.Subject or '(no subject)'

                if not self._match_email(msg, email_filters):
                    continue

                matched_mails += 1
                subj = msg.Subject or '(no subject)'
                sender = getattr(msg, 'SenderEmailAddress', '') or ''
                rcv_time = getattr(msg, 'ReceivedTime', None)

                # 简化日志：只显示邮件主题和发件人
                logger(f"📧 {subj} | {sender}")

                atts = getattr(msg, 'Attachments', None)
                if not atts:
                    continue

                if save:
                    os.makedirs(save_dir, exist_ok=True)

                # iterate attachments (1-based)
                try:
                    att_count = atts.Count
                except Exception:
                    att_count = 0

                for a in range(1, att_count + 1):
                    try:
                        att = atts.Item(a)
                        att_name = att.FileName or f"attachment_{a}"
                    except Exception as e:
                        continue

                    # 簡化附件過濾：只檢查副檔名，接受所有附件
                    if not self._match_attachment_simple(att, ext_whitelist):
                        continue

                    if save:
                        fname = att.FileName or 'attachment'
                        # 提取订单号或发票号
                        order_number = self._extract_order_number(subj, fname)

                        # 生成更简洁的文件名：订单号_原始文件名
                        if order_number:
                            out_name = f"{order_number}_{fname}"
                        else:
                            # 如果没有订单号，使用原始文件名
                            out_name = fname

                        # 按供应商创建子文件夹
                        if self.merge_by_supplier and sender:
                            # 查找供应商名称
                            supplier_name = self._find_supplier_name(sender)
                            if supplier_name:
                                supplier_dir = self._create_supplier_subfolder(
                                    save_dir, supplier_name)
                                out_path = _safe_save_path(
                                    supplier_dir, out_name)
                            else:
                                out_path = _safe_save_path(save_dir, out_name)

                        try:
                            att.SaveAsFile(out_path)
                            saved_atts += 1
                            # 简化日志：只显示文件名和保存路径
                            logger(f"📎 {fname} → {os.path.basename(out_path)}")
                        except Exception as e:
                            logger(f"❌ 保存失敗：{fname}")
                    else:
                        # preview mode
                        saved_atts += 1
                        logger(f"📎 {att.FileName}")

            except Exception as e:
                logger(f"⚠️ 郵件處理錯誤：{e}")

        # 下载完成后，合并同名PDF文件
        if save and self.merge_pdfs and saved_atts > 0:
            logger(f"\n🔄 开始合并同名PDF文件...")
            try:
                # 先尝试智能合并（基于相似名称）
                logger(f"🔍 尝试智能PDF合并...")
                merged_count = self._merge_pdfs_by_similar_names(
                    save_dir, logger)

                # 如果智能合并没有效果，尝试传统合并
                if merged_count == 0:
                    logger(f"🔍 智能合并无效果，尝试传统合并...")
                    merged_count = self._merge_pdfs_by_name(save_dir, logger)

                # 再合并所有供应商子文件夹中的PDF
                if self.merge_by_supplier:
                    for item in os.listdir(save_dir):
                        item_path = os.path.join(save_dir, item)
                        if os.path.isdir(item_path):
                            # 先尝试智能合并
                            subfolder_merged = self._merge_pdfs_by_similar_names(
                                item_path, logger)
                            if subfolder_merged == 0:
                                # 如果智能合并无效果，尝试传统合并
                                subfolder_merged = self._merge_pdfs_by_name(
                                    item_path, logger)

                            merged_count += subfolder_merged
                            if subfolder_merged > 0:
                                logger(
    f"📁 供应商子文件夹 {item} 中合并了 {subfolder_merged} 组PDF")

                if merged_count > 0:
                    logger(f"✅ 成功合并 {merged_count} 组PDF文件")
                else:
                    logger(f"ℹ️ 没有找到需要合并的PDF文件")
                
                # 🔗 新增：执行最终合并 - 将所有已合并的文件再次合并
                logger(f"\n🔗 开始最终合并所有文件...")
                try:
                    # 1. 为每个供应商创建最终合并文件
                    if self.merge_by_supplier:
                        supplier_finals_created = self._create_supplier_final_merges(save_dir, logger)
                        logger(f"✅ 供应商最终合并完成，创建了 {supplier_finals_created} 个文件")
                    
                    # 2. 创建包含所有供应商的最终合并文件
                    all_suppliers_final_created = self._create_all_suppliers_final_merge(save_dir, logger)
                    if all_suppliers_final_created:
                        logger(f"✅ 所有供应商最终合并完成")
                    else:
                        logger(f"ℹ️ 所有供应商最终合并跳过（无文件需要合并）")
                        
                except Exception as e:
                    logger(f"⚠️ 最终合并过程中发生错误: {e}")
                    
            except Exception as e:
                logger(f"⚠️ PDF合并过程中发生错误: {e}")

            # 生成下载日志文件
            self._generate_download_log(save_dir, logger)

        logger(
    f"\n總結：命中郵件 {matched_mails} 封，命中附件 {saved_atts} 個{
        '（已保存）' if save else '（預覽）'}\n")
        return matched_mails, saved_atts

    def _create_supplier_final_merges(self, save_dir: str, logger) -> int:
        """为每个供应商创建最终合并文件"""
        try:
            logger(f"   🔗 开始为每个供应商创建最终合并文件...")
            
            # 查找所有供应商子文件夹
            supplier_folders = []
            for item in os.listdir(save_dir):
                item_path = os.path.join(save_dir, item)
                if os.path.isdir(item_path):
                    supplier_folders.append(item)
            
            if not supplier_folders:
                logger(f"      ⚠️ 未找到供应商子文件夹，跳过供应商最终合并")
                return 0
            
            logger(f"      📁 找到 {len(supplier_folders)} 个供应商文件夹")
            
            total_created = 0
            
            # 为每个供应商创建最终合并文件
            for supplier in supplier_folders:
                supplier_path = os.path.join(save_dir, supplier)
                logger(f"      🏢 处理供应商: {supplier}")
                
                # 查找该供应商文件夹中的所有已合并文件
                supplier_merged_files = []
                for filename in os.listdir(supplier_path):
                    if filename.lower().endswith('.pdf') and '_merged.pdf' in filename:
                        supplier_merged_files.append(filename)
                
                if not supplier_merged_files:
                    logger(f"         ⚠️ 供应商 {supplier} 没有已合并的文件")
                    continue
                
                logger(f"         📋 供应商 {supplier} 有 {len(supplier_merged_files)} 个已合并文件")
                
                # 按文件名排序
                supplier_merged_files.sort()
                
                # 生成该供应商的最终合并文件名
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                supplier_final_filename = f"{supplier}_FINAL_MERGED_{timestamp}.pdf"
                supplier_final_path = os.path.join(supplier_path, supplier_final_filename)
                
                # 执行供应商最终合并
                try:
                    self._merge_pdf_files(supplier_path, supplier_merged_files, supplier_final_path, logger)
                    logger(f"         ✅ 供应商 {supplier} 最终合并完成: {supplier_final_filename}")
                    total_created += 1
                    
                except Exception as e:
                    logger(f"         ❌ 供应商 {supplier} 最终合并失败: {e}")
            
            logger(f"      📊 供应商最终合并统计: 共创建 {total_created} 个最终合并文件")
            return total_created
            
        except Exception as e:
            logger(f"      ❌ 供应商最终合并处理失败: {e}")
            return 0

    def _create_all_suppliers_final_merge(self, save_dir: str, logger) -> bool:
        """创建包含所有供应商的最终合并文件"""
        try:
            logger(f"   🔗 创建包含所有供应商的最终合并文件...")
            
            # 查找所有供应商的最终合并文件
            all_supplier_finals = []
            
            for item in os.listdir(save_dir):
                item_path = os.path.join(save_dir, item)
                if os.path.isdir(item_path):
                    # 查找该供应商的最终合并文件
                    for filename in os.listdir(item_path):
                        if filename.startswith(f"{item}_FINAL_MERGED_") and filename.endswith('.pdf'):
                            all_supplier_finals.append(os.path.join(item, filename))
                            logger(f"      📎 找到供应商最终文件: {item}/{filename}")
                            break
            
            if not all_supplier_finals:
                logger(f"      ⚠️ 未找到供应商最终合并文件，跳过所有供应商最终合并")
                return False
            
            logger(f"      📋 找到 {len(all_supplier_finals)} 个供应商最终合并文件")
            
            # 生成主目录的最终合并文件名
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            main_final_filename = f"ALL_SUPPLIERS_FINAL_MERGED_{timestamp}.pdf"
            main_final_path = os.path.join(save_dir, main_final_filename)
            
            try:
                # 执行跨文件夹的最终合并
                self._merge_cross_folder_pdfs(save_dir, all_supplier_finals, main_final_path, logger)
                logger(f"      ✅ 所有供应商最终合并完成: {main_final_filename}")
                return True
                
            except Exception as e:
                logger(f"      ❌ 所有供应商最终合并失败: {e}")
                return False
                
        except Exception as e:
            logger(f"      ❌ 创建所有供应商最终合并文件失败: {e}")
            return False

    def _merge_cross_folder_pdfs(self, base_dir: str, relative_paths: List[str], output_path: str, logger):
        """跨文件夹合并PDF文件"""
        try:
            # 尝试使用PyPDF2
            try:
                from PyPDF2 import PdfMerger
                merger = PdfMerger()

                for relative_path in sorted(relative_paths):
                    full_path = os.path.join(base_dir, relative_path)
                    if os.path.exists(full_path):
                        merger.append(full_path)
                        logger(f"         📎 添加文件: {relative_path}")
                    else:
                        logger(f"         ⚠️ 文件不存在: {full_path}")

                merger.write(output_path)
                merger.close()
                logger(f"         📎 跨文件夹PDF合并成功")

            except ImportError:
                # 如果没有PyPDF2，尝试使用pdfrw
                try:
                    from pdfrw import PdfReader, PdfWriter
                    writer = PdfWriter()

                    for relative_path in sorted(relative_paths):
                        full_path = os.path.join(base_dir, relative_path)
                        if os.path.exists(full_path):
                            reader = PdfReader(full_path)
                            writer.addpages(reader.pages)
                            logger(f"         📎 添加文件: {relative_path}")

                    writer.write(output_path)
                    logger(f"         📎 使用pdfrw跨文件夹PDF合并成功")

                except ImportError:
                    # 如果都没有，使用文件复制作为替代方案
                    logger(f"         ⚠️ 未找到PDF合并库，使用文件复制作为替代方案")
                    import shutil
                    if relative_paths:
                        first_file = os.path.join(base_dir, relative_paths[0])
                        if os.path.exists(first_file):
                            shutil.copy2(first_file, output_path)
                            logger(f"         📎 使用文件复制作为跨文件夹PDF合并替代方案")

        except Exception as e:
            logger(f"         ❌ 跨文件夹PDF合并失败: {e}")
            raise

    def _detect_base_date_from_worksheet(self):
        """从工作表中检测基准日期"""
        try:
            # 这个方法需要在有工作表对象时调用
            # 由于MonthEndDownloader类没有直接访问工作表，我们需要通过其他方式获取
            # 这里返回None，让调用者使用默认逻辑
            return None
        except Exception as e:
            return None

    def _detect_base_date_from_worksheet(self):
        """从工作表中检测基准日期"""
        try:
            # 这个方法需要在有工作表对象时调用
            # 由于OperationSuppliesOrder类没有直接访问工作表，我们需要通过其他方式获取
            # 这里返回None，让调用者使用默认逻辑
            return None
        except Exception as e:
            return None


class MonthEndDownloadUI(ctk.CTkFrame):
    """UI wrapper for Month End SOA/Invoice downloader."""

    def __init__(self, master):
        super().__init__(master, fg_color='transparent')
        self.downloader = MonthEndDownloader(self)
        self.config_path = None
        self.suppliers = []
        self.selected_suppliers = []  # 新增：选中的供应商列表
        self._build()

    # --- UI ---
    def _build(self):
        # date range row - 左右排列
        row1 = ctk.CTkFrame(self, fg_color=DARK_PANEL)
        row1.pack(fill='x', padx=10, pady=10)

        # 日期選擇區域
        date_frame = ctk.CTkFrame(row1, fg_color='transparent')
        date_frame.pack(fill='x', padx=10, pady=(10, 0))

        # 左側：開始日期
        left_date_frame = ctk.CTkFrame(date_frame, fg_color='transparent')
        left_date_frame.pack(side='left', fill='x', expand=True, padx=(0, 5))
        ctk.CTkLabel(
    left_date_frame,
    text='日期起 / From',
    font=FONT_MID,
    text_color=TEXT_COLOR).pack(
        anchor='w',
        pady=(
            0,
             5))

        start_date_frame = ctk.CTkFrame(
    left_date_frame, fg_color='transparent')
        start_date_frame.pack(fill='x')
        # 设置开始日期为当前月份的第一天
        current_date = datetime.now()
        start_date = current_date.replace(day=1)
        self.var_start = ctk.StringVar(value=start_date.strftime('%Y-%m-%d'))

        # 使用 tkcalendar.DateEntry 替代 CTkEntry
        import tkinter as tk
        start_cal_frame = tk.Frame(start_date_frame)
        start_cal_frame.pack(fill='x', expand=True)

        if DateEntry is not None:
            self.start_date_entry = DateEntry(start_cal_frame,
                                             selectmode='day',
                                             date_pattern='yyyy-mm-dd',
                                             font=('Arial', 12),
                                             background='#2b2b2b',
                                             foreground='white',
                                             bordercolor='#3b8ed0',
                                             headersbackground='#3b8ed0',
                                             headersforeground='white',
                                             normalbackground='#2b2b2b',
                                             normalforeground='white',
                                             weekendbackground='#343638',
                                             weekendforeground='white',
                                             othermonthbackground='#242424',
                                             othermonthforeground='gray50',
                                             selectbackground='#3b8ed0',
                                             selectforeground='white',
                                             year=datetime.now().replace(day=1).year,
                                             month=datetime.now().replace(day=1).month,
                                             day=datetime.now().replace(day=1).day,
                                             locale='en_US',
                                             state='readonly')  # 回到最基本的配置
            self.start_date_entry.pack(fill='x', expand=True)
            self.start_date_entry.bind(
    "<<DateSelected>>", self._on_start_date_selected)
            # 只保留基本的月份变化事件绑定
            self.start_date_entry.bind(
    "<<CalendarMonthChanged>>",
     self._on_start_month_changed)
            print(f"🔍 已绑定开始日期基本事件")
        else:
            # Fallback to CTkEntry if DateEntry is not available
            self.start_date_entry = ctk.CTkEntry(
    start_cal_frame, textvariable=self.var_start)
            self.start_date_entry.pack(fill='x', expand=True)
            ctk.CTkButton(start_cal_frame, text='📅', command=lambda: self._show_date_picker('start'),
                          width=40, fg_color=ACCENT_BLUE).pack(side='right', padx=(5, 0))

        # 右側：結束日期
        right_date_frame = ctk.CTkFrame(date_frame, fg_color='transparent')
        right_date_frame.pack(side='right', fill='x', expand=True, padx=(5, 0))
        ctk.CTkLabel(
    right_date_frame,
    text='截至日期 / To',
    font=FONT_MID,
    text_color=TEXT_COLOR).pack(
        anchor='w',
        pady=(
            0,
             5))

        end_date_frame = ctk.CTkFrame(right_date_frame, fg_color='transparent')
        end_date_frame.pack(fill='x')
        # 设置结束日期为当前日期
        self.var_end = ctk.StringVar(value=current_date.strftime('%Y-%m-%d'))

        # 移動強制更新按鈕到快速日期按鈕區

        # 使用 tkcalendar.DateEntry 替代 CTkEntry
        end_cal_frame = tk.Frame(end_date_frame)
        end_cal_frame.pack(fill='x', expand=True)

        if DateEntry is not None:
            self.end_date_entry = DateEntry(end_cal_frame,
                                           selectmode='day',
                                           date_pattern='yyyy-mm-dd',
                                           font=('Arial', 12),
                                           background='#2b2b2b',
                                           foreground='white',
                                           bordercolor='#3b8ed0',
                                           headersbackground='#3b8ed0',
                                           headersforeground='white',
                                           normalbackground='#2b2b2b',
                                           normalforeground='white',
                                           weekendbackground='#343638',
                                           weekendforeground='white',
                                           othermonthbackground='#242424',
                                           othermonthforeground='gray50',
                                           selectbackground='#3b8ed0',
                                           selectforeground='white',
                                           year=datetime.now().year,
                                           month=datetime.now().month,
                                           day=datetime.now().day,
                                           locale='en_US',
                                           state='readonly')  # 回到最基本的配置
            self.end_date_entry.pack(fill='x', expand=True)
            self.end_date_entry.bind(
    "<<DateSelected>>",
     self._on_end_date_selected)
            # 只保留基本的月份变化事件绑定
            self.end_date_entry.bind(
    "<<CalendarMonthChanged>>",
     self._on_end_month_changed)
            print(f"🔍 已绑定结束日期基本事件")
        else:
            # Fallback to CTkEntry if DateEntry is not available
            self.end_date_entry = ctk.CTkEntry(
    end_cal_frame, textvariable=self.var_end)
            self.end_date_entry.pack(fill='x', expand=True)
            ctk.CTkButton(end_cal_frame, text='📅', command=lambda: self._show_date_picker('end'),
                          width=40, fg_color=ACCENT_BLUE).pack(side='right', padx=(5, 0))

        # 快速日期按鈕
        btns = ctk.CTkFrame(row1, fg_color='transparent')
        btns.pack(fill='x', padx=10, pady=(10, 10))
        ctk.CTkButton(
    btns,
    text='本月\nThis Month',
    command=self._quick_this_month,
    fg_color=ACCENT_BLUE,
    corner_radius=8).pack(
        side='left',
         padx=4)
        # 新增：強制更新放在上月左邊
        ctk.CTkButton(
    btns,
    text='🔄 強制更新\nForce Update',
    command=self._force_update_dates,
    fg_color=ACCENT_BLUE,
    corner_radius=8).pack(
        side='left',
         padx=4)
        ctk.CTkButton(
    btns,
    text='上月\nLast Month',
    command=self._quick_last_month,
    corner_radius=8).pack(
        side='left',
         padx=4)

        # save folder row
        row2 = ctk.CTkFrame(self, fg_color=DARK_PANEL)
        row2.pack(fill='x', padx=10, pady=10)
        ctk.CTkLabel(
    row2,
    text='另存到 / Save to folder',
    font=FONT_MID,
    text_color=TEXT_COLOR).pack(
        anchor='w',
        padx=10,
        pady=(
            10,
             0))
        row2b = ctk.CTkFrame(row2, fg_color='transparent')
        row2b.pack(fill='x', padx=10, pady=(0, 10))
        self.var_save = ctk.StringVar(
    value=os.path.join(
        os.path.expanduser('~'),
        'Downloads',
         'MonthEnd'))
        ctk.CTkEntry(
    row2b,
    textvariable=self.var_save).pack(
        side='left',
        fill='x',
         expand=True)
        ctk.CTkButton(
    row2b,
    text='選擇...',
    command=self._pick_save_dir).pack(
        side='left',
         padx=6)

        # config file selection row
        row_config = ctk.CTkFrame(self, fg_color=DARK_PANEL)
        row_config.pack(fill='x', padx=10, pady=10)
        ctk.CTkLabel(
    row_config,
    text='配置文件 / Config File',
    font=FONT_MID,
    text_color=TEXT_COLOR).pack(
        anchor='w',
        padx=10,
        pady=(
            10,
             0))
        row_configb = ctk.CTkFrame(row_config, fg_color='transparent')
        row_configb.pack(fill='x', padx=10, pady=(0, 10))
        self.var_config = ctk.StringVar(value='')
        ctk.CTkEntry(
    row_configb,
    textvariable=self.var_config,
    placeholder_text='選擇配置文件...').pack(
        side='left',
        fill='x',
         expand=True)
        ctk.CTkButton(
    row_configb,
    text='選擇...',
    command=self._pick_config_file).pack(
        side='left',
         padx=6)
        ctk.CTkButton(
    row_configb,
    text='載入供應商',
    command=self._load_suppliers,
    fg_color=ACCENT_BLUE).pack(
        side='left',
         padx=6)

        # supplier selection row - 简化，只显示按钮
        row_supplier = ctk.CTkFrame(self, fg_color=DARK_PANEL)
        row_supplier.pack(fill='x', padx=10, pady=10)
        ctk.CTkLabel(
    row_supplier,
    text='選擇供應商 / Select Suppliers',
    font=FONT_MID,
    text_color=TEXT_COLOR).pack(
        anchor='w',
        padx=10,
        pady=(
            10,
             0))

        # 简化的供应商选择按钮
        supplier_btn_frame = ctk.CTkFrame(row_supplier, fg_color='transparent')
        supplier_btn_frame.pack(fill='x', padx=10, pady=(0, 10))

        # 打开供应商选择窗口的按钮
        ctk.CTkButton(supplier_btn_frame, text='📋 選擇供應商 / Select Suppliers',
                      command=self._open_supplier_selection,
                      fg_color=ACCENT_BLUE, width=200, height=35).pack(side='left', padx=5)

        # 显示已选择的供应商数量
        self.supplier_count_label = ctk.CTkLabel(supplier_btn_frame, text="未選擇供應商",
                                                font=FONT_MID, text_color=TEXT_COLOR)
        self.supplier_count_label.pack(side='left', padx=10)

        # filters row (simplified - only email filter)
        row3 = ctk.CTkFrame(self, fg_color=DARK_PANEL)
        row3.pack(fill='x', padx=10, pady=10)
        ctk.CTkLabel(
    row3,
    text='寄件者篩選（以 ; , 空白 分隔）\nEmail Filter (Sender; , space separated)',
    font=FONT_MID,
    text_color=TEXT_COLOR).pack(
        anchor='w',
        padx=10,
        pady=(
            10,
             0))
        self.var_email = ctk.StringVar(value='')
        ctk.CTkEntry(
    row3, textvariable=self.var_email).pack(
        fill='x', padx=10, pady=4)

        # 移除 content filter 相關的 UI 元素

        # actions row - 优化按钮布局
        row4 = ctk.CTkFrame(self, fg_color='transparent')
        row4.pack(fill='x', padx=10, pady=(20, 20))

        # 按钮容器 - 居中对齐，优化间距
        button_container = ctk.CTkFrame(row4, fg_color='transparent')
        button_container.pack(fill='x', expand=True)

        # 创建内部容器来居中按钮
        center_container = ctk.CTkFrame(
    button_container, fg_color='transparent')
        center_container.pack(expand=True)

        # 预览按钮 - 更大尺寸
        preview_btn = ctk.CTkButton(center_container, text='預覽\nPreview', command=self._on_preview,
                                   fg_color=ACCENT_BLUE, width=180, height=50, corner_radius=10,
                                   font=("Microsoft YaHei", 14, "bold"))
        preview_btn.pack(side='left', padx=(0, 20), pady=15)

        # 下载按钮 - 更大尺寸
        download_btn = ctk.CTkButton(center_container, text='下載\nDownload', command=self._on_download,
                                    fg_color=ACCENT_GREEN, width=180, height=50, corner_radius=10,
                                    font=("Microsoft YaHei", 14, "bold"))
        download_btn.pack(side='left', padx=(0, 20), pady=15)
        
        # Siahuat 訂單下載按鈕
        siahuat_btn = ctk.CTkButton(center_container, text='🏢 Siahuat 訂單\nSiahuat Orders', command=self._on_download_siahuat,
                                   fg_color="#FF6B35", width=180, height=50, corner_radius=10,
                                   font=("Microsoft YaHei", 14, "bold"))
        siahuat_btn.pack(side='left', padx=(0, 0), pady=15)

        # 添加状态标签
        self.status_label = ctk.CTkLabel(
    self, text="", font=FONT_MID, text_color=TEXT_COLOR)
        self.status_label.pack(pady=(0, 10))

        # 添加调试信息
        print("🔍 调试：按钮已创建")
        print(f"   预览按钮: {preview_btn}")
        print(f"   下载按钮: {download_btn}")
        print(f"   状态标签: {self.status_label}")

    def _open_supplier_selection(self):
        """打开供应商选择窗口"""
        if not self.suppliers:
            messagebox.showwarning("警告", "請先載入供應商配置文件")
            return

        # 创建供应商选择窗口
        supplier_window = ctk.CTkToplevel(self)
        supplier_window.title("選擇供應商 / Select Suppliers")
        supplier_window.geometry("700x800")  # 进一步增加宽度和高度
        supplier_window.resizable(False, False)

        # 居中显示
        supplier_window.update_idletasks()
        x = (supplier_window.winfo_screenwidth() // 2) - (700 // 2)
        y = (supplier_window.winfo_screenheight() // 2) - (800 // 2)
        supplier_window.geometry(f"700x800+{x}+{y}")

        # 设置为最顶层
        supplier_window.attributes('-topmost', True)

        # 标题
        title_label = ctk.CTkLabel(supplier_window, text="選擇供應商 / Select Suppliers",
                                  font=FONT_TITLE, text_color=TEXT_COLOR)
        title_label.pack(pady=20)

        # 供应商滚动框架
        supplier_scroll = ctk.CTkScrollableFrame(
            supplier_window, height=500)  # 进一步增加高度
        supplier_scroll.pack(fill="both", expand=True, padx=20, pady=10)

        # 创建供应商复选框
        supplier_vars = []
        for supplier in self.suppliers:
            var = ctk.BooleanVar()
            supplier_vars.append((supplier, var))

            # 供应商复选框
            supplier_frame = ctk.CTkFrame(
    supplier_scroll, fg_color='transparent')
            supplier_frame.pack(fill='x', pady=2)

            ctk.CTkCheckBox(supplier_frame, text=f"{supplier['name']} ({supplier['email']})",
                           variable=var, font=FONT_MID, text_color=TEXT_COLOR).pack(side='left', padx=10)

        # 全选/取消全选按钮
        select_btns_frame = ctk.CTkFrame(
    supplier_window, fg_color='transparent')
        select_btns_frame.pack(fill='x', padx=20, pady=15)

        ctk.CTkButton(select_btns_frame, text='全選 / Select All',
                      command=lambda: [var.set(True)
                                               for _, var in supplier_vars],
                      fg_color=ACCENT_BLUE, width=120, height=30).pack(side='left', padx=5)

        ctk.CTkButton(select_btns_frame, text='取消全選 / Deselect All',
                      command=lambda: [var.set(False)
                                               for _, var in supplier_vars],
                      fg_color="#666666", width=120, height=30).pack(side='left', padx=5)

        # 确认按钮 - 增加更多空间确保完全可见
        def confirm_selection():
            selected_suppliers = [
    supplier for supplier,
     var in supplier_vars if var.get()]
            self.selected_suppliers = selected_suppliers

            # 更新显示
            if selected_suppliers:
                count = len(selected_suppliers)
                names = ", ".join([s['name'] for s in selected_suppliers[:3]])
                if count > 3:
                    names += f" 等 {count} 個供應商"
                self.supplier_count_label.configure(text=f"已選擇: {names}")
            else:
                self.supplier_count_label.configure(text="未選擇供應商")

            supplier_window.destroy()
            messagebox.showinfo("完成", f"已選擇 {len(selected_suppliers)} 個供應商")

        # 为确认按钮创建专门的容器，确保有足够空间
        confirm_frame = ctk.CTkFrame(
    supplier_window, fg_color='transparent', height=80)
        confirm_frame.pack(fill='x', padx=20, pady=20)
        confirm_frame.pack_propagate(False)  # 防止容器被压缩

        confirm_btn = ctk.CTkButton(confirm_frame, text='確認選擇 / Confirm Selection',
                                   command=confirm_selection, fg_color=ACCENT_GREEN, height=50, width=200)
        confirm_btn.pack(expand=True)

    def _show_date_picker(self, date_type):
        """顯示日期選擇器（備用方案）"""
        try:
            import tkcalendar
            from tkcalendar import DateEntry
        except ImportError:
            messagebox.showwarning(
    "缺少模組", "請安裝 tkcalendar: pip install tkcalendar")
            return

        # 創建日期選擇器窗口
        picker_window = ctk.CTkToplevel(self)
        picker_window.title("選擇日期 / Select Date")
        picker_window.geometry("300x250")
        picker_window.resizable(False, False)

        # 居中顯示
        picker_window.update_idletasks()
        x = (picker_window.winfo_screenwidth() // 2) - (300 // 2)
        y = (picker_window.winfo_screenheight() // 2) - (250 // 2)
        picker_window.geometry(f"300x250+{x}+{y}")

        # 設置為最頂層
        picker_window.attributes('-topmost', True)

        # 標題
        title_label = ctk.CTkLabel(picker_window, text=f"選擇{'開始' if date_type == 'start' else '結束'}日期",
                                  font=FONT_TITLE, text_color=TEXT_COLOR)
        title_label.pack(pady=20)

        # 創建日期選擇器
        def on_date_select():
            selected_date = cal.get_date()
            if date_type == 'start':
                self.var_start.set(selected_date.strftime('%Y-%m-%d'))
            else:
                self.var_end.set(selected_date.strftime('%Y-%m-%d'))
            picker_window.destroy()

        # 使用 tkinter 的 Frame 來容納 tkcalendar
        import tkinter as tk
        cal_frame = tk.Frame(picker_window)
        cal_frame.pack(pady=10)

        # 創建日期選擇器
        cal = DateEntry(cal_frame, width=20, background='darkblue',
                       foreground='white', borderwidth=2, date_pattern='yyyy-mm-dd')
        cal.pack(pady=10)

        # 確認按鈕
        confirm_btn = ctk.CTkButton(picker_window, text="確認 / Confirm",
                                   command=on_date_select, fg_color=ACCENT_BLUE)
        confirm_btn.pack(pady=10)

        # 取消按鈕
        cancel_btn = ctk.CTkButton(picker_window, text="取消 / Cancel",
                                  command=picker_window.destroy, fg_color="#666666")
        cancel_btn.pack(pady=5)

    # --- quick range helpers ---

    def _quick_this_month(self):
        now = datetime.now()
        start = now.replace(day=1)
        end = now
        if hasattr(self.start_date_entry, 'set_date'):
            self.start_date_entry.set_date(start.date())
            self.end_date_entry.set_date(end.date())
        self.var_start.set(start.strftime('%Y-%m-%d'))
        self.var_end.set(end.strftime('%Y-%m-%d'))
        # 更新状态标签
        self.status_label.configure(
            text=f"已设置为本月：{start.strftime('%Y-%m-%d')} 到 {end.strftime('%Y-%m-%d')}")

    def _on_start_date_selected(self, event=None):
        """當開始日期被選擇時觸發"""
        try:
            selected_date = self.start_date_entry.get_date()
            date_str = selected_date.strftime('%Y-%m-%d')
            self.var_start.set(date_str)
            print(f"開始日期已更新: {date_str}")
        except Exception as e:
            print(f"更新開始日期時發生錯誤: {e}")

    def _on_end_date_selected(self, event=None):
        """當結束日期被選擇時觸發"""
        try:
            selected_date = self.end_date_entry.get_date()
            date_str = selected_date.strftime('%Y-%m-%d')
            self.var_end.set(date_str)
            print(f"結束日期已更新: {date_str}")
        except Exception as e:
            print(f"更新結束日期時發生錯誤: {e}")

    def _on_start_month_changed(self, event=None):
        """當開始日期的月份被改變時觸發"""
        try:
            # 月份改變時，保持當月的第一天
            current_date = self.start_date_entry.get_date()
            new_date = current_date.replace(day=1)
            self.start_date_entry.set_date(new_date)
            date_str = new_date.strftime('%Y-%m-%d')
            self.var_start.set(date_str)
            print(f"開始月份已改變，日期更新為: {date_str}")
        except Exception as e:
            print(f"處理開始月份變化時發生錯誤: {e}")

    def _on_end_month_changed(self, event=None):
        """當結束日期的月份被改變時觸發"""
        try:
            # 月份改變時，保持當月的最後一天
            current_date = self.end_date_entry.get_date()
            # 計算當月最後一天
            if current_date.month == 12:
                next_month = current_date.replace(
    year=current_date.year + 1, month=1, day=1)
            else:
                next_month = current_date.replace(
                    month=current_date.month + 1, day=1)
            last_day = next_month - timedelta(days=1)

            self.end_date_entry.set_date(last_day)
            date_str = last_day.strftime('%Y-%m-%d')
            self.var_end.set(date_str)
            print(f"結束月份已改變，日期更新為: {date_str}")
        except Exception as e:
            print(f"處理結束月份變化時發生錯誤: {e}")

    def _on_start_date_click(self, event=None):
        """當開始日期被點擊時觸發"""
        try:
            print(f"🔍 開始日期被點擊，事件: {event}")
            # 強制更新日期變數
            current_date = self.start_date_entry.get_date()
            date_str = current_date.strftime('%Y-%m-%d')
            self.var_start.set(date_str)
            print(f"開始日期點擊後更新為: {date_str}")
        except Exception as e:
            print(f"處理開始日期點擊時發生錯誤: {e}")

    def _on_start_date_key(self, event=None):
        """當開始日期有鍵盤輸入時觸發"""
        try:
            print(f"🔍 開始日期鍵盤輸入，事件: {event}")
            # 強制更新日期變數
            current_date = self.start_date_entry.get_date()
            date_str = current_date.strftime('%Y-%m-%d')
            self.var_start.set(date_str)
            print(f"開始日期鍵盤輸入後更新為: {date_str}")
        except Exception as e:
            print(f"處理開始日期鍵盤輸入時發生錯誤: {e}")

    def _on_end_date_click(self, event=None):
        """當結束日期被點擊時觸發"""
        try:
            print(f"🔍 結束日期被點擊，事件: {event}")
            # 強制更新日期變數
            current_date = self.end_date_entry.get_date()
            date_str = current_date.strftime('%Y-%m-%d')
            self.var_end.set(date_str)
            print(f"結束日期點擊後更新為: {date_str}")
        except Exception as e:
            print(f"處理結束日期點擊時發生錯誤: {e}")

    def _on_end_date_key(self, event=None):
        """當結束日期有鍵盤輸入時觸發"""
        try:
            print(f"🔍 結束日期鍵盤輸入，事件: {event}")
            # 強制更新日期變數
            current_date = self.end_date_entry.get_date()
            date_str = current_date.strftime('%Y-%m-%d')
            self.var_end.set(date_str)
            print(f"結束日期鍵盤輸入後更新為: {date_str}")
        except Exception as e:
            print(f"處理結束日期鍵盤輸入時發生錯誤: {e}")

    def _on_start_date_focus(self, event=None):
        """當開始日期獲得焦點時觸發"""
        try:
            print(f"🔍 開始日期獲得焦點，事件: {event}")
            # 强制显示下拉日历并立即调整位置
            self.after(50, self._force_show_and_position_start_calendar)
        except Exception as e:
            print(f"處理開始日期焦點時發生錯誤: {e}")

    def _on_end_date_focus(self, event=None):
        """當結束日期獲得焦點時觸發"""
        try:
            print(f"🔍 結束日期獲得焦點，事件: {event}")
            # 强制显示下拉日历并立即调整位置
            self.after(50, self._force_show_and_position_end_calendar)
        except Exception as e:
            print(f"處理結束日期焦點時發生錯誤: {e}")

    def _on_start_date_double_click(self, event=None):
        """當開始日期被雙擊時觸發"""
        try:
            print(f"🔍 開始日期被雙擊，事件: {event}")
            # 强制显示下拉日历
            self.start_date_entry.event_generate('<Button-1>')
            # 延迟一下再尝试显示
            self.after(100, self._force_show_start_calendar)
        except Exception as e:
            print(f"處理開始日期雙擊時發生錯誤: {e}")

    def _on_end_date_double_click(self, event=None):
        """當結束日期被雙擊時觸發"""
        try:
            print(f"🔍 結束日期被雙擊，事件: {event}")
            # 强制显示下拉日历
            self.end_date_entry.event_generate('<Button-1>')
            # 延迟一下再尝试显示
            self.after(100, self._force_show_end_calendar)
        except Exception as e:
            print(f"處理結束日期雙擊時發生錯誤: {e}")

    def _force_show_start_calendar(self):
        """强制显示开始日期日历"""
        try:
            if hasattr(self.start_date_entry, '_top_cal'):
                calendar_window = self.start_date_entry._top_cal
                calendar_window.deiconify()
                calendar_window.lift()

                # 计算正确的日历位置（在输入框下方）
                x = self.start_date_entry.winfo_rootx()
                y = self.start_date_entry.winfo_rooty() + self.start_date_entry.winfo_height()

                # 确保日历不会超出屏幕边界
                screen_width = self.winfo_screenwidth()
                screen_height = self.winfo_screenheight()

                if x + calendar_window.winfo_width() > screen_width:
                    x = screen_width - calendar_window.winfo_width()
                if y + calendar_window.winfo_height() > screen_height:
                    y = self.start_date_entry.winfo_rooty() - calendar_window.winfo_height()

                calendar_window.geometry(f"+{x}+{y}")
                print("✅ 强制显示开始日期日历成功，位置已调整")
        except Exception as e:
            print(f"强制显示开始日期日历失败: {e}")

    def _force_show_end_calendar(self):
        """强制显示结束日期日历"""
        try:
            if hasattr(self.end_date_entry, '_top_cal'):
                calendar_window = self.end_date_entry._top_cal
                calendar_window.deiconify()
                calendar_window.lift()

                # 计算正确的日历位置（在输入框下方）
                x = self.end_date_entry.winfo_rootx()
                y = self.end_date_entry.winfo_rooty() + self.end_date_entry.winfo_height()

                # 确保日历不会超出屏幕边界
                screen_width = self.winfo_screenwidth()
                screen_height = self.winfo_screenheight()

                if x + calendar_window.winfo_width() > screen_width:
                    x = screen_width - calendar_window.winfo_width()
                if y + calendar_window.winfo_height() > screen_height:
                    y = self.end_date_entry.winfo_rooty() - calendar_window.winfo_height()

                calendar_window.geometry(f"+{x}+{y}")
                print("✅ 强制显示结束日期日历成功，位置已调整")
        except Exception as e:
            print(f"强制显示结束日期日历失败: {e}")

    def _on_start_calendar_shown(self, event=None):
        """当开始日期日历显示后触发，确保位置正确"""
        try:
            print(f"🔍 开始日期日历已显示，调整位置")
            self.after(100, self._adjust_start_calendar_position)
        except Exception as e:
            print(f"处理开始日期日历显示事件时发生错误: {e}")

    def _on_end_calendar_shown(self, event=None):
        """当结束日期日历显示后触发，确保位置正确"""
        try:
            print(f"🔍 结束日期日历已显示，调整位置")
            self.after(100, self._adjust_end_calendar_position)
        except Exception as e:
            print(f"处理结束日期日历显示事件时发生错误: {e}")

    def _adjust_start_calendar_position(self):
        """调整开始日期日历位置"""
        try:
            if hasattr(self.start_date_entry, '_top_cal'):
                calendar_window = self.start_date_entry._top_cal
                if calendar_window.winfo_exists():
                    # 计算正确的日历位置（在输入框下方）
                    x = self.start_date_entry.winfo_rootx()
                    y = self.start_date_entry.winfo_rooty() + self.start_date_entry.winfo_height()

                    # 确保日历不会超出屏幕边界
                    screen_width = self.winfo_screenwidth()
                    screen_height = self.winfo_screenheight()

                    if x + calendar_window.winfo_width() > screen_width:
                        x = screen_width - calendar_window.winfo_width()
                    if y + calendar_window.winfo_height() > screen_height:
                        y = self.start_date_entry.winfo_rooty() - calendar_window.winfo_height()

                    calendar_window.geometry(f"+{x}+{y}")
                    print("✅ 开始日期日历位置已调整")
        except Exception as e:
            print(f"调整开始日期日历位置失败: {e}")

    def _adjust_end_calendar_position(self):
        """调整结束日期日历位置"""
        try:
            if hasattr(self.end_date_entry, '_top_cal'):
                calendar_window = self.end_date_entry._top_cal
                if calendar_window.winfo_exists():
                    # 计算正确的日历位置（在输入框下方）
                    x = self.end_date_entry.winfo_rootx()
                    y = self.end_date_entry.winfo_rooty() + self.end_date_entry.winfo_height()

                    # 确保日历不会超出屏幕边界
                    screen_width = self.winfo_screenwidth()
                    screen_height = self.winfo_screenheight()

                    if x + calendar_window.winfo_width() > screen_width:
                        x = screen_width - calendar_window.winfo_width()
                    if y + calendar_window.winfo_height() > screen_height:
                        y = self.end_date_entry.winfo_rooty() - calendar_window.winfo_height()

                    calendar_window.geometry(f"+{x}+{y}")
                    print("✅ 结束日期日历位置已调整")
        except Exception as e:
            print(f"调整结束日期日历位置失败: {e}")

    def _force_show_and_position_start_calendar(self):
        """强制显示并正确定位开始日期日历"""
        try:
            print("🔍 开始强制显示并定位开始日期日历")

            # 首先尝试触发下拉
            self.start_date_entry.event_generate('<Button-1>')

            # 等待一下让日历显示
            self.after(100, self._reposition_start_calendar)

        except Exception as e:
            print(f"强制显示开始日期日历失败: {e}")

    def _force_show_and_position_end_calendar(self):
        """强制显示并正确定位结束日期日历"""
        try:
            print("🔍 开始强制显示并定位结束日期日历")

            # 首先尝试触发下拉
            self.end_date_entry.event_generate('<Button-1>')

            # 等待一下让日历显示
            self.after(100, self._reposition_end_calendar)

        except Exception as e:
            print(f"强制显示结束日期日历失败: {e}")

    def _reposition_start_calendar(self):
        """重新定位开始日期日历"""
        try:
            if hasattr(self.start_date_entry, '_top_cal'):
                calendar_window = self.start_date_entry._top_cal
                if calendar_window.winfo_exists():
                    # 计算正确的日历位置（在输入框下方）
                    x = self.start_date_entry.winfo_rootx()
                    y = self.start_date_entry.winfo_rooty() + self.start_date_entry.winfo_height() + 5

                    # 确保日历不会超出屏幕边界
                    screen_width = self.winfo_screenwidth()
                    screen_height = self.winfo_screenheight()

                    if x + calendar_window.winfo_width() > screen_width:
                        x = screen_width - calendar_window.winfo_width() - 10
                    if y + calendar_window.winfo_height() > screen_height:
                        y = self.start_date_entry.winfo_rooty() - calendar_window.winfo_height() - 5

                    # 强制设置位置
                    calendar_window.geometry(f"+{x}+{y}")
                    calendar_window.lift()
                    calendar_window.focus_force()

                    print(f"✅ 开始日期日历已重新定位到: ({x}, {y})")
                else:
                    print("⚠️ 开始日期日历窗口不存在")
            else:
                print("⚠️ 开始日期DateEntry没有_top_cal属性")
        except Exception as e:
            print(f"重新定位开始日期日历失败: {e}")

    def _reposition_end_calendar(self):
        """重新定位结束日期日历"""
        try:
            if hasattr(self.end_date_entry, '_top_cal'):
                calendar_window = self.end_date_entry._top_cal
                if calendar_window.winfo_exists():
                    # 计算正确的日历位置（在输入框下方）
                    x = self.end_date_entry.winfo_rootx()
                    y = self.end_date_entry.winfo_rooty() + self.end_date_entry.winfo_height() + 5

                    # 确保日历不会超出屏幕边界
                    screen_width = self.winfo_screenwidth()
                    screen_height = self.winfo_screenheight()

                    if x + calendar_window.winfo_width() > screen_width:
                        x = screen_width - calendar_window.winfo_width() - 10
                    if y + calendar_window.winfo_height() > screen_height:
                        y = self.end_date_entry.winfo_rooty() - calendar_window.winfo_height() - 5

                    # 强制设置位置
                    calendar_window.geometry(f"+{x}+{y}")
                    calendar_window.lift()
                    calendar_window.focus_force()

                    print(f"✅ 结束日期日历已重新定位到: ({x}, {y})")
                else:
                    print("⚠️ 结束日期日历窗口不存在")
            else:
                print("⚠️ 结束日期DateEntry没有_top_cal属性")
        except Exception as e:
            print(f"重新定位结束日期日历失败: {e}")

    def _force_update_dates(self):
        """強制更新日期變數"""
        try:
            # 從 DateEntry 讀取當前選擇的日期
            start_date = self.start_date_entry.get_date()
            end_date = self.end_date_entry.get_date()

            # 更新變數
            self.var_start.set(start_date.strftime('%Y-%m-%d'))
            self.var_end.set(end_date.strftime('%Y-%m-%d'))

            print(f"🔄 強制更新日期完成")
            print(f"   開始日期: {self.var_start.get()}")
            print(f"   結束日期: {self.var_end.get()}")

            # 顯示成功消息
            messagebox.showinfo(
    '日期更新', f'日期已強制更新為：\n開始：{
        self.var_start.get()}\n結束：{
            self.var_end.get()}')

        except Exception as e:
            print(f"❌ 強制更新日期時發生錯誤: {e}")
            messagebox.showerror('錯誤', f'強制更新日期時發生錯誤：{e}')

    def _quick_last_month(self):
        now = datetime.now()
        # 計算上個月的開始和結束日期
        if now.month == 1:  # 如果是1月，上個月是去年12月
            last_month_start = now.replace(year=now.year - 1, month=12, day=1)
            last_month_end = now.replace(year=now.year - 1, month=12, day=31)
        else:  # 其他月份
            last_month_start = now.replace(month=now.month - 1, day=1)
            # 計算上個月的最後一天
            if now.month == 3:  # 3月，上個月是2月
                if now.year % 4 == 0 and (
    now.year % 100 != 0 or now.year % 400 == 0):  # 閏年
                    last_month_end = now.replace(month=2, day=29)
                else:
                    last_month_end = now.replace(month=2, day=28)
            elif now.month in [5, 7, 10, 12]:  # 4, 6, 9, 11月有30天
                last_month_end = now.replace(month=now.month - 1, day=30)
            else:  # 其他月份有31天
                last_month_end = now.replace(month=now.month - 1, day=31)

        print(f"🔍 調試：_quick_last_month 計算結果")
        print(f"   計算的開始日期: {last_month_start.strftime('%Y-%m-%d')}")
        print(f"   計算的結束日期: {last_month_end.strftime('%Y-%m-%d')}")

        if hasattr(self.start_date_entry, 'set_date'):
            self.start_date_entry.set_date(last_month_start.date())
            self.end_date_entry.set_date(last_month_end.date())
            print(f"   ✅ 已更新 DateEntry 顯示")
        else:
            print(f"   ❌ DateEntry 沒有 set_date 方法")

        self.var_start.set(last_month_start.strftime('%Y-%m-%d'))
        self.var_end.set(last_month_end.strftime('%Y-%m-%d'))
        # 更新状态标签
        self.status_label.configure(
    text=f"已设置为上月：{
        last_month_start.strftime('%Y-%m-%d')} 到 {
            last_month_end.strftime('%Y-%m-%d')}")
        print(f"   ✅ 已更新變數值")
        print(f"   var_start: {self.var_start.get()}")
        print(f"   var_end: {self.var_end.get()}")

        # 強制更新 DateEntry 的顯示
        try:
            self.start_date_entry.configure(date_pattern='yyyy-mm-dd')
            self.end_date_entry.configure(date_pattern='yyyy-mm-dd')
            print(f"   ✅ 已強制更新 DateEntry 配置")
        except Exception as e:
            print(f"   ❌ 強制更新 DateEntry 配置失敗: {e}")

    def _pick_save_dir(self):
        path = filedialog.askdirectory()
        if path:
            self.var_save.set(path)

    # --- actions ---
    def _collect_params(self, *, need_account=False) -> Optional[dict]:
        # 調試：顯示當前日期變數的值
        start_date_str = self.var_start.get().strip()
        end_date_str = self.var_end.get().strip()
        print(f"🔍 調試：當前日期變數值")
        print(f"   var_start: '{start_date_str}'")
        print(f"   var_end: '{end_date_str}'")

        try:
            start = datetime.strptime(
    start_date_str + ' 00:00', '%Y-%m-%d %H:%M')
            end = datetime.strptime(end_date_str + ' 23:59', '%Y-%m-%d %H:%M')
            print(f"   parsed_start: {start}")
            print(f"   parsed_end: {end}")

            if end < start:
                messagebox.showwarning('日期', '結束日期不可早於開始日期')
                return None
        except Exception as e:
            print(f"❌ 日期解析錯誤: {e}")
            messagebox.showwarning('日期', '日期格式需為 YYYY-MM-DD')
            return None
        save_dir = self.var_save.get().strip()
        if not save_dir:
            messagebox.showwarning('路徑', '請選擇下載儲存資料夾')
            return None

        # 獲取選中的供應商郵箱（可選，不強制要求）
        selected_supplier_emails = self._get_selected_supplier_emails()

        # 組合郵件過濾器：用戶輸入的 + 選中的供應商郵箱（如果有的話）
        user_email_filters = self.var_email.get().strip()
        all_email_filters = []
        if user_email_filters:
            all_email_filters.extend(
                [email.strip() for email in user_email_filters.split(';') if email.strip()])
        if selected_supplier_emails:
            all_email_filters.extend(selected_supplier_emails)

        params = {
            'start_date': start,
            'end_date': end,
            'save_dir': save_dir,
            # 如果沒有過濾器，則為空
            'email_filters': ';'.join(all_email_filters) if all_email_filters else '',
            'content_filters': '',  # 移除 content filter
            'scope_subj': False,    # 移除 content filter
            'scope_body': False,    # 移除 content filter
            'attach_use_defaults': False,  # 不使用預設關鍵字，下載所有附件
            'attach_extra_keywords': '',  # 移除額外關鍵字
            # 使用預設副檔名
            'ext_whitelist': ','.join(MonthEndDownloader.DEFAULT_EXTS),
        }
        if need_account:
            idx = self.downloader._select_outlook_account()
            if idx is None:
                return None
            params['account_idx'] = idx
        return params

    def _open_log(self, title: str):
        popup = ProgressPopup(self, title)
        popup.log(f"{title}\n")
        return popup

    def _run_in_thread(self, fn, *args):
        th = threading.Thread(target=fn, args=args, daemon=True)
        th.start()

    def _on_preview(self):
        params = self._collect_params(need_account=True)
        if not params:
            return

        # 調試：顯示傳遞給 preview 的參數
        print(f"🔍 調試：傳遞給 preview 的參數")
        print(f"   start_date: {params['start_date']}")
        print(f"   end_date: {params['end_date']}")

        # 更新状态标签
        self.status_label.configure(
    text=f"正在预览：{
        params['start_date'].strftime('%Y-%m-%d')} 到 {
            params['end_date'].strftime('%Y-%m-%d')}")

        log_popup = self._open_log('MonthEnd 預覽 / Preview')

        def logger(msg: str):
            log_popup.log(msg)

        def job():
            try:
                mails, atts = self.downloader.preview(params, logger)
                logger(f"\nPreview Done: mails={mails}, attachments={atts}\n")
                # 更新状态标签
                if mails > 0:
                    self.status_label.configure(
    text=f"预览完成：找到 {mails} 封邮件，{atts} 个附件")
                else:
                    self.status_label.configure(text=f"预览完成：未找到符合条件的邮件")
            finally:
                pass
        self._run_in_thread(job)

    def _on_download(self):
        params = self._collect_params(need_account=True)
        if not params:
            return
        os.makedirs(params['save_dir'], exist_ok=True)

        # 更新状态标签
        self.status_label.configure(
    text=f"正在下载：{
        params['start_date'].strftime('%Y-%m-%d')} 到 {
            params['end_date'].strftime('%Y-%m-%d')}")

        log_popup = self._open_log('MonthEnd 下載 / Download')

        def logger(msg: str):
            log_popup.log(msg)

        def job():
            try:
                mails, atts = self.downloader.download(params, logger)
                logger(
    f"\nDownload Done: mails={mails}, attachments saved={atts}\n")
                messagebox.showinfo(
    '完成', f"下載完成\n郵件：{mails}\n附件：{atts}\n存放：{
        params['save_dir']}")
                # 更新状态标签
                if mails > 0:
                    self.status_label.configure(
    text=f"下载完成：{mails} 封邮件，{atts} 个附件已保存")
                else:
                    self.status_label.configure(text=f"下载完成：未找到符合条件的邮件")
            finally:
                pass
        self._run_in_thread(job)

    def _on_download_siahuat(self):
        """下載 Siahuat 訂單 - 從本月1號開始"""
        try:
            # 設置特定的日期範圍：本月1號到今天
            current_date = datetime.now()
            start_of_month = current_date.replace(day=1)
            
            # 自動設置日期
            if hasattr(self, 'start_date_entry') and hasattr(self.start_date_entry, 'set_date'):
                self.start_date_entry.set_date(start_of_month)
            else:
                self.var_start.set(start_of_month.strftime('%Y-%m-%d'))
                
            if hasattr(self, 'end_date_entry') and hasattr(self.end_date_entry, 'set_date'):
                self.end_date_entry.set_date(current_date)
            else:
                self.var_end.set(current_date.strftime('%Y-%m-%d'))
            
            # 收集參數，但使用 Siahuat 特定設置
            params = self._collect_params_siahuat()
            if not params:
                return
                
            os.makedirs(params['save_dir'], exist_ok=True)
            log_popup = self._open_log('Siahuat 訂單下載 / Siahuat Orders Download')
            
            def logger(msg: str):
                log_popup.log(msg)
                
            def job():
                try:
                    logger(f"🏢 開始下載 Siahuat 訂單...")
                    logger(f"📅 日期範圍: {params['start_date']} 到 {params['end_date']}")
                    logger(f"📁 保存位置: {params['save_dir']}")
                    logger("=" * 50)
                    
                    mails, atts = self.downloader.download(params, logger)
                    logger(f"\n✅ Siahuat 訂單下載完成: 郵件={mails}, 附件={atts}\n")
                    messagebox.showinfo('完成', f"Siahuat 訂單下載完成\n郵件：{mails}\n附件：{atts}\n存放：{params['save_dir']}")
                except Exception as e:
                    logger(f"❌ Siahuat 訂單下載失敗: {str(e)}")
                    messagebox.showerror('錯誤', f"Siahuat 訂單下載失敗:\n{str(e)}")
                    
            self._run_in_thread(job)
            
        except Exception as e:
            messagebox.showerror('錯誤', f"設置 Siahuat 下載失敗:\n{str(e)}")

    def _collect_params_siahuat(self):
        """收集 Siahuat 訂單下載的特定參數"""
        try:
            # 使用當前設置的日期
            start_date_str = self.var_start.get().strip()
            end_date_str = self.var_end.get().strip()
            
            if not start_date_str or not end_date_str:
                messagebox.showerror('錯誤', '請設置有效的日期範圍')
                return None
                
            # 解析日期
            start_date = datetime.strptime(start_date_str, '%Y-%m-%d')
            end_date = datetime.strptime(end_date_str, '%Y-%m-%d').replace(hour=23, minute=59, second=59)
            
            # 設置保存目錄 - 在原目錄下創建 Siahuat 子文件夾
            base_save_dir = self.var_save.get().strip()
            siahuat_save_dir = os.path.join(base_save_dir, 'Siahuat_Orders')
            
            # Siahuat 特定的參數
            params = {
                'start_date': start_date,
                'end_date': end_date,
                'save_dir': siahuat_save_dir,
                'outlook_folder': 'Inbox',  # 預設使用收件匣
                'email_filters': ['siahuat'],  # 專門篩選 Siahuat 相關郵件
                'content_filters': ['order', 'siahuat', '訂單'],  # 內容篩選關鍵詞
                'content_scope_subj': True,
                'content_scope_body': True,
                'account_idx': self.downloader._select_outlook_account()
            }
            
            if params['account_idx'] is None:
                messagebox.showerror('錯誤', '無法選擇 Outlook 帳戶')
                return None
                
            return params
            
        except ValueError as e:
            messagebox.showerror('錯誤', f'日期格式錯誤: {str(e)}')
            return None
        except Exception as e:
            messagebox.showerror('錯誤', f'參數收集失敗: {str(e)}')
            return None

    def _test_outlook(self):
        """测试Outlook连接和邮件数量"""
        try:
            # 更新状态标签
            self.status_label.configure(text="正在测试Outlook连接...")

            # 选择Outlook账户
            account_idx = self.downloader._select_outlook_account()
            if account_idx is None:
                self.status_label.configure(text="测试失败：无法选择Outlook账户")
                return

            # 创建测试参数 - 使用更大的日期范围
            now = datetime.now()
            test_start = now - timedelta(days=30)  # 测试最近30天
            test_end = now

            test_params = {
                'start_date': test_start,
                'end_date': test_end,
                # 添加save_dir
                'save_dir': os.path.join(os.path.expanduser('~'), 'Downloads', 'MonthEnd'),
                'email_filters': '',  # 不过滤发件人
                'content_filters': '',
                'scope_subj': False,
                'scope_body': False,
                'attach_use_defaults': True,
                'attach_extra_keywords': '',
                'ext_whitelist': ','.join(MonthEndDownloader.DEFAULT_EXTS),
                'account_idx': account_idx
            }

            log_popup = self._open_log(
                'Outlook 连接测试 / Outlook Connection Test')

            def logger(msg: str):
                log_popup.log(msg)

            def test_job():
                try:
                    logger("🔍 开始测试Outlook连接...")
                    logger(
                        f"📅 测试日期范围：{test_start.strftime('%Y-%m-%d')} 到 {test_end.strftime('%Y-%m-%d')}")
                    logger("📧 不过滤发件人，检查所有邮件...")

                    # 使用预览模式测试
                    mails, atts = self.downloader.preview(test_params, logger)

                    if mails > 0:
                        logger(f"\n✅ 测试成功！找到 {mails} 封邮件，{atts} 个附件")
                        self.status_label.configure(
                            text=f"测试成功：找到 {mails} 封邮件")
                    else:
                        logger(f"\n⚠️ 测试完成，但未找到邮件")
                        logger("可能的原因：")
                        logger("1. 该时间段内确实没有邮件")
                        logger("2. Outlook权限问题")
                        logger("3. 邮件存储在其他位置")
                        self.status_label.configure(text="测试完成：未找到邮件")

                except Exception as e:
                    logger(f"\n❌ 测试失败：{str(e)}")
                    self.status_label.configure(text=f"测试失败：{str(e)}")

            self._run_in_thread(test_job)

        except Exception as e:
            messagebox.showerror("测试失败", f"测试Outlook时发生错误：{str(e)}")
            self.status_label.configure(text=f"测试失败：{str(e)}")

    @staticmethod
    def get_smtp_sender(msg):
        try:
            sender = msg.Sender
            if sender is not None:
                if sender.AddressEntryUserType == 0:  # olExchangeUserAddressEntry
                    ex_user = sender.GetExchangeUser()
                    if ex_user is not None:
                        return ex_user.PrimarySmtpAddress.lower()
                elif sender.AddressEntryUserType == 5:  # olSmtpAddressEntry
                    return sender.Address.lower()
            return str(getattr(msg, 'SenderEmailAddress', '')).lower()
        except Exception as e:
            print(f"[DEBUG] get_smtp_sender: Exception: {e}")
            return str(getattr(msg, 'SenderEmailAddress', '')).lower()

    def _pick_config_file(self):
        """選擇配置文件"""
        file_path = filedialog.askopenfilename(
            title="選擇配置文件 / Select Config File",
            filetypes=[("Excel files", "*.xlsx *.xls"), ("All files", "*.*")]
        )
        if file_path:
            self.var_config.set(file_path)
            self.config_path = file_path
            # 自動載入供應商
            self._load_suppliers()

    def _load_suppliers(self):
        """從配置文件載入供應商列表"""
        config_path = self.var_config.get().strip()
        if not config_path:
            messagebox.showwarning("警告", "請先選擇配置文件")
            return

        if not os.path.exists(config_path):
            messagebox.showerror("錯誤", "配置文件不存在")
            return

        try:
            # 清空現有的供應商列表
            self.suppliers = []

            # 讀取 Excel 文件
            wb = load_workbook(config_path, data_only=True)

            # 尋找 monthend sheet
            monthend_sheet = None
            for sheet_name in wb.sheetnames:
                if 'monthend' in sheet_name.lower():
                    monthend_sheet = wb[sheet_name]
                    break

            if not monthend_sheet:
                messagebox.showwarning("警告", "在配置文件中未找到 monthend 工作表")
                return

            # 讀取供應商信息 (Column A: 供應商名稱, Column B: 郵箱)
            for row in monthend_sheet.iter_rows(min_row=2, values_only=True):
                if row and row[0] and row[1]:  # 確保名稱和郵箱都存在
                    supplier_name = str(row[0]).strip()
                    supplier_email = str(row[1]).strip()

                    if supplier_name and supplier_email:
                        supplier_data = {
                            'name': supplier_name,
                            'email': supplier_email
                        }
                        self.suppliers.append(supplier_data)

            if self.suppliers:
                messagebox.showinfo("成功", f"已載入 {len(self.suppliers)} 個供應商")
                # 更新供应商数量标签
                self.supplier_count_label.configure(
                    text=f"已載入 {len(self.suppliers)} 個供應商")
            else:
                messagebox.showwarning("警告", "未找到有效的供應商數據")
                self.supplier_count_label.configure(text="未找到供應商數據")

        except Exception as e:
            messagebox.showerror("錯誤", f"載入供應商時發生錯誤：{str(e)}")
            print(f"載入供應商錯誤：{e}")

    # 这些方法现在在独立窗口中处理
    def _select_all_suppliers(self):
        """全選所有供應商 - 已移至獨立窗口"""
        pass

    def _deselect_all_suppliers(self):
        """取消全選所有供應商 - 已移至獨立窗口"""
        pass

    def _get_selected_supplier_emails(self):
        """獲取選中的供應商郵箱列表"""
        if hasattr(self, 'selected_suppliers') and self.selected_suppliers:
            return [supplier['email'] for supplier in self.selected_suppliers]
        return []

# ========== 營運用品訂單處理 ==========

class OperationSuppliesOrder:
    """營運用品訂單處理 - 全新設計版本"""

    def __init__(self):
        """初始化訂單處理器"""
        self.suppliers = ['Freshening', 'Legacy', 'Unikleen']
        self.outlet_data = {}  # 从Config文件读取的门市信息
        self.supplier_templates = {}  # 厂商模板数据

        # 厂商产品范围（根据实际模板调整）- 根據實際數據調整
        self.supplier_ranges = {
            'Freshening': {'start_row': 5, 'end_row': 100},
            'Legacy': {'start_row': 5, 'end_row': 100},
            'Unikleen': {'start_row': 5, 'end_row': 100}
        }

    def process_orders(self, supplies_file, config_file, output_folder, log_callback=None, selected_supplier=None):
        """处理订单主函数"""
        try:
            if log_callback:
                if selected_supplier:
                    log_callback(f"🚀 開始處理 {selected_supplier} 營運用品訂單...")
                else:
                    log_callback("🚀 開始處理營運用品訂單...")
                log_callback(f"📁 供應商文件: {os.path.basename(supplies_file)}")
                log_callback(f"📁 配置文件: {os.path.basename(config_file)}")
                log_callback(f"📁 輸出資料夾: {output_folder}")

            # 确保输出文件夹存在
            if not os.path.exists(output_folder):
                os.makedirs(output_folder)

            # 1. 读取Config文件的门市信息
            self._read_outlet_config(config_file, log_callback)

            # 2. 读取Operation Supplies文件兩次：一次讀取數據，一次讀取模板
            # 用於讀取門市數據的工作簿（公式計算結果）
            wb_data = openpyxl.load_workbook(supplies_file, data_only=True)
            # 用於複製模板的工作簿（保留格式和公式）
            wb_templates = openpyxl.load_workbook(supplies_file, data_only=False)

            # 3. 读取厂商模板
            self._read_supplier_templates(wb_templates, log_callback)

            # 4. 生成厂商订单文件
            all_results = self._generate_supplier_orders(wb_data, wb_templates, output_folder, log_callback, selected_supplier)

            wb_data.close()
            wb_templates.close()

            # 5. 顯示 treeview 結果
            if all_results:
                self._show_operation_supplies_results(all_results)

            if log_callback:
                log_callback("✅ 營運用品訂單處理完成！")

            return True

        except Exception as e:
            if log_callback:
                log_callback(f"❌ 處理失敗: {str(e)}")
            return False

    def _read_outlet_config(self, config_file, log_callback=None):
        """读取Config文件的OUTLET工作表"""
        try:
            if log_callback:
                log_callback("📖 讀取門市配置信息...")

            # 读取OUTLET工作表
            df = pd.read_excel(config_file, sheet_name="OUTLET")

            # 处理门市数据
            print(f"\n📖 开始读取门市配置...")
            print(f"📋 Config文件列数: {len(df.columns)}")
            print(f"📋 Config文件行数: {len(df)}")
            
            for idx, row in df.iterrows():
                short_name = str(row.iloc[0]).strip()  # Column A: Short Name (如 NEX, WS, HLM)
                outlet_name = str(row.iloc[1]).strip()  # Column B: Outlet Full Name (如 Sushi Express NEX Serangoon)
                address = str(row.iloc[3]).strip()      # Column D: Address
                delivery_date = str(row.iloc[5]).strip() # Column F: Freshening Delivery Date
                
                print(f"行 {idx+1}: 简称='{short_name}', 全名='{outlet_name}', 地址='{address}', 送货日期='{delivery_date}'")

                if short_name and short_name != 'nan' and outlet_name and outlet_name != 'nan':
                    # 主要使用简称作为键，因为工作表名称通常是简称
                    self.outlet_data[short_name] = {
                        'outlet_name': outlet_name,  # 全名用于显示
                        'address': address,
                        'delivery_date': delivery_date
                    }
                    print(f"✅ 保存门市配置: '{short_name}' -> '{outlet_name}'")
                    
                    # 同时保存全名到简称的映射，以防万一
                    self.outlet_data[outlet_name] = {
                        'outlet_name': outlet_name,
                        'address': address,
                        'delivery_date': delivery_date
                    }
                    print(f"✅ 保存门市配置: '{outlet_name}' -> '{outlet_name}'")
                else:
                    print(f"⚠️ 跳过无效行: 简称='{short_name}', 全名='{outlet_name}'")

            if log_callback:
                log_callback(f"✅ 讀取到 {len(self.outlet_data)} 個門市配置")

        except Exception as e:
            if log_callback:
                log_callback(f"❌ 讀取門市配置失敗: {str(e)}")
            raise

    def _read_supplier_templates(self, workbook, log_callback=None):
        """读取厂商模板"""
        if log_callback:
            log_callback("📖 讀取廠商模板...")

        for supplier in self.suppliers:
            if supplier in workbook.sheetnames:
                if log_callback:
                    log_callback(f"讀取 {supplier} 模板")

                # 保存模板工作表
                self.supplier_templates[supplier] = workbook[supplier]
            else:
                if log_callback:
                    log_callback(f"⚠️ 找不到 {supplier} 模板")

    def _generate_supplier_orders(self, data_workbook, template_workbook, output_folder, log_callback=None, selected_supplier=None):
        """生成厂商订单文件"""
        if log_callback:
            if selected_supplier:
                log_callback(f"📋 生成 {selected_supplier} 廠商訂單文件...")
        else:
                log_callback("📋 生成所有廠商訂單文件...")

        # 获取所有门市工作表
        supplier_sheets = set(self.suppliers)
        outlet_sheets = [name for name in data_workbook.sheetnames if name not in supplier_sheets]

        if log_callback:
            log_callback(f"找到 {len(outlet_sheets)} 個門市工作表")

        # 收集所有數據用於 treeview
        all_results = {}

        # 确定要处理的供应商列表
        if selected_supplier:
            suppliers_to_process = [selected_supplier] if selected_supplier in self.suppliers else []
            if log_callback:
                log_callback(f"🎯 只处理 {selected_supplier} 供应商")
        else:
            suppliers_to_process = self.suppliers
            if log_callback:
                log_callback("🎯 处理所有供应商")

        # 为每个厂商生成订单文件
        for supplier in suppliers_to_process:
            if supplier not in self.supplier_templates:
                if log_callback:
                    log_callback(f"⚠️ 跳過 {supplier}：找不到模板")
                continue

            if log_callback:
                log_callback(f"生成 {supplier} 訂單文件...")

            # 创建输出文件路径 - 使用下週的日期
            current_date = datetime.now()
            next_week = current_date + timedelta(days=7)
            filename = f"{supplier}_Order_{next_week.strftime('%Y_%m_%d')}.xlsx"
            output_path = os.path.join(output_folder, filename)

            # 创建新的工作簿
            wb_new = openpyxl.Workbook()

            outlet_count = 0
            first_sheet_created = False
            supplier_results = {}

            # 为每个门市创建工作表
            for outlet_sheet_name in outlet_sheets:
                if log_callback:
                    log_callback(f"  處理門市: {outlet_sheet_name}")

                # 读取门市订单数据（使用數據工作簿）
                outlet_orders, found_products, valid_orders = self._read_outlet_orders(data_workbook[outlet_sheet_name], supplier)

                if outlet_orders:  # 只为有订单的门市创建工作表
                    outlet_count += 1

                    # 复制厂商模板（使用模板工作簿）
                    template_ws = self.supplier_templates[supplier]

                    if not first_sheet_created:
                        # 使用默认工作表作为第一个工作表
                        new_ws = wb_new.active
                        new_ws.title = outlet_sheet_name
                        first_sheet_created = True
                    else:
                        new_ws = wb_new.create_sheet(title=outlet_sheet_name)

                    # 完整复制模板（包括格式）
                    self._copy_template_fully(template_ws, new_ws)

                    # 更新门市信息（包括日期）
                    self._update_outlet_info(new_ws, outlet_sheet_name, supplier, log_callback)

                    # 移除重复的日期更新，因为_update_outlet_info已经处理了日期
                    # self._update_dates(new_ws, log_callback)

                    # 填入订单数量
                    filled_count = self._fill_orders(new_ws, outlet_orders, supplier, outlet_sheet_name, log_callback)

                    # 收集結果數據
                    supplier_results[outlet_sheet_name] = {
                        'found_products': found_products,
                        'valid_orders': valid_orders,
                        'filled_count': filled_count,
                        'products': list(outlet_orders.keys()),
                        'product_quantities': outlet_orders  # 添加产品数量信息
                    }

            # 如果没有创建任何工作表，创建一个空的默认工作表
            if not first_sheet_created:
                wb_new.active.title = "No Orders"

            # 保存工作簿
            wb_new.save(output_path)

            all_results[supplier] = {
                'outlet_count': outlet_count,
                'outlets': supplier_results
            }

            if log_callback:
                log_callback(f"✅ {supplier} 訂單文件生成完成，包含 {outlet_count} 個門市")

        return all_results

    def _read_outlet_orders(self, outlet_ws, supplier):
        """读取单个门市的特定厂商订单数据 - 改進版本"""
        orders = {}

        if supplier not in self.supplier_ranges:
            return orders, 0, 0

        range_info = self.supplier_ranges[supplier]
        start_row = range_info['start_row']
        end_row = range_info['end_row']

        found_products = 0
        valid_orders = 0

        # 遍歷更大的範圍來找到所有產品
        for row in range(start_row, min(end_row + 1, outlet_ws.max_row + 1)):
            # Column A: 产品名称 (Description)
            product_cell = outlet_ws.cell(row=row, column=1)
            
            # 只從L列讀取數量
            quantity_cell = outlet_ws.cell(row=row, column=12)  # L列: Final Order QTY

            # 如果有產品名稱
            if product_cell.value and str(product_cell.value).strip():
                product_name = str(product_cell.value).strip()
                
                # 跳過標題行
                if product_name.lower() in ['description', 'outlet', 'product name', '品名']:
                    continue
                    
                found_products += 1
                final_quantity = 0

                # 只從L列讀取數量
                if quantity_cell.value is not None:
                    try:
                        # 嘗試直接讀取數值
                        quantity = float(quantity_cell.value)
                        if quantity > 0:
                            final_quantity = quantity
                    except (ValueError, TypeError):
                        # 如果是公式或文字，跳過
                        pass

                # 如果找到有效數量，添加到訂單
                if final_quantity > 0:
                    orders[product_name] = final_quantity
                    valid_orders += 1
                    print(f"✅ 產品: {product_name}, 數量: {final_quantity} (從L列)")
                elif product_name:  # 即使沒有數量也記錄產品（用於調試）
                    print(f"⚠️ 產品: {product_name}, L列數量為0或無效")

        return orders, found_products, valid_orders

    def _copy_template_fully(self, source_ws, target_ws):
        """完整复制模板，包括格式、公式等"""
        from copy import copy

        # 复制所有单元格内容、格式和公式
        for row in source_ws.iter_rows():
            for cell in row:
                target_cell = target_ws.cell(row=cell.row, column=cell.column)

                # 复制值或公式
                if cell.data_type == 'f':  # 公式
                    if hasattr(cell, 'formula') and cell.formula:
                        target_cell.value = f"={cell.formula}"
                    elif hasattr(cell, '_formula') and cell._formula:
                        target_cell.value = f"={cell._formula}"
                    else:
                        target_cell.value = cell.value
                else:
                    target_cell.value = cell.value

                # 复制格式
                if cell.has_style:
                    target_cell.font = copy(cell.font)
                    target_cell.border = copy(cell.border)
                    target_cell.fill = copy(cell.fill)
                    target_cell.number_format = cell.number_format
                    target_cell.protection = copy(cell.protection)
                    target_cell.alignment = copy(cell.alignment)

        # 复制行高和列宽
        for row_num in range(1, source_ws.max_row + 1):
            if source_ws.row_dimensions[row_num].height:
                target_ws.row_dimensions[row_num].height = source_ws.row_dimensions[row_num].height

        for col_letter in source_ws.column_dimensions:
            if source_ws.column_dimensions[col_letter].width:
                target_ws.column_dimensions[col_letter].width = source_ws.column_dimensions[col_letter].width

        # 复制合并单元格
        for merged_range in source_ws.merged_cells.ranges:
            target_ws.merge_cells(str(merged_range))

        # 复制条件格式
        if hasattr(source_ws, 'conditional_formatting') and hasattr(source_ws.conditional_formatting, '_cf_rules'):
            for sqref, rules in source_ws.conditional_formatting._cf_rules.items():
                if isinstance(rules, list):
                    for rule in rules:
                        target_ws.conditional_formatting.add(sqref, rule)
                else:
                    target_ws.conditional_formatting.add(sqref, rules)

        # 复制冻结窗格 - 修正為正確的位置
        if source_ws.freeze_panes:
            # 對於 Freshening，固定在第11行
            if source_ws.title == 'Freshening':
                target_ws.freeze_panes = 'A11'
            else:
                target_ws.freeze_panes = source_ws.freeze_panes

    def _update_outlet_info(self, worksheet, outlet_sheet_name, supplier, log_callback=None):
        """更新门市信息"""
        try:
            # 添加终端输出
            print(f"\n🔍 查找門市配置: {outlet_sheet_name}")
            print(f"📋 可用門市配置键: {list(self.outlet_data.keys())}")
            
            if log_callback:
                log_callback(f"    🔍 查找門市配置: {outlet_sheet_name}")
                log_callback(f"    📋 可用門市: {list(self.outlet_data.keys())}")
            
            if outlet_sheet_name in self.outlet_data:
                outlet_info = self.outlet_data[outlet_sheet_name]
                print(f"✅ 找到門市配置: {outlet_sheet_name}")
                print(f"   门市名称: {outlet_info['outlet_name']}")
                print(f"   地址: {outlet_info['address']}")
                print(f"   送货日期: {outlet_info['delivery_date']}")

                # 根據供應商設置不同的標題
                if supplier == 'Freshening':
                    worksheet.cell(row=1, column=1, value="FRESHENING INDUSTRIES PTE LTD")
                    print(f"📝 设置公司标题: 行1列1 = FRESHENING INDUSTRIES PTE LTD")
                elif supplier == 'Legacy':
                    worksheet.cell(row=1, column=1, value="LEGACY OFFICE")
                    print(f"📝 设置公司标题: 行1列1 = LEGACY OFFICE")
                elif supplier == 'Unikleen':
                    worksheet.cell(row=1, column=1, value="UNIKLEEN INDUSTRIES PTE LTD")
                    print(f"📝 设置公司标题: 行1列1 = UNIKLEEN INDUSTRIES PTE LTD")

                # 更新门市名称（F5位置）
                worksheet.cell(row=5, column=6).value = outlet_info['outlet_name']
                print(f"📝 设置门市名称: 行5列6 = {outlet_info['outlet_name']}")

                # 更新门市地址（F6位置）
                worksheet.cell(row=6, column=6).value = outlet_info['address']
                print(f"📝 设置门市地址: 行6列6 = {outlet_info['address']}")

                # F7 保持空白 - 不填任何內容

                # F8 只對 Freshening 填入送貨日期
                if supplier == 'Freshening':
                    # 計算下週的實際送貨日期
                    delivery_day = outlet_info['delivery_date'].strip().upper()
                    actual_date = self._get_next_delivery_date(delivery_day)
                    worksheet.cell(row=8, column=6).value = actual_date
                    print(f"📝 设置送货日期: 行8列6 = {actual_date} (原始: {delivery_day})")

                # 修正日期行位置
                if supplier == 'Freshening':
                    date_row = 11  # Freshening 的日期在第12行
                elif supplier == 'Legacy':
                    date_row = 11  # Legacy 的日期在第12行
                elif supplier == 'Unikleen':
                    date_row = 11  # Unikleen 的日期在第12行
                else:
                    date_row = 11  # 默认第12行

                # 更新日期行
                print(f"📅 正在更新日期行，供应商: {supplier}")
                
                if supplier == 'Legacy':
                    # Legacy 模板：不修改日期，保持原始日期，跟Unikleen一樣
                    print(f"📅 Legacy 模板：跳過日期更新，保持原始日期")
                    # 不進行任何日期修改
                        
                elif supplier == 'Unikleen':
                    # Unikleen 模板：不修改日期，保持原始日期
                    print(f"📅 Unikleen 模板：跳過日期更新，保持原始日期")
                    # 不進行任何日期修改
                        
                else:
                    # Freshening 和其他供应商：只更新一个日期行
                    print(f"📅 更新日期行 {date_row}")
                    days = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']
                    for i, day in enumerate(days):
                        col = 6 + i  # F列开始
                        date_value = self._get_next_week_date(i)
                        worksheet.cell(row=date_row, column=col).value = date_value
                        print(f"   {day}: 列 {chr(64 + col)} (行 {date_row}) = {date_value}")
                        print(f"📝 设置日期: 行{date_row}列{col} = {date_value}")

                if log_callback:
                    log_callback(f"    ✅ 更新門市信息: {outlet_sheet_name}")
            else:
                print(f"❌ 找不到門市配置: {outlet_sheet_name}")
                # 尝试模糊匹配
                for key in self.outlet_data.keys():
                    if outlet_sheet_name.lower() in key.lower() or key.lower() in outlet_sheet_name.lower():
                        print(f"   可能的匹配: {key}")
                
                if log_callback:
                    log_callback(f"    ⚠️ 找不到門市配置: {outlet_sheet_name}")

        except Exception as e:
            if log_callback:
                log_callback(f"    ❌ 更新門市信息失敗: {str(e)}")

    def _get_next_week_date(self, day_offset):
        """獲取下週的日期"""
        today = datetime.now()
        # 计算下周一：如果今天是周一，则下周一就是今天+7天；否则计算到下周一的距离
        days_until_monday = (7 - today.weekday()) % 7
        if days_until_monday == 0:  # 今天是周一
            next_monday = today + timedelta(days=7)
        else:
            next_monday = today + timedelta(days=days_until_monday)
        
        target_date = next_monday + timedelta(days=day_offset)
        
        # 添加详细的终端输出
        print(f"📅 日期计算: 今天={today.strftime('%Y-%m-%d')}, 下周一={next_monday.strftime('%Y-%m-%d')}, 偏移={day_offset}天, 目标日期={target_date}")
        
        if hasattr(self, 'log_callback') and self.log_callback:
            self.log_callback(f"    📅 计算日期: 今天={today.strftime('%Y-%m-%d')}, 下周一={next_monday.strftime('%Y-%m-%d')}, 目标日期={target_date}")
        return target_date.strftime('%d-%b')  # 例如: "01-Sep"

    def _get_next_delivery_date(self, delivery_day):
        """根據送貨日期計算下週的實際日期"""
        try:
            # 計算下週的日期
            today = datetime.now()
            # 计算下周一：如果今天是周一，则下周一就是今天+7天；否则计算到下周一的距离
            days_until_monday = (7 - today.weekday()) % 7
            if days_until_monday == 0:  # 今天是周一
                next_monday = today + timedelta(days=7)
            else:
                next_monday = today + timedelta(days=days_until_monday)
            
            # 日期映射
            day_mapping = {
                'MON': 0, 'MONDAY': 0,
                'TUE': 1, 'TUESDAY': 1,
                'WED': 2, 'WEDNESDAY': 2,
                'THU': 3, 'THURSDAY': 3,
                'FRI': 4, 'FRIDAY': 4,
                'SAT': 5, 'SATURDAY': 5,
                'SUN': 6, 'SUNDAY': 6
            }
            
            # 處理多個送貨日期，取第一個
            for day_str in delivery_day.split('/'):
                day_str = day_str.strip().upper()
                if day_str in day_mapping:
                    days_to_add = day_mapping[day_str]
                    delivery_date = next_monday + timedelta(days=days_to_add)
                    return delivery_date.strftime('%d-%b')  # 例如: "01-Sep"
            
            # 默認下週一
            return next_monday.strftime('%d-%b')
                
        except Exception as e:
            # 如果出錯，返回下週一
            today = datetime.now()
            days_until_monday = (7 - today.weekday()) % 7
            if days_until_monday == 0:  # 今天是周一
                next_monday = today + timedelta(days=7)
            else:
                next_monday = today + timedelta(days=days_until_monday)
            return next_monday.strftime('%d-%b')

    def _update_dates(self, worksheet, log_callback=None):
        """更新日期为下一周 - 只更新第10行的日期 (已废弃，不再使用)"""
        # 此方法已被废弃，日期更新现在在 _update_outlet_info 中处理
        # 保留此方法以避免破坏其他可能调用它的代码
        pass

    def _fill_orders(self, worksheet, orders, supplier, outlet_sheet_name, log_callback=None):
        """填入订单数量 - 简化版本"""
        if not orders:
            return 0

        # 根据送货日期获取目标列
        print(f"\n🎯 开始计算目标列...")
        print(f"🎯 门市: {outlet_sheet_name}, 供应商: {supplier}")
        target_column = self._get_target_column(outlet_sheet_name, supplier)
        print(f"🎯 最终目标列: {chr(64 + target_column)} (列 {target_column})")

        if log_callback:
            col_letter = chr(64 + target_column)
            log_callback(f"    📝 填入到 Column {col_letter}")

        # 智能产品匹配逻辑 - 先建立模板产品映射，再精确匹配
        print(f"🔍 开始填写订单，使用智能匹配逻辑")
        
        # 填入订单数量
        filled_count = 0
        if log_callback:
            log_callback(f"    🔍 开始匹配产品，使用智能匹配逻辑")
        
        # 获取所有订单产品
        order_products = list(orders.keys())
        print(f"📋 订单产品列表: {order_products}")
        
        # 第一步：建立模板产品行映射（从第12行开始，限制扫描范围）
        template_products = {}
        print(f"\n🔍 开始扫描模板产品行...")
        
        # 根据供应商设置不同的扫描策略
        if supplier == 'Legacy':
            # Legacy 模板：只掃描第一個週期的產品（行11-13），跟Unikleen一樣
            start_row = 11
            max_scan_row = min(13, worksheet.max_row)
            print(f"🔍 Legacy 供应商: 扫描范围: 行{start_row}到行{max_scan_row}")
            print(f"🔍 Legacy 模板结构: 只掃描第一個週期的產品（行11-13）")
        elif supplier == 'Unikleen':
            # Unikleen 模板：产品在行11, 37等（每周表格的第1行产品）
            start_row = 11
            max_scan_row = min(50, worksheet.max_row)
            print(f"🔍 Unikleen 供应商: 扫描范围: 行{start_row}到行{max_scan_row}")
            print(f"🔍 Unikleen 模板结构: 产品在行11, 37等（每周表格的第1行产品）")
        else:
            # Freshening 和其他供应商：从第12行开始
            start_row = 12
            max_scan_row = min(50, worksheet.max_row)
            print(f"🔍 {supplier} 供应商: 扫描范围: 行{start_row}到行{max_scan_row}")
        
        # 显示所有扫描到的行内容（用于调试）
        print(f"🔍 扫描到的所有行内容:")
        for row in range(start_row, max_scan_row + 1):
            product_cell = worksheet.cell(row=row, column=2)  # Column B
            if product_cell.value:
                product_name = str(product_cell.value).strip()
                print(f"   行{row}: '{product_name}'")
        
        print(f"🔍 开始处理产品行...")
        for row in range(start_row, max_scan_row + 1):
            product_cell = worksheet.cell(row=row, column=2)  # Column B
            if product_cell.value:
                product_name = str(product_cell.value).strip()
                
                # 跳过标题行和公司信息
                skip_words = ['description', 'outlet', 'address', 'order', 'delivery', 'freshening', 'industries', 'pte', 'ltd', 'singapore', 'tel', 'fax', 'requesitioner', 'admin', 'moq', 'pkt']
                skip_reason = None
                for skip_word in skip_words:
                    if skip_word in product_name.lower():
                        skip_reason = skip_word
                        break

                if skip_reason:
                    print(f"⏭️ 跳过行{row}: {product_name} (原因: 包含 '{skip_reason}')")
                    continue
                
                # 检查是否到达产品列表的结束（通常是空行或特殊标记）
                if not product_name or product_name.lower() in ['remark', '備注', 'note', 'total', 'sum', 'subtotal']:
                    print(f"⏭️ 到达产品列表结束，停止扫描: 行{row}")
                    break
                
                # 直接使用原始產品名稱進行匹配，不進行過度清理
                if len(product_name) > 2:  # 确保是产品行
                    # 保存原始名称的映射
                    template_products[product_name.lower()] = row
                    print(f"✅ 模板产品行{row}: '{product_name}' -> 行{row}")
                    
                    # 同時保存去除多餘空格的版本
                    clean_name = ' '.join(product_name.split())
                    if clean_name.lower() != product_name.lower():
                        template_products[clean_name.lower()] = row
                        print(f"✅ 清理版本行{row}: '{clean_name}' -> 行{row}")
                    
                    # 添加更多调试信息
                    print(f"🔍 行{row}详细信息:")
                    print(f"   Column B (产品名): '{product_name}'")
                    print(f"   Column C (中文名): '{worksheet.cell(row=row, column=3).value}'")
                    print(f"   Column D (价格): '{worksheet.cell(row=row, column=4).value}'")
                    print(f"   Column E (单位): '{worksheet.cell(row=row, column=5).value}'")
        
        print(f"📋 模板产品映射: {len(template_products)} 个产品")
        for name, row in template_products.items():
            print(f"   {name} -> 行{row}")
        
        # 第二步：为每个订单产品找到精确匹配
        for product, quantity in orders.items():
            product_clean = product.lower().strip()
            print(f"🔍 匹配产品: '{product}' (清理后: '{product_clean}')")

            # 直接查找精确匹配
            matched_row = None
            
            # 首先尝试精确匹配
            if product_clean in template_products:
                matched_row = template_products[product_clean]
                print(f"✅ 精确匹配: '{product}' -> 行{matched_row}")
            else:
                # 如果没有精确匹配，尝试包含匹配
                for template_name, row in template_products.items():
                    if product_clean in template_name or template_name in product_clean:
                        matched_row = row
                        print(f"✅ 包含匹配: '{product}' -> '{template_name}' (行{row})")
                        break

            if matched_row:
                if log_callback:
                    log_callback(f"      ✅ 匹配成功: '{product}' -> 行{matched_row}")
                
                try:
                    # 读取产品价格信息
                    price_cell = worksheet.cell(row=matched_row, column=3)  # Column C (PRICE)
                    uom_cell = worksheet.cell(row=matched_row, column=4)   # Column D (UOM)
                    price = price_cell.value if price_cell.value else "N/A"
                    uom = uom_cell.value if uom_cell.value else "N/A"
                    
                    # 檢查是否為合併單元格
                    target_cell = worksheet.cell(row=matched_row, column=target_column)
                    
                    # 添加详细的位置输出
                    col_letter = chr(64 + target_column)
                    print(f"📝 准备填写数据: 产品='{product}', 数量={quantity}, 价格={price}, 单位={uom}")
                    print(f"📝 目标位置: 行{matched_row}列{target_column} ({col_letter}{matched_row})")
                    
                    if hasattr(target_cell, '_value'):
                        # 這是一個合併單元格，需要找到實際的單元格
                        for merged_range in worksheet.merged_cells.ranges:
                            if target_cell.coordinate in merged_range:
                                # 找到合併範圍的左上角單元格
                                top_left = merged_range.start_cell
                                worksheet.cell(row=top_left.row, column=top_left.column).value = quantity
                                print(f"📝 合并单元格，实际填写位置: 行{top_left.row}列{top_left.column} ({chr(64 + top_left.column)}{top_left.row})")
                                break
                        else:
                            # 不是合併單元格，直接設置
                            target_cell.value = quantity
                            print(f"📝 直接填写到: 行{matched_row}列{target_column} ({col_letter}{matched_row})")
                    else:
                        target_cell.value = quantity
                        print(f"📝 直接填写到: 行{matched_row}列{target_column} ({col_letter}{matched_row})")
                    
                    filled_count += 1
                    if log_callback:
                        log_callback(f"      ✅ {product}: {quantity} (价格: {price}, 单位: {uom})")

                except Exception as e:
                    print(f"❌ 填写失败: {product}, 错误: {str(e)}")
                    if log_callback:
                        log_callback(f"      ❌ 填入失敗 {product}: {str(e)}")
            else:
                print(f"⚠️ 找不到匹配: {product}")
                if log_callback:
                    log_callback(f"      ⚠️ 找不到匹配: {product}")

        if log_callback:
            log_callback(f"    📊 成功填入 {filled_count}/{len(orders)} 個產品")

        return filled_count

    def _get_target_column(self, outlet_sheet_name, supplier):
        """根据送货日期获取目标列"""
        if supplier == 'Legacy':
            print(f"🎯 Legacy 使用列: F (列 6)")
            return 6  # F列（Legacy 模板的日期列，與Freshening一致）
        elif supplier == 'Unikleen':
            print(f"🎯 Unikleen 使用列: J (列 10)")
            return 10  # J列（Unikleen 模板的日期列）
        elif supplier != 'Freshening':
            print(f"🎯 {supplier} 使用默认列: F (列 6)")
            return 6  # 默认F列（下週一）

        # 添加终端输出
        print(f"\n🎯 查找目标列: {outlet_sheet_name}, 供应商: {supplier}")
        print(f"📋 可用门市配置: {list(self.outlet_data.keys())}")

        if outlet_sheet_name in self.outlet_data:
            delivery_date = self.outlet_data[outlet_sheet_name]['delivery_date']
            print(f"📅 送货日期: {delivery_date}")

            # 解析送货日期，例如 "MON", "TUE", "WED" 等
            day_mapping = {
                'MON': 6, 'MONDAY': 6,    # F列（下週一）
                'TUE': 7, 'TUESDAY': 7,   # G列（下週二）
                'WED': 8, 'WEDNESDAY': 8, # H列（下週三）
                'THU': 9, 'THURSDAY': 9,  # I列（下週四）
                'FRI': 10, 'FRIDAY': 10,  # J列（下週五）
                'SAT': 11, 'SATURDAY': 11, # K列（下週六）
                'SUN': 12, 'SUNDAY': 12   # L列（下週日）
            }

            # 处理多个送货日期，取第一个
            for day_str in delivery_date.split('/'):
                day_str = day_str.strip().upper()
                if day_str in day_mapping:
                    target_col = day_mapping[day_str]
                    print(f"✅ 目标列: {chr(64 + target_col)} (列 {target_col})")
                    return target_col

        print(f"⚠️ 使用默认列: F (列 6)")
        return 6  # 默认F列（下週一）

    def _fuzzy_match_product(self, product_name, template_product):
        """模糊匹配产品名称 - 改進版本"""
        if not product_name or not template_product:
            return False

        # 跳过标题行和公司信息
        skip_words = ['description', 'outlet', 'address', 'order', 'delivery', 'freshening', 'industries', 'pte', 'ltd', 'singapore', 'tel', 'fax', 'requesitioner', 'ops', 'admin']
        if any(skip_word in str(template_product).lower() for skip_word in skip_words):
            return False

        # 清理产品名称，移除特殊字符
        import re
        name1 = re.sub(r'[^\w\s]', ' ', str(product_name).lower().strip())
        name2 = re.sub(r'[^\w\s]', ' ', str(template_product).lower().strip())
        
        # 移除多餘空格
        name1 = ' '.join(name1.split())
        name2 = ' '.join(name2.split())

        # 1. 精确匹配
        if name1 == name2:
            return True

        # 2. 包含匹配（更严格）
        if len(name1) > 3 and len(name2) > 3:  # 确保名称足够长
            if name1 in name2 or name2 in name1:
                return True

        # 3. 關鍵詞匹配 - 檢查主要關鍵詞
        keywords1 = [w for w in name1.split() if len(w) > 3]  # 忽略短詞
        keywords2 = [w for w in name2.split() if len(w) > 3]
        
        if keywords1 and keywords2:
            # 檢查是否有關鍵詞匹配
            for k1 in keywords1:
                for k2 in keywords2:
                    if k1 in k2 or k2 in k1:
                        return True

        # 4. 词汇匹配 - 提高閾值
        words1 = set(name1.split())
        words2 = set(name2.split())

        if not words1 or not words2:
            return False

        # 计算交集比例
        intersection = words1.intersection(words2)
        union = words1.union(words2)

        if len(union) == 0:
            return False

        # 提高 Jaccard 相似度閾值
        similarity = len(intersection) / len(union)
        return similarity >= 0.5  # 從 0.3 提高到 0.5

    def _show_operation_supplies_results(self, results):
        """顯示營運用品處理結果的表格窗口 - 門市底下顯示產品數量"""
        try:
            import tkinter as tk
            from tkinter import ttk
            import customtkinter as ctk
            
            # 創建窗口
            window = ctk.CTkToplevel()
            window.title("營運用品處理結果 Summary / Operation Supplies Results Summary")
            window.geometry("1000x700")
            window.configure(fg_color=DARK_BG)
            
            # 居中顯示
            window.update_idletasks()
            x = (window.winfo_screenwidth() // 2) - (1000 // 2)
            y = (window.winfo_screenheight() // 2) - (700 // 2)
            window.geometry(f"1000x700+{x}+{y}")
            
            # 主容器
            main_frame = ctk.CTkFrame(window, fg_color="transparent")
            main_frame.pack(fill="both", expand=True, padx=20, pady=20)
            
            # 標題
            title_label = ctk.CTkLabel(
                main_frame,
                text="📊 營運用品處理結果 Summary\n📊 Operation Supplies Results Summary",
                font=("Microsoft JhengHei", 18, "bold"),
                text_color=ACCENT_BLUE
            )
            title_label.pack(pady=(0, 20))
            
            # 統計信息
            total_suppliers = len(results)
            total_outlets = sum(data['outlet_count'] for data in results.values())
            total_products = 0
            total_matched = 0
            
            for data in results.values():
                for outlet_data in data['outlets'].values():
                    total_products += len(outlet_data['products'])
                    total_matched += outlet_data['filled_count']
            
            match_rate = (total_matched / total_products * 100) if total_products > 0 else 0
            
            stats_frame = ctk.CTkFrame(main_frame, fg_color=DARK_PANEL, corner_radius=12)
            stats_frame.pack(fill="x", pady=(0, 20))
            
            stats_text = f"📈 總計: {total_suppliers} 個供應商, {total_outlets} 個門市\n總產品數: {total_products}, 成功匹配: {total_matched} (匹配率: {match_rate:.1f}%)"
            stats_label = ctk.CTkLabel(
                stats_frame,
                text=stats_text,
                font=("Microsoft JhengHei", 14, "bold"),
                text_color=TEXT_COLOR
            )
            stats_label.pack(pady=15)
            
            # Treeview 容器
            tree_frame = ctk.CTkFrame(main_frame, fg_color=DARK_PANEL, corner_radius=12)
            tree_frame.pack(fill="both", expand=True)
            
            # 創建 Treeview
            tree = ttk.Treeview(tree_frame, columns=("supplier", "outlet", "products", "matched"), show="tree headings")
            tree.heading("#0", text="供應商/門市/產品")
            tree.heading("supplier", text="供應商")
            tree.heading("outlet", text="門市")
            tree.heading("products", text="產品數量")
            tree.heading("matched", text="成功匹配")
            
            # 設置列寬
            tree.column("#0", width=300, minwidth=250)
            tree.column("supplier", width=100, minwidth=80)
            tree.column("outlet", width=150, minwidth=120)
            tree.column("products", width=100, minwidth=80)
            tree.column("matched", width=100, minwidth=80)
            
            # 滾動條
            v_scrollbar = ttk.Scrollbar(tree_frame, orient="vertical", command=tree.yview)
            h_scrollbar = ttk.Scrollbar(tree_frame, orient="horizontal", command=tree.xview)
            tree.configure(yscrollcommand=v_scrollbar.set, xscrollcommand=h_scrollbar.set)
            
            # 填充數據
            for supplier, data in results.items():
                # 供應商節點
                supplier_id = tree.insert("", "end", text=f"🏭 {supplier}", 
                                       values=(supplier, "", f"{total_products} 個", f"{total_matched} 個"))
                
                # 門市節點
                for outlet_name, outlet_data in data['outlets'].items():
                    outlet_id = tree.insert(supplier_id, "end", text=f"🏪 {outlet_name}", 
                                          values=("", outlet_name, 
                                                 f"{len(outlet_data['products'])} 個",
                                                 f"{outlet_data['filled_count']} 個"))
                    
                    # 產品節點
                    for product in outlet_data['products']:
                        # 获取实际的产品数量，如果没有则显示0
                        product_qty = outlet_data.get('product_quantities', {}).get(product, 0)
                        tree.insert(outlet_id, "end", text=f"📦 {product}", 
                                  values=("", "", f"{product_qty}", f"{product_qty}" if product_qty > 0 else "0"))
            
            # 佈局表格和滾動條
            tree.grid(row=0, column=0, sticky="nsew", padx=10, pady=10)
            v_scrollbar.grid(row=0, column=1, sticky="ns", pady=10)
            h_scrollbar.grid(row=1, column=0, sticky="ew", padx=10)
            
            # 配置 grid weights
            tree_frame.grid_rowconfigure(0, weight=1)
            tree_frame.grid_columnconfigure(0, weight=1)
            
            # 說明標籤
            legend_frame = ctk.CTkFrame(main_frame, fg_color="transparent")
            legend_frame.pack(pady=(10, 0))
            
            legend_label = ctk.CTkLabel(
                legend_frame,
                text="說明: 🏭 = 供應商, 🏪 = 門市, 📦 = 產品",
                font=("Microsoft JhengHei", 10),
                text_color=TEXT_COLOR
            )
            legend_label.pack()
            
            # 按鈕容器
            btn_frame = ctk.CTkFrame(main_frame, fg_color="transparent")
            btn_frame.pack(pady=(10, 0))
            
            # 關閉按鈕
            close_btn = ctk.CTkButton(
                btn_frame,
                text="關閉 / Close",
                command=window.destroy,
                fg_color=ACCENT_BLUE,
                hover_color=BTN_HOVER,
                font=("Microsoft JhengHei", 12, "bold"),
                width=120,
                height=35
            )
            close_btn.pack()
            
        except Exception as e:
            print(f"❌ 顯示結果窗口失敗: {str(e)}")
            import traceback
            traceback.print_exc()
            # 如果 treeview 失敗，至少顯示基本統計
            print(f"📊 處理完成: {len(results)} 個供應商")
            for supplier, data in results.items():
                print(f"  {supplier}: {data['outlet_count']} 個門市")

class F5FixAndDeductWithFileWindow(ctk.CTkToplevel):
    """F5 修正和自動扣分窗口（包含文件選擇）"""

    def __init__(self, parent, mismatch_records):
        super().__init__(parent)
        self.title("F5 修正和自動扣分 / F5 Fix & Auto Deduction")
        self.geometry("1000x800")  # 增加高度從 700 到 800
        self.minsize(900, 700)  # 設置最小大小
        self.resizable(True, True)  # 允許用戶調整大小
        self.transient(parent)
        self.grab_set()
        self.configure(fg_color=DARK_BG)
        self.parent = parent
        self.mismatch_records = mismatch_records

        # 居中顯示
        self.center_window()

        # 主容器
        main_frame = ctk.CTkFrame(self, fg_color="transparent")
        main_frame.pack(fill="both", expand=True, padx=20, pady=20)

        # 標題
        title_label = ctk.CTkLabel(
            main_frame,
            text="🔧 F5 修正和自動扣分工具\n🔧 F5 Fix & Auto Deduction Tool",
            font=("Microsoft JhengHei", 18, "bold"),
            text_color=ACCENT_BLUE
        )
        title_label.pack(pady=(0, 20))

        # 說明
        info_label = ctk.CTkLabel(
            main_frame,
            text=f"發現 {
    len(mismatch_records)} 個 mismatch 錯誤\n將自動修正 F5 並為相關門市扣分\nFound {
        len(mismatch_records)} mismatch errors\nWill auto-fix F5 and deduct points for related outlets",
            font=("Microsoft JhengHei", 12),
            text_color=TEXT_COLOR
        )
        info_label.pack(pady=(0, 20))

        # 文件選擇區域
        file_frame = ctk.CTkFrame(
    main_frame,
    fg_color=DARK_PANEL,
     corner_radius=12)
        file_frame.pack(fill="x", pady=(0, 20))

        ctk.CTkLabel(
            file_frame,
            text="選擇扣分文件 / Select Deduction File: *必填",
            font=("Microsoft JhengHei", 14, "bold"),
            text_color=ACCENT_RED
        ).pack(anchor="w", padx=15, pady=(15, 5))

        # 文件路徑輸入
        file_input_frame = ctk.CTkFrame(file_frame, fg_color="transparent")
        file_input_frame.pack(fill="x", padx=15, pady=(0, 15))

        self.file_path_var = ctk.StringVar()
        self.file_path_entry = ctk.CTkEntry(
            file_input_frame,
            textvariable=self.file_path_var,
            font=("Microsoft JhengHei", 12),
            height=35,
            placeholder_text="選擇扣分文件路徑..."
        )
        self.file_path_entry.pack(
    side="left",
    fill="x",
    expand=True,
    padx=(
        0,
         10))

        browse_btn = ctk.CTkButton(
            file_input_frame,
            text="瀏覽 / Browse",
            command=self._browse_file,
            fg_color=ACCENT_BLUE,
            hover_color=BTN_HOVER,
            font=("Microsoft JhengHei", 12, "bold"),
            width=100,
            height=35
        )
        browse_btn.pack(side="right")

        # 扣分人員輸入區域
        deductor_frame = ctk.CTkFrame(
    main_frame, fg_color=DARK_PANEL, corner_radius=12)
        deductor_frame.pack(fill="x", pady=(0, 20))

        ctk.CTkLabel(
            deductor_frame,
            text="扣分人員 / Deducted By: *必填",
            font=("Microsoft JhengHei", 14, "bold"),
            text_color=ACCENT_RED
        ).pack(anchor="w", padx=15, pady=(15, 5))

        self.deducted_by_var = ctk.StringVar()
        self.deducted_by_entry = ctk.CTkEntry(
            deductor_frame,
            textvariable=self.deducted_by_var,
            font=("Microsoft JhengHei", 12),
            height=35,
            placeholder_text="請輸入扣分人員姓名..."
        )
        self.deducted_by_entry.pack(fill="x", padx=15, pady=(0, 15))

        # Mismatch 記錄顯示
        records_frame = ctk.CTkFrame(
    main_frame, fg_color=DARK_PANEL, corner_radius=12)
        records_frame.pack(fill="both", expand=True, pady=(0, 20))

        ctk.CTkLabel(
            records_frame,
            text="Mismatch 記錄 / Mismatch Records:",
            font=("Microsoft JhengHei", 14, "bold"),
            text_color=TEXT_COLOR
        ).pack(anchor="w", padx=15, pady=(15, 5))

        # 記錄列表
        self.records_text = ctk.CTkTextbox(
            records_frame,
            wrap="word",
            font=("Consolas", 12),
            fg_color=TEXTBOX_BG,
            text_color=TEXT_COLOR,
            corner_radius=8
        )
        self.records_text.pack(fill="both", expand=True, padx=15, pady=(0, 15))

        # 顯示 mismatch 記錄
        self._display_mismatch_records()

        # 按鈕區域
        btn_frame = ctk.CTkFrame(main_frame, fg_color="transparent")
        btn_frame.pack(fill="x", pady=(10, 0))

        # 關閉按鈕
        close_btn = ctk.CTkButton(
            btn_frame,
            text="關閉 / Close",
            command=self.destroy,
            fg_color="#6b7280",
            hover_color="#4b5563",
            font=("Microsoft JhengHei", 12, "bold"),
            corner_radius=8,
            width=120,
            height=40
        )
        close_btn.pack(side="right", padx=(10, 0))

        # 執行修正和扣分按鈕
        fix_btn = ctk.CTkButton(
            btn_frame,
            text="執行修正和扣分\nFix & Deduct",
            command=self._start_fix_and_deduct,
            fg_color=ACCENT_GREEN,
            hover_color="#059669",
            font=("Microsoft JhengHei", 12, "bold"),
            corner_radius=8,
            width=180,
            height=40
        )
        fix_btn.pack(side="right", padx=(0, 10))

        # 強制獲得焦點
        self.focus_force()

    def center_window(self):
        """居中顯示視窗"""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        self.geometry(f"{width}x{height}+{x}+{y}")

    def _browse_file(self):
        """瀏覽選擇文件"""
        from tkinter import filedialog
        file_path = filedialog.askopenfilename(
            title="選擇扣分文件",
            filetypes=[("Excel files", "*.xlsx"), ("All files", "*.*")]
        )
        if file_path:
            self.file_path_var.set(file_path)

    def _display_mismatch_records(self):
        """顯示 mismatch 記錄"""
        content = "🔍 Mismatch 錯誤記錄 / Mismatch Error Records\n"
        content += "=" * 80 + "\n\n"

        for i, record in enumerate(self.mismatch_records, 1):
            content += f"{i}. 供應商 / Supplier: {
    record.get(
        'supplier', 'N/A')}\n"
            content += f"   分店 / Outlet: {record.get('outlet', 'N/A')}\n"
            content += f"   狀態 / Status: {record.get('cover_status', 'N/A')}\n"
            content += f"   錯誤 / Error: {record.get('remark', 'N/A')}\n"
            content += "-" * 60 + "\n"

        content += "\n📋 將執行的操作 / Operations to be performed:\n"
        content += "1. 修正供應商文件中的 F5 儲存格 / Fix F5 cells in supplier files\n"
        content += "2. 為每個 mismatch 門市自動扣分 / Auto deduct points for each mismatch outlet\n"
        content += "3. 扣分描述: Order Wrong Data (e.g. Wrong Date, Wrong Outlet Selected, etc.)\n"
        content += "4. 扣分記錄將保存到您選擇的文件中 / Deduction records will be saved to your selected file\n"

        self.records_text.delete("1.0", "end")
        self.records_text.insert("1.0", content)

    def _start_fix_and_deduct(self):
        """開始修正 F5 並自動扣分"""
        try:
            # 檢查必填欄位
            deducted_by = self.deducted_by_var.get().strip()
            if not deducted_by:
                messagebox.showwarning("警告", "請輸入扣分人員姓名！")
                return

            file_path = self.file_path_var.get().strip()
            if not file_path:
                messagebox.showwarning("警告", "請選擇扣分文件！")
                return

            # 檢查是否有 Master Config
            if not hasattr(
    self.parent,
     'master_config_var') or not self.parent.master_config_var.get():
                messagebox.showwarning("警告", "請先選擇 Master Config 文件！")
                return

            # 檢查是否有 checklist 資料夾
            if not hasattr(
    self.parent,
     'checklist_folder_var') or not self.parent.checklist_folder_var.get():
                messagebox.showwarning("警告", "請先選擇 Weekly Order 資料夾！")
                return

            # 開始修正和扣分流程
            self._perform_fix_and_deduct(deducted_by, file_path)

        except Exception as e:
            messagebox.showerror("錯誤", f"執行修正和扣分時發生錯誤：{str(e)}")

    def _extract_sheet_name_from_remark(self, remark):
        """從 remark 中提取 Sheet 名稱"""
        try:
            # 尋找 "Sheet→" 模式
            if "Sheet→" in remark:
                # 找到 "Sheet→" 的位置
                sheet_start = remark.find("Sheet→") + len("Sheet→")
                # 找到下一個分隔符或結尾
                sheet_end = len(remark)
                for delimiter in [";", ",", ")", "\n"]:
                    pos = remark.find(delimiter, sheet_start)
                    if pos != -1 and pos < sheet_end:
                        sheet_end = pos

                sheet_name = remark[sheet_start:sheet_end].strip()
                return sheet_name if sheet_name else None

            return None
        except Exception as e:
            print(f"解析 Sheet 名稱時發生錯誤: {e}")
            return None

    def _should_deduct_points(self, remark):
        """判斷是否應該扣分"""
        try:
            # 只有包含 F5 錯誤的 mismatch 才需要扣分
            # 避免重複扣分：純 Sheet mismatch 不扣分
            if "F5" in remark and ("F5 error" in remark or "F5→" in remark):
                return True
            return False
        except Exception as e:
            print(f"判斷是否扣分時發生錯誤: {e}")
            return False

    def _perform_fix_and_deduct(self, deducted_by, deduction_file_path):
        """執行 F5 修正和自動扣分到指定文件"""
        try:
            import openpyxl
            import os
            from datetime import datetime

            config_path = self.parent.master_config_var.get()
            folder_path = self.parent.checklist_folder_var.get()

            # 載入 Master Config
            config_manager = UnifiedConfigManager(config_path)

            fixed_count = 0
            deduct_count = 0
            skip_count = 0  # 跳過的重複記錄數
            error_count = 0
            deduction_details = {}  # 記錄每個門市的扣分詳情 {outlet: points}
            # 記錄修正詳情 [{supplier, wrong_outlet, correct_outlet, file_path,
            # sheet_name}]
            fix_details = []

            # 打開用戶選擇的扣分文件
            if not os.path.exists(deduction_file_path):
                messagebox.showerror("錯誤", f"扣分文件不存在：{deduction_file_path}")
                return

            wb_deduct = openpyxl.load_workbook(deduction_file_path)

            # 處理每個 mismatch 記錄
            for record in self.mismatch_records:
                supplier = record.get('supplier', '')
                outlet = record.get('outlet', '')
                remark = record.get('remark', '')

                try:
                    # 從 remark 中提取正確的門市代碼
                    sheet_name = self._extract_sheet_name_from_remark(remark)
                    correct_outlet = sheet_name if sheet_name else outlet

                    # 1. 修正 F5 和 G5 儲存格
                    # outlet = 錯誤的門市代碼（來自 F5）
                    # correct_outlet = 正確的門市代碼（來自 Sheet→）
                    print(
    f"[DEBUG] 準備修正: {supplier} - 錯誤門市: {outlet}, 正確門市: {correct_outlet}")
                    fix_result = self._fix_f5_cell(
    supplier, outlet, correct_outlet, folder_path, config_manager)
                    print(f"[DEBUG] 修正結果: {fix_result}")
                    if fix_result:
                        fixed_count += 1
                        fix_details.append(fix_result)
                        print(
    f"[DEBUG] 已添加修正記錄，當前 fix_details 數量: {
        len(fix_details)}")

                    # 2. 判斷是否需要扣分（只有包含 F5 錯誤的才扣分）
                    if self._should_deduct_points(remark):
                        # 3. 自動扣分到用戶選擇的文件（使用正確的門市代碼）
                        deduct_result = self._add_deduction_to_file(
                            wb_deduct, supplier, correct_outlet, deducted_by, remark
                        )
                        if deduct_result is True:
                            # 成功添加新的扣分記錄
                            deduct_count += 1
                            # 記錄扣分詳情（每次扣 10 分）
                            if correct_outlet in deduction_details:
                                deduction_details[correct_outlet] += 10
                            else:
                                deduction_details[correct_outlet] = 10
                        elif deduct_result is False:
                            # 跳過重複記錄
                            skip_count += 1

                except Exception as e:
                    error_count += 1
                    print(f"處理 {supplier}-{outlet} 時發生錯誤: {e}")

            # 保存扣分記錄文件
            wb_deduct.save(deduction_file_path)
            wb_deduct.close()

            # 構建結果訊息
            result_msg = f"F5 修正和自動扣分完成！\n\n"
            result_msg += f"F5 修正成功: {fixed_count} 個\n"
            result_msg += f"自動扣分成功: {deduct_count} 個\n"
            result_msg += f"跳過重複記錄: {skip_count} 個\n"
            result_msg += f"處理失敗: {error_count} 個\n"
            result_msg += f"總計處理: {len(self.mismatch_records)} 個\n\n"

            # 添加扣分統計詳情
            if deduction_details:
                result_msg += "扣分統計:\n"
                for outlet, points in sorted(deduction_details.items()):
                    result_msg += f"  {outlet}: {points} 分\n"
                result_msg += "\n"

            result_msg += f"扣分記錄已保存到:\n{deduction_file_path}"

            messagebox.showinfo("處理完成", result_msg)

            # 顯示詳細的修改記錄視窗
            if fix_details:
                self._show_fix_details_window(fix_details)

        except Exception as e:
            messagebox.showerror("錯誤", f"執行修正和扣分時發生錯誤：{str(e)}")

    def _fix_f5_cell(
    self,
    supplier,
    wrong_outlet,
    correct_outlet,
    folder_path,
     config_manager):
        """修正單個供應商文件的 F5 儲存格

        Args:
            supplier: 供應商名稱
            wrong_outlet: 錯誤的門市代碼（來自 F5 儲存格）
            correct_outlet: 正確的門市代碼（來自 Sheet→）
            folder_path: 供應商文件夾路徑
            config_manager: 配置管理器

        Returns:
            dict: 修正詳情，包含 supplier, wrong_outlet, correct_outlet, file_path, sheet_name, old_f5, new_f5, old_f6, new_f6, old_g5, new_g5
            None: 修正失敗
        """
        try:
            import openpyxl
            import os

            # 從 Master Config 獲取正確的店名和地址
            correct_outlet_info = None
            for outlet_info in config_manager.outlets:
                if outlet_info['code'].upper() == correct_outlet.upper():
                    correct_outlet_info = outlet_info
                    break

            if not correct_outlet_info:
                print(f"❌ 找不到正確門市 {correct_outlet} 的配置信息")
                return None

            # 找到對應的供應商文件
            supplier_files = [f for f in os.listdir(
                folder_path) if f.endswith('.xlsx')]
            supplier_file = find_supplier_file(supplier, supplier_files)

            if not supplier_file:
                print(f"❌ 找不到供應商 {supplier} 的文件")
                return None

            file_path = os.path.join(folder_path, supplier_file)

            # 修正 F5 儲存格
            wb = openpyxl.load_workbook(file_path)

            # 找到正確的工作表（與 correct_outlet 匹配）
            target_sheet = None
            target_sheet_name = None
            for sheet_name in wb.sheetnames:
                if correct_outlet.upper() in sheet_name.upper():
                    target_sheet = wb[sheet_name]
                    target_sheet_name = sheet_name
                    break

            if target_sheet:
                # 處理合併儲存格的問題
                def set_cell_value_safe(sheet, cell_ref, value):
                    """安全地設置儲存格值，處理合併儲存格的情況"""
                    try:
                        # 檢查是否為合併儲存格
                        cell = sheet[cell_ref]
                        old_value = None

                        # 先檢查是否在合併範圍內
                        merged_range_to_unmerge = None
                        for merged_range in list(sheet.merged_cells.ranges):
                            if cell_ref in merged_range:
                                merged_range_to_unmerge = merged_range
                                # 獲取合併範圍的左上角儲存格值
                                top_left = sheet.cell(
    merged_range.min_row, merged_range.min_col)
                                old_value = top_left.value
                                break

                        if merged_range_to_unmerge:
                            # 如果是合併儲存格，先取消合併
                            print(
    f"🔧 發現合併儲存格 {merged_range_to_unmerge}，準備取消合併")
                            sheet.unmerge_cells(str(merged_range_to_unmerge))
                            print(f"✅ 已取消合併 {merged_range_to_unmerge}")
                        else:
                            # 如果不是合併儲存格，直接獲取值
                            old_value = cell.value

                        # 設置新值
                        sheet[cell_ref].value = value
                        print(f"✅ 設置 {cell_ref} = '{value}'")
                        return old_value

                    except Exception as e:
                        print(f"❌ 設置 {cell_ref} 時發生錯誤: {e}")
                        return None

                # 記錄修正前的值並設置新值
                # F5 = 門市全名 (Outlet)
                old_f5 = set_cell_value_safe(
    target_sheet, 'F5', correct_outlet_info['name'])
                # F6 = 地址 (Address) - 根據您的截圖，地址應該在 F6
                old_f6 = set_cell_value_safe(
    target_sheet, 'F6', correct_outlet_info['address'])

                # 清除 G5 中可能的錯誤地址數據
                old_g5 = None
                try:
                    old_g5 = target_sheet['G5'].value
                    if old_g5 and (
    str(old_g5).strip() == str(
        correct_outlet_info['address']).strip()):
                        target_sheet['G5'].value = None
                        print(f"✅ 清除 G5 中的錯誤地址數據: '{old_g5}'")
                except:
                    pass

                print(f"✅ 修正 {supplier} - 工作表 {target_sheet_name}:")
                print(
    f"   F5 (門市全名): '{old_f5}' → '{
        correct_outlet_info['name']}'")
                print(
    f"   F6 (地址): '{old_f6}' → '{
        correct_outlet_info['address']}'")
                if old_g5:
                    print(f"   G5 (清除錯誤地址): '{old_g5}' → None")

                # 安全保存文件 - 處理外部鏈接問題
                try:
                    # 創建備份
                    import shutil
                    backup_path = file_path.replace('.xlsx', '_backup.xlsx')
                    shutil.copy2(file_path, backup_path)

                    # 使用工作簿複製方法，完全避免外部鏈接和命名範圍問題
                    print("✅ 使用工作簿複製方法，避免所有Excel修復問題")
                    
                    try:
                        # 創建新的工作簿
                        new_wb = openpyxl.Workbook()
                        
                        # 刪除默認工作表
                        if 'Sheet' in new_wb.sheetnames:
                            del new_wb['Sheet']
                        
                        # 複製所有工作表
                        for sheet in wb.worksheets:
                            new_ws = new_wb.create_sheet(sheet.title)
                            
                            # 複製所有數據和格式
                            for row in sheet.iter_rows():
                                for cell in row:
                                    new_cell = new_ws.cell(row=cell.row, column=cell.column)
                                    
                                    # 複製值（保持原始值）
                                    if cell.value is not None:
                                        new_cell.value = cell.value
                                        print(f"[DEBUG] 複製值: {cell.coordinate} = {cell.value}")
                                    
                                    # 安全複製格式，避免循環引用
                                    try:
                                        if cell.font:
                                            from openpyxl.styles import Font
                                            new_cell.font = Font(
                                                name=cell.font.name,
                                                size=cell.font.size,
                                                bold=cell.font.bold,
                                                italic=cell.font.italic,
                                                vertAlign=cell.font.vertAlign,
                                                underline=cell.font.underline,
                                                strike=cell.font.strike,
                                                color=cell.font.color
                                            )
                                    except Exception:
                                        pass
                                        
                                    try:
                                        if cell.fill and hasattr(cell.fill, 'fill_type'):
                                            from openpyxl.styles import PatternFill
                                            new_cell.fill = PatternFill(
                                                fill_type=cell.fill.fill_type,
                                                start_color=cell.fill.start_color,
                                                end_color=cell.fill.end_color
                                            )
                                    except Exception:
                                        pass
                                        
                                    try:
                                        if cell.alignment:
                                            from openpyxl.styles import Alignment
                                            new_cell.alignment = Alignment(
                                                horizontal=cell.alignment.horizontal,
                                                vertical=cell.alignment.vertical,
                                                text_rotation=cell.alignment.text_rotation,
                                                wrap_text=cell.alignment.wrap_text,
                                                shrink_to_fit=cell.alignment.shrink_to_fit,
                                                indent=cell.alignment.indent
                                            )
                                    except Exception:
                                        pass
                                        
                                    try:
                                        if cell.border:
                                            from openpyxl.styles import Border, Side
                                            new_cell.border = Border(
                                                left=Side(border_style=cell.border.left.style, color=cell.border.left.color),
                                                right=Side(border_style=cell.border.right.style, color=cell.border.right.color),
                                                top=Side(border_style=cell.border.top.style, color=cell.border.top.color),
                                                bottom=Side(border_style=cell.border.bottom.style, color=cell.border.bottom.color)
                                            )
                                    except Exception:
                                        pass
                                    
                                    # 複製數字格式（包含日期格式）
                                    try:
                                        if cell.number_format and cell.number_format != 'General':
                                            new_cell.number_format = cell.number_format
                                            print(f"[DEBUG] 複製格式: {cell.coordinate} -> {cell.number_format}")
                                    except Exception as format_error:
                                        print(f"[DEBUG] 格式複製失敗: {cell.coordinate} - {format_error}")
                                        pass
                            
                            # 複製合併儲存格
                            for merged_range in sheet.merged_cells.ranges:
                                new_ws.merge_cells(str(merged_range))
                            
                            # 複製列寬和行高
                            for col in sheet.column_dimensions:
                                new_ws.column_dimensions[col].width = sheet.column_dimensions[col].width
                                # 複製列的隱藏狀態
                                if hasattr(sheet.column_dimensions[col], 'hidden'):
                                    new_ws.column_dimensions[col].hidden = sheet.column_dimensions[col].hidden
                                    print(f"[DEBUG] 複製列隱藏狀態: 列{col} = {sheet.column_dimensions[col].hidden}")
                            
                            for row in sheet.row_dimensions:
                                new_ws.row_dimensions[row].height = sheet.row_dimensions[row].height
                                # 複製行的隱藏狀態
                                if hasattr(sheet.row_dimensions[row], 'hidden'):
                                    new_ws.row_dimensions[row].hidden = sheet.row_dimensions[row].hidden
                                    print(f"[DEBUG] 複製行隱藏狀態: 行{row} = {sheet.row_dimensions[row].hidden}")
                            
                            # 固定設定凍結窗格為 A9
                            try:
                                new_ws.freeze_panes = "A9"
                                print(f"✅ 設定固定凍結窗格: A9")
                            except Exception as freeze_error:
                                print(f"⚠️ 設定凍結窗格失敗: {freeze_error}")
                            
                            # 複製工作表保護
                            if sheet.protection:
                                new_ws.protection = sheet.protection
                            
                            # 處理公式，將外部引用轉換為數值以避免#REF!錯誤
                            print(f"[DEBUG] 開始處理公式轉換...")
                            for row in new_ws.iter_rows():
                                for cell in row:
                                    if cell.value and isinstance(cell.value, str) and cell.value.startswith('='):
                                        # 檢查是否包含外部引用
                                        if any(ref in cell.value for ref in ['[', ']', '!']):
                                            try:
                                                # 嘗試使用 xlwings 獲取計算結果
                                                import xlwings as xw
                                                # 這裡我們先保存原始公式，然後在保存後處理
                                                print(f"[DEBUG] 發現外部引用公式: {cell.coordinate} = {cell.value}")
                                            except Exception as e:
                                                print(f"[DEBUG] 處理公式失敗: {cell.coordinate} - {e}")
                        
                        # 關閉原工作簿
                        wb.close()
                        
                        # 保存新工作簿
                        new_wb.save(file_path)
                        new_wb.close()
                        print(f"✅ 工作簿複製保存成功: {file_path}")
                        
                        # 使用 xlwings 讀取原始文件的計算結果，然後替換公式
                        try:
                            print(f"[DEBUG] 開始使用 xlwings 讀取原始文件計算結果...")
                            import xlwings as xw
                            
                            # 打開原始文件獲取計算結果
                            app = xw.App(visible=False)
                            wb_original = app.books.open(src_file)
                            
                            # 打開目標文件
                            wb_target = app.books.open(file_path)
                            
                            # 處理每個工作表
                            for sheet_name in wb_target.sheets:
                                if sheet_name in wb_original.sheets:
                                    print(f"[DEBUG] 處理工作表: {sheet_name}")
                                    original_sheet = wb_original.sheets[sheet_name]
                                    target_sheet = wb_target.sheets[sheet_name]
                                    
                                    # 獲取所有使用範圍
                                    used_range = target_sheet.used_range
                                    if used_range:
                                        # 遍歷所有儲存格
                                        for row in range(1, used_range.last_cell.row + 1):
                                            for col in range(1, used_range.last_cell.column + 1):
                                                target_cell = target_sheet.cells(row, col)
                                                if target_cell.formula and target_cell.formula.startswith('='):
                                                    # 檢查是否包含外部引用
                                                    if any(ref in target_cell.formula for ref in ['[', ']', '!']):
                                                        try:
                                                            # 從原始文件獲取對應儲存格的計算結果
                                                            original_cell = original_sheet.cells(row, col)
                                                            calculated_value = original_cell.value
                                                            
                                                            if calculated_value is not None and not isinstance(calculated_value, str):
                                                                # 將公式替換為計算結果
                                                                target_cell.value = calculated_value
                                                                print(f"[DEBUG] 轉換公式: {target_cell.address} = {calculated_value}")
                                                            else:
                                                                # 如果無法獲取計算結果，設為0
                                                                target_cell.value = 0
                                                                print(f"[DEBUG] 設為0: {target_cell.address}")
                                                        except Exception as e:
                                                            print(f"[DEBUG] 轉換公式失敗: {target_cell.address} - {e}")
                                                            # 設為0作為備選
                                                            target_cell.value = 0
                            
                            # 保存並關閉
                            wb_target.save()
                            wb_target.close()
                            wb_original.close()
                            app.quit()
                            print(f"✅ 公式轉換完成")
                            
                        except Exception as e:
                            print(f"⚠️ 公式轉換失敗: {e}")
                            # 如果 xlwings 處理失敗，繼續執行
                        
                    except Exception as copy_error:
                        print(f"⚠️ 工作簿複製失敗，使用備份: {copy_error}")
                        # 如果複製失敗，恢復備份
                        wb.close()
                        if os.path.exists(backup_path):
                            shutil.copy2(backup_path, file_path)
                            print(f"✅ 已恢復備份文件")
                        raise copy_error

                    # 刪除備份
                    import os
                    if os.path.exists(backup_path):
                        os.remove(backup_path)

                except Exception as save_error:
                    print(f"❌ 保存文件時發生錯誤: {save_error}")
                    # 如果保存失敗，嘗試恢復備份
                    if os.path.exists(backup_path):
                        shutil.copy2(backup_path, file_path)
                        os.remove(backup_path)
                        print(f"✅ 已恢復備份文件")
                    raise save_error
                finally:
                    wb.close()

                # 返回修正詳情
                return {
                    'supplier': supplier,
                    'wrong_outlet': wrong_outlet,
                    'correct_outlet': correct_outlet,
                    'file_path': supplier_file,
                    'sheet_name': target_sheet_name,
                    'old_f5': old_f5,
                    'new_f5': correct_outlet_info['name'],
                    'old_f6': old_f6,
                    'new_f6': correct_outlet_info['address'],
                    'old_g5': old_g5,
                    'new_g5': None  # G5 被清除
                }
            else:
                wb.close()
                print(f"❌ 在 {supplier} 文件中找不到工作表 {wrong_outlet}")
                return None

        except Exception as e:
            print(f"修正 F5 儲存格時發生錯誤: {e}")
            return None

    def _add_deduction_to_file(
    self,
    wb_deduct,
    supplier,
    outlet,
    deducted_by,
     remark=""):
        """添加扣分記錄到指定的工作簿"""
        try:
            from datetime import datetime

            # 找到或創建對應門市的工作表
            sheet_name = outlet
            if sheet_name not in wb_deduct.sheetnames:
                # 如果工作表不存在，創建新的工作表
                ws = wb_deduct.create_sheet(title=sheet_name)

                # 設置標題行（第1行：門市名稱，第2行：欄位標題）
                ws.cell(row=1, column=1, value=f"Outlet: {outlet}")
                ws.merge_cells('A1:H1')
                ws.cell(
    row=1, column=1).font = openpyxl.styles.Font(
        bold=True, size=14)
                ws.cell(
    row=1,
    column=1).alignment = openpyxl.styles.Alignment(
        horizontal="center")

                # 第2行：欄位標題
                headers = [
                    "Offence Date", "Category", "Description", "Employee Id/Name",
                    "Points Deducted", "Offence #", "Entered By", "Notes"
                ]
                for col, header in enumerate(headers, 1):
                    cell = ws.cell(row=2, column=col, value=header)
                    cell.font = openpyxl.styles.Font(bold=True)
                    cell.alignment = openpyxl.styles.Alignment(
                        horizontal="center")

                # 設置列寬
                column_widths = [12, 15, 50, 20, 12, 10, 15, 20]
                for i, width in enumerate(column_widths, 1):
                    ws.column_dimensions[openpyxl.utils.get_column_letter(
                        i)].width = width
            else:
                ws = wb_deduct[sheet_name]

            # 構建備註信息，包含供應商和原始錯誤信息
            notes = f"{supplier} - Mismatch"
            if remark:
                # 如果有 remark，添加簡化的錯誤信息
                if "Sheet→" in remark:
                    notes += f" ({
    remark.split('Sheet→')[0].strip().rstrip(';').rstrip(',')})"

            # 準備要添加的數據
            today = datetime.now().strftime("%Y-%m-%d")
            category = "WeeklyOrder"
            description = "Order Wrong Data (e.g. Wrong Date, Wrong Outlet Selected, etc.)"
            employee_id = "System Auto"

            # 檢查是否已經存在相同的記錄（避免重複扣分）
            existing_row = self._check_duplicate_deduction(
    ws, today, category, description, supplier, deducted_by)
            if existing_row:
                print(
    f"⚠️  跳過重複扣分: {supplier} - {outlet} (已存在於第 {existing_row} 行)")
                return False  # 返回 False 表示沒有添加新記錄（但不是錯誤）

            # 找到下一個空行（從第3行開始）
            next_row = 3
            while ws.cell(row=next_row, column=1).value is not None:
                next_row += 1

            # 填入數據
            ws.cell(row=next_row, column=1, value=today)  # A: 日期
            ws.cell(row=next_row, column=2, value=category)  # B: 類別
            ws.cell(row=next_row, column=3, value=description)  # C: 描述
            ws.cell(
    row=next_row,
    column=4,
     value=employee_id)  # D: Employee Id/Name
            # E: Points Deducted (調整為 10)
            ws.cell(row=next_row, column=5, value=10)
            ws.cell(row=next_row, column=6, value=1)   # F: Offence # (調整為 1)
            ws.cell(row=next_row, column=7, value=deducted_by)  # G: Entered By
            ws.cell(row=next_row, column=8, value=notes)  # H: Notes

            print(f"✅ 新增扣分記錄: {supplier} - {outlet} (第 {next_row} 行)")
            return True

        except Exception as e:
            print(f"添加扣分記錄時發生錯誤: {e}")
            return False

    def _check_duplicate_deduction(
    self,
    ws,
    date,
    category,
    description,
    supplier,
     deducted_by):
        """檢查是否已經存在相同的扣分記錄"""
        try:
            # 從第3行開始檢查（跳過標題行）
            row = 3
            while ws.cell(row=row, column=1).value is not None:
                # 檢查關鍵欄位是否匹配
                existing_date = ws.cell(row=row, column=1).value
                existing_category = ws.cell(row=row, column=2).value
                existing_description = ws.cell(row=row, column=3).value
                existing_notes = ws.cell(row=row, column=8).value
                existing_deducted_by = ws.cell(row=row, column=7).value

                # 轉換日期格式進行比較
                if existing_date:
                    if isinstance(existing_date, str):
                        existing_date_str = existing_date
                    else:
                        # 如果是 datetime 對象，轉換為字符串
                        existing_date_str = existing_date.strftime(
                            "%Y-%m-%d") if hasattr(existing_date, 'strftime') else str(existing_date)
                else:
                    existing_date_str = ""

                # 檢查是否為相同記錄
                is_same_date = existing_date_str == date
                is_same_category = str(
    existing_category or "").strip() == category
                is_same_description = str(
    existing_description or "").strip() == description
                is_same_deducted_by = str(
    existing_deducted_by or "").strip() == deducted_by
                is_same_supplier = supplier in str(existing_notes or "")

                if (is_same_date and is_same_category and is_same_description and
                    is_same_deducted_by and is_same_supplier):
                    return row  # 返回重複記錄的行號

                row += 1

            return None  # 沒有找到重複記錄

        except Exception as e:
            print(f"檢查重複記錄時發生錯誤: {e}")
            return None

    def _show_fix_details_window(self, fix_details):
        """顯示修正詳情視窗"""
        details_window = ctk.CTkToplevel(self)
        details_window.title("F5/G5 修正詳情 / F5/G5 Fix Details")
        details_window.geometry("1200x700")
        details_window.minsize(1000, 600)
        details_window.resizable(True, True)
        details_window.transient(self)
        details_window.grab_set()
        details_window.configure(fg_color=DARK_BG)

        # 居中顯示
        details_window.update_idletasks()
        width = details_window.winfo_width()
        height = details_window.winfo_height()
        x = (details_window.winfo_screenwidth() // 2) - (width // 2)
        y = (details_window.winfo_screenheight() // 2) - (height // 2)
        details_window.geometry(f"{width}x{height}+{x}+{y}")

        # 主容器
        main_frame = ctk.CTkFrame(details_window, fg_color="transparent")
        main_frame.pack(fill="both", expand=True, padx=20, pady=20)

        # 標題
        title_label = ctk.CTkLabel(
            main_frame,
            text="📝 F5/G5 修正詳情報告\n📝 F5/G5 Fix Details Report",
            font=("Microsoft JhengHei", 20, "bold"),
            text_color=ACCENT_BLUE
        )
        title_label.pack(pady=(0, 20))

        # 說明和選擇區域
        info_frame = ctk.CTkFrame(main_frame, fg_color="transparent")
        info_frame.pack(fill="x", pady=(0, 15))

        # 說明
        info_label = ctk.CTkLabel(
            info_frame,
            text=f"成功修正 {
    len(fix_details)} 個供應商文件的 F5/G5 儲存格\nSuccessfully fixed F5/G5 cells in {
        len(fix_details)} supplier files",
            font=("Microsoft JhengHei", 14),
            text_color=TEXT_COLOR
        )
        info_label.pack(side="left")

        # 選擇區域
        select_frame = ctk.CTkFrame(info_frame, fg_color="transparent")
        select_frame.pack(side="right")

        # 選擇標籤
        select_label = ctk.CTkLabel(
            select_frame,
            text="選擇查看 / Select:",
            font=("Microsoft JhengHei", 12),
            text_color=TEXT_COLOR
        )
        select_label.pack(side="left", padx=(0, 10))

        # 選擇下拉選單
        supplier_options = [
            "全部 / All"] + [f"{detail['supplier']} - {detail['sheet_name']}" for detail in fix_details]

        supplier_var = ctk.StringVar(value="全部 / All")
        supplier_dropdown = ctk.CTkComboBox(
            select_frame,
            values=supplier_options,
            variable=supplier_var,
            font=("Microsoft JhengHei", 12),
            width=300,
            height=35
        )
        supplier_dropdown.pack(side="left", padx=(0, 10))

        # 詳情文本框
        details_text = ctk.CTkTextbox(
            main_frame,
            font=("Consolas", 12),  # 增大字體從 10 到 12
            fg_color=TEXTBOX_BG,
            text_color=TEXT_COLOR,
            corner_radius=8
        )
        details_text.pack(fill="both", expand=True, pady=(0, 15))

        def update_details_display():
            """更新詳情顯示"""
            selected = supplier_var.get()
            details_text.configure(state="normal")
            details_text.delete("1.0", "end")

            if selected == "全部 / All":
                # 顯示所有記錄
                content = ""
                for i, detail in enumerate(fix_details, 1):
                    content += f"{i}. 供應商 / Supplier: {detail['supplier']}\n"
                    content += f"   文件 / File: {detail['file_path']}\n"
                    content += f"   工作表 / Sheet: {detail['sheet_name']}\n"
                    content += f"   錯誤門市 / Wrong Outlet: {
    detail['wrong_outlet']}\n"
                    content += f"   正確門市 / Correct Outlet: {
    detail['correct_outlet']}\n"
                    content += f"   \n"
                    content += f"   修正前 / Before:\n"
                    content += f"     F5 (門市全名): '{detail['old_f5']}'\n"
                    content += f"     G5 (地址): '{detail['old_g5']}'\n"
                    content += f"   \n"
                    content += f"   修正後 / After:\n"
                    content += f"     F5 (門市全名): '{detail['new_f5']}'\n"
                    content += f"     G5 (地址): '{detail['new_g5']}'\n"
                    content += f"   \n"
                    content += "=" * 80 + "\n\n"
            else:
                # 顯示選中的記錄
                for i, detail in enumerate(fix_details, 1):
                    if f"{detail['supplier']} - {detail['sheet_name']}" == selected:
                        content = f"供應商 / Supplier: {detail['supplier']}\n"
                        content += f"文件 / File: {detail['file_path']}\n"
                        content += f"工作表 / Sheet: {detail['sheet_name']}\n"
                        content += f"錯誤門市 / Wrong Outlet: {
    detail['wrong_outlet']}\n"
                        content += f"正確門市 / Correct Outlet: {
    detail['correct_outlet']}\n"
                        content += f"\n"
                        content += f"修正前 / Before:\n"
                        content += f"  F5 (門市全名): '{detail['old_f5']}'\n"
                        content += f"  G5 (地址): '{detail['old_g5']}'\n"
                        content += f"\n"
                        content += f"修正後 / After:\n"
                        content += f"  F5 (門市全名): '{detail['new_f5']}'\n"
                        content += f"  G5 (地址): '{detail['new_g5']}'\n"
                        content += f"\n"
                        content += "詳細對比 / Detailed Comparison:\n"
                        content += f"  F5 (門市全名): '{
    detail['old_f5']}' → '{
        detail['new_f5']}'\n"
                        content += f"  F6 (地址): '{
    detail['old_f6']}' → '{
        detail['new_f6']}'\n"
                        if detail.get('old_g5'):
                            content += f"  G5 (清除錯誤): '{
    detail['old_g5']}' → None\n"
                        break

            details_text.insert("1.0", content)
            details_text.configure(state="disabled")

        # 綁定下拉選單變更事件
        supplier_dropdown.configure(
    command=lambda value: update_details_display())

        # 初始顯示所有記錄
        update_details_display()

        # 按鈕區域
        btn_frame = ctk.CTkFrame(main_frame, fg_color="transparent")
        btn_frame.pack(fill="x")

        # 字體大小控制
        font_frame = ctk.CTkFrame(btn_frame, fg_color="transparent")
        font_frame.pack(side="left")

        font_label = ctk.CTkLabel(
            font_frame,
            text="字體大小 / Font Size:",
            font=("Microsoft JhengHei", 12),
            text_color=TEXT_COLOR
        )
        font_label.pack(side="left", padx=(0, 10))

        def change_font_size(size):
            """改變字體大小"""
            details_text.configure(font=("Consolas", size))

        # 字體大小按鈕
        font_small_btn = ctk.CTkButton(
            font_frame,
            text="小 / S",
            command=lambda: change_font_size(10),
            fg_color="#6b7280",
            hover_color="#4b5563",
            font=("Microsoft JhengHei", 10),
            width=50,
            height=30
        )
        font_small_btn.pack(side="left", padx=2)

        font_medium_btn = ctk.CTkButton(
            font_frame,
            text="中 / M",
            command=lambda: change_font_size(12),
            fg_color=ACCENT_BLUE,
            hover_color="#1e40af",
            font=("Microsoft JhengHei", 10),
            width=50,
            height=30
        )
        font_medium_btn.pack(side="left", padx=2)

        font_large_btn = ctk.CTkButton(
            font_frame,
            text="大 / L",
            command=lambda: change_font_size(14),
            fg_color="#6b7280",
            hover_color="#4b5563",
            font=("Microsoft JhengHei", 10),
            width=50,
            height=30
        )
        font_large_btn.pack(side="left", padx=2)

        # 關閉按鈕
        close_btn = ctk.CTkButton(
            btn_frame,
            text="關閉 / Close",
            command=details_window.destroy,
            fg_color="#6b7280",
            hover_color="#4b5563",
            font=("Microsoft JhengHei", 14, "bold"),
            corner_radius=8,
            width=120,
            height=40
        )
        close_btn.pack(side="right")


class AddDeductionDialog(ctk.CTkToplevel):
    """添加扣分記錄對話框"""

    def __init__(self, parent, file_path, outlet_name, refresh_callback):
        super().__init__(parent)
        self.title("添加扣分記錄 / Add Deduction Record")
        self.geometry("600x500")
        self.transient(parent)
        self.grab_set()
        self.configure(fg_color=DARK_BG)
        self.file_path = file_path
        self.outlet_name = outlet_name
        self.refresh_callback = refresh_callback

        # 居中顯示
        self.center_window()

        # 主容器
        main_frame = ctk.CTkFrame(self, fg_color="transparent")
        main_frame.pack(fill="both", expand=True, padx=20, pady=20)

        # 標題
        title_label = ctk.CTkLabel(
            main_frame,
            text=f"📝 為 {outlet_name} 添加扣分記錄\n📝 Add Deduction Record for {outlet_name}",
            font=("Microsoft JhengHei", 16, "bold"),
            text_color=ACCENT_BLUE
        )
        title_label.pack(pady=(0, 20))

        # 表單區域
        form_frame = ctk.CTkFrame(
    main_frame,
    fg_color=DARK_PANEL,
     corner_radius=12)
        form_frame.pack(fill="both", expand=True, pady=(0, 20))

        # 日期
        ctk.CTkLabel(
            form_frame,
            text="日期 / Date:",
            font=("Microsoft JhengHei", 12, "bold"),
            text_color=TEXT_COLOR
        ).pack(anchor="w", padx=15, pady=(15, 5))

        self.date_var = ctk.StringVar(
    value=datetime.now().strftime("%Y-%m-%d"))
        date_entry = ctk.CTkEntry(
            form_frame,
            textvariable=self.date_var,
            font=("Microsoft JhengHei", 12),
            height=35
        )
        date_entry.pack(fill="x", padx=15, pady=(0, 10))

        # 類別
        ctk.CTkLabel(
            form_frame,
            text="類別 / Category:",
            font=("Microsoft JhengHei", 12, "bold"),
            text_color=TEXT_COLOR
        ).pack(anchor="w", padx=15, pady=(5, 5))

        self.category_var = ctk.StringVar(value="WeeklyOrder")
        category_entry = ctk.CTkEntry(
            form_frame,
            textvariable=self.category_var,
            font=("Microsoft JhengHei", 12),
            height=35
        )
        category_entry.pack(fill="x", padx=15, pady=(0, 10))

        # 描述
        ctk.CTkLabel(
            form_frame,
            text="描述 / Description:",
            font=("Microsoft JhengHei", 12, "bold"),
            text_color=TEXT_COLOR
        ).pack(anchor="w", padx=15, pady=(5, 5))

        self.description_var = ctk.StringVar(
    value="Order Wrong Data (e.g. Wrong Date, Wrong Outlet Selected, etc.)")
        description_entry = ctk.CTkEntry(
            form_frame,
            textvariable=self.description_var,
            font=("Microsoft JhengHei", 12),
            height=35
        )
        description_entry.pack(fill="x", padx=15, pady=(0, 10))

        # 扣分項目
        ctk.CTkLabel(
            form_frame,
            text="扣分項目 / Deduction Item:",
            font=("Microsoft JhengHei", 12, "bold"),
            text_color=TEXT_COLOR
        ).pack(anchor="w", padx=15, pady=(5, 5))

        self.item_var = ctk.StringVar(value="10")
        item_entry = ctk.CTkEntry(
            form_frame,
            textvariable=self.item_var,
            font=("Microsoft JhengHei", 12),
            height=35
        )
        item_entry.pack(fill="x", padx=15, pady=(0, 10))

        # 扣分
        ctk.CTkLabel(
            form_frame,
            text="扣分 / Points Deducted:",
            font=("Microsoft JhengHei", 12, "bold"),
            text_color=TEXT_COLOR
        ).pack(anchor="w", padx=15, pady=(5, 5))

        self.points_var = ctk.StringVar(value="1")
        points_entry = ctk.CTkEntry(
            form_frame,
            textvariable=self.points_var,
            font=("Microsoft JhengHei", 12),
            height=35
        )
        points_entry.pack(fill="x", padx=15, pady=(0, 10))

        # 扣分人員
        ctk.CTkLabel(
            form_frame,
            text="扣分人員 / Deducted By: *",
            font=("Microsoft JhengHei", 12, "bold"),
            text_color=ACCENT_RED
        ).pack(anchor="w", padx=15, pady=(5, 5))

        self.deducted_by_var = ctk.StringVar()
        deducted_by_entry = ctk.CTkEntry(
            form_frame,
            textvariable=self.deducted_by_var,
            font=("Microsoft JhengHei", 12),
            height=35,
            placeholder_text="必填項目..."
        )
        deducted_by_entry.pack(fill="x", padx=15, pady=(0, 10))

        # 備註
        ctk.CTkLabel(
            form_frame,
            text="備註 / Notes:",
            font=("Microsoft JhengHei", 12, "bold"),
            text_color=TEXT_COLOR
        ).pack(anchor="w", padx=15, pady=(5, 5))

        self.notes_var = ctk.StringVar()
        notes_entry = ctk.CTkEntry(
            form_frame,
            textvariable=self.notes_var,
            font=("Microsoft JhengHei", 12),
            height=35,
            placeholder_text="可選項目..."
        )
        notes_entry.pack(fill="x", padx=15, pady=(0, 15))

        # 按鈕區域
        btn_frame = ctk.CTkFrame(main_frame, fg_color="transparent")
        btn_frame.pack(fill="x", pady=(10, 0))

        # 取消按鈕
        cancel_btn = ctk.CTkButton(
            btn_frame,
            text="取消 / Cancel",
            command=self.destroy,
            fg_color="#6b7280",
            hover_color="#4b5563",
            font=("Microsoft JhengHei", 12, "bold"),
            corner_radius=8,
            width=120,
            height=40
        )
        cancel_btn.pack(side="right", padx=(10, 0))

        # 保存按鈕
        save_btn = ctk.CTkButton(
            btn_frame,
            text="保存 / Save",
            command=self._save_record,
            fg_color=ACCENT_GREEN,
            hover_color="#059669",
            font=("Microsoft JhengHei", 12, "bold"),
            corner_radius=8,
            width=120,
            height=40
        )
        save_btn.pack(side="right", padx=(0, 10))

        # 強制獲得焦點
        self.focus_force()

    def center_window(self):
        """居中顯示視窗"""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        self.geometry(f"{width}x{height}+{x}+{y}")

    def _save_record(self):
        """保存扣分記錄"""
        try:
            import openpyxl

            # 檢查必填欄位
            deducted_by = self.deducted_by_var.get().strip()
            if not deducted_by:
                messagebox.showwarning("警告", "請輸入扣分人員姓名！")
                return

            # 打開文件
            wb = openpyxl.load_workbook(self.file_path)

            # 確保工作表存在
            if self.outlet_name not in wb.sheetnames:
                messagebox.showerror("錯誤", f"工作表 '{self.outlet_name}' 不存在！")
                return

            ws = wb[self.outlet_name]

            # 找到下一個空行（從第3行開始）
            next_row = 3
            while ws.cell(row=next_row, column=1).value is not None:
                next_row += 1

            # 填入數據
            ws.cell(row=next_row, column=1, value=self.date_var.get().strip())
            ws.cell(
    row=next_row,
    column=2,
     value=self.category_var.get().strip())
            ws.cell(
    row=next_row,
    column=3,
     value=self.description_var.get().strip())
            ws.cell(row=next_row, column=4, value=self.item_var.get().strip())
            ws.cell(
    row=next_row,
    column=5,
     value=self.points_var.get().strip())
            ws.cell(row=next_row, column=6, value=deducted_by)
            ws.cell(row=next_row, column=7, value=self.notes_var.get().strip())

            # 保存文件
            wb.save(self.file_path)
            wb.close()

            messagebox.showinfo("成功", f"扣分記錄已保存到 {self.outlet_name}")

            # 刷新父窗口
            if self.refresh_callback:
                self.refresh_callback()

            self.destroy()

        except Exception as e:
            messagebox.showerror("錯誤", f"保存扣分記錄時發生錯誤：{str(e)}")


# ============================================================================
# Siahuat SOA 核对窗口 / Siahuat SOA Reconciliation Window
# ============================================================================

class SiahuatSOAWindow(ctk.CTkToplevel):
    """Siahuat专用的SOA核对弹窗"""

    def __init__(self, parent):
        super().__init__(parent)
        self.title("🏢 Siahuat SOA 核對系統 / Siahuat SOA Reconciliation System")
        self.geometry("1200x800")
        self.resizable(True, True)
        self.configure(fg_color=DARK_BG)

        # 居中显示
        self.center_window()

        # 创建界面
        self._setup_ui()

    def center_window(self):
        """居中显示窗口"""
        self.update_idletasks()
        x = (self.winfo_screenwidth() // 2) - (self.winfo_width() // 2)
        y = (self.winfo_screenheight() // 2) - (self.winfo_height() // 2)
        self.geometry(f"+{x}+{y}")

    def _setup_ui(self):
        """设置界面"""
        # 主容器
        main_frame = ctk.CTkFrame(self, fg_color="transparent")
        main_frame.pack(fill="both", expand=True, padx=20, pady=20)

        # 顶部标题区域
        header_frame = ctk.CTkFrame(
    main_frame,
    fg_color=DARK_PANEL,
     corner_radius=12)
        header_frame.pack(fill="x", pady=(0, 20))

        # 标题
        title_label = ctk.CTkLabel(
            header_frame,
            text="🏢 Siahuat SOA 核對系統\nSiahuat SOA Reconciliation System",
            font=("Microsoft YaHei", 20, "bold"),
            text_color=ACCENT_BLUE
        )
        title_label.pack(pady=20)

        # 副标题
        subtitle_label = ctk.CTkLabel(
            header_frame,
            text="針對思華達貿易的 PDF 和 SOA 數據進行核對\nReconcile PDF and SOA data specifically for Siahuat Trading",
            font=("Microsoft YaHei", 12),
            text_color="#cccccc"
        )
        subtitle_label.pack(pady=(0, 20))

        # SOA核对界面内容
        content_frame = ctk.CTkFrame(main_frame, fg_color="transparent")
        content_frame.pack(fill="both", expand=True)

        # 创建Siahuat专用的SOA核对UI
        self.soa_ui = SiahuatSOAUI(content_frame)
        self.soa_ui.pack(fill="both", expand=True)

        # 底部按钮区域
        bottom_frame = ctk.CTkFrame(main_frame, fg_color="transparent")
        bottom_frame.pack(fill="x", pady=(20, 0))

        # 关闭按钮
        close_btn = ctk.CTkButton(
            bottom_frame,
            text="❌ 關閉 / Close",
            font=("Microsoft YaHei", 12, "bold"),
            fg_color="#dc3545",
            hover_color="#c82333",
            width=120,
            height=40,
            command=self.destroy
        )
        close_btn.pack(side="right", padx=(10, 0))

        # 最终合并按钮
        final_merge_btn = ctk.CTkButton(
            bottom_frame,
            text="🔗 最終合併\nFinal Merge",
            font=("Microsoft YaHei", 12, "bold"),
            fg_color=ACCENT_GREEN,
            hover_color="#059669",
            width=120,
            height=40,
            command=self._create_final_merge
        )
        final_merge_btn.pack(side="right", padx=(0, 10))

        # 帮助按钮
        help_btn = ctk.CTkButton(
            bottom_frame,
            text="❓ 幫助 / Help",
            font=("Microsoft YaHei", 12),
            fg_color="#6c757d",
            hover_color="#5a6268",
            width=120,
            height=40,
            command=self._show_help
        )
        help_btn.pack(side="right", padx=(0, 10))

    def _show_help(self):
        """显示帮助信息"""
        help_text = """
🏢 Siahuat SOA 核對系統使用說明

1. 📁 選擇文件：
   • Invoices: 選擇 Siahuat 的發票 PDF 文件
   • SOA: 選擇對應的 SOA (Statement of Account) 文件

2. 🔄 開始核對：
   • 點擊 "開始核對" 按鈕執行自動比對
   • 系統會自動提取發票號碼和金額進行比對

3. 📊 查看結果：
   • 匹配項目會顯示為 ✅ 匹配
   • 不匹配項目會顯示差異金額
   • 可以導出 Excel 或 CSV 格式的報告

4. 🔧 OCR 智能修復：
   • 系統內建 OCR 錯誤修復功能
   • 自動修正常見的數字識別錯誤

注意事項：
• 確保 PDF 文件格式正確且清晰
• 建議使用高質量的 PDF 文件以獲得最佳效果
        """

        ScrollableMessageBox(self, "幫助 / Help", help_text.strip())


# ============================================================================
# Siahuat 專用 SOA UI / Siahuat Dedicated SOA UI
# ============================================================================

class SiahuatSOAUI(ctk.CTkFrame):
    """Siahuat專用的SOA核對界面"""
    
    def __init__(self, master):
        super().__init__(master, fg_color='transparent')
        self.invoice_path = None
        self.soa_path = None
        self.invoice_data = {}
        self.soa_data = {}
        self._build()
    
    def _build(self):
        """建立界面"""
        # 主要內容框架
        main_frame = ctk.CTkFrame(self, fg_color="transparent")
        main_frame.pack(fill="both", expand=True, padx=10, pady=10)
        
        # 文件選擇區域
        file_frame = ctk.CTkFrame(main_frame, fg_color=DARK_PANEL, corner_radius=12)
        file_frame.pack(fill="x", pady=(0, 20))
        
        # 標題
        title_label = ctk.CTkLabel(
            file_frame, 
            text="📁 文件選擇 / File Selection",
            font=("Microsoft YaHei", 16, "bold"),
            text_color=ACCENT_BLUE
        )
        title_label.pack(pady=(15, 10))
        
        # Invoice PDF 選擇
        invoice_frame = ctk.CTkFrame(file_frame, fg_color="transparent")
        invoice_frame.pack(fill="x", padx=20, pady=10)
        
        invoice_label = ctk.CTkLabel(
            invoice_frame,
            text="📄 Invoice PDF\n發票 PDF 文件",
            font=("Microsoft YaHei", 12, "bold"),
            text_color=ACCENT_GREEN
        )
        invoice_label.pack(side="left", padx=(0, 15))
        
        self.invoice_path_var = ctk.StringVar()
        invoice_entry = ctk.CTkEntry(
            invoice_frame,
            textvariable=self.invoice_path_var,
            placeholder_text="選擇 Siahuat Invoice PDF 文件...",
            font=("Microsoft YaHei", 11),
            width=300
        )
        invoice_entry.pack(side="left", fill="x", expand=True, padx=(0, 10))
        
        invoice_browse_btn = ctk.CTkButton(
            invoice_frame,
            text="瀏覽\nBrowse",
            font=("Microsoft YaHei", 10, "bold"),
            width=70,
            height=45,
            command=self._browse_invoice_file
        )
        invoice_browse_btn.pack(side="right")
        
        # SOA PDF 選擇
        soa_frame = ctk.CTkFrame(file_frame, fg_color="transparent")
        soa_frame.pack(fill="x", padx=20, pady=(10, 20))
        
        soa_label = ctk.CTkLabel(
            soa_frame,
            text="📊 SOA PDF\nStatement of Account",
            font=("Microsoft YaHei", 12, "bold"),
            text_color=ACCENT_ORANGE
        )
        soa_label.pack(side="left", padx=(0, 15))
        
        self.soa_path_var = ctk.StringVar()
        soa_entry = ctk.CTkEntry(
            soa_frame,
            textvariable=self.soa_path_var,
            placeholder_text="選擇 Siahuat SOA PDF 文件...",
            font=("Microsoft YaHei", 11),
            width=300
        )
        soa_entry.pack(side="left", fill="x", expand=True, padx=(0, 10))
        
        soa_browse_btn = ctk.CTkButton(
            soa_frame,
            text="瀏覽\nBrowse",
            font=("Microsoft YaHei", 10, "bold"),
            width=70,
            height=45,
            command=self._browse_soa_file
        )
        soa_browse_btn.pack(side="right")
        
        # 操作按鈕區域
        action_frame = ctk.CTkFrame(main_frame, fg_color="transparent")
        action_frame.pack(fill="x", pady=(0, 20))
        
        # 開始核對按鈕
        start_btn = ctk.CTkButton(
            action_frame,
            text="🔄 開始核對\nStart Reconciliation",
            font=("Microsoft YaHei", 14, "bold"),
            fg_color=ACCENT_GREEN,
            hover_color="#047857",
            width=200,
            height=60,
            command=self._start_reconciliation
        )
        start_btn.pack(side="left", padx=(0, 10))
        
        # 清空結果按鈕
        clear_btn = ctk.CTkButton(
            action_frame,
            text="🗑️ 清空結果\nClear Results",
            font=("Microsoft YaHei", 12, "bold"),
            fg_color="#6c757d",
            hover_color="#5a6268",
            width=120,
            height=45,
            command=self._clear_results
        )
        clear_btn.pack(side="left", padx=(0, 10))
        
        # 結果顯示區域
        result_frame = ctk.CTkFrame(main_frame, fg_color=DARK_PANEL, corner_radius=12)
        result_frame.pack(fill="both", expand=True)
        
        result_title = ctk.CTkLabel(
            result_frame,
            text="📊 核對結果 / Reconciliation Results",
            font=("Microsoft YaHei", 16, "bold"),
            text_color=ACCENT_BLUE
        )
        result_title.pack(pady=(15, 10))
        
        # 結果文本框
        self.result_text = ctk.CTkTextbox(
            result_frame,
            font=("Consolas", 11),
            wrap="word"
        )
        self.result_text.pack(fill="both", expand=True, padx=20, pady=(0, 20))
    
    def _browse_invoice_file(self):
        """瀏覽選擇 Invoice PDF 文件"""
        from tkinter import filedialog
        file_path = filedialog.askopenfilename(
            title="選擇 Siahuat Invoice PDF 文件",
            filetypes=[("PDF files", "*.pdf"), ("All files", "*.*")]
        )
        if file_path:
            self.invoice_path_var.set(file_path)
            self.invoice_path = file_path
            self._log(f"✅ 已選擇 Invoice PDF: {file_path}")
    
    def _browse_soa_file(self):
        """瀏覽選擇 SOA PDF 文件"""
        from tkinter import filedialog
        file_path = filedialog.askopenfilename(
            title="選擇 Siahuat SOA PDF 文件",
            filetypes=[("PDF files", "*.pdf"), ("All files", "*.*")]
        )
        if file_path:
            self.soa_path_var.set(file_path)
            self.soa_path = file_path
            self._log(f"✅ 已選擇 SOA PDF: {file_path}")
    
    def _start_reconciliation(self):
        """開始核對"""
        if not self.invoice_path or not self.soa_path:
            self._log("❌ 錯誤: 請先選擇 Invoice 和 SOA PDF 文件")
            return
        
        self._log("🔄 開始 Siahuat SOA 核對...")
        
        try:
            # 提取 Invoice 數據
            self._log("📄 正在提取 Invoice PDF 數據...")
            invoice_text = self._extract_pdf_text(self.invoice_path)
            self.invoice_data = self._extract_invoice_data(invoice_text)
            self._log(f"✅ Invoice 數據提取完成，找到 {len(self.invoice_data)} 條記錄")
            
            # 提取 SOA 數據
            self._log("📊 正在提取 SOA PDF 數據...")
            soa_text = self._extract_pdf_text(self.soa_path)
            self.soa_data = self._extract_soa_data(soa_text)
            self._log(f"✅ SOA 數據提取完成，找到 {len(self.soa_data)} 條記錄")
            
            # 進行核對
            self._log("🔍 正在進行數據核對...")
            self._perform_reconciliation()
            
        except Exception as e:
            self._log(f"❌ 核對過程發生錯誤: {str(e)}")
    
    def _extract_pdf_text(self, pdf_path):
        """提取 PDF 文字內容"""
        try:
            import pdfplumber
            text = ""
            with pdfplumber.open(pdf_path) as pdf:
                for page in pdf.pages:
                    page_text = page.extract_text()
                    if page_text:
                        text += page_text + "\n"
            return text
        except Exception as e:
            raise Exception(f"PDF 文字提取失敗: {str(e)}")
    
    def _extract_invoice_data(self, text):
        """從 Invoice PDF 提取數據 - 調用現有的 Siahuat 專用方法"""
        # 這裡調用現有的 SiahuatSOAWindow 中的方法
        # 我們需要找到這個方法並將其移到這裡或創建一個 helper 類
        return self._extract_invoice_data_siahuat(text)
    
    def _extract_soa_data(self, text):
        """從 SOA PDF 提取數據 - 調用現有的 Siahuat 專用方法"""
        # 這裡調用現有的 SiahuatSOAWindow 中的方法
        return self._extract_soa_data_siahuat(text)
    
    def _extract_invoice_data_siahuat(self, text):
        """從Invoice PDF提取Invoice號碼和Amount Due - 專門針對Siahuat模板優化"""
        data = {}
        try:
            import re
            
            print("🔍 DEBUG: === 開始提取Siahuat Invoice數據 ===")
            print(f"🔍 DEBUG: 輸入文本長度: {len(text)}")
            
            # ===== SIAHUAT SPECIFIC PATTERNS =====
            # 查找Invoice號碼模式 - Siahuat格式: INV-SH250604007
            inv_pattern = r'INV-SH\d+'
            inv_matches = re.findall(inv_pattern, text)
            print(f"🔍 DEBUG: 找到Siahuat Invoice號碼: {inv_matches}")
            
            if inv_matches:
                # 按行處理，查找包含Invoice號碼和金額的行
                lines = text.split('\n')
                for idx, line in enumerate(lines):
                    line = line.strip()
                    if line and 'INV-SH' in line:
                        # 提取Invoice號碼
                        inv_match = re.search(inv_pattern, line)
                        if inv_match:
                            inv = inv_match.group()
                            
                            # Siahuat格式的Amount Due查找
                            amount_patterns = [
                                r'Amount Due[:\s]*\$?(\d+\.?\d*)',
                                r'Total[:\s]*\$?(\d+\.?\d*)',
                                r'(\d+\.\d{2})'  # 最後備用的金額模式
                            ]
                            
                            amount_found = None
                            for pattern in amount_patterns:
                                matches = re.findall(pattern, line, re.IGNORECASE)
                                if matches:
                                    amount_found = matches[0]
                                    break
                            
                            if amount_found:
                                data[inv] = float(amount_found)
                                print(f"🔍 DEBUG: 找到匹配 {inv} -> ${amount_found}")
            
            return data
            
        except Exception as e:
            print(f"🔍 DEBUG: Siahuat Invoice數據提取失敗: {e}")
            return {}
    
    def _extract_soa_data_siahuat(self, text):
        """從SOA PDF提取Invoice號碼和Dr金額 - 專門針對Siahuat SOA模板優化"""
        data = {}
        try:
            import re
            
            print("🔍 DEBUG: 開始提取Siahuat SOA數據")
            
            # ===== SIAHUAT SOA SPECIFIC PATTERNS =====
            # 查找Invoice號碼模式 - Siahuat格式: INV-SH250603XXX
            inv_pattern = r'INV-SH\d+'
            inv_matches = re.findall(inv_pattern, text)
            print(f"🔍 DEBUG: 找到Siahuat SOA中的Invoice號碼: {inv_matches}")
            
            # 按行處理，查找包含Invoice號碼和Dr金額的行
            lines = text.split('\n')
            for idx, line in enumerate(lines):
                line = line.strip()
                if line and 'INV-SH' in line:
                    print(f"🔍 DEBUG: 處理Siahuat SOA行: {line}")
                    
                    # 提取Invoice號碼
                    inv_match = re.search(inv_pattern, line)
                    if inv_match:
                        inv = inv_match.group()
                        
                        # Siahuat SOA特定的Dr金額查找模式
                        dr_patterns = [
                            r'Dr\s*([\d,]+\.?\d*)\s*(?:$|Balance|Cr)',  # 明確抓 Dr 後金額
                            r'([\d,]+\.?\d*)\s*Dr',                      # 金額在前，接 Dr
                        ]
                        
                        dr_amount = None
                        for pattern in dr_patterns:
                            matches = re.findall(pattern, line)
                            if matches:
                                # 过滤掉行号等小数字，选择合理的金额
                                potential_amounts = []
                                for m in matches:
                                    try:
                                        num = float(m.replace(',', ''))
                                        # Siahuat的Dr金额通常在10-10000之间
                                        if 10 <= num <= 10000:
                                            potential_amounts.append(num)
                                    except ValueError:
                                        continue
                                
                                if potential_amounts:
                                    dr_amount = str(max(potential_amounts))
                                    print(f"🔍 DEBUG: Siahuat SOA使用模式 '{pattern}' 找到Dr金額: {dr_amount}")
                                    break
                        
                        if dr_amount:
                            data[inv] = float(dr_amount)
                            print(f"🔍 DEBUG: SOA匹配 {inv} -> Dr ${dr_amount}")
            
            return data
            
        except Exception as e:
            print(f"🔍 DEBUG: Siahuat SOA數據提取失敗: {e}")
            return {}
    
    def _perform_reconciliation(self):
        """執行核對"""
        self._log("\n" + "="*60)
        self._log("📊 核對結果摘要 / Reconciliation Summary")
        self._log("="*60)
        
        matched = 0
        unmatched_invoice = 0
        unmatched_soa = 0
        
        # 比對 Invoice 和 SOA 數據
        for inv_no, inv_amount in self.invoice_data.items():
            if inv_no in self.soa_data:
                soa_amount = self.soa_data[inv_no]
                if abs(inv_amount - soa_amount) < 0.01:  # 允許微小差異
                    self._log(f"✅ {inv_no}: Invoice ${inv_amount:.2f} = SOA ${soa_amount:.2f}")
                    matched += 1
                else:
                    self._log(f"⚠️ {inv_no}: Invoice ${inv_amount:.2f} ≠ SOA ${soa_amount:.2f} (差異: ${abs(inv_amount - soa_amount):.2f})")
                    matched += 1  # 仍然算匹配，只是金額不同
            else:
                self._log(f"❌ {inv_no}: 只在 Invoice 中找到 (${inv_amount:.2f})")
                unmatched_invoice += 1
        
        # 找出只在 SOA 中的項目
        for inv_no, soa_amount in self.soa_data.items():
            if inv_no not in self.invoice_data:
                self._log(f"❌ {inv_no}: 只在 SOA 中找到 (${soa_amount:.2f})")
                unmatched_soa += 1
        
        # 統計摘要
        self._log("\n" + "-"*40)
        self._log("📈 統計摘要 / Statistics Summary")
        self._log("-"*40)
        self._log(f"✅ 匹配項目: {matched}")
        self._log(f"❌ 只在 Invoice: {unmatched_invoice}")
        self._log(f"❌ 只在 SOA: {unmatched_soa}")
        self._log(f"📊 總計: {matched + unmatched_invoice + unmatched_soa}")
        
        if matched > 0 and unmatched_invoice == 0 and unmatched_soa == 0:
            self._log("\n🎉 核對完成！所有項目都匹配成功！")
        else:
            self._log(f"\n⚠️ 核對完成，發現 {unmatched_invoice + unmatched_soa} 個不匹配項目")
    
    def _clear_results(self):
        """清空結果"""
        self.result_text.delete("1.0", "end")
        self.invoice_data = {}
        self.soa_data = {}
        self._log("🗑️ 結果已清空")
    
    def _log(self, message):
        """記錄日誌到結果文本框"""
        from datetime import datetime
        timestamp = datetime.now().strftime("%H:%M:%S")
        log_message = f"[{timestamp}] {message}\n"
        self.result_text.insert("end", log_message)
        self.result_text.see("end")
        print(log_message.strip())


# ============================================================================
# Monthend Consolidate 窗口 / Monthend Consolidate Window
# ============================================================================


# ============================================================================
# 旧的MonthendConsolidateWindow类已删除
# 现在使用oriental_monthend.py中的OrientalMonthendWindow类
# ============================================================================

class SOAReconciliationUI(ctk.CTkFrame):
    """月結檢查功能界面 - 支持多廠商統一處理"""
    
    def __init__(self, master):
        super().__init__(master, fg_color='transparent')
        self.pdf_files = {}  # {廠商名稱: {path: pdf路徑, data: 提取的數據}}
        self.excel_data = {}  # 存储Excel数据
        self.config_data = {}  # 存储配置映射数据
        self._build()
    
    def _build(self):
        """构建Oriental月結檢查界面"""
        # 主要功能区域 - 添加渐变边框效果
        main_frame = ctk.CTkFrame(self, fg_color=DARK_PANEL, corner_radius=20)
        main_frame.pack(fill="both", expand=True, padx=25, pady=(10, 15))
        
        # 添加标题区域
        title_frame = ctk.CTkFrame(main_frame, fg_color='transparent')
        title_frame.pack(fill='x', padx=25, pady=(20, 25))
        
        ctk.CTkLabel(
            title_frame,
            text="🌟 多廠商月結檢查系統",
            font=("Microsoft YaHei", 22, "bold"),
            text_color=ACCENT_GREEN
        ).pack(anchor='center')
        
        ctk.CTkLabel(
            title_frame,
            text="Multi-Vendor Month-End Check System",
            font=("Segoe UI", 14),
            text_color=TEXT_COLOR
        ).pack(anchor='center', pady=(5, 0))
        
        # 内容区域
        content_frame = ctk.CTkFrame(main_frame, fg_color='transparent')
        content_frame.pack(fill='both', expand=True, padx=25, pady=(0, 20))
        
        # 左侧：文件选择区域 - 添加卡片式设计
        left_frame = ctk.CTkFrame(content_frame, fg_color='transparent')
        left_frame.pack(side='left', fill='both', expand=True, padx=(0, 15))
        
        # PDF文件选择 - 卡片式设计
        pdf_frame = ctk.CTkFrame(left_frame, fg_color=DARK_BG, corner_radius=15)
        pdf_frame.pack(fill='x', pady=(0, 20))
        
        # 添加图标和标题
        pdf_header = ctk.CTkFrame(pdf_frame, fg_color='transparent')
        pdf_header.pack(fill='x', padx=20, pady=(15, 10))
        
        ctk.CTkLabel(
            pdf_header,
            text="📄",
            font=("Segoe UI", 24)
        ).pack(side='left')
        
        ctk.CTkLabel(
            pdf_header,
            text="多廠商PDF文件 / Multi-Vendor PDF Files",
            font=("Microsoft YaHei", 16, "bold"),
            text_color=ACCENT_GREEN
        ).pack(side='left', padx=(10, 0))
        
        # 創建三個廠商的PDF選擇區域
        self.pdf_widgets = {}
        vendors = [
            ("Oriental", "🍜", "#10b981"),
            ("Aries Fresh", "🥬", "#059669"), 
            ("Ever-Shine", "✨", "#3b82f6")  # 藍色，表示啟用
        ]
        
        for vendor, icon, color in vendors:
            vendor_frame = ctk.CTkFrame(pdf_frame, fg_color='transparent')
            vendor_frame.pack(fill='x', padx=20, pady=(5, 10))
            
            # 廠商標籤
            vendor_label_frame = ctk.CTkFrame(vendor_frame, fg_color='transparent')
            vendor_label_frame.pack(fill='x', pady=(0, 5))
            
            ctk.CTkLabel(
                vendor_label_frame,
                text=f"{icon} {vendor}",
                font=("Microsoft YaHei", 12, "bold"),
                text_color=color
            ).pack(side='left')
            
            # PDF選擇控件
            pdf_input_frame = ctk.CTkFrame(vendor_frame, fg_color='transparent')
            pdf_input_frame.pack(fill='x')
            
            path_var = ctk.StringVar()
            entry = ctk.CTkEntry(
                pdf_input_frame,
                textvariable=path_var,
                placeholder_text=f"選擇 {vendor} PDF文件",
                font=FONT_SMALL,
                height=30,
                corner_radius=6
            )
            entry.pack(side='left', fill='x', expand=True)
            
            browse_btn = ctk.CTkButton(
                pdf_input_frame,
                text="瀏覽\nBrowse",
                command=lambda v=vendor: self._browse_vendor_pdf(v),
                width=70,
                height=45,  # 增加高度以適應雙行文本
                font=FONT_SMALL,
                corner_radius=6,
                fg_color=color,
                hover_color=color
            )
            browse_btn.pack(side='left', padx=(5, 0))
            
            extract_btn = ctk.CTkButton(
                pdf_input_frame,
                text="提取\nExtract",
                command=lambda v=vendor: self._extract_vendor_pdf(v),
                width=70,
                height=45,  # 增加高度以適應雙行文本
                font=FONT_SMALL,
                corner_radius=6,
                fg_color=ACCENT_BLUE,
                hover_color="#2563eb"
            )
            extract_btn.pack(side='left', padx=(5, 0))
            
            # 儲存控件引用
            self.pdf_widgets[vendor] = {
                'path_var': path_var,
                'entry': entry,
                'browse_btn': browse_btn,
                'extract_btn': extract_btn,
                'enabled': True  # 所有廠商都啟用
            }
            
            # 所有廠商都啟用
            # if vendor == "Ever-Shine":
            #     entry.configure(state="disabled")
            #     browse_btn.configure(state="disabled")
            #     extract_btn.configure(state="disabled")
        
        # Consolidate Excel文件选择 - 卡片式设计
        excel_frame = ctk.CTkFrame(left_frame, fg_color=DARK_BG, corner_radius=15)
        excel_frame.pack(fill='x', pady=(0, 20))
        
        excel_header = ctk.CTkFrame(excel_frame, fg_color='transparent')
        excel_header.pack(fill='x', padx=20, pady=(15, 10))
        
        ctk.CTkLabel(
            excel_header,
            text="📊",
            font=("Segoe UI", 24)
        ).pack(side='left')
        
        ctk.CTkLabel(
            excel_header,
            text="Consolidate Excel\n合併Excel文件",
            font=("Microsoft YaHei", 16, "bold"),
            text_color=ACCENT_BLUE
        ).pack(side='left', padx=(10, 0))
        
        excel_file_frame = ctk.CTkFrame(excel_frame, fg_color='transparent')
        excel_file_frame.pack(fill='x', padx=20, pady=(0, 15))
        
        self.excel_path_var = ctk.StringVar()
        ctk.CTkEntry(
            excel_file_frame,
            textvariable=self.excel_path_var,
            placeholder_text="選擇Consolidate Excel文件 / Select Consolidate Excel file",
            font=FONT_MID,
            height=35,
            corner_radius=8
        ).pack(side='left', fill='x', expand=True)
        
        ctk.CTkButton(
            excel_file_frame,
            text="瀏覽\nBrowse",
            command=self._browse_excel,
            fg_color=ACCENT_BLUE,
            hover_color=BTN_HOVER,
            font=FONT_MID,
            width=80,
            height=45,  # 增加高度以適應雙行文本
            corner_radius=8
        ).pack(side='right', padx=(10, 0))
        
        # Excel智能讀取按鈕
        excel_read_frame = ctk.CTkFrame(excel_frame, fg_color='transparent')
        excel_read_frame.pack(fill='x', padx=20, pady=(0, 15))
        
        ctk.CTkButton(
            excel_read_frame,
            text="📊 智能讀取Excel\nSmart Read Excel",
            command=self._read_excel_smart_ui,
            fg_color=ACCENT_BLUE,
            hover_color=BTN_HOVER,
            font=FONT_MID,
            height=55,  # 增加高度以適應雙行文本
            corner_radius=12
        ).pack(fill='x')
        
        # Config Excel文件选择 - 卡片式设计
        config_frame = ctk.CTkFrame(left_frame, fg_color=DARK_BG, corner_radius=15)
        config_frame.pack(fill='x', pady=(0, 25))
        
        config_header = ctk.CTkFrame(config_frame, fg_color='transparent')
        config_header.pack(fill='x', padx=20, pady=(15, 10))
        
        ctk.CTkLabel(
            config_header,
            text="⚙️",
            font=("Segoe UI", 24)
        ).pack(side='left')
        
        ctk.CTkLabel(
            config_header,
            text="Config Excel\n配置Excel文件",
            font=("Microsoft YaHei", 16, "bold"),
            text_color=ACCENT_PURPLE
        ).pack(side='left', padx=(10, 0))
        
        config_file_frame = ctk.CTkFrame(config_frame, fg_color='transparent')
        config_file_frame.pack(fill='x', padx=20, pady=(0, 15))
        
        self.config_path_var = ctk.StringVar()
        ctk.CTkEntry(
            config_file_frame,
            textvariable=self.config_path_var,
            placeholder_text="選擇Config Excel文件 / Select Config Excel file",
            font=FONT_MID,
            height=35,
            corner_radius=8
        ).pack(side='left', fill='x', expand=True)
        
        ctk.CTkButton(
            config_file_frame,
            text="瀏覽\nBrowse",
            command=self._browse_config,
            fg_color=ACCENT_PURPLE,
            hover_color=BTN_HOVER,
            font=FONT_MID,
            width=80,
            height=45,  # 增加高度以適應雙行文本
            corner_radius=8
        ).pack(side='right', padx=(10, 0))
        
        # 功能按钮区域 - 美化按钮设计
        button_frame = ctk.CTkFrame(left_frame, fg_color='transparent')
        button_frame.pack(fill='x', pady=(0, 20))
        
        # 匹配并更新/对比按钮
        compare_btn = ctk.CTkButton(
            button_frame,
            text="🔄 多廠商匹配對比\nMulti-Vendor Match & Compare",
            command=self._update_and_compare_ui,
            fg_color=ACCENT_RED,
            hover_color=BTN_HOVER,
            font=FONT_MID,
            height=55,  # 增加高度以適應雙行文本
            corner_radius=12
        )
        compare_btn.pack(fill='x', pady=(0, 0))
        
        # 右侧：日志显示区域 - 美化标签页和日志区域
        right_frame = ctk.CTkFrame(content_frame, fg_color='transparent')
        right_frame.pack(side='right', fill='both', expand=True, padx=(15, 0))
        
        # 日志标题
        log_title = ctk.CTkLabel(
            right_frame,
            text="📋 操作日誌 / Operation Logs",
            font=("Microsoft YaHei", 18, "bold"),
            text_color=ACCENT_BLUE
        )
        log_title.pack(anchor='w', pady=(0, 15))
        
        # 标签页 - 美化设计
        self.tabview = ctk.CTkTabview(right_frame, fg_color=DARK_BG, corner_radius=15)
        self.tabview.pack(fill="both", expand=True)
        
        # 操作日志标签页
        self.tabview.add("📝 操作日誌\nOperation Log")
        self.operation_log = ctk.CTkTextbox(
            self.tabview.tab("📝 操作日誌\nOperation Log"),
            fg_color=TEXTBOX_BG,
            text_color=TEXT_COLOR,
            font=FONT_LOG,
            corner_radius=10
        )
        self.operation_log.pack(fill="both", expand=True, padx=15, pady=15)
        
        # 对比日志标签页
        self.tabview.add("🔍 對比日誌\nComparison Log")
        self.comparison_log = ctk.CTkTextbox(
            self.tabview.tab("🔍 對比日誌\nComparison Log"),
            fg_color=TEXTBOX_BG,
            text_color=TEXT_COLOR,
            font=FONT_LOG,
            corner_radius=10
        )
        self.comparison_log.pack(fill="both", expand=True, padx=15, pady=15)
        
        # 清空日志按钮 - 美化设计
        clear_button = ctk.CTkButton(
            right_frame,
            text="🧹 清空日誌\nClear Logs",
            command=self._clear_logs,
            fg_color=ACCENT_ORANGE,
            hover_color=BTN_HOVER,
            font=FONT_MID,
            height=35,
            corner_radius=10
        )
        clear_button.pack(side='bottom', pady=(15, 0))
        
        # 添加數據顯示區域（與pdf_extractor_ui_simple.py相同的格式）
        data_frame = ctk.CTkFrame(content_frame, fg_color='transparent')
        data_frame.pack(fill='both', expand=True, pady=(20, 0))
        
        # 數據顯示標題
        data_title = ctk.CTkLabel(
            data_frame,
            text="📊 數據顯示 / Data Display",
            font=("Microsoft YaHei", 18, "bold"),
            text_color=ACCENT_GREEN
        )
        data_title.pack(anchor='w', pady=(0, 15))
        
        # 創建標籤頁區域
        self._create_results_table(data_frame)
    
    def _create_results_table(self, parent):
        """創建與pdf_extractor_ui_simple.py完全相同的標籤頁格式"""
        # 創建標籤頁控件
        self.notebook = ctk.CTkTabview(parent, fg_color=DARK_BG, corner_radius=15)
        self.notebook.pack(fill="both", expand=True, pady=10)
        
        # 創建各個標籤頁
        self._create_key_data_tab()
        self._create_invoices_tab()
        self._create_excel_data_tab()
        self._create_details_tab()
        self._create_raw_text_tab()
        self._create_compare_log_tab()
    
    def _create_key_data_tab(self):
        """創建關鍵數據標籤頁 - 與pdf_extractor_ui_simple.py完全相同的格式"""
        # CTkTabview 的語法：先 add，再設置 text
        tab_name = "關鍵數據\nKey Data"
        self.notebook.add(tab_name)
        frame = self.notebook.tab(tab_name)
        
        # 創建樹形視圖
        import tkinter.ttk as ttk
        columns = ('門市名稱', '賬齡金額', '發票數量', '行號')
        self.key_data_tree = ttk.Treeview(frame, columns=columns, show='headings', height=15)
        
        # 設置列標題
        for col in columns:
            self.key_data_tree.heading(col, text=col)
            self.key_data_tree.column(col, width=150)
        
        # 添加滾動條
        scrollbar = ttk.Scrollbar(frame, orient='vertical', command=self.key_data_tree.yview)
        self.key_data_tree.configure(yscrollcommand=scrollbar.set)
        
        # 布局
        self.key_data_tree.pack(side='left', fill='both', expand=True)
        scrollbar.pack(side='right', fill='y')
    
    def _create_invoices_tab(self):
        """創建發票信息標籤頁 - 與pdf_extractor_ui_simple.py完全相同的格式"""
        tab_name = "發票信息\nInvoice Information"
        self.notebook.add(tab_name)
        frame = self.notebook.tab(tab_name)
        
        # 創建樹形視圖
        import tkinter.ttk as ttk
        columns = ('門市名稱', '日期', '發票號', '金額', '餘額', '賬齡金額')
        self.invoices_tree = ttk.Treeview(frame, columns=columns, show='headings', height=15)
        
        # 設置列標題
        for col in columns:
            self.invoices_tree.heading(col, text=col)
            if col in ['金額', '餘額', '賬齡金額']:
                self.invoices_tree.column(col, width=100)
            else:
                self.invoices_tree.column(col, width=120)
        
        # 添加滾動條
        scrollbar = ttk.Scrollbar(frame, orient='vertical', command=self.invoices_tree.yview)
        self.invoices_tree.configure(yscrollcommand=scrollbar.set)
        
        # 布局
        self.invoices_tree.pack(side='left', fill='both', expand=True)
        scrollbar.pack(side='right', fill='y')
    
    def _create_excel_data_tab(self):
        """創建Excel數據標籤頁 - 與pdf_extractor_ui_simple.py完全相同的格式"""
        tab_name = "Excel數據\nExcel Data"
        self.notebook.add(tab_name)
        frame = self.notebook.tab(tab_name)
        
        # 創建樹形視圖
        import tkinter.ttk as ttk
        columns = ('門市名稱', '行號', '日期', '金額')
        self.excel_data_tree = ttk.Treeview(frame, columns=columns, show='headings', height=15)
        
        # 設置列標題
        for col in columns:
            self.excel_data_tree.heading(col, text=col)
            if col == '金額':
                self.excel_data_tree.column(col, width=100)
            else:
                self.excel_data_tree.column(col, width=120)
        
        # 添加滾動條
        scrollbar = ttk.Scrollbar(frame, orient='vertical', command=self.excel_data_tree.yview)
        self.excel_data_tree.configure(yscrollcommand=scrollbar.set)
        
        # 布局
        self.excel_data_tree.pack(side='left', fill='both', expand=True)
        scrollbar.pack(side='right', fill='y')
    
    def _create_details_tab(self):
        """創建詳細信息標籤頁 - 與pdf_extractor_ui_simple.py完全相同的格式"""
        tab_name = "詳細信息\nDetailed Information"
        self.notebook.add(tab_name)
        frame = self.notebook.tab(tab_name)
        
        # 創建文本區域
        self.details_text = ctk.CTkTextbox(
            frame, 
            fg_color=TEXTBOX_BG,
            text_color=TEXT_COLOR,
            font=FONT_LOG,
            corner_radius=10
        )
        
        # 添加滾動條
        scrollbar = ctk.CTkScrollbar(frame, command=self.details_text.yview)
        self.details_text.configure(yscrollcommand=scrollbar.set)
        
        # 布局
        self.details_text.pack(side='left', fill='both', expand=True)
        scrollbar.pack(side='right', fill='y')
    
    def _create_raw_text_tab(self):
        """創建原始文本標籤頁 - 與pdf_extractor_ui_simple.py完全相同的格式"""
        tab_name = "原始文本\nRaw Text"
        self.notebook.add(tab_name)
        frame = self.notebook.tab(tab_name)
        
        # 創建文本區域
        self.raw_text = ctk.CTkTextbox(
            frame, 
            fg_color=TEXTBOX_BG,
            text_color=TEXT_COLOR,
            font=FONT_LOG,
            corner_radius=10
        )
        
        # 添加滾動條
        scrollbar = ctk.CTkScrollbar(frame, command=self.raw_text.yview)
        self.raw_text.configure(yscrollcommand=scrollbar.set)
        
        # 布局
        self.raw_text.pack(side='left', fill='both', expand=True)
        scrollbar.pack(side='right', fill='y')
    
    def _create_compare_log_tab(self):
        """創建對比日誌標籤頁 - 與pdf_extractor_ui_simple.py完全相同的格式"""
        tab_name = "對比日誌\nComparison Log"
        self.notebook.add(tab_name)
        frame = self.notebook.tab(tab_name)
        
        # 創建文本區域
        self.compare_log = ctk.CTkTextbox(
            frame, 
            fg_color=TEXTBOX_BG,
            text_color=TEXT_COLOR,
            font=FONT_LOG,
            corner_radius=10
        )
        
        # 添加滾動條
        scrollbar = ctk.CTkScrollbar(frame, command=self.compare_log.yview)
        self.compare_log.configure(yscrollcommand=scrollbar.set)
        
        # 布局
        self.compare_log.pack(side='left', fill='both', expand=True)
        scrollbar.pack(side='right', fill='y')
    

    
    def _browse_vendor_pdf(self, vendor):
        """瀏覽特定廠商的PDF文件"""
        file_path = filedialog.askopenfilename(
            title=f"選擇 {vendor} PDF文件",
            filetypes=[("PDF files", "*.pdf"), ("All files", "*.*")]
        )
        if file_path:
            self.pdf_widgets[vendor]['path_var'].set(file_path)
            # 初始化PDF文件數據結構
            if vendor not in self.pdf_files:
                self.pdf_files[vendor] = {'path': '', 'data': None}
            self.pdf_files[vendor]['path'] = file_path
    
    def _extract_vendor_pdf(self, vendor):
        """提取特定廠商的PDF數據"""
        if vendor not in self.pdf_widgets:
            self._log(f"❌ 廠商 {vendor} 不存在")
            return
            
        if not self.pdf_widgets[vendor]['enabled']:
            self._log(f"❌ 廠商 {vendor} 暫時不支援")
            return
            
        pdf_path = self.pdf_widgets[vendor]['path_var'].get().strip()
        if not pdf_path:
            self._log(f"❌ 請先選擇 {vendor} PDF文件")
            return
            
        self._log(f"🔍 開始提取 {vendor} PDF數據...")
        
        try:
            if vendor == "Oriental":
                pdf_data = self._extract_oriental_pdf(pdf_path)
            elif vendor == "Aries Fresh":
                pdf_data = self._extract_aries_fresh_pdf(pdf_path)
            elif vendor == "Ever-Shine":
                pdf_data = self._extract_evershine_pdf(pdf_path)
            else:
                self._log(f"❌ 不支持的廠商: {vendor}")
                return
                
            if pdf_data and isinstance(pdf_data, dict):
                self.pdf_files[vendor] = {'path': pdf_path, 'data': pdf_data}
                self._log(f"✅ {vendor} PDF數據提取完成！")
                self._log(f"🏪 發現 {len(pdf_data.get('outlets', []))} 個門市")
                self._log(f"📄 發現 {len(pdf_data.get('invoices', []))} 張發票")
                
                # 更新對應標籤頁
                self._update_all_tabs()
            else:
                self._log(f"❌ {vendor} PDF數據提取失敗")
                
        except Exception as e:
            self._log(f"❌ {vendor} PDF提取失敗: {str(e)}")
    
    def _browse_pdf(self):
        """舊的浏览PDF文件方法 - 保留向後兼容"""
        self._browse_vendor_pdf("Oriental")
    
    def _browse_excel(self):
        """浏览Consolidate Excel文件"""
        file_path = filedialog.askopenfilename(
            title="選擇Consolidate Excel文件 / Select Consolidate Excel file",
            filetypes=[("Excel files", "*.xlsx *.xls"), ("All files", "*.*")]
        )
        if file_path:
            self.excel_path_var.set(file_path)
    
    def _browse_config(self):
        """浏览Config Excel文件"""
        file_path = filedialog.askopenfilename(
            title="選擇Config Excel文件 / Select Config Excel file",
            filetypes=[("Excel files", "*.xlsx *.xls"), ("All files", "*.*")]
        )
        if file_path:
            self.config_path_var.set(file_path)
    

    
    def _update_all_tabs(self):
        """更新所有標籤頁數據 - 支持多廠商數據合併顯示"""
        # 清空所有標籤頁
        self._clear_all_tabs()
        
        # 合併所有廠商的數據來顯示
        all_outlets = []
        all_invoices = []
        all_raw_text = []
        
        for vendor, data_info in self.pdf_files.items():
            if 'data' in data_info:
                pdf_data = data_info['data']
                
                # 收集門市數據（添加廠商標識）
                for outlet in pdf_data.get('outlets', []):
                    outlet_copy = outlet.copy()
                    outlet_copy['vendor'] = vendor
                    all_outlets.append(outlet_copy)
                
                # 收集發票數據（添加廠商標識）
                for invoice in pdf_data.get('invoices', []):
                    invoice_copy = invoice.copy()
                    invoice_copy['vendor'] = vendor
                    all_invoices.append(invoice_copy)
                
                # 收集原始文本
                raw_text = pdf_data.get('raw_text', '')
                if raw_text:
                    all_raw_text.append(f"=== {vendor} ===\n{raw_text}")
        
        # 更新各個標籤頁
        self._update_key_data_tab_multi(all_outlets)
        self._update_invoices_tab_multi(all_invoices)
        self._update_details_tab_multi()
        self._update_raw_text_tab_multi(all_raw_text)
    
    def _clear_all_tabs(self):
        """清空所有標籤頁數據"""
        # 清空關鍵數據
        for item in self.key_data_tree.get_children():
            self.key_data_tree.delete(item)
        
        # 清空發票信息
        for item in self.invoices_tree.get_children():
            self.invoices_tree.delete(item)
        
        # 清空詳細信息
        self.details_text.delete("0.0", "end")
        
        # 清空原始文本
        self.raw_text.delete("0.0", "end")
    
    def _update_key_data_tab_multi(self, all_outlets):
        """更新關鍵數據標籤頁 - 多廠商版本"""
        for outlet in all_outlets:
            # 計算該門市的發票數量
            vendor = outlet.get('vendor', 'Unknown')
            invoice_count = 0
            if vendor in self.pdf_files and 'data' in self.pdf_files[vendor]:
                invoice_count = len([inv for inv in self.pdf_files[vendor]['data'].get('invoices', []) 
                                   if inv.get('outlet_name') == outlet['name']])
            
            self.key_data_tree.insert('', 'end', values=(
                f"[{vendor}] {outlet['name']}",
                f"${outlet['aging_amount']:.2f}",
                invoice_count,
                outlet.get('location', 'N/A')
            ))
    
    def _update_invoices_tab_multi(self, all_invoices):
        """更新發票信息標籤頁 - 多廠商版本"""
        for invoice in all_invoices:
            vendor = invoice.get('vendor', 'Unknown')
            self.invoices_tree.insert('', 'end', values=(
                f"[{vendor}] {invoice.get('outlet_name', 'N/A')}",
                invoice.get('date', 'N/A'),
                invoice.get('invoice_no', 'N/A'),
                f"${invoice.get('amount', 0):.2f}",
                f"${invoice.get('balance', 0):.2f}" if invoice.get('balance') else 'N/A',
                f"${invoice.get('outlet_aging_amount', 0):.2f}"
            ))
    
    def _update_details_tab_multi(self):
        """更新詳細信息標籤頁 - 多廠商版本"""
        details = f"多廠商PDF數據摘要\n"
        details += "="*50 + "\n\n"
        
        total_outlets = 0
        total_invoices = 0
        total_amount = 0.0
        
        for vendor, data_info in self.pdf_files.items():
            if 'data' in data_info:
                pdf_data = data_info['data']
                vendor_outlets = len(pdf_data.get('outlets', []))
                vendor_invoices = len(pdf_data.get('invoices', []))
                vendor_amount = sum(inv['amount'] for inv in pdf_data.get('invoices', []) if inv.get('amount'))
                
                details += f"📋 {vendor}:\n"
                details += f"  門市數: {vendor_outlets}\n"
                details += f"  發票數: {vendor_invoices}\n"
                details += f"  總金額: ${vendor_amount:.2f}\n\n"
                
                total_outlets += vendor_outlets
                total_invoices += vendor_invoices
                total_amount += vendor_amount
        
        details += "-" * 30 + "\n"
        details += f"📊 總計:\n"
        details += f"  總門市數: {total_outlets}\n"
        details += f"  總發票數: {total_invoices}\n"
        details += f"  總金額: ${total_amount:.2f}\n"
        if total_invoices > 0:
            details += f"  平均發票金額: ${total_amount/total_invoices:.2f}\n"
        
        self.details_text.insert("0.0", details)
    
    def _update_raw_text_tab_multi(self, all_raw_text):
        """更新原始文本標籤頁 - 多廠商版本"""
        combined_text = "\n\n".join(all_raw_text)
        self.raw_text.insert("0.0", combined_text)
    
    def _update_key_data_tab(self):
        """更新關鍵數據標籤頁 - 與pdf_extractor_ui_simple.py完全相同的邏輯"""
        if not self.pdf_data or 'outlets' not in self.pdf_data:
            return
        
        # 清空現有數據
        for item in self.key_data_tree.get_children():
            self.key_data_tree.delete(item)
        
        # 添加新數據
        for outlet in self.pdf_data['outlets']:
            # 計算該門市的發票數量
            invoice_count = len([inv for inv in self.pdf_data.get('invoices', []) 
                               if inv.get('outlet_name') == outlet['name']])
            
            self.key_data_tree.insert('', 'end', values=(
                outlet['name'],
                f"${outlet['aging_amount']:.2f}",
                invoice_count,
                outlet['line_number']
            ))
    
    def _update_invoices_tab(self):
        """更新發票信息標籤頁 - 與pdf_extractor_ui_simple.py完全相同的邏輯"""
        if not self.pdf_data or 'invoices' not in self.pdf_data:
            return
        
        # 清空現有數據
        for item in self.invoices_tree.get_children():
            self.invoices_tree.delete(item)
        
        # 添加新數據
        for invoice in self.pdf_data['invoices']:
            self.invoices_tree.insert('', 'end', values=(
                invoice.get('outlet_name', 'N/A'),
                invoice.get('date', 'N/A'),
                invoice.get('invoice_no', 'N/A'),
                f"${invoice.get('amount', 0):.2f}",
                f"${invoice.get('balance', 0):.2f}" if invoice.get('balance') else 'N/A',
                f"${invoice.get('outlet_aging_amount', 0):.2f}"
            ))
    
    def _update_details_tab(self):
        """更新詳細信息標籤頁 - 與pdf_extractor_ui_simple.py完全相同的邏輯"""
        if not self.pdf_data:
            return
        
        # 清空現有內容
        self.details_text.delete("0.0", "end")
        
        # 添加摘要信息
        details = f"PDF數據摘要\n"
        details += "="*50 + "\n\n"
        details += f"門市總數: {len(self.pdf_data.get('outlets', []))}\n"
        details += f"發票總數: {len(self.pdf_data.get('invoices', []))}\n"
        
        if 'invoices' in self.pdf_data and self.pdf_data['invoices']:
            total_amount = sum(inv['amount'] for inv in self.pdf_data['invoices'] if inv['amount'])
            avg_amount = total_amount / len(self.pdf_data['invoices']) if self.pdf_data['invoices'] else 0
            details += f"發票總金額: ${total_amount:.2f}\n"
            details += f"平均發票金額: ${avg_amount:.2f}\n"
        
        details += "\n門市詳細信息:\n"
        details += "-" * 30 + "\n"
        
        for outlet in self.pdf_data.get('outlets', []):
            details += f"門市: {outlet['name']}\n"
            details += f"  賬齡金額: ${outlet['aging_amount']:.2f}\n"
            details += f"  行號: {outlet['line_number']}\n"
            details += f"  完整名稱: {outlet['full_name']}\n\n"
        
        self.details_text.insert("0.0", details)
    
    def _update_excel_data_tab(self):
        """更新Excel數據標籤頁 - 支持多廠商"""
        if not self.excel_data:
            return
        
        # 清空現有數據
        for item in self.excel_data_tree.get_children():
            self.excel_data_tree.delete(item)
        
        # 處理多廠商數據
        if isinstance(self.excel_data, dict):
            # 新格式：多廠商數據 {vendor: {outlets, dates, ...}}
            for vendor, vendor_data in self.excel_data.items():
                if 'outlets' in vendor_data and 'dates' in vendor_data:
                    for outlet in vendor_data['outlets']:
                        for date_info in vendor_data['dates']:
                            amount = outlet['daily_data'].get(date_info['date'], 0)
                            if amount > 0:  # 只顯示有金額的日期
                                self.excel_data_tree.insert('', 'end', values=(
                                    f"[{vendor}] {outlet['name']}",
                                    outlet['row'],
                                    date_info['date'],
                                    f"${amount:.2f}"
                                ))
        else:
            # 舊格式：單廠商數據（向後兼容）
            if 'outlets' in self.excel_data:
                for outlet in self.excel_data['outlets']:
                    for date_info in self.excel_data['dates']:
                        amount = outlet['daily_data'].get(date_info['date'], 0)
                        if amount > 0:  # 只顯示有金額的日期
                            self.excel_data_tree.insert('', 'end', values=(
                                outlet['name'],
                                outlet['row'],
                                date_info['date'],
                                f"${amount:.2f}"
                            ))
    
    def _update_raw_text_tab(self):
        """更新原始文本標籤頁 - 與pdf_extractor_ui_simple.py完全相同的邏輯"""
        if not self.pdf_data or 'raw_text' not in self.pdf_data:
            return
        
        # 清空現有內容
        self.raw_text.delete("0.0", "end")
        
        # 添加原始文本
        self.raw_text.insert("0.0", self.pdf_data['raw_text'])
    
    def _extract_oriental_pdf(self, pdf_path):
        """
        從Oriental PDF中提取關鍵數據：門市名稱、發票信息、賬齡金額
        多重備用提取方法：pdfplumber -> PyPDF2 -> OCR
        """
        self._log(f"🚀 開始提取PDF關鍵數據: {pdf_path}")
        
        all_text = ""
        
        # 方法1: pdfplumber (主要方法)
        try:
            import pdfplumber
            with pdfplumber.open(pdf_path) as pdf:
                self._log(f"📄 PDF已打開，共 {len(pdf.pages)} 頁")
                
                for page_num, page in enumerate(pdf.pages, 1):
                    self._log(f"📄 正在處理第 {page_num} 頁...")
                    
                    page_text = page.extract_text()
                    if page_text:
                        all_text += f"\n--- 第 {page_num} 頁 ---\n{page_text}\n"
                        self._log(f"✅ 第 {page_num} 頁提取成功，文本長度: {len(page_text)} 字符")
                    else:
                        self._log(f"⚠️ 第 {page_num} 頁沒有提取到文本")
                
                self._log(f"📊 pdfplumber 總文本長度: {len(all_text)} 字符")
                
        except Exception as e:
            self._log(f"⚠️ pdfplumber 提取失敗: {str(e)}")
        
        # 如果 pdfplumber 沒有提取到文本，嘗試 PyPDF2
        if len(all_text.strip()) == 0:
            self._log("🔄 嘗試使用 PyPDF2 提取...")
            try:
                import PyPDF2
                with open(pdf_path, 'rb') as file:
                    reader = PyPDF2.PdfReader(file)
                    for page_num, page in enumerate(reader.pages, 1):
                        page_text = page.extract_text()
                        if page_text:
                            all_text += f"\n--- 第 {page_num} 頁 ---\n{page_text}\n"
                            self._log(f"✅ PyPDF2 第 {page_num} 頁提取成功")
                
                self._log(f"📊 PyPDF2 總文本長度: {len(all_text)} 字符")
                        
            except Exception as e:
                self._log(f"⚠️ PyPDF2 提取失敗: {str(e)}")
        
        # 如果 PyPDF2 也沒有提取到文本，嘗試 OCR
        if len(all_text.strip()) == 0:
            self._log("🔄 嘗試使用 OCR 提取...")
            try:
                import fitz  # PyMuPDF
                import pytesseract
                from PIL import Image
                
                # 檢查 Tesseract 是否可用
                try:
                    pytesseract.get_tesseract_version()
                    self._log("✅ Tesseract OCR 可用")
                except:
                    self._log("❌ Tesseract OCR 不可用，請安裝 Tesseract")
                    raise Exception("Tesseract OCR 不可用")
                
                doc = fitz.open(pdf_path)
                for page_num, page in enumerate(doc, 1):
                    # 將頁面轉換為圖像
                    pix = page.get_pixmap()
                    img = Image.frombytes("RGB", [pix.width, pix.height], pix.samples)
                    
                    # 使用 OCR 提取文本
                    page_text = pytesseract.image_to_string(img, lang='eng')
                    if page_text and page_text.strip():
                        all_text += f"\n--- 第 {page_num} 頁 ---\n{page_text}\n"
                        self._log(f"✅ OCR 第 {page_num} 頁提取成功")
                
                doc.close()
                self._log(f"📊 OCR 總文本長度: {len(all_text)} 字符")
                        
            except Exception as e:
                self._log(f"⚠️ OCR 提取失敗: {str(e)}")
        
        # 如果所有方法都失敗
        if len(all_text.strip()) == 0:
            self._log("❌ 所有 PDF 提取方法都失敗，可能是：")
            self._log("   1. PDF 是純圖像格式且 OCR 不可用")
            self._log("   2. PDF 已加密或損壞")
            self._log("   3. PDF 格式不支持")
            return {
                'outlets': [],
                'invoices': [],
                'raw_text': '❌ 無法提取 PDF 文本內容'
            }
        
        try:
            # 解析提取的關鍵數據
            key_data = self._parse_key_data(all_text)
            return key_data
                
        except Exception as e:
            self._log(f"❌ 數據解析失敗: {str(e)}")
            return {
                'outlets': [],
                'invoices': [],
                'raw_text': all_text
            }
    
    def _extract_aries_fresh_pdf(self, pdf_path):
        """
        從Aries Fresh PDF中提取關鍵數據
        多重備用提取方法：pdfplumber -> PyPDF2 -> OCR
        """
        self._log(f"🚀 開始提取Aries Fresh PDF關鍵數據: {pdf_path}")
        
        all_text = ""
        
        # 方法1: pdfplumber (主要方法)
        try:
            import pdfplumber
            with pdfplumber.open(pdf_path) as pdf:
                self._log(f"📄 PDF已打開，共 {len(pdf.pages)} 頁")
                
                for page_num, page in enumerate(pdf.pages, 1):
                    self._log(f"📄 正在處理第 {page_num} 頁...")
                    
                    page_text = page.extract_text()
                    if page_text:
                        all_text += f"\n--- 第 {page_num} 頁 ---\n{page_text}\n"
                        self._log(f"✅ 第 {page_num} 頁提取成功，文本長度: {len(page_text)} 字符")
                    else:
                        self._log(f"⚠️ 第 {page_num} 頁沒有提取到文本")
                
                self._log(f"📊 pdfplumber 總文本長度: {len(all_text)} 字符")
                
        except Exception as e:
            self._log(f"⚠️ pdfplumber 提取失敗: {str(e)}")
        
        # 如果 pdfplumber 沒有提取到文本，嘗試 PyPDF2
        if len(all_text.strip()) == 0:
            self._log("🔄 嘗試使用 PyPDF2 提取...")
            try:
                import PyPDF2
                with open(pdf_path, 'rb') as file:
                    reader = PyPDF2.PdfReader(file)
                    for page_num, page in enumerate(reader.pages, 1):
                        page_text = page.extract_text()
                        if page_text:
                            all_text += f"\n--- 第 {page_num} 頁 ---\n{page_text}\n"
                            self._log(f"✅ PyPDF2 第 {page_num} 頁提取成功")
                
                self._log(f"📊 PyPDF2 總文本長度: {len(all_text)} 字符")
                        
            except Exception as e:
                self._log(f"⚠️ PyPDF2 提取失敗: {str(e)}")
        
        # 如果 PyPDF2 也沒有提取到文本，嘗試 OCR
        if len(all_text.strip()) == 0:
            self._log("🔄 嘗試使用 OCR 提取...")
            try:
                import fitz  # PyMuPDF
                import pytesseract
                from PIL import Image
                
                # 檢查 Tesseract 是否可用
                try:
                    pytesseract.get_tesseract_version()
                    self._log("✅ Tesseract OCR 可用")
                except:
                    self._log("❌ Tesseract OCR 不可用，請安裝 Tesseract")
                    raise Exception("Tesseract OCR 不可用")
                
                doc = fitz.open(pdf_path)
                for page_num, page in enumerate(doc, 1):
                    # 將頁面轉換為圖像
                    pix = page.get_pixmap()
                    img = Image.frombytes("RGB", [pix.width, pix.height], pix.samples)
                    
                    # 使用 OCR 提取文本
                    page_text = pytesseract.image_to_string(img, lang='eng')
                    if page_text and page_text.strip():
                        all_text += f"\n--- 第 {page_num} 頁 ---\n{page_text}\n"
                        self._log(f"✅ OCR 第 {page_num} 頁提取成功")
                
                doc.close()
                self._log(f"📊 OCR 總文本長度: {len(all_text)} 字符")
                        
            except Exception as e:
                self._log(f"⚠️ OCR 提取失敗: {str(e)}")
        
        # 如果所有方法都失敗
        if len(all_text.strip()) == 0:
            self._log("❌ 所有 PDF 提取方法都失敗")
            return {
                'outlets': [],
                'invoices': [],
                'raw_text': '❌ 無法提取 PDF 文本內容'
            }
        
        try:
            # 解析Aries Fresh格式的關鍵數據
            key_data = self._parse_aries_fresh_data(all_text)
            return key_data
                
        except Exception as e:
            self._log(f"❌ 數據解析失敗: {str(e)}")
            return {
                'outlets': [],
                'invoices': [],
                'raw_text': all_text
            }
    
    def _parse_aries_fresh_data(self, text):
        """
        解析Aries Fresh格式的文本
        格式：Customer Name: Sushi Express Group P/L(門市名)
              DATE Type Doc Number Debit Credit Balance
              Current 1 Month 2 Month 3 Month 4 Month 5 Month + Total
        """
        self._log("🔍 開始解析Aries Fresh關鍵數據...")
        
        # 初始化數據結構
        key_data = {
            'outlets': [],     # 門市信息列表
            'invoices': [],    # 發票信息列表
            'raw_text': text   # 原始文本
        }
        
        # 按頁分割文本
        pages = text.split('--- 第')
        self._log(f"📄 共 {len(pages)-1} 頁")  # 第一個分割通常是空的
        
        for i, page_text in enumerate(pages):
            if not page_text.strip() or i == 0:
                continue
                
            # 解析單頁數據
            page_data = self._parse_aries_fresh_page(page_text, i)
            if page_data:
                key_data['outlets'].append(page_data['outlet'])
                key_data['invoices'].extend(page_data['invoices'])
        
        self._log("✅ Aries Fresh關鍵數據解析完成")
        return key_data
    
    def _extract_evershine_pdf(self, pdf_path):
        """
        提取Ever-Shine PDF中的關鍵數據
        多重備用提取方法：pdfplumber -> PyPDF2 -> OCR
        """
        self._log("🔍 開始解析Ever-Shine PDF...")
        
        all_text = ""
        
        # 方法1: pdfplumber (主要方法)
        try:
            import pdfplumber
            with pdfplumber.open(pdf_path) as pdf:
                self._log(f"📄 PDF已打開，共 {len(pdf.pages)} 頁")
                
                for page_num, page in enumerate(pdf.pages, 1):
                    self._log(f"📄 處理第 {page_num} 頁...")
                    
                    page_text = page.extract_text()
                    if page_text:
                        all_text += f"\n--- 第 {page_num} 頁 ---\n{page_text}\n"
                        self._log(f"✅ 第 {page_num} 頁提取成功")
                    else:
                        self._log(f"⚠️ 第 {page_num} 頁沒有提取到文本")
                
                self._log(f"📊 pdfplumber 總文本長度: {len(all_text)} 字符")
                
        except Exception as e:
            self._log(f"⚠️ pdfplumber 提取失敗: {str(e)}")
        
        # 如果 pdfplumber 沒有提取到文本，嘗試 PyPDF2
        if len(all_text.strip()) == 0:
            self._log("🔄 嘗試使用 PyPDF2 提取...")
            try:
                import PyPDF2
                with open(pdf_path, 'rb') as file:
                    reader = PyPDF2.PdfReader(file)
                    for page_num, page in enumerate(reader.pages, 1):
                        page_text = page.extract_text()
                        if page_text:
                            all_text += f"\n--- 第 {page_num} 頁 ---\n{page_text}\n"
                            self._log(f"✅ PyPDF2 第 {page_num} 頁提取成功")
                
                self._log(f"📊 PyPDF2 總文本長度: {len(all_text)} 字符")
                        
            except Exception as e:
                self._log(f"⚠️ PyPDF2 提取失敗: {str(e)}")
        
        # 如果 PyPDF2 也沒有提取到文本，嘗試 OCR
        if len(all_text.strip()) == 0:
            self._log("🔄 嘗試使用 OCR 提取...")
            try:
                import fitz  # PyMuPDF
                import pytesseract
                from PIL import Image
                
                # 檢查 Tesseract 是否可用
                try:
                    pytesseract.get_tesseract_version()
                    self._log("✅ Tesseract OCR 可用")
                except:
                    self._log("❌ Tesseract OCR 不可用，請安裝 Tesseract")
                    raise Exception("Tesseract OCR 不可用")
                
                doc = fitz.open(pdf_path)
                for page_num, page in enumerate(doc, 1):
                    # 將頁面轉換為圖像
                    pix = page.get_pixmap()
                    img = Image.frombytes("RGB", [pix.width, pix.height], pix.samples)
                    
                    # 使用 OCR 提取文本
                    page_text = pytesseract.image_to_string(img, lang='eng')
                    if page_text and page_text.strip():
                        all_text += f"\n--- 第 {page_num} 頁 ---\n{page_text}\n"
                        self._log(f"✅ OCR 第 {page_num} 頁提取成功")
                
                doc.close()
                self._log(f"📊 OCR 總文本長度: {len(all_text)} 字符")
                        
            except Exception as e:
                self._log(f"⚠️ OCR 提取失敗: {str(e)}")
        
        # 如果所有方法都失敗
        if len(all_text.strip()) == 0:
            self._log("❌ 所有 PDF 提取方法都失敗")
            return {
                'outlets': [],
                'invoices': [],
                'raw_text': '❌ 無法提取 PDF 文本內容'
            }
        
        try:
            # 解析Ever-Shine格式的關鍵數據
            key_data = self._parse_evershine_data(all_text)
            return key_data
                
        except Exception as e:
            self._log(f"❌ 數據解析失敗: {str(e)}")
            return {
                'outlets': [],
                'invoices': [],
                'raw_text': all_text
            }
    
    def _parse_evershine_data(self, text):
        """解析Ever-Shine PDF的關鍵數據"""
        self._log("🔍 開始解析Ever-Shine關鍵數據...")
        
        lines = text.split('\n')
        
        key_data = {
            'outlets': [],
            'invoices': [],
            'details': [],
            'raw_text': text
        }
        
        # 逐頁解析
        for i, page in enumerate(self._split_evershine_pages(lines)):
            page_data = self._parse_evershine_page(page, i)
            if page_data:
                key_data['outlets'].append(page_data['outlet'])
                key_data['invoices'].extend(page_data['invoices'])
        
        self._log("✅ Ever-Shine關鍵數據解析完成")
        return key_data
    
    def _split_evershine_pages(self, lines):
        """分割Ever-Shine PDF的頁面"""
        pages = []
        current_page = []
        
        for line in lines:
            # Ever-Shine每頁都有"STATEMENT OF ACCOUNT"標題
            if 'STATEMENT OF ACCOUNT' in line and current_page:
                pages.append(current_page)
                current_page = [line]
            else:
                current_page.append(line)
        
        if current_page:
            pages.append(current_page)
        
        return pages
    
    def _parse_evershine_page(self, page_lines, page_num):
        """解析Ever-Shine單頁數據"""
        import re
        
        # 查找客戶信息（門市名稱）
        customer_name = None
        for line in page_lines:
            # Ever-Shine格式：Sushi Express - Northpoint 或 Sushi GOGO - xxx 等
            if ('Sushi Express' in line or 'Sushi GOGO' in line or 'Sushi TakeOut' in line) and '-' in line:
                # 提取門市名稱，支持多種品牌格式
                patterns = [
                    r'Sushi Express\s*-\s*(.+)',
                    r'Sushi GOGO\s*-\s*(.+)', 
                    r'Sushi TakeOut\s*-\s*(.+)'
                ]
                for pattern in patterns:
                    match = re.search(pattern, line.strip())
                    if match:
                        customer_name = match.group(1).strip()
                        self._log(f"🔍 找到門市名稱: '{customer_name}' (完整行: {repr(line.strip())})")
                        break
                if customer_name:
                    break
        
        if not customer_name:
            self._log(f"⚠️ 第 {page_num+1} 頁未找到客戶名稱")
            return None
        
        self._log(f"🏪 找到門市: {customer_name}")
        
        # 查找Current金額（從Statement Aging表格）
        current_amount = 0.0
        
        # 首先打印所有包含Current的行進行調試
        self._log(f"🔍 調試：查找包含'Current'的行...")
        for i, line in enumerate(page_lines):
            if 'Current' in line:
                self._log(f"🔍 第{i+1}行: {repr(line)}")
        
        # 查找 Sub Total 金額（在發票表格結束後）
        for i, line in enumerate(page_lines):
            line_stripped = line.strip()
            if 'Sub Total' in line_stripped:
                self._log(f"🔍 找到Sub Total行: {repr(line_stripped)}")
                
                # 從Sub Total行提取金額
                # 格式: "Sub Total 1880.69"
                match = re.search(r'Sub Total\s+([\d,]+\.?\d*)', line_stripped)
                if match:
                    try:
                        current_amount = float(match.group(1).replace(',', ''))
                        self._log(f"💰 從Sub Total找到金額: ${current_amount:.2f}")
                        break
                    except ValueError:
                        pass
                
                # 備用方法：分割並查找數字
                parts = re.split(r'\s+', line_stripped)
                for part in parts:
                    if re.match(r'^[\d,]+\.?\d*$', part):
                        try:
                            current_amount = float(part.replace(',', ''))
                            self._log(f"💰 從Sub Total(備用方法)找到金額: ${current_amount:.2f}")
                            break
                        except ValueError:
                            continue
                break
        
        # 如果沒找到Sub Total，查找Statement Aging表格
        if current_amount == 0.0:
            aging_section_found = False
            for i, line in enumerate(page_lines):
                if 'Statement Aging' in line:
                    aging_section_found = True
                    self._log(f"🔍 找到Statement Aging表格")
                    
                    for j in range(i+1, min(i+10, len(page_lines))):
                        header_line = page_lines[j].strip()
                        if 'Current' in header_line and 'Days' in header_line:
                            self._log(f"🔍 找到aging標題行: {repr(header_line)}")
                            
                            if j+1 < len(page_lines):
                                data_line = page_lines[j+1].strip()
                                self._log(f"🔍 aging數據行: {repr(data_line)}")
                                
                                parts = re.split(r'\s+', data_line)
                                numeric_parts = []
                                for part in parts:
                                    if re.match(r'^[\d,]+\.?\d*$', part):
                                        numeric_parts.append(part)
                                
                                if numeric_parts:
                                    try:
                                        current_amount = float(numeric_parts[0].replace(',', ''))
                                        self._log(f"💰 從Statement Aging找到Current金額: ${current_amount:.2f}")
                                        break
                                    except ValueError:
                                        continue
                                break
                    break
        
        # 檢查 aging_section_found 變量是否已定義
        if current_amount == 0.0 and 'aging_section_found' not in locals():
            self._log(f"⚠️ 未找到Sub Total和Statement Aging表格")
        
        # 查找發票信息
        invoices = []
        in_invoice_table = False
        
        for line in page_lines:
            line = line.strip()
            
            # 檢測發票表格開始
            if 'Document' in line and 'Invoice Date' in line and 'Amount' in line:
                in_invoice_table = True
                self._log(f"📊 找到發票表格開始")
                continue
            
            # 檢測發票表格結束
            if in_invoice_table and ('Sub Total' in line or 'Statement Aging' in line):
                in_invoice_table = False
                self._log(f"📊 發票表格結束")
                continue
            
            # 解析發票數據
            if in_invoice_table and line:
                # Ever-Shine發票格式：INV25-23557 02/07/25 Order INV25-23557 31/08/25 180.01 180.01
                parts = re.split(r'\s+', line)
                if len(parts) >= 6:
                    try:
                        invoice_num = parts[0]
                        invoice_date = parts[1]
                        due_date = parts[4] if len(parts) > 4 else ''
                        amount = float(parts[-2].replace(',', '')) if len(parts) >= 2 else 0.0
                        
                        if invoice_num and amount > 0:
                            invoices.append({
                                'invoice_number': invoice_num,
                                'invoice_no': invoice_num,  # 添加invoice_no字段
                                'outlet_name': customer_name,  # 添加outlet_name字段
                                'amount': amount,
                                'date': invoice_date,
                                'due_date': due_date,
                                'balance': amount,  # 添加balance字段
                                'outlet_aging_amount': current_amount  # 添加outlet_aging_amount字段
                            })
                            self._log(f"📝 發票: {invoice_num}, 金額: ${amount:.2f}")
                    except (ValueError, IndexError):
                        continue
        
        # 如果 aging 金額為 0，使用發票總額作為當前金額
        if current_amount == 0.0 and invoices:
            current_amount = sum(inv['amount'] for inv in invoices)
            self._log(f"💡 Aging金額為0，使用發票總額作為當前金額: ${current_amount:.2f}")
        
        # 應用1.09調整（與Aries Fresh相同）
        adjusted_amount = current_amount / 1.09 if current_amount > 0 else current_amount
        self._log(f"🔄 金額調整: ${current_amount:.2f} ÷ 1.09 = ${adjusted_amount:.2f}")
        
        return {
            'outlet': {
                'name': customer_name,
                'amount': adjusted_amount,
                'raw_amount': current_amount,
                'aging_amount': current_amount,  # 添加aging_amount字段
                'invoice_count': len(invoices)
            },
            'invoices': invoices
        }
    
    def _parse_aries_fresh_page(self, page_text, page_num):
        """解析Aries Fresh單頁數據"""
        import re
        lines = page_text.split('\n')
        
        # 查找Customer Name
        customer_name = None
        for line in lines:
            if 'Customer Name:' in line:
                # 提取門市名稱，格式：Sushi Express Group P/L(門市名) 或 Sushi Express West Mall (WSM)
                # 處理兩種格式
                if 'P/L(' in line and ')' in line:
                    # 格式1: Sushi Express Group P/L(門市名)
                    match = re.search(r'Customer Name:\s*Sushi Express.*P/L\(([^)]+)\)', line)
                    if match:
                        customer_name = match.group(1).strip()
                elif 'Sushi Express' in line:
                    # 格式2: Sushi Express West Mall (WSM)
                    match = re.search(r'Customer Name:\s*(Sushi Express[^C]*?)(?:\s+Customer|$)', line)
                    if match:
                        full_name = match.group(1).strip()
                        # 去除 "Sushi Express" 前綴，保留門市名稱
                        customer_name = full_name.replace('Sushi Express ', '').strip()
                break
        
        if not customer_name:
            self._log(f"⚠️ 第 {page_num} 頁未找到Customer Name")
            return None
        
        self._log(f"🏪 找到門市: {customer_name}")
        
        # 查找Current金額（關鍵數據）
        current_amount = 0.0
        
        # 首先打印所有包含Current的行進行調試
        self._log(f"🔍 調試：查找包含'Current'的行...")
        for i, line in enumerate(lines):
            if 'Current' in line:
                self._log(f"🔍 第{i+1}行: {repr(line)}")
        
        # 特別處理aging表格：查找包含Current列標題和數據的兩行
        aging_header_idx = -1
        for i, line in enumerate(lines):
            if 'Current' in line and '1 Month' in line and '2 Month' in line:
                aging_header_idx = i
                self._log(f"🔍 找到aging表格標題行: {repr(line)}")
                break
        
        if aging_header_idx >= 0 and aging_header_idx + 1 < len(lines):
            # 檢查下一行是否包含數據
            data_line = lines[aging_header_idx + 1].strip()
            self._log(f"🔍 aging表格數據行: {repr(data_line)}")
            
            # 解析數據行：第一個數字就是Current金額
            parts = re.split(r'\s+', data_line)
            if len(parts) >= 1:
                for part in parts:
                    # 匹配格式如 1,553.08 或 1553.08
                    if re.match(r'^[\d,]+\.?\d*$', part):
                        try:
                            current_amount = float(part.replace(',', ''))
                            self._log(f"💰 從aging表格找到Current金額: ${current_amount:.2f}")
                            break
                        except ValueError:
                            continue
        
        # 如果aging表格方法失敗，使用原有的多模式匹配
        if current_amount == 0.0:
            for i, line in enumerate(lines):
                # 查找包含 "Current" 和數字的行，特別是aging表格
                if 'Current' in line and any(char.isdigit() for char in line):
                    self._log(f"🔍 正在分析包含Current的行: {repr(line)}")
                    
                    # 嘗試多種模式匹配Current金額
                    # 模式1: Current直接後面跟金額
                    match = re.search(r'Current\s+([\d,]+\.?\d*)', line)
                    if match:
                        try:
                            current_amount = float(match.group(1).replace(',', ''))
                            self._log(f"💰 找到Current金額 (模式1): ${current_amount:.2f}")
                            break
                        except ValueError:
                            pass
                    
                    # 模式2: 表格格式 Current | amount | amount | ...
                    if '|' in line or '\t' in line:
                        parts = re.split(r'[\|\t]+', line.strip())
                        for j, part in enumerate(parts):
                            if 'Current' in part and j + 1 < len(parts):
                                try:
                                    amount_str = parts[j + 1].strip().replace(',', '').replace('$', '')
                                    if amount_str and amount_str != '-':
                                        current_amount = float(amount_str)
                                        self._log(f"💰 找到Current金額 (模式2): ${current_amount:.2f}")
                                        break
                                except ValueError:
                                    continue
                        if current_amount > 0:
                            break
                    
                    # 模式3: 空格分隔的表格格式
                    parts = re.split(r'\s+', line.strip())
                    for j, part in enumerate(parts):
                        if part == 'Current' and j + 1 < len(parts):
                            try:
                                # 檢查下一個有效的數字
                                for k in range(j + 1, min(j + 4, len(parts))):  # 檢查接下來3個位置
                                    amount_str = parts[k].replace(',', '').replace('$', '')
                                    if re.match(r'^\d+\.?\d*$', amount_str):
                                        amount = float(amount_str)
                                        if amount > 1.0:  # 過濾掉1.00這種明顯錯誤的值
                                            current_amount = amount
                                            self._log(f"💰 找到Current金額 (模式3): ${current_amount:.2f}")
                                            break
                                if current_amount > 1.0:
                                    break
                            except ValueError:
                                continue
                    if current_amount > 1.0:
                        break
        
        # 查找發票信息
        invoices = []
        in_invoice_table = False
        
        for line in lines:
            line = line.strip()
            
            # 檢測發票表格開始
            if 'DATE' in line and 'Type' in line and 'Doc Number' in line:
                in_invoice_table = True
                self._log(f"📊 找到發票表格開始")
                continue
            
            # 檢測發票表格結束
            if in_invoice_table and ('Current' in line or 'E. & O.E' in line):
                in_invoice_table = False
                self._log(f"📊 發票表格結束")
                continue
            
            # 解析發票行
            if in_invoice_table and line:
                invoice = self._parse_aries_fresh_invoice_line(line, customer_name)
                if invoice:
                    invoices.append(invoice)
        
        self._log(f"💰 門市 {customer_name} 找到 {len(invoices)} 條發票")
        
        # 創建門市信息
        outlet = {
            'name': customer_name,
            'full_name': f"Sushi Express Group P/L({customer_name})",
            'aging_amount': current_amount,
            'line_number': page_num
        }
        
        return {
            'outlet': outlet,
            'invoices': invoices
        }
    
    def _parse_aries_fresh_invoice_line(self, line, outlet_name):
        """解析Aries Fresh發票行"""
        import re
        # 格式：03/07/2025 AR INV 817318 92.92 92.92
        parts = re.split(r'\s+', line.strip())
        if len(parts) >= 5:
            try:
                date_str = parts[0]
                doc_type1 = parts[1] if len(parts) > 1 else ''
                doc_type2 = parts[2] if len(parts) > 2 else ''
                doc_number = parts[3] if len(parts) > 3 else ''
                debit_amount = parts[4] if len(parts) > 4 else '0'
                balance = parts[5] if len(parts) > 5 else '0'
                
                # 只處理AR INV類型的發票
                if doc_type1 == 'AR' and doc_type2 == 'INV':
                    # 驗證日期格式
                    if re.match(r'\d{2}/\d{2}/\d{4}', date_str):
                        # 轉換為dd/mm/yy格式
                        date_parts = date_str.split('/')
                        if len(date_parts) == 3:
                            day, month, year = date_parts
                            short_year = year[-2:]  # 取年份後兩位
                            converted_date = f"{day}/{month}/{short_year}"
                            
                            return {
                                'outlet_name': outlet_name,
                                'date': converted_date,
                                'invoice_no': doc_number,
                                'amount': float(debit_amount.replace(',', '')),
                                'balance': float(balance.replace(',', '')),
                                'outlet_aging_amount': 0.0,  # 將在後續處理中填充
                                'raw_line': line
                            }
            except (ValueError, IndexError) as e:
                # 靜默忽略解析錯誤
                pass
        
        return None
    
    def _parse_key_data(self, text):
        """
        解析提取的文本，識別關鍵數據元素
        與pdf_extractor_simple.py完全相同的邏輯
        """
        self._log("🔍 開始解析關鍵數據...")
        
        # 初始化數據結構
        key_data = {
            'outlets': [],                # 門市信息列表
            'invoices': [],               # 發票信息列表（包含門市信息）
            'raw_text': text             # 原始文本
        }
        
        # 按行分割文本
        lines = text.split('\n')
        self._log(f"📝 文本共 {len(lines)} 行")
        
        # 1. 提取所有門市信息
        key_data['outlets'] = self._extract_all_outlets(lines)
        
        # 2. 提取所有發票信息（關聯門市）
        key_data['invoices'] = self._extract_all_invoices_with_outlets(lines, key_data['outlets'])
        
        self._log("✅ 關鍵數據解析完成")
        return key_data
    
    def _extract_all_outlets(self, lines):
        """提取所有門市信息 - 修正Oriental格式解析"""
        outlets = []
        
        for i, line in enumerate(lines):
            line = line.strip()
            
            # 查找包含 "Customer Name" 的行（兼容不同格式）
            if 'Customer Name' in line and ':' in line:
                self._log(f"🔍 第{i+1}行: 找到Customer Name行: '{line}'")
                
                # 提取冒號後面的門市名稱，支持多種格式
                if 'Customer Name :' in line:
                    parts = line.split('Customer Name :')
                elif 'Customer Name:' in line:
                    parts = line.split('Customer Name:')
                else:
                    continue
                    
                if len(parts) > 1:
                    full_outlet_name = parts[1].strip()
                    
                    # 清理門市名稱（移除Currency等信息）
                    if 'Currency' in full_outlet_name:
                        full_outlet_name = full_outlet_name.split('Currency')[0].strip()
                    
                    self._log(f"🔍 清理後的門市名稱: '{full_outlet_name}'")
                    
                    # 提取括號內的門市名稱
                    extracted_name = self._extract_outlet_from_brackets(full_outlet_name)
                    
                    if extracted_name:
                        # 檢查是否已經存在這個門市
                        if not any(outlet['name'] == extracted_name for outlet in outlets):
                            outlet_info = {
                                'name': extracted_name,  # 只保存括號內的名稱
                                'full_name': full_outlet_name,  # 保存完整名稱用於調試
                                'line_number': i + 1,
                                'aging_amount': 0.0
                            }
                            outlets.append(outlet_info)
                            self._log(f"✅ 新增門市: {extracted_name}")
                    else:
                        self._log(f"⚠️ 無法從 '{full_outlet_name}' 提取門市名稱")
        
        # 為每個門市查找賬齡金額
        for outlet in outlets:
            outlet['aging_amount'] = self._find_outlet_aging_amount(lines, outlet['full_name'])
        
        return outlets
    
    def _extract_outlet_from_brackets(self, full_name):
        """從完整門市名稱中提取括號內的部分"""
        try:
            # 查找括號內的內容
            # 支持多種括號格式：(), [], {}
            bracket_patterns = [
                r'\(([^)]+)\)',  # 圓括號 ()
                r'\[([^\]]+)\]',  # 方括號 []
                r'\{([^}]+)\}'   # 大括號 {}
            ]
            
            for pattern in bracket_patterns:
                match = re.search(pattern, full_name)
                if match:
                    extracted = match.group(1).strip()
                    self._log(f"🔍 從 '{full_name}' 提取門市名稱: '{extracted}'")
                    return extracted
            
            # 如果沒有找到括號，返回原始名稱
            self._log(f"⚠️ 未找到括號，使用原始名稱: {full_name}")
            return full_name
            
        except Exception as e:
            self._log(f"❌ 提取門市名稱失敗: {str(e)}")
            return full_name
    
    def _find_outlet_aging_amount(self, lines, outlet_name):
        """為特定門市查找賬齡金額 - 與pdf_extractor_simple.py完全相同的邏輯"""
        aging_amount = 0.0
        
        # 查找該門市在文檔中的位置
        outlet_start = None
        outlet_end = None
        
        # 查找門市開始位置（Customer Name行）
        for i, line in enumerate(lines):
            if 'Customer Name :' in line and outlet_name in line:
                outlet_start = i
                break
        
        # 如果沒找到，嘗試用部分名稱匹配（用於長名稱門市）
        if outlet_start is None:
            # 提取關鍵詞進行匹配
            key_parts = outlet_name.split()
            for i, line in enumerate(lines):
                if 'Customer Name :' in line:
                    # 檢查是否包含關鍵詞
                    match_count = sum(1 for part in key_parts if part in line)
                    if match_count >= len(key_parts) * 0.6:  # 60%匹配度
                        outlet_start = i
                        self._log(f"🔍 通過部分匹配找到門市 {outlet_name} 位置: 行 {i+1}")
                        break
        
        if outlet_start is None:
            self._log(f"⚠️ 未找到門市 {outlet_name} 的位置")
            return aging_amount
        
        # 查找該門市的結束位置（下一個門市開始或文檔結束）
        outlet_end = len(lines)
        for i in range(outlet_start + 1, len(lines)):
            if 'Customer Name :' in lines[i]:
                outlet_end = i
                break
        
        # 在該門市範圍內查找賬齡信息
        self._log(f"🔍 在門市 {outlet_name} 範圍內 (行 {outlet_start+1} 到 {outlet_end}) 查找賬齡金額...")
        
        # 1. 優先查找 "Statement Aging" 表格的 "Current" 列下的金額
        # 這通常在 "Statement Aging" 表格的第二行
        statement_aging_found = False
        for i in range(outlet_start, outlet_end):
            line = lines[i].strip()
            if "Statement Aging" in line or ("Days Old" in line and "Current" in line):
                statement_aging_found = True
                self._log(f"🔍 找到Statement Aging表格: {line}")
                
                # 查找下一行的數據
                if i + 1 < outlet_end:
                    data_line = lines[i+1].strip()
                    self._log(f"🔍 Statement Aging數據行: '{data_line}'")
                    
                    # 檢查是否包含 "ged Amounts" 或 "Aged Amounts"
                    if 'ged Amounts' in data_line or 'Aged Amounts' in data_line:
                        # 從這行提取金額
                        amount_text = data_line.split(':')[-1].strip() if ':' in data_line else data_line
                        amount_match = re.search(r'(\d{4,7})', amount_text)
                        if amount_match:
                            raw_amount = amount_match.group(1)
                            self._log(f"🔍 在Statement Aging中找到數字: {raw_amount}")
                            if len(raw_amount) >= 4:
                                try:
                                    corrected_amount = raw_amount[:-2] + '.' + raw_amount[-2:]
                                    aging_amount = float(corrected_amount)
                                    self._log(f"🔧 修正Statement Aging金額: {raw_amount} -> {corrected_amount}")
                                    self._log(f"💰 通過Statement Aging表格找到門市 {outlet_name} 的賬齡金額: ${aging_amount}")
                                    return aging_amount
                                except ValueError:
                                    pass
                    else:
                        # 標準格式：查找第一個金額
                        amount_match = re.search(r'(\d+,?\d*\.\d{2})', data_line)
                        if amount_match:
                            try:
                                aging_amount = float(amount_match.group(1).replace(',', ''))
                                self._log(f"💰 通過 'Statement Aging' 表格的 'Current' 列找到門市 {outlet_name} 的賬齡金額: ${aging_amount}")
                                return aging_amount
                            except ValueError:
                                self._log(f"⚠️ 解析 'Statement Aging' 表格 'Current' 金額失敗: {data_line}")
                        else:
                            # 處理沒有小數點的格式，如 "52510 0.00 000 000"
                            amount_match = re.search(r'(\d{4,7})', data_line)
                            if amount_match:
                                raw_amount = amount_match.group(1)
                                self._log(f"🔍 找到無小數點數字: {raw_amount}")
                                if len(raw_amount) >= 4:
                                    try:
                                        corrected_amount = raw_amount[:-2] + '.' + raw_amount[-2:]
                                        aging_amount = float(corrected_amount)
                                        self._log(f"🔧 修正Statement Aging格式: {raw_amount} -> {corrected_amount}")
                                        self._log(f"💰 通過Statement Aging表格找到門市 {outlet_name} 的賬齡金額: ${aging_amount}")
                                        return aging_amount
                                    except ValueError:
                                        pass
                break # 找到Statement Aging就停止
        
        # 2. 如果沒有找到，嘗試查找 "Aged Amounts :" 這一行
        if aging_amount == 0.0:
            for i in range(outlet_start, outlet_end):
                line = lines[i].strip()
                if "Aged Amounts :" in line:
                    # 提取冒號後面的金額
                    parts = line.split('Aged Amounts :')
                    if len(parts) > 1:
                        # 提取第一個金額（Current金額）
                        amount_part = parts[1].strip()
                        self._log(f"🔍 分析Aged Amounts行: '{amount_part}'")
                        
                        # 先嘗試標準格式 (有小數點)
                        amount_match = re.search(r'(\d+,?\d*\.\d{2})', amount_part)
                        if amount_match:
                            try:
                                amount_str = amount_match.group(1).replace(',', '')
                                aging_amount = float(amount_str)
                                self._log(f"💰 通過 'Aged Amounts :' 找到門市 {outlet_name} 的賬齡金額: ${aging_amount}")
                                return aging_amount
                            except ValueError:
                                pass
                        
                        # 如果沒有小數點，嘗試修正格式
                        # 例如 "129057" 應該是 "1290.57"，"52510" 應該是 "525.10"
                        no_decimal_match = re.search(r'(\d{4,7})', amount_part)  # 修改：支持4-7位數字，不要求空格
                        if no_decimal_match:
                            raw_amount = no_decimal_match.group(1)
                            self._log(f"🔍 找到無小數點數字: {raw_amount}")
                            if len(raw_amount) >= 4:
                                try:
                                    # 假設最後兩位是小數部分
                                    corrected_amount = raw_amount[:-2] + '.' + raw_amount[-2:]
                                    aging_amount = float(corrected_amount)
                                    self._log(f"🔧 修正Aged Amounts格式: {raw_amount} -> {corrected_amount}")
                                    self._log(f"💰 通過 'Aged Amounts :' 找到門市 {outlet_name} 的賬齡金額: ${aging_amount}")
                                    return aging_amount
                                except ValueError:
                                    self._log(f"⚠️ 轉換失敗: {corrected_amount}")
                                    pass
                            else:
                                # 對於較短的數字，直接使用
                                try:
                                    aging_amount = float(raw_amount)
                                    self._log(f"💰 直接使用數字: {raw_amount} -> ${aging_amount}")
                                    return aging_amount
                                except ValueError:
                                    pass
                        else:
                            # 如果沒有找到4-7位數字，嘗試查找第一個3位以上的數字
                            fallback_match = re.search(r'(\d{3,})', amount_part)
                            if fallback_match:
                                raw_amount = fallback_match.group(1)
                                self._log(f"🔍 找到備用數字: {raw_amount}")
                                if len(raw_amount) >= 5:  # 5位或以上才修正小數點
                                    try:
                                        corrected_amount = raw_amount[:-2] + '.' + raw_amount[-2:]
                                        aging_amount = float(corrected_amount)
                                        self._log(f"🔧 修正Aged Amounts格式: {raw_amount} -> {corrected_amount}")
                                        self._log(f"💰 通過 'Aged Amounts :' 找到門市 {outlet_name} 的賬齡金額: ${aging_amount}")
                                        return aging_amount
                                    except ValueError:
                                        pass
                                elif len(raw_amount) == 4:  # 對於4位數字，也嘗試修正小數點
                                    try:
                                        corrected_amount = raw_amount[:-2] + '.' + raw_amount[-2:]
                                        aging_amount = float(corrected_amount)
                                        self._log(f"🔧 修正4位Aged Amounts格式: {raw_amount} -> {corrected_amount}")
                                        self._log(f"💰 通過 'Aged Amounts :' 找到門市 {outlet_name} 的賬齡金額: ${aging_amount}")
                                        return aging_amount
                                    except ValueError:
                                        pass
                        
                        self._log(f"⚠️ 解析 'Aged Amounts' 金額失敗: {line}")
                                
        # 3. 如果以上兩種方式都失敗，嘗試更通用的方式查找包含 "Current" 的行
        if aging_amount == 0.0:
            self._log(f"⚠️ 門市 {outlet_name} 未找到Aged Amounts行，使用通用Current模式")
            for i in range(outlet_start, outlet_end):
                line = lines[i].strip()
                self._log(f"🔍 檢查第{i+1}行: {repr(line)}")
                
                if 'Current' in line and any(char.isdigit() for char in line):
                    self._log(f"🔍 找到包含Current的行: {repr(line)}")
                    
                    # 改進的邏輯：優先查找表格格式的Current金額
                    # 模式1: Statement Aging表格格式 "Days Old Current 31- 60 Days..."
                    if 'Days Old' in line and 'Current' in line:
                        # 查找下一行的數據
                        if i + 1 < outlet_end:
                            data_line = lines[i+1].strip()
                            self._log(f"🔍 Statement Aging數據行: {repr(data_line)}")
                            
                            # 改進的邏輯：處理 Statement Aging 數據行
                            if 'ged Amounts' in data_line or 'Aged Amounts' in data_line:
                                # 處理 "ged Amounts : 2,07831 0.00 0.00 0.00" 格式
                                parts = data_line.split(':')
                                if len(parts) > 1:
                                    amount_part = parts[1].strip()
                                    # 查找第一個金額
                                    amount_match = re.search(r'(\d+,?\d*\.?\d*)', amount_part)
                                    if amount_match:
                                        raw_amount = amount_match.group(1).replace(',', '')
                                        self._log(f"🔍 Statement Aging找到原始金額: {raw_amount}")
                                        
                                        # 檢查是否需要修正小數點
                                        if '.' not in raw_amount and len(raw_amount) >= 4:
                                            # 修正格式：如 "207831" -> "2078.31", "81529" -> "815.29"
                                            corrected_amount = raw_amount[:-2] + '.' + raw_amount[-2:]
                                            aging_amount = float(corrected_amount)
                                            self._log(f"🔧 修正Statement Aging格式: {raw_amount} -> {corrected_amount}")
                                        else:
                                            aging_amount = float(raw_amount)
                                        
                                        self._log(f"💰 通過Statement Aging表格找到門市 {outlet_name} 的賬齡金額: ${aging_amount}")
                                        break
                            else:
                                # 原有邏輯：直接提取數字
                                amounts = re.findall(r'(\d+,?\d*\.?\d+)', data_line)
                                if amounts:
                                    try:
                                        aging_amount = float(amounts[0].replace(',', ''))
                                        self._log(f"💰 通過Statement Aging表格找到門市 {outlet_name} 的賬齡金額: ${aging_amount}")
                                        break
                                    except ValueError:
                                        pass
                    
                    # 模式2: 原有的通用模式，但提高匹配要求
                    if aging_amount == 0.0:
                        # 查找較大的金額（可能是賬齡金額）
                        amounts = re.findall(r'(\d+,?\d*\.?\d+)', line)
                        self._log(f"🔍 行中找到的所有金額: {amounts}")
                        
                        # 選擇最大的金額作為賬齡金額（通常賬齡金額是最大的）
                        if amounts:
                            try:
                                amount_values = [float(amt.replace(',', '')) for amt in amounts]
                                # 過濾掉太小的金額（可能是天數等）
                                valid_amounts = [amt for amt in amount_values if amt > 100]
                                if valid_amounts:
                                    aging_amount = max(valid_amounts)
                                    self._log(f"💰 通過通用模式找到門市 {outlet_name} 的賬齡金額: ${aging_amount} (從{amount_values}中選擇)")
                                    break
                                elif amount_values:
                                    # 如果沒有大於100的，選擇最大的
                                    aging_amount = max(amount_values)
                                    self._log(f"💰 通過通用模式找到門市 {outlet_name} 的賬齡金額: ${aging_amount} (備用選擇)")
                                    break
                            except ValueError:
                                pass
        
        return aging_amount
    
    def _extract_all_invoices_with_outlets(self, lines, outlets):
        """提取所有發票信息，並關聯門市 - 與pdf_extractor_simple.py完全相同的邏輯"""
        all_invoices = []
        
        # 為每個門市提取發票
        for outlet in outlets:
            self._log(f"🔍 為門市 {outlet['name']} 提取發票...")
            
            # 在門市名稱附近查找發票數據
            outlet_invoices = self._extract_invoices_for_outlet(lines, outlet)
            
            # 為每個發票添加門市信息
            for invoice in outlet_invoices:
                invoice['outlet_name'] = outlet['name']
                invoice['outlet_aging_amount'] = outlet['aging_amount']
                all_invoices.append(invoice)
            
            self._log(f"💰 門市 {outlet['name']} 找到 {len(outlet_invoices)} 條發票")
        
        return all_invoices
    
    def _extract_invoices_for_outlet(self, lines, outlet):
        """為特定門市提取發票信息 - 與pdf_extractor_simple.py完全相同的邏輯"""
        invoices = []
        
        # 查找該門市的交易表格
        outlet_start = None
        outlet_end = None
        
        # 查找門市開始位置（Customer Name行）
        for i, line in enumerate(lines):
            if 'Customer Name :' in line and outlet['full_name'] in line:
                outlet_start = i
                self._log(f"🏪 找到門市 {outlet['name']} 開始位置: 第 {i+1} 行")
                break
        
        if outlet_start is None:
            self._log(f"⚠️ 未找到門市 {outlet['name']} 的開始位置")
            return invoices
        
        # 查找該門市的結束位置（下一個門市開始或文檔結束）
        outlet_end = len(lines)
        for i in range(outlet_start + 1, len(lines)):
            if 'Customer Name :' in lines[i]:
                outlet_end = i
                self._log(f"🏪 門市 {outlet['name']} 結束位置: 第 {i+1} 行")
                break
        
        # 在該門市範圍內查找發票
        self._log(f"🔍 在門市 {outlet['name']} 範圍內搜索發票 (行 {outlet_start+1} 到 {outlet_end})")
        
        # 查找交易表格的開始
        table_started = False
        for i in range(outlet_start, outlet_end):
            line = lines[i].strip()
            
            # 檢查是否到達交易表格（包含列標題）
            if 'Posting Date' in line and 'Doc Type' in line and 'Document No' in line:
                table_started = True
                self._log(f"📊 找到交易表格開始，行 {i+1}: {line}")
                continue
            
            if table_started:
                # 跳過空行和表頭
                if not line or any(keyword in line for keyword in ['Posting Date', 'Doc Type', 'Document No', 'Debit', 'Credit', 'Balance']):
                    continue
                
                # 嘗試解析發票行
                invoice = self._parse_invoice_line(line)
                if invoice:
                    invoices.append(invoice)
                    self._log(f"💰 解析到發票: {invoice}")
                
                # 檢查是否到達表格結束（通常是賬齡摘要開始）
                if any(keyword in line for keyword in ['Statement Aging', 'Days Old', 'Aged Amounts']):
                    self._log(f"📊 交易表格結束，行 {i+1}: {line}")
                    break
        
        # 如果沒有找到發票，嘗試在該門市範圍內搜索
        if not invoices:
            self._log(f"🔍 在交易表格中沒有找到發票，嘗試在門市 {outlet['name']} 範圍內搜索...")
            invoices = self._search_invoices_in_outlet_range(lines, outlet, outlet_start, outlet_end)
        
        return invoices
    
    def _search_invoices_in_outlet_range(self, lines, outlet, start_line, end_line):
        """在特定門市範圍內搜索發票信息 - 與pdf_extractor_simple.py完全相同的邏輯"""
        invoices = []
        
        self._log(f"🔍 在門市 {outlet['name']} 範圍內 (行 {start_line+1} 到 {end_line}) 搜索發票...")
        
        # 搜索發票
        for i in range(start_line, end_line):
            line = lines[i].strip()
            
            # 跳過空行
            if not line:
                continue
            
            # 嘗試解析發票行
            invoice = self._parse_invoice_line(line)
            if invoice:
                invoices.append(invoice)
                self._log(f"💰 在第 {i+1} 行找到門市 {outlet['name']} 的發票: {invoice}")
            
            # 如果找到太多發票，停止搜索
            if len(invoices) > 50:
                self._log(f"🔍 門市 {outlet['name']} 已找到足夠多的發票，停止搜索")
                break
        
        return invoices
    
    def _parse_invoice_line(self, line):
        """解析單行發票記錄 - 與pdf_extractor_simple.py完全相同的邏輯"""
        # 清理行數據
        line = line.strip()
        if not line:
            return None
        
        # 嘗試匹配發票行模式
        # 格式: 日期 | Invoice | 發票號 | 金額 | 餘額
        
        # 查找日期
        date_match = re.search(r'(\d{1,2}/\d{1,2}/\d{2,4})', line)
        if not date_match:
            return None
        
        date_str = date_match.group(1)
        
        # 檢查是否是發票行 - 更嚴格的檢查
        if 'Invoice' not in line:
            return None
        
        # 查找發票號 - 更準確的模式
        # 發票號通常是6-7位數字
        invoice_match = re.search(r'Invoice\s+(\d{6,7})', line)
        if not invoice_match:
            return None
        
        invoice_no = invoice_match.group(1)
        
        # 查找金額 - 優化的模式，支持多種格式
        # 金額應該是Debit列的值，通常是正數
        # 嘗試多種金額格式的模式
        
        # 模式1: 標準金額格式 (xx.xx)
        debit_match = re.search(r'Invoice\s+\d{6,7}\s+(\d+,?\d*\.\d{2})', line)
        if debit_match:
            try:
                amount = float(debit_match.group(1).replace(',', ''))
            except ValueError:
                return None
        else:
            # 模式2: 處理格式錯誤的情況，如 "12573" 應該是 "125.73"
            # 查找發票號後面的第一個數字
            pattern = r'Invoice\s+\d{6,7}\s+(\d+)\s+[\d,]+\.\d{2}'
            error_match = re.search(pattern, line)
            if error_match:
                raw_amount = error_match.group(1)
                # 如果是4-5位數字且沒有小數點，嘗試插入小數點
                if len(raw_amount) >= 4 and '.' not in raw_amount:
                    try:
                        # 假設最後兩位是小數部分
                        amount_str = raw_amount[:-2] + '.' + raw_amount[-2:]
                        amount = float(amount_str)
                        self._log(f"🔧 修正金額格式: {raw_amount} -> {amount_str}")
                    except ValueError:
                        return None
                else:
                    return None
            else:
                # 模式3: 後備方案，查找行中的任何有效金額
                fallback_match = re.search(r'(\d+,?\d*\.\d{2})', line)
                if fallback_match:
                    try:
                        amount = float(fallback_match.group(1).replace(',', ''))
                    except ValueError:
                        return None
                else:
                    return None
        
        # 查找餘額 - 通常是Balance列的值
        balance_match = re.search(r'(\d+,?\d*\.\d{2})(?:\s*$)', line)
        balance = None
        if balance_match:
            try:
                balance = float(balance_match.group(1).replace(',', ''))
            except ValueError:
                pass
        
        # 驗證數據合理性
        if amount <= 0 or amount > 10000:  # 金額應該在合理範圍內
            return None
        
        if balance and balance < 0:  # 餘額不應該為負數
            return None
        
        invoice = {
            'date': date_str,
            'invoice_no': invoice_no,
            'amount': amount,
            'balance': balance,
            'raw_line': line
        }
        
        return invoice
    
    def _read_excel_smart_ui(self):
        """智能读取Excel UI"""
        excel_path = self.excel_path_var.get().strip()
        if not excel_path:
            self._log("❌ 請先選擇Consolidate Excel文件")
            return
        
        if not os.path.exists(excel_path):
            self._log("❌ Excel文件不存在")
            return
        
        self._log("📊 開始智能讀取Excel數據...")
        try:
            from openpyxl import load_workbook
            from openpyxl.utils import get_column_letter
            
            # 加載工作簿
            wb = load_workbook(excel_path, data_only=True)
            
            # 讀取所有廠商的工作表資料
            target_sheets = ["Oriental", "Aries Fresh", "Ever-Shine"]
            all_excel_data = {}
            
            self._log(f"📋 工作簿中的所有工作表: {wb.sheetnames}")
            
            for sheet_name in target_sheets:
                if sheet_name in wb.sheetnames:
                    self._log(f"📋 正在讀取工作表: {sheet_name}")
                    ws = wb[sheet_name]
                    
                    # 智能識別結構
                    structure_result = self._identify_excel_structure(ws)
                    if structure_result[0] == 'ORIENTAL_FORMAT':
                        # Oriental格式：直接使用生成的日期和門市列
                        outlet_col = structure_result[1]
                        dates = structure_result[2]
                        date_row = 'ORIENTAL_FORMAT'  # 設置特殊標記
                        self._log(f"🎯 {sheet_name} 使用Oriental格式：門市列 {get_column_letter(outlet_col)}, 生成 {len(dates)} 個日期")
                    else:
                        # 標準格式：解析日期行
                        date_row, outlet_col, dates = structure_result
                        if date_row is None or outlet_col is None:
                            self._log(f"❌ 無法識別 {sheet_name} 工作表結構")
                            continue
                        
                        self._log(f"📅 {sheet_name} 日期行: {date_row}, 門市列: {get_column_letter(outlet_col)}")
                        
                        # 解析日期
                        dates = self._parse_excel_dates(ws, date_row)
                        if not dates:
                            self._log(f"❌ 無法解析 {sheet_name} 日期")
                            continue
                    
                    self._log(f"✅ {sheet_name} 成功解析 {len(dates)} 個日期")
                    
                    # 讀取門市數據
                    outlets = self._read_excel_outlets(ws, outlet_col, date_row, dates)
                    if not outlets:
                        self._log(f"❌ 無法讀取 {sheet_name} 門市數據")
                        continue
                    
                    self._log(f"✅ {sheet_name} 成功讀取 {len(outlets)} 個門市")
                    
                    # 保存該廠商的數據
                    all_excel_data[sheet_name] = {
                        'sheet_name': sheet_name,
                        'dates': dates,
                        'outlets': outlets,
                        'file_path': excel_path
                    }
                else:
                    self._log(f"⚠️ 未找到 {sheet_name} 工作表")
            
            if not all_excel_data:
                self._log("❌ 沒有成功讀取任何工作表數據")
                wb.close()
                return
            
            # 保存所有廠商的數據
            self.excel_data = all_excel_data
            
            wb.close()
            self._log("🎉 Excel數據讀取完成！")
            
            # 更新Excel數據標籤頁
            self._update_excel_data_tab()
            
        except Exception as e:
            self._log(f"❌ Excel讀取失敗: {str(e)}")
            import traceback
            self._log(f"🔍 錯誤詳情: {traceback.format_exc()}")
    
    def _identify_excel_structure(self, ws):
        """智能識別Excel結構 - 針對Oriental格式優化"""
        try:
            self._log(f"🔍 開始智能識別Excel結構...")
            self._log(f"  工作表大小: {ws.max_row} 行 x {ws.max_column} 列")
            
            # 針對Oriental格式的特殊處理：沒有日期行，日期通過列位置表示
            # 第1行：ORIENTAL（標題）
            # 第2行：Code, Outlets（列標題）
            # 第3行開始：門市數據，每行包含門市代碼、門市名稱和每日金額
            
            # 檢查是否是Oriental格式
            first_row = ws.cell(row=1, column=1).value
            second_row_a = ws.cell(row=2, column=1).value
            second_row_b = ws.cell(row=2, column=2).value
            
            # 檢查Oriental格式：第1行包含"ORIENTAL"，第2行有CODE和OUTLETS
            is_oriental = (isinstance(first_row, str) and 'ORIENTAL' in first_row.upper() and
                          isinstance(second_row_a, str) and 'CODE' in second_row_a.upper() and
                          isinstance(second_row_b, str) and 'OUTLETS' in second_row_b.upper())
            
            # 檢查Aries Fresh格式：第2行有CODE和OUTLETS（但第1行不是ORIENTAL）
            is_aries_fresh = (not is_oriental and
                             isinstance(second_row_a, str) and 'CODE' in second_row_a.upper() and
                             isinstance(second_row_b, str) and 'OUTLETS' in second_row_b.upper())
            
            if is_oriental or is_aries_fresh:
                
                format_name = "Oriental" if is_oriental else "Aries Fresh"
                self._log(f"  🎯 檢測到{format_name}格式：沒有日期行，日期通過列位置表示")
                
                # 門市列是第2列（B列）
                outlet_col = 2
                self._log(f"  🏪 門市列: 列 B (Outlets)")
                
                # 數據從第3行開始
                data_start_row = 3
                self._log(f"  📊 數據開始行: 第 {data_start_row} 行")
                
                # 日期列從第3列（C列）開始，每列代表一天
                # 基於檢測到的月份作為基準月份
                from datetime import datetime, timedelta
                
                # 檢查第2行是否包含月份信息
                month_patterns = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec']
                detected_month = None
                detected_year = None
                
                # 添加调试信息
                self._log(f"  🔍 開始檢測第2行的月份信息...")
                
                for col in range(3, min(21, ws.max_column + 1)):
                    cell_value = ws.cell(row=2, column=col).value
                    self._log(f"    列 {get_column_letter(col)}: '{cell_value}' (類型: {type(cell_value)})")
                    
                    # 檢查是否是日期時間對象
                    if hasattr(cell_value, 'month') and hasattr(cell_value, 'year'):
                        detected_month = month_patterns[cell_value.month - 1]  # 月份從1開始，所以減1
                        detected_year = cell_value.year
                        self._log(f"  🎯 檢測到日期時間對象: 月份={detected_month}, 年份={detected_year}")
                        break
                    
                    # 檢查字符串格式的日期
                    if cell_value and isinstance(cell_value, str):
                        # 檢查 "1-Aug" 格式
                        if '-' in str(cell_value):
                            parts = str(cell_value).split('-')
                            self._log(f"      分割後: {parts}")
                            
                            if len(parts) == 2:
                                day_part, month_part = parts
                                self._log(f"      日期部分: '{day_part}', 月份部分: '{month_part}'")
                                
                                if day_part.isdigit() and month_part.lower()[:3] in month_patterns:
                                    detected_month = month_part.lower()[:3]
                                    detected_year = datetime.now().year
                                    self._log(f"  🎯 檢測到月份: {detected_month}, 年份: {detected_year}")
                                    break
                                else:
                                    self._log(f"      檢查失敗: day_part.isdigit()={day_part.isdigit()}, month_part.lower()[:3]='{month_part.lower()[:3]}' in month_patterns={month_part.lower()[:3] in month_patterns}")
                        
                        # 檢查 "2025-08-01" 格式
                        elif cell_value.count('-') == 2:
                            try:
                                # 嘗試解析為日期
                                date_obj = datetime.strptime(cell_value, '%Y-%m-%d')
                                detected_month = month_patterns[date_obj.month - 1]
                                detected_year = date_obj.year
                                self._log(f"  🎯 檢測到日期格式: 月份={detected_month}, 年份={detected_year}")
                                break
                            except ValueError:
                                self._log(f"      無法解析日期格式: {cell_value}")
                
                # 如果還是沒有檢測到，嘗試更寬鬆的檢測
                if not detected_month:
                    self._log(f"  🔍 嘗試更寬鬆的月份檢測...")
                    for col in range(3, min(21, ws.max_column + 1)):
                        cell_value = ws.cell(row=2, column=col).value
                        if cell_value and isinstance(cell_value, str):
                            # 直接檢查是否包含月份縮寫
                            for month_abbr in month_patterns:
                                if month_abbr in cell_value.lower():
                                    detected_month = month_abbr
                                    detected_year = datetime.now().year
                                    self._log(f"  🎯 通過寬鬆檢測找到月份: {detected_month}, 年份: {detected_year}")
                                    break
                            if detected_month:
                                break
                
                # 如果檢測到月份信息，使用檢測到的月份；否則使用當前月份
                if detected_month and detected_year:
                    month_map = {
                        'jan': 1, 'feb': 2, 'mar': 3, 'apr': 4,
                        'may': 5, 'jun': 6, 'jul': 7, 'aug': 8,
                        'sep': 9, 'oct': 10, 'nov': 11, 'dec': 12
                    }
                    detected_month_num = month_map.get(detected_month, 7)
                    base_date = datetime(detected_year, detected_month_num, 1)
                    self._log(f"  📅 使用檢測到的基準日期: {base_date.strftime('%Y-%m-%d')}")
                else:
                    # 如果無法檢測到月份，使用當前月份
                    current_date = datetime.now()
                    base_date = current_date.replace(day=1)
                    self._log(f"  📅 使用當前月份作為基準日期: {base_date.strftime('%Y-%m-%d')}")
                
                dates = []
                for col in range(3, ws.max_column + 1):
                    # 計算日期：C列=7月1日，D列=7月2日，以此類推
                    days_offset = col - 3
                    date_value = base_date + timedelta(days=days_offset)
                    date_str = date_value.strftime('%d/%m/%y')
                    
                    dates.append({
                        'column': get_column_letter(col),
                        'date': date_str,
                        'col_index': col,
                        'original_value': f'列{get_column_letter(col)}',
                        'datetime': date_value
                    })
                
                self._log(f"  📅 基於列位置生成 {len(dates)} 個日期")
                
                # 返回特殊標記，表示這是Oriental格式
                return 'ORIENTAL_FORMAT', outlet_col, dates
            
            # 如果不是Oriental格式，使用原有的日期行識別邏輯
            self._log(f"  📅 使用標準日期行識別邏輯...")
            
            # 查找日期行（通常在前10行）
            date_row = None
            for row in range(1, min(11, ws.max_row + 1)):
                self._log(f"    檢查第 {row} 行...")
                date_cells = 0
                total_cells = 0
                
                for col in range(1, min(21, ws.max_column + 1)):
                    cell_value = ws.cell(row=row, column=col).value
                    if cell_value:
                        total_cells += 1
                        col_letter = get_column_letter(col)
                        self._log(f"      列 {col_letter}: '{cell_value}' (類型: {type(cell_value)})")
                        
                        # 檢查是否是有效的日期或日期公式
                        if self._is_valid_date_or_formula(cell_value):
                            date_cells += 1
                            self._log(f"        ✅ 有效日期/公式")
                        else:
                            self._log(f"        ❌ 無效日期/公式")
                
                # 降低閾值到30%，因為有些行可能只有部分日期
                if total_cells > 0 and date_cells / total_cells > 0.3:
                    date_row = row
                    self._log(f"      ✅ 找到日期行: 第 {row} 行 (日期單元格: {date_cells}/{total_cells})")
                    break
                else:
                    self._log(f"      ❌ 第 {row} 行不是日期行 (日期單元格: {date_cells}/{total_cells})")
            
            if not date_row:
                self._log(f"      ❌ 未找到日期行")
                return None, None, None
            
            # 查找門市列（通常在A、B、C列）— 使用評分選擇更像"名稱"的列
            outlet_col = None
            self._log(f"  🏪 查找門市列...")
            best_score = -1
            for col in [1, 2, 3]:  # A, B, C列
                if col <= ws.max_column:
                    score = 0
                    col_letter = get_column_letter(col)
                    self._log(f"    檢查列 {col_letter}...")
                    for row in range(date_row + 1, min(date_row + 31, ws.max_row + 1)):
                        value = ws.cell(row=row, column=col).value
                        if value is None:
                            continue
                        # 文本且包含字母或空格，給較高分
                        if isinstance(value, str):
                            txt = value.strip()
                            if len(txt) >= 2:
                                if any(ch.isalpha() for ch in txt):
                                    score += 3
                                # 純數字的字符串不給分
                                elif not txt.isdigit():
                                    score += 1
                        # 純數字（門店代碼）降低分
                        elif isinstance(value, (int, float)):
                            score -= 2
                    self._log(f"      列 {col_letter} 得分: {score}")
                    if score > best_score:
                        best_score = score
                        outlet_col = col
            if outlet_col:
                col_letter = get_column_letter(outlet_col)
                self._log(f"      ✅ 判定門市列: 列 {col_letter} (得分 {best_score})")
            
            if not outlet_col:
                self._log(f"      ❌ 未找到門市列")
                return None, None
            
            self._log(f"  ✅ 結構識別完成: 日期行={date_row}, 門市列={get_column_letter(outlet_col)}")
            return date_row, outlet_col
            
        except Exception as e:
            self._log(f"❌ 結構識別失敗: {str(e)}")
            return None, None
    
    def _is_valid_date_or_formula(self, value):
        """檢查是否是有效的日期或日期公式（更嚴格的判斷）"""
        try:
            if isinstance(value, str):
                # 排除明顯的非日期內容
                if value.lower() in ['code', 'outlets', 'oriental', 'ever-shine']:
                    return False
                
                # 檢查是否是跨工作表的引用公式（這些通常不是日期）
                if value.startswith("='") and "!" in value:
                    return False
                
                # 檢查是否是WEEKDAY函數（這些通常不是日期）
                if value.startswith('=WEEKDAY('):
                    return False
                
                # 檢查是否是日期公式
                if value.startswith('='):
                    # 檢查是否包含日期相關的關鍵詞
                    date_keywords = ['date', 'today', 'now', '+', '-']
                    return any(keyword in value.lower() for keyword in date_keywords)
                
                # 檢查是否是日期格式
                date_patterns = [
                    r'\d{1,2}[/-]\d{1,2}[/-]\d{2,4}',  # dd/mm/yy, dd-mm-yy
                    r'\d{1,2}-[A-Za-z]{3}',  # 1-Jul, 2-Aug
                    r'\d{4}-\d{1,2}-\d{1,2}'  # yyyy-mm-dd
                ]
                return any(re.match(pattern, str(value)) for pattern in date_patterns)
            
            # 檢查是否是datetime對象
            if hasattr(value, 'strftime'):
                return True
            
            # 檢查是否是Excel日期序列號
            if isinstance(value, (int, float)) and value > 1000:
                return True
            
            return False
        except:
            return False
    
    def _parse_excel_dates(self, ws, date_row):
        """智能解析Excel日期（處理公式）"""
        try:
            dates = []
            base_date = None
            
            self._log(f"🔍 開始解析第 {date_row} 行的日期...")
            
            for col in range(1, ws.max_column + 1):
                cell = ws.cell(row=date_row, column=col)
                cell_value = cell.value
                
                if not cell_value:
                    continue
                
                col_letter = get_column_letter(col)
                self._log(f"  📅 列 {col_letter}: 值 = '{cell_value}' (類型: {type(cell_value)})")
                
                # 處理日期公式
                if isinstance(cell_value, str) and cell_value.startswith('='):
                    self._log(f"    🔧 檢測到公式: {cell_value}")
                    date_value = self._evaluate_date_formula(cell_value, base_date, col)
                    if date_value:
                        self._log(f"    ✅ 公式解析成功: {date_value}")
                    else:
                        self._log(f"    ❌ 公式解析失敗")
                else:
                    self._log(f"    📝 嘗試解析普通日期值")
                    date_value = self._parse_date_value(cell_value)
                    if date_value:
                        self._log(f"    ✅ 日期解析成功: {date_value}")
                    else:
                        self._log(f"    ❌ 日期解析失敗")
                
                if date_value:
                    if base_date is None:
                        base_date = date_value
                        self._log(f"    🎯 設置基準日期: {base_date}")
                    
                    date_str = date_value.strftime('%d/%m/%y')
                    dates.append({
                        'column': col,
                        'date': date_str,
                        'col_index': col,
                        'original_value': str(cell_value),
                        'datetime': date_value
                    })
                    self._log(f"    📅 添加日期: {date_str}")
                else:
                    self._log(f"    ⚠️ 跳過無效日期值")
            
            self._log(f"📊 總共解析到 {len(dates)} 個有效日期")
            return dates
        except Exception as e:
            self._log(f"❌ 日期解析失敗: {str(e)}")
            return []
    
    def _evaluate_date_formula(self, formula, base_date, col_index):
        """評估日期公式"""
        try:
            self._log(f"        🔧 評估公式: '{formula}' (基準日期: {base_date}, 列: {col_index})")
            
            # 處理常見的日期公式模式
            if '=' in formula:
                # 處理 =C2+1, =E2+1 等模式
                if '+' in formula:
                    # 簡化邏輯：直接基於列位置計算日期
                    try:
                        # 嘗試從工作表中檢測基準月份
                        base_date = self._detect_base_date_from_worksheet()
                        if not base_date:
                            # 如果無法檢測，使用當前月份
                            current_date = datetime.now()
                            base_date = current_date.replace(day=1)
                        
                        days_offset = col_index - 3  # C列是第3列，從0開始計算
                        if days_offset >= 0:
                            result = base_date + timedelta(days=days_offset)
                            self._log(f"        ✅ 基於列位置計算日期: {base_date} + {days_offset}天 = {result}")
                            return result
                    except Exception as e:
                        self._log(f"        ❌ 列位置日期計算失敗: {str(e)}")
                
                # 處理 =C2-1 等模式
                elif '-' in formula:
                    parts = formula.split('-')
                    if len(parts) == 2 and parts[1].strip().isdigit():
                        days_to_subtract = int(parts[1].strip())
                        if base_date:
                            result = base_date - timedelta(days=days_to_subtract)
                            self._log(f"        ✅ 減法公式解析成功: {base_date} - {days_to_subtract}天 = {result}")
                            return result
                        else:
                            self._log(f"        ❌ 缺少基準日期")
                
                # 處理 =C2 等引用公式
                elif '=' in formula and not ('+' in formula or '-' in formula):
                    self._log(f"        ℹ️ 引用公式，需要基準日期")
                    if base_date:
                        result = base_date
                        self._log(f"        ✅ 使用基準日期: {result}")
                        return result
            
            # 如果無法解析公式，嘗試基於列位置計算
            if base_date and col_index > 1:
                days_offset = col_index - 1
                result = base_date + timedelta(days=days_offset)
                self._log(f"        ✅ 基於列位置計算: {base_date} + {days_offset}天 = {result}")
                return result
            elif col_index > 1:
                # 如果沒有基準日期，嘗試基於列位置和檢測到的月份作為基準
                try:
                    # 嘗試從工作表中檢測基準月份
                    base_date = self._detect_base_date_from_worksheet()
                    if not base_date:
                        # 如果無法檢測，使用當前月份
                        current_date = datetime.now()
                        base_date = current_date.replace(day=1)
                    
                    days_offset = col_index - 3  # C列是第3列，從0開始計算
                    if days_offset >= 0:
                        result = base_date + timedelta(days=days_offset)
                        self._log(f"        ✅ 使用檢測到的基準日期計算: {base_date} + {days_offset}天 = {result}")
                        return result
                except Exception as e:
                    self._log(f"        ❌ 基準日期計算失敗: {str(e)}")
            else:
                self._log(f"        ❌ 無法計算: 缺少基準日期或列位置無效")
                
        except Exception as e:
            self._log(f"        ❌ 公式評估異常: {str(e)}")
        
        return None
    
    def _parse_date_value(self, value):
        """解析日期值"""
        try:
            self._log(f"      🔍 解析日期值: '{value}' (類型: {type(value)})")
            
            # 檢查是否是datetime對象
            if hasattr(value, 'strftime'):
                self._log(f"      ✅ 已經是datetime對象: {value}")
                return value
            
            # 檢查是否是Excel日期序列號
            if isinstance(value, (int, float)) and value > 1000:
                try:
                    from openpyxl.utils.datetime import from_excel
                    excel_date = from_excel(value)
                    self._log(f"      ✅ Excel序列號轉換成功: {excel_date}")
                    return excel_date
                except:
                    self._log(f"      ⚠️ Excel序列號轉換失敗")
            
            if isinstance(value, str):
                self._log(f"      📝 處理字符串值")
                
                # 處理 "1-Jul" 格式
                if '-' in value and len(value.split('-')) == 2:
                    day, month = value.split('-')
                    if day.isdigit():
                        day = int(day)
                        # 簡化的月份映射
                        month_map = {
                            'jan': 1, 'feb': 2, 'mar': 3, 'apr': 4,
                            'may': 5, 'jun': 6, 'jul': 7, 'aug': 8,
                            'sep': 9, 'oct': 10, 'nov': 11, 'dec': 12
                        }
                        month_str = month.lower()[:3]
                        if month_str in month_map:
                            month = month_map[month_str]
                            # 假設當前年份
                            year = datetime.now().year
                            result = datetime(year, month, day)
                            self._log(f"      ✅ 1-Jul格式解析成功: {result}")
                            return result
                        else:
                            self._log(f"      ❌ 月份映射失敗: {month_str}")
                
                # 處理其他日期格式
                date_formats = ['%d/%m/%y', '%d-%m-%y', '%Y-%m-%d', '%d/%m/%Y', '%m/%d/%y', '%m-%d-%y']
                for fmt in date_formats:
                    try:
                        result = datetime.strptime(value, fmt)
                        self._log(f"      ✅ 格式 {fmt} 解析成功: {result}")
                        return result
                    except ValueError:
                        continue
                
                self._log(f"      ❌ 所有日期格式都解析失敗")
            else:
                self._log(f"      ❌ 不支持的值類型: {type(value)}")
            
        except Exception as e:
            self._log(f"      ❌ 解析異常: {str(e)}")
        
        return None
    
    def _read_excel_outlets(self, ws, outlet_col, date_row, dates):
        """智能讀取Excel門市數據 - 支持Oriental格式"""
        try:
            outlets = []
            col_letter = get_column_letter(outlet_col)
            self._log(f"🔍 開始讀取門市數據...")
            self._log(f"  門市列: {col_letter}")
            
            # 確定數據開始行
            if date_row == 'ORIENTAL_FORMAT':
                # Oriental格式：數據從第3行開始
                data_start_row = 3
                self._log(f"  📊 Oriental格式：數據從第 {data_start_row} 行開始")
            else:
                # 標準格式：數據從日期行+1開始
                data_start_row = date_row + 1
                self._log(f"  📊 標準格式：數據從第 {data_start_row} 行開始")
            
            for row in range(data_start_row, ws.max_row + 1):
                outlet_name = ws.cell(row=row, column=outlet_col).value
                if not outlet_name:
                    continue
                
                self._log(f"  🏪 處理門市: '{outlet_name}' (行 {row})")
                
                outlet_info = {
                    'name': str(outlet_name).strip(),
                    'row': row,
                    'daily_data': {}
                }
                
                # 讀取該門市的每日金額
                for date_info in dates:
                    amount_cell = ws.cell(row=row, column=date_info['col_index'])
                    if amount_cell.value:
                        try:
                            amount = float(amount_cell.value)
                            outlet_info['daily_data'][date_info['date']] = amount
                            if amount > 0:
                                self._log(f"    📅 {date_info['date']}: ${amount:.2f}")
                        except (ValueError, TypeError):
                            outlet_info['daily_data'][date_info['date']] = 0.0
                    else:
                        outlet_info['daily_data'][date_info['date']] = 0.0
                
                outlets.append(outlet_info)
            
            self._log(f"  ✅ 成功讀取 {len(outlets)} 個門市")
            return outlets
        except Exception as e:
            self._log(f"❌ 門市數據讀取失敗: {str(e)}")
            return []
    
    def _update_and_compare_ui(self):
        """多廠商匹配并更新/对比UI"""
        # 檢查是否有任何PDF數據
        active_vendors = [v for v in self.pdf_files.keys() if self.pdf_files[v].get('data')]
        if not active_vendors:
            self._log("❌ 請先提取至少一個廠商的PDF數據")
            return
        
        if not self.excel_data:
            self._log("❌ 請先讀取Excel數據")
            return
        
        config_path = self.config_path_var.get().strip()
        if not config_path or not os.path.exists(config_path):
            self._log("❌ 請先選擇Config Excel文件")
            return
        
        consolidate_path = self.excel_path_var.get().strip()
        if not consolidate_path or not os.path.exists(consolidate_path):
            self._log("❌ 請先選擇Consolidate Excel文件")
            return
        
        self._log(f"🔄 開始多廠商匹配對比 ({', '.join(active_vendors)})...")
        self._log_compare(f"🔄 開始多廠商匹配對比 ({', '.join(active_vendors)})...")
        
        try:
            from openpyxl import load_workbook
            from openpyxl.styles import PatternFill
            
            # 1) 讀取配置映射: B(合併店名) -> C(PDF店名)
            self._log("📋 讀取配置映射...")
            self._log_compare("📋 讀取配置映射...")
            map_wb = load_workbook(config_path, data_only=True)
            map_ws = map_wb.active
            
            # 建立PDF門市到Consolidate門市的映射
            pdf_to_consolidate = {}
            def _norm(name: str) -> str:
                import re
                s = re.sub(r"[\s\-_/()]+", "", name.upper())
                # 去掉公司前後綴等噪聲詞
                for token in ["SUSHIEXPRESSGROUPPTELTD", "SUSHIEXPRESS", "PTE", "LTD", "@"]:
                    s = s.replace(token, "")
                return s
            
            for row in range(2, map_ws.max_row + 1):
                consolidate_name = map_ws.cell(row=row, column=2).value  # B列：Consolidate門市名
                pdf_name = map_ws.cell(row=row, column=3).value         # C列：PDF門市名
                if consolidate_name and pdf_name:
                    pdf_key = str(pdf_name).strip().upper()
                    consolidate_val = str(consolidate_name).strip()
                    pdf_to_consolidate[pdf_key] = consolidate_val
                    pdf_to_consolidate[_norm(pdf_key)] = consolidate_val  # 歸一化鍵，支持模糊
            map_wb.close()
            self._log(f"✅ 配置映射讀取完成，共 {len(pdf_to_consolidate)} 個映射")
            self._log_compare(f"✅ 配置映射讀取完成，共 {len(pdf_to_consolidate)} 個映射")
            
            # 2) 合併所有廠商的PDF門市日金額，金額/1.09，並記錄發票號
            daily_pdf = {}  # {consolidate_outlet: {dd/mm/yy: {amount: float, invoice_nos: [str], vendors: [str]}}}
            
            # 處理每個活躍廠商的數據
            for vendor in active_vendors:
                vendor_data = self.pdf_files[vendor]['data']
                self._log(f"📊 處理 {vendor} 廠商數據...")
                self._log_compare(f"📊 處理 {vendor} 廠商數據...")
                
                for inv in vendor_data.get('invoices', []):
                    raw_name = str(inv.get('outlet_name', '')).strip()
                    pdf_name = raw_name.upper()
                    mapped = pdf_to_consolidate.get(pdf_name)
                    if not mapped:
                        mapped = pdf_to_consolidate.get(_norm(pdf_name))
                    if not mapped:
                        # 顯示未匹配信息
                        self._log(f"[{vendor}] [未匹配] PDF門市 '{raw_name}' 未在配置中找到映射，跳過聚合")
                        self._log_compare(f"[{vendor}] [未匹配] PDF門市 '{raw_name}' 未在配置中找到映射，跳過聚合")
                        continue
                    date_str = inv.get('date')
                    amt = inv.get('amount', 0) or 0
                    amt = float(amt) / 1.09
                    invoice_no = str(inv.get('invoice_no', '')).strip()
                    if mapped and date_str:
                        entry = daily_pdf.setdefault(mapped, {}).setdefault(date_str, {"amount": 0.0, "invoice_nos": [], "vendors": []})
                        entry["amount"] += amt
                        if invoice_no:
                            entry["invoice_nos"].append(f"[{vendor}] {invoice_no}")
                        if vendor not in entry["vendors"]:
                            entry["vendors"].append(vendor)
            
            # 3) 打開合併表，寫入關鍵數據到AK列（按映射對齊）並逐日對比
            wb = load_workbook(consolidate_path)
            
            # 根據活躍廠商對比各自的工作表
            comparison_results = {}
            for vendor in active_vendors:
                self._log(f"🔍 處理 {vendor} 廠商工作表...")
                self._log_compare(f"🔍 處理 {vendor} 廠商工作表...")
                
                # 選擇對應廠商的工作表
                if vendor in wb.sheetnames:
                    ws = wb[vendor]
                    self._log(f"📋 選擇工作表: {vendor}")
                else:
                    self._log(f"⚠️ 未找到 '{vendor}' 工作表，跳過此廠商")
                    self._log_compare(f"⚠️ 未找到 '{vendor}' 工作表，跳過此廠商")
                    continue
            
            # 3.1 找出日期行與門市列(B)
            # 固定使用第2行作為日期行（與智能識別一致），若為空則回退到自動探測
            date_row = 2
            if not any(ws.cell(row=date_row, column=c).value for c in range(3, ws.max_column + 1)):
                for r in range(1, min(10, ws.max_row + 1)):
                    if any(ws.cell(row=r, column=c).value for c in range(3, ws.max_column + 1)):
                        date_row = r
                        break
            
            # 構造列索引: 日期 -> 列（支持公式，通過智能解析第二行日期）
            date_to_col = {}
            from datetime import datetime as _dt
            import re as _re
            # 復用智能日期解析：如果是字符串公式如 =C2+1，也能解析
            base_date = None
            for c in range(1, ws.max_column + 1):
                raw = ws.cell(row=date_row, column=c).value
                parsed = None
                if hasattr(raw, 'strftime'):
                    parsed = raw
                elif isinstance(raw, (int, float)) and raw > 1000:
                    try:
                        from openpyxl.utils.datetime import from_excel as _from_excel
                        parsed = _from_excel(raw)
                    except Exception:
                        parsed = None
                elif isinstance(raw, str):
                    s = raw.strip()
                    if s.startswith('='):
                        # 處理 =C2+1 按列偏移
                        if base_date is None:
                            # 查找左邊最近一個非空的已解析日期作為基準
                            for c2 in range(c-1, 0, -1):
                                left = ws.cell(row=date_row, column=c2).value
                                if isinstance(left, str) and not left:
                                    continue
                                if isinstance(left, str) and '/' in left:
                                    try:
                                        base_date = _dt.strptime(left, '%d/%m/%y')
                                        break
                                    except Exception:
                                        pass
                        if base_date is None:
                            # 使用 1-Jul 當前年作為基準
                            base_date = _dt(_dt.now().year, 7, 1)
                        # 根據到第3列(C)的偏移估算
                        try:
                            from datetime import timedelta as _td
                            offset = c - 3
                            parsed = base_date + _td(days=max(0, offset))
                        except Exception:
                            parsed = None
                    else:
                        # 普通日期文本
                        for fmt in ['%d/%m/%y', '%d-%m-%y', '%Y-%m-%d', '%d/%m/%Y']:
                            try:
                                parsed = _dt.strptime(s, fmt)
                                break
                            except Exception:
                                continue
                if parsed is not None:
                    date_to_col[parsed.strftime('%d/%m/%y')] = c
            
            yellow = PatternFill(start_color="00FFFF00", end_color="00FFFF00", fill_type="solid")
            
            # 3.2 遍歷門市行，從B列讀取店名，寫AK列並比對
            AK_COL = 37  # AK 列索引
            matched_outlets = 0
            unmatched_outlets = 0
            total_differences = 0
            
            for r in range(date_row + 1, ws.max_row + 1):
                outlet = ws.cell(row=r, column=2).value
                if not outlet:
                    continue
                outlet = str(outlet).strip()
                
                # 寫入關鍵數據: 取映射到該門市的賬齡金額（如果有）
                aging_amount = 0.0
                # 從當前廠商的PDF數據中查找門市
                vendor_data = self.pdf_files[vendor]['data']
                for o in vendor_data.get('outlets', []):
                    oname = str(o['name']).strip()
                    mapped = pdf_to_consolidate.get(oname.upper()) or pdf_to_consolidate.get(_norm(oname))
                    if mapped == outlet:
                        aging_amount = o.get('aging_amount', 0.0) or 0.0
                        break
                ws.cell(row=r, column=AK_COL, value=aging_amount)
                
                # 對比逐日
                pdf_days = daily_pdf.get(outlet, {})
                if pdf_days:
                    matched_outlets += 1
                    self._log(f"🏪 處理門市: {outlet}")
                    self._log(f"  ✅ 找到PDF對應")
                    # 對比日誌只記錄差異，不記錄處理過程
                    
                    for d, pdf_entry in pdf_days.items():
                        pdf_amt = pdf_entry.get("amount", 0.0)
                        invoice_list = pdf_entry.get("invoice_nos", [])
                        c = date_to_col.get(d)
                        if not c:
                            # 只記錄差異/問題；找不到列也記一次
                            self._log(f"    [缺列] {d}：找不到列，PDF={pdf_amt:.2f} 發票={','.join(invoice_list) or '-'}")
                            self._log_compare(f"    [缺列] {d}：找不到列，PDF={pdf_amt:.2f} 發票={','.join(invoice_list) or '-'}")
                            continue
                        try:
                            excel_amt = ws.cell(row=r, column=c).value or 0
                            excel_amt = float(excel_amt)
                        except Exception:
                            excel_amt = 0
                        # 差異高亮
                        if abs(pdf_amt - excel_amt) > 0.01:
                            ws.cell(row=r, column=c).fill = yellow
                            total_differences += 1
                            invs = ','.join(invoice_list) if invoice_list else '-'
                            self._log(f"    ❌ {d}: PDF=${pdf_amt:.2f} vs Excel=${excel_amt:.2f} (差異: ${abs(pdf_amt - excel_amt):.2f})")
                            self._log_compare(f"🏪 {outlet} - ❌ {d}: PDF=${pdf_amt:.2f} vs Excel=${excel_amt:.2f} (差異: ${abs(pdf_amt - excel_amt):.2f})")
                            self._log(f"        📄 PDF發票: {invs}")
                            self._log_compare(f"        📄 PDF發票: {invs}")
                        else:
                            self._log(f"    ✅ {d}: PDF=${pdf_amt:.2f} vs Excel=${excel_amt:.2f} (匹配)")
                            # 對比日誌只記錄差異，不記錄匹配
                else:
                    unmatched_outlets += 1
                    self._log(f"🏪 處理門市: {outlet}")
                    self._log(f"  ❌ 未找到PDF對應")
                    # 對比日誌只記錄差異，不記錄未匹配門市
            
            # 保存Excel文件
            wb.save(consolidate_path)
            
            # 記錄統計結果
            self._log("📊 匹配統計結果:")
            self._log_compare("📊 匹配統計結果:")
            self._log(f"  ✅ 匹配門市: {matched_outlets}")
            self._log_compare(f"  ✅ 匹配門市: {matched_outlets}")
            self._log(f"  ❌ 未匹配門市: {unmatched_outlets}")
            self._log_compare(f"  ❌ 未匹配門市: {unmatched_outlets}")
            self._log(f"  🔍 總差異: {total_differences}")
            self._log_compare(f"  🔍 總差異: {total_differences}")
            
            self._log("🎉 匹配並更新/對比完成！")
            self._log_compare("🎉 匹配並更新/對比完成！")
            self._log("✅ Excel文件已更新：")
            self._log_compare("✅ Excel文件已更新：")
            self._log("   - AK列已寫入PDF關鍵數據")
            self._log_compare("   - AK列已寫入PDF關鍵數據")
            self._log("   - 差異單元格已標黃")
            self._log_compare("   - 差異單元格已標黃")
            self._log(f"   - 文件已保存到: {consolidate_path}")
            self._log_compare(f"   - 文件已保存到: {consolidate_path}")
            
            # 生成发票号码总结报告
            self._log("📋 發票號碼總結報告:")
            self._log_compare("📋 發票號碼總結報告:")
            
            # 按厂商分组统计发票号码
            vendor_invoices = {}
            for vendor in active_vendors:
                vendor_data = self.pdf_files[vendor]['data']
                vendor_invoices[vendor] = []
                
                for inv in vendor_data.get('invoices', []):
                    invoice_no = str(inv.get('invoice_no', '')).strip()
                    if invoice_no:
                        vendor_invoices[vendor].append(invoice_no)
            
            # 输出每个厂商的发票号码
            for vendor, invoices in vendor_invoices.items():
                if invoices:
                    self._log(f"[{vendor}]")
                    self._log_compare(f"[{vendor}]")
                    # 将每个发票号码单独一行输出
                    for invoice in invoices:
                        self._log(f"{invoice}")
                        self._log_compare(f"{invoice}")
                    self._log("")  # 发票号码后空一行
                    self._log_compare("")  # 发票号码后空一行
                    self._log("")  # 空行分隔
                    self._log_compare("")  # 空行分隔
                else:
                    self._log(f"[{vendor}]")
                    self._log_compare(f"[{vendor}]")
                    self._log("無發票號碼")
                    self._log_compare("無發票號碼")
                    self._log("")
                    self._log_compare("")
            
            self._log("📋 發票號碼總結報告完成！")
            self._log_compare("📋 發票號碼總結報告完成！")
            
        except Exception as e:
            self._log(f"❌ 匹配並更新/對比失敗: {str(e)}")
            import traceback
            self._log(f"🔍 錯誤詳情: {traceback.format_exc()}")
    
    def _log(self, message):
        """记录操作日志"""
        timestamp = datetime.now().strftime("%H:%M:%S")
        log_message = f"[{timestamp}] {message}\n"
        self.operation_log.insert('end', log_message)
        self.operation_log.see('end')
        print(log_message.strip())
    
    def _log_compare(self, message):
        """记录对比日志到对比日志标签页"""
        timestamp = datetime.now().strftime("%H:%M:%S")
        log_message = f"[{timestamp}] {message}\n"
        if hasattr(self, 'compare_log'):
            self.compare_log.insert('end', log_message)
            self.compare_log.see('end')
        print(log_message.strip())
    
    def _clear_logs(self):
        """清空所有日志"""
        self.operation_log.delete('1.0', 'end')
        self.comparison_log.delete('1.0', 'end')
        self._log("日誌已清空")
    
    def _extract_pdf_data(self):
        """提取PDF数据"""
        print("🔍 DEBUG: 开始提取PDF数据")
        pdf_path = self.pdf_path_var.get()
        print(f"🔍 DEBUG: PDF文件路径: {pdf_path}")
        
        if not pdf_path:
            print("❌ DEBUG: 没有选择PDF文件")
            messagebox.showwarning("警告", "請先選擇PDF文件！")
            return
        
        try:
            print("🔍 DEBUG: 清空之前的数据")
            # 清空之前的数据
            self.pdf_text.delete('1.0', 'end')
            self.pdf_data = {}
            
            print("🔍 DEBUG: 开始调用_extract_pdf_content")
            # 提取PDF数据
            extracted_data = self._extract_pdf_content(pdf_path)
            print(f"🔍 DEBUG: 提取的数据长度: {len(extracted_data) if extracted_data else 0}")
            
            print("🔍 DEBUG: 显示提取的数据到文本框")
            # 显示提取的数据
            self.pdf_text.insert('1.0', extracted_data)
            
            print("🔍 DEBUG: 显示成功消息")
            messagebox.showinfo("成功", "PDF數據提取完成！")
            print("✅ DEBUG: PDF数据提取完成")
            
        except Exception as e:
            print(f"❌ DEBUG: PDF数据提取失败: {e}")
            import traceback
            print(f"❌ DEBUG: 错误详情: {traceback.format_exc()}")
            messagebox.showerror("錯誤", f"PDF數據提取失敗：{str(e)}")
    
    def _test_pdf_text(self):
        """测试PDF文本提取 - 显示详细的提取过程"""
        if not self.pdf_path_var.get():
            messagebox.showwarning("警告", "請先選擇PDF文件！")
            return
        
        try:
            pdf_path = self.pdf_path_var.get()
            print(f"🧪 DEBUG: 开始测试PDF文本提取: {pdf_path}")
            
            # 测试不同的提取方法
            print("🧪 DEBUG: === 测试PDF文本提取 ===")
            
            # 方法1: pdfplumber
            try:
                import pdfplumber
                print("🧪 DEBUG: 尝试使用pdfplumber...")
                with pdfplumber.open(pdf_path) as pdf:
                    text_content = ""
                    for i, page in enumerate(pdf.pages):
                        page_text = page.extract_text()
                        print(f"🧪 DEBUG: 第{i+1}页 (pdfplumber): 长度={len(page_text) if page_text else 0}")
                        if page_text:
                            text_content += f"\n--- 第{i+1}页 ---\n{page_text}\n"
                    
                    if text_content.strip():
                        print(f"🧪 DEBUG: pdfplumber成功，总长度: {len(text_content)}")
                        # 显示前500个字符
                        preview = text_content[:500] + "..." if len(text_content) > 500 else text_content
                        print(f"🧪 DEBUG: 文本预览: {preview}")
                    else:
                        print("🧪 DEBUG: pdfplumber提取的文本为空")
            except Exception as e:
                print(f"🧪 DEBUG: pdfplumber失败: {e}")
            
            # 方法2: PyPDF2
            try:
                import PyPDF2
                print("🧪 DEBUG: 尝试使用PyPDF2...")
                with open(pdf_path, 'rb') as file:
                    pdf_reader = PyPDF2.PdfReader(file)
                    text_content = ""
                    for i, page in enumerate(pdf_reader.pages):
                        page_text = page.extract_text()
                        print(f"🧪 DEBUG: 第{i+1}页 (PyPDF2): 长度={len(page_text) if page_text else 0}")
                        if page_text:
                            text_content += f"\n--- 第{i+1}页 ---\n{page_text}\n"
                    
                    if text_content.strip():
                        print(f"🧪 DEBUG: PyPDF2成功，总长度: {len(text_content)}")
                        # 显示前500个字符
                        preview = text_content[:500] + "..." if len(text_content) > 500 else text_content
                        print(f"🧪 DEBUG: 文本预览: {preview}")
                    else:
                        print("🧪 DEBUG: PyPDF2提取的文本为空")
            except Exception as e:
                print(f"🧪 DEBUG: PyPDF2失败: {e}")
            
            # 方法3: OCR (如果可用)
            try:
                import fitz  # PyMuPDF
                import pytesseract
                from PIL import Image
                print("🧪 DEBUG: 尝试使用OCR...")
                
                # 检查Tesseract是否可用
                try:
                    pytesseract.get_tesseract_version()
                    print("🧪 DEBUG: Tesseract可用")
                except:
                    print("🧪 DEBUG: Tesseract不可用")
                    return
                
                doc = fitz.open(pdf_path)
                text_content = ""
                for i, page in enumerate(doc):
                    # 将页面转换为图像
                    pix = page.get_pixmap()
                    img = Image.frombytes("RGB", [pix.width, pix.height], pix.samples)
                    
                    # 使用OCR提取文本
                    page_text = pytesseract.image_to_string(img, lang='eng')
                    print(f"🧪 DEBUG: 第{i+1}页 (OCR): 长度={len(page_text) if page_text else 0}")
                    if page_text:
                        text_content += f"\n--- 第{i+1}页 ---\n{page_text}\n"
                
                doc.close()
                
                if text_content.strip():
                    print(f"🧪 DEBUG: OCR成功，总长度: {len(text_content)}")
                    # 显示前500个字符
                    preview = text_content[:500] + "..." if len(text_content) > 500 else text_content
                    print(f"🧪 DEBUG: 文本预览: {preview}")
                else:
                    print("🧪 DEBUG: OCR提取的文本为空")
                    
            except Exception as e:
                print(f"🧪 DEBUG: OCR失败: {e}")
            
            print("🧪 DEBUG: === PDF文本提取测试完成 ===")
            messagebox.showinfo("测试完成", "PDF文本提取测试完成！\n请查看控制台输出获取详细信息。")
            
        except Exception as e:
            print(f"🧪 DEBUG: PDF文本测试异常: {e}")
            messagebox.showerror("錯誤", f"PDF文本测试失敗：{str(e)}")
    
    def _analyze_extracted_text(self):
        """分析已提取的文本内容 - 帮助诊断数据提取问题"""
        try:
            # 获取已提取的PDF文本
            pdf_text = self.pdf_text.get('1.0', 'end-1c')
            if not pdf_text.strip():
                messagebox.showwarning("警告", "請先提取PDF數據！")
                return
            
            print("🔍 DEBUG: === 分析已提取的文本内容 ===")
            print(f"🔍 DEBUG: 文本总长度: {len(pdf_text)}")
            
            # 分析文本内容
            lines = pdf_text.split('\n')
            print(f"🔍 DEBUG: 总行数: {len(lines)}")
            
            # 查找关键信息
            import re
            
            # 1. 查找Invoice号码
            inv_pattern = r'INV-SH\d+'
            inv_matches = re.findall(inv_pattern, pdf_text)
            print(f"🔍 DEBUG: 找到的Invoice号码: {inv_matches}")
            print(f"🔍 DEBUG: Invoice号码数量: {len(inv_matches)}")
            
            # 2. 查找所有数字
            all_numbers = re.findall(r'(\d+\.?\d*)', pdf_text)
            print(f"🔍 DEBUG: 找到的所有数字: {all_numbers[:20]}...")  # 只显示前20个
            
            # 3. 查找可能的金额
            potential_amounts = []
            for num_str in all_numbers:
                try:
                    num = float(num_str)
                    if 10 <= num <= 100000:  # 合理的金额范围
                        potential_amounts.append((num, num_str))
                except ValueError:
                    continue
            
            # 按金额排序
            potential_amounts.sort(key=lambda x: x[0], reverse=True)
            print(f"🔍 DEBUG: 潜在的金额 (前10个): {[f'{num:.2f}' for num, _ in potential_amounts[:10]]}")
            
            # 4. 查找关键文本模式
            key_patterns = [
                r'Amount Due',
                r'Total',
                r'Sub Total',
                r'GST',
                r'Invoice',
                r'Date',
                r'Due Date'
            ]
            
            for pattern in key_patterns:
                matches = re.findall(pattern, pdf_text, re.IGNORECASE)
                if matches:
                    print(f"🔍 DEBUG: 找到 '{pattern}': {len(matches)} 次")
            
            # 5. 显示文本的前几行和后几行
            print(f"🔍 DEBUG: 文本前5行:")
            for i, line in enumerate(lines[:5]):
                print(f"  {i+1}: {line}")
            
            print(f"🔍 DEBUG: 文本后5行:")
            for i, line in enumerate(lines[-5:]):
                print(f"  {len(lines)-4+i}: {line}")
            
            # 6. 查找包含Invoice号码的行
            print(f"🔍 DEBUG: 包含Invoice号码的行:")
            for i, line in enumerate(lines):
                if 'INV-SH' in line:
                    print(f"  第{i+1}行: {line}")
            
            print("🔍 DEBUG: === 文本分析完成 ===")
            messagebox.showinfo("分析完成", "文本内容分析完成！\n请查看控制台输出获取详细信息。")
            
        except Exception as e:
            print(f"🔍 DEBUG: 文本分析失败: {e}")
            import traceback
            print(f"🔍 DEBUG: 错误详情: {traceback.format_exc()}")
            messagebox.showerror("錯誤", f"文本分析失敗：{str(e)}")
    
    # _extract_pdf_content方法已移除
    
    def _parse_soa_data_from_text(self, text):
        """从PDF文本中解析SOA数据"""
        try:
            import re
            
            # 清空之前的数据
            self.soa_data = {}
            
            # 改进的金额模式，支持更多格式
            amount_pattern = r'[\$]?[\d,]+\.?\d*'
            
            # 按行处理文本
            lines = text.split('\n')
            line_count = 0
            
            for line in lines:
                line = line.strip()
                line_count += 1
                
                if line and len(line) > 5:  # 确保行有足够的内容
                    # 查找行中的金额
                    amounts = re.findall(amount_pattern, line)
                    
                    if amounts:
                        # 尝试提取项目名称
                        for amount in amounts:
                            amount_pos = line.find(amount)
                            if amount_pos > 0:
                                # 提取金额前的文本作为项目名称
                                item_name = line[:amount_pos].strip()
                                # 清理项目名称，保留更多有效字符
                                item_name = re.sub(r'[^\w\s\-\.\-\/\(\)]', '', item_name).strip()
                                
                                if item_name and len(item_name) > 2:
                                    # 避免重复，使用行号作为标识
                                    unique_name = f"{item_name}_行{line_count}"
                                    self.soa_data[unique_name] = amount
                                elif not item_name or len(item_name) <= 2:
                                    # 如果没有找到有意义的项目名称，使用行号
                                    unique_name = f"项目_行{line_count}"
                                    self.soa_data[unique_name] = amount
            
            # 如果没有找到结构化数据，尝试其他方法
            if not self.soa_data:
                self._parse_table_format_data(text)
            
            # 如果还是没有数据，创建一些示例数据用于演示
            if not self.soa_data:
                self.soa_data = {
                    "示例项目1": "$100.00",
                    "示例项目2": "$250.50",
                    "示例项目3": "$75.25"
                }
            
            print(f"解析完成，找到 {len(self.soa_data)} 个项目")
            for item, amount in self.soa_data.items():
                print(f"  {item}: {amount}")
                
        except Exception as e:
            print(f"解析SOA数据失败: {e}")
            import traceback
            print(f"错误详情: {traceback.format_exc()}")
            # 创建默认数据
            self.soa_data = {
                "默认项目": "$0.00"
            }
    
    def _parse_table_format_data(self, text):
        """解析表格格式的数据"""
        try:
            import re
            
            # 查找表格行（通常包含多个金额）
            lines = text.split('\n')
            for line in lines:
                line = line.strip()
                if line and len(line) > 10:  # 确保行有足够的内容
                    # 查找行中的金额
                    amounts = re.findall(r'[\$]?[\d,]+\.?\d*', line)
                    if len(amounts) >= 2:  # 至少有两个金额的行可能是表格行
                        # 尝试分割行内容
                        parts = re.split(r'\s+', line)
                        for i, part in enumerate(parts):
                            if re.match(r'[\$]?[\d,]+\.?\d*', part):
                                # 这是一个金额，尝试找到对应的项目名称
                                if i > 0:
                                    item_name = ' '.join(parts[:i]).strip()
                                    if item_name:
                                        self.soa_data[item_name] = part
                                        break
                                        
        except Exception as e:
            print(f"解析表格格式数据失败: {e}")
    
    def _extract_soa_pdf_data(self):
        """提取SOA PDF数据"""
        print("🔍 DEBUG: 开始提取SOA PDF数据")
        soa_path = self.soa_path_var.get()
        print(f"🔍 DEBUG: SOA PDF文件路径: {soa_path}")
        
        if not soa_path:
            print("❌ DEBUG: 没有选择SOA PDF文件")
            messagebox.showwarning("警告", "請先選擇SOA PDF文件！")
            return
        
        try:
            print("🔍 DEBUG: 清空之前的数据")
            # 清空之前的数据
            self.soa_text.delete('1.0', 'end')
            self.soa_data = {}
            
            print("🔍 DEBUG: 开始调用_extract_pdf_content")
            # 提取SOA PDF数据
            extracted_data = self._extract_pdf_content(soa_path)
            print(f"🔍 DEBUG: 提取的数据长度: {len(extracted_data) if extracted_data else 0}")
            
            print("🔍 DEBUG: 显示提取的数据到文本框")
            # 显示提取的数据
            self.soa_text.insert('1.0', extracted_data)
            
            print("🔍 DEBUG: 开始解析SOA数据")
            # 从提取的文本中解析关键数据
            self._parse_soa_data_from_text(extracted_data)
            print(f"🔍 DEBUG: 解析后的SOA数据数量: {len(self.soa_data)}")
            
            print("🔍 DEBUG: 显示解析后的数据")
            # 显示解析后的数据
            self._display_soa_data()
            
            print("🔍 DEBUG: 显示成功消息")
            messagebox.showinfo("成功", "SOA PDF數據提取完成！")
            print("✅ DEBUG: SOA PDF数据提取完成")
            
        except Exception as e:
            print(f"❌ DEBUG: SOA PDF数据提取失败: {e}")
            import traceback
            print(f"❌ DEBUG: 错误详情: {traceback.format_exc()}")
            messagebox.showerror("錯誤", f"SOA PDF數據提取失敗：{str(e)}")
    
    def _load_csv_data(self, file_path):
        """加载CSV数据"""
        import csv
        
        with open(file_path, 'r', encoding='utf-8') as file:
            reader = csv.DictReader(file)
            for row in reader:
                # 假设CSV有 'item', 'amount' 列
                item = row.get('item', '')
                amount = row.get('amount', '')
                if item and amount:
                    self.soa_data[item] = amount
    
    def _load_excel_data(self, file_path):
        """加载Excel数据"""
        try:
            import openpyxl
            
            wb = openpyxl.load_workbook(file_path)
            ws = wb.active
            
            # 假设第一行是标题，从第二行开始读取数据
            for row in ws.iter_rows(min_row=2, values_only=True):
                if len(row) >= 2:
                    item = str(row[0]) if row[0] else ''
                    amount = str(row[1]) if row[1] else ''
                    if item and amount:
                        self.soa_data[item] = amount
            
            wb.close()
            
        except Exception as e:
            raise Exception(f"Excel文件讀取失敗：{str(e)}")
    
    def _display_soa_data(self):
        """显示SOA数据"""
        self.soa_text.delete('1.0', 'end')
        
        if not self.soa_data:
            self.soa_text.insert('1.0', "無數據 / No data")
            return
        
        # 格式化显示数据
        for item, amount in self.soa_data.items():
            self.soa_text.insert('end', f"{item}: {amount}\n")
    
    def _start_reconciliation(self):
        """开始核对"""
        print("🔍 DEBUG: 开始执行核对")
        
        # 簡化：僅檢查是否選擇了兩個檔案
        if not self.pdf_path_var.get():
            messagebox.showwarning("警告", "請先選擇 Invoices PDF！")
            return
        if not self.soa_path_var.get():
            messagebox.showwarning("警告", "請先選擇 SOA PDF！")
            return
        
        # 簡化模式不再預先依賴 self.soa_data；直接在核對流程中解析選取的 SOA 檔案
        
        try:
            print("🔍 DEBUG: 清空之前的结果表格")
            # 清空之前的结果
            for item in self.tree.get_children():
                self.tree.delete(item)
            
            print("🔍 DEBUG: 开始执行_perform_reconciliation")
            # 执行核对
            self.reconciliation_results = self._perform_reconciliation()
            print(f"🔍 DEBUG: 核对结果数量: {len(self.reconciliation_results) if self.reconciliation_results else 0}")
            
            print("🔍 DEBUG: 开始显示结果")
            # 显示结果
            self._display_reconciliation_results()
            
            if self.reconciliation_results:
                print(f"✅ DEBUG: 核对完成，找到 {len(self.reconciliation_results)} 个项目")
                messagebox.showinfo("成功", f"核對完成！發現 {len(self.reconciliation_results)} 個項目")
            else:
                print("⚠️ DEBUG: 核对完成，但没有找到匹配的数据")
                messagebox.showwarning("警告", "核對完成，但沒有找到匹配的數據！")
            
        except Exception as e:
            print(f"❌ DEBUG: 核对失败: {e}")
            import traceback
            print(f"❌ DEBUG: 错误详情: {traceback.format_exc()}")
            messagebox.showerror("錯誤", f"核對失敗：{str(e)}")
    
    def _perform_reconciliation(self):
        """执行核对逻辑 - 比较两个PDF文件"""
        print("🔍 DEBUG: 开始执行核对逻辑")
        results = []
        
        # 从两个PDF文本中提取关键数据
        # 自動從檔案路徑讀取文本（簡化模式）
        pdf1_text = self._extract_pdf_content(self.pdf_path_var.get()) if getattr(self, 'pdf_path_var', None) else ''
        pdf2_text = self._extract_pdf_content(self.soa_path_var.get()) if getattr(self, 'soa_path_var', None) else ''
        print(f"🔍 DEBUG: PDF1文本长度: {len(pdf1_text)}")
        print(f"🔍 DEBUG: PDF2文本长度: {len(pdf2_text)}")
        
        import re
        
        print("🔍 DEBUG: 开始从PDF1提取结构化数据")
        # 从第一个PDF中提取数据
        pdf1_data = self._extract_structured_data(pdf1_text, "PDF1")
        print(f"🔍 DEBUG: PDF1结构化数据: {pdf1_data}")
        
        print("🔍 DEBUG: 开始从PDF2提取结构化数据")
        # 从第二个PDF中提取数据
        pdf2_data = self._extract_structured_data(pdf2_text, "PDF2")
        print(f"🔍 DEBUG: PDF2结构化数据: {pdf2_data}")
        
        # 比较两个PDF的数据
        all_items = set(list(pdf1_data.keys()) + list(pdf2_data.keys()))
        print(f"🔍 DEBUG: 所有项目数量: {len(all_items)}")
        print(f"🔍 DEBUG: 所有项目: {all_items}")
        
        for item in all_items:
            pdf1_value = pdf1_data.get(item, "未找到")
            pdf2_value = pdf2_data.get(item, "未找到")
            
            print(f"🔍 DEBUG: 核对项目 {item}: PDF1={pdf1_value}, PDF2={pdf2_value}")
            
            if pdf1_value != "未找到" and pdf2_value != "未找到":
                # 两个PDF都有这个项目
                try:
                    # 清理金额字符串，只保留数字和小数点
                    pdf1_clean = re.sub(r'[^\d.]', '', str(pdf1_value))
                    pdf2_clean = re.sub(r'[^\d.]', '', str(pdf2_value))
                    
                    print(f"🔍 DEBUG: 清理后金额: PDF1={pdf1_clean}, PDF2={pdf2_clean}")
                    
                    if pdf1_clean == pdf2_clean:
                        # 金额匹配
                        status = "✅ 匹配"
                        difference = "0.00"
                        print(f"🔍 DEBUG: 金额匹配: {pdf1_clean}")
                    else:
                        # 金额不匹配
                        status = "⚠️ 金額不匹配"
                        try:
                            diff = float(pdf1_clean) - float(pdf2_clean)
                            difference = f"{diff:+.2f}"
                            print(f"🔍 DEBUG: 金额不匹配，差异: {difference}")
                        except:
                            difference = "計算錯誤"
                            print(f"🔍 DEBUG: 金额计算错误")
                except Exception as e:
                    print(f"🔍 DEBUG: 金额处理异常: {e}")
                    status = "❌ 處理錯誤"
                    difference = "錯誤"
                
                results.append({
                    'item': item,
                    'pdf_value': pdf1_value,
                    'soa_value': pdf2_value,
                    'difference': difference,
                    'status': status
                })
            elif pdf1_value != "未找到":
                # 只在Invoice中找到
                print(f"🔍 DEBUG: 仅在Invoice中找到: {item} = {pdf1_value}")
                results.append({
                    'item': item,
                    'pdf_value': pdf1_value,
                    'soa_value': "未找到",
                    'difference': "N/A",
                    'status': "❌ 仅在Invoice中"
                })
            else:
                # 只在SOA中找到
                print(f"🔍 DEBUG: 仅在SOA中找到: {item} = {pdf2_value}")
                results.append({
                    'item': item,
                    'pdf_value': "未找到",
                    'soa_value': pdf2_value,
                    'difference': "N/A",
                    'status': "❌ 仅在SOA中"
                })
        
        print(f"🔍 DEBUG: 核对完成，共生成 {len(results)} 个结果")
        
        return results
    
    def _extract_structured_data(self, text, source_name):
        """从PDF文本中提取结构化数据"""
        print(f"🔍 DEBUG: 开始从{source_name}提取结构化数据")
        data = {}
        
        try:
            import re
            
            if source_name == "PDF1":  # Invoice PDF
                # 提取Invoice号码和Amount Due
                data = self._extract_invoice_data(text)
            elif source_name == "PDF2":  # SOA PDF
                # 提取Invoice号码和Dr金额
                data = self._extract_soa_data(text)
            
            print(f"🔍 DEBUG: {source_name}最终提取数据: {data}")
            return data
            
        except Exception as e:
            print(f"🔍 DEBUG: {source_name}结构化数据提取失败: {e}")
            import traceback
            print(f"🔍 DEBUG: 错误详情: {traceback.format_exc()}")
            return {}
    
    def _is_likely_non_amount(self, amount_str, line_context):
        """判断提取的数字是否可能不是Amount Due"""
        line_upper = line_context.upper()
        
        # 检查是否是页码、行号、数量等
        non_amount_indicators = [
            'PAGE', 'P.', 'QTY', 'QUANTITY', 'S/NO', 'NO.', 'ITEM',
            'STOCK CODE', 'PC', 'PCS', 'PIECES', 'UNIT', 'PCT', 'PKT',
            'LOT', 'BOX', 'CARTON', 'DOZEN', 'DOZ'
        ]
        
        for indicator in non_amount_indicators:
            if indicator in line_upper:
                return True
        
        # 检查是否是很小的整数（通常不是金额）
        try:
            amt_float = float(amount_str)
            if amt_float <= 10 and amt_float == int(amt_float):  # 小于等于10的整数
                return True
        except:
            pass
            
        return False

    def _fix_ocr_amount_errors(self, amount_str):
        """修复常见的OCR金额识别错误"""
        try:
            # 常见OCR错误模式修复
            corrected = amount_str
            
            # 模式1: 705.xx -> 105.xx (7被误识别为1)
            if corrected.startswith('7') and '.' in corrected:
                # 检查是否是7xx.xx格式
                import re
                if re.match(r'^7\d{1,2}\.\d{1,2}$', corrected):
                    test_corrected = '1' + corrected[1:]  # 7 -> 1
                    test_float = float(test_corrected)
                    # 如果修正后的金额在合理范围内，使用修正值
                    if 50 <= test_float <= 500:
                        print(f"🔍 DEBUG: OCR修正 {corrected} -> {test_corrected}")
                        corrected = test_corrected
            
            # 模式2: 8538 -> 85.38 (小数点丢失)
            if len(corrected) == 4 and corrected.isdigit():
                if int(corrected) > 1000:
                    test_corrected = corrected[:2] + '.' + corrected[2:]
                    test_float = float(test_corrected)
                    if 10 <= test_float <= 500:
                        print(f"🔍 DEBUG: OCR修正 {corrected} -> {test_corrected}")
                        corrected = test_corrected
            
            # 模式3: 797.63 -> 79.63 或 97.63 (多了一位数字)
            if len(corrected) >= 6 and '.' in corrected:
                parts = corrected.split('.')
                if len(parts[0]) >= 3:
                    # 尝试去掉第一位数字
                    test_corrected = parts[0][1:] + '.' + parts[1]
                    test_float = float(test_corrected)
                    if 20 <= test_float <= 500:
                        print(f"🔍 DEBUG: OCR修正 {corrected} -> {test_corrected}")
                        corrected = test_corrected
            
            return corrected
            
        except Exception as e:
            print(f"🔍 DEBUG: OCR修正失败: {e}")
            return amount_str
    
    def _extract_invoice_data(self, text):
        """从Invoice PDF提取Invoice号码和Amount Due - 专门针对Siahuat模板优化"""
        data = {}
        try:
            import re
            
            print("🔍 DEBUG: === 开始提取Siahuat Invoice数据 ===")
            print(f"🔍 DEBUG: 输入文本长度: {len(text)}")
            
            # ===== SIAHUAT SPECIFIC PATTERNS =====
            # 查找Invoice号码模式 - Siahuat格式: INV-SH250604007
            inv_pattern = r'INV-SH\d+'
            inv_matches = re.findall(inv_pattern, text)
            print(f"🔍 DEBUG: 找到Siahuat Invoice号码: {inv_matches}")
            print(f"🔍 DEBUG: Invoice号码数量: {len(inv_matches)}")
            
            # 强制调试：显示所有找到的Invoice号码
            if inv_matches:
                print("🔍 DEBUG: 详细Invoice号码列表:")
                for i, inv in enumerate(inv_matches):
                    print(f"  {i+1}. {inv}")
            else:
                print("🔍 DEBUG: 没有找到任何Invoice号码！")
                # 尝试其他模式
                print("🔍 DEBUG: 尝试其他Invoice模式...")
                alt_patterns = [
                    r'INV-\w+\d+',  # INV-任意字母+数字
                    r'INV\d+',       # INV+数字
                    r'INVOICE\s*\d+', # INVOICE+数字
                    r'INV\s*\d+',    # INV+空格+数字
                ]
                
                for pattern in alt_patterns:
                    alt_matches = re.findall(pattern, text, re.IGNORECASE)
                    if alt_matches:
                        print(f"🔍 DEBUG: 使用模式 '{pattern}' 找到: {alt_matches}")
                        inv_matches = alt_matches
                        break
            
            # 不再查找单一全局Amount Due，直接跳过这个错误逻辑
            # 因为这会导致所有Invoice使用相同的Amount Due
            amount_found = None
            print(f"🔍 DEBUG: 跳过全局Amount Due查找，改用精确匹配每个Invoice的Amount Due")

            # 若仍未找到，再用模式（避免誤抓 Sub Total）
            if not amount_found:
                siahuat_amount_patterns = [
                    r'Amount\s*Due[^\d\n]*([\d,]+\.?\d*)',     # 金額在同一行的任意位置
                    r'(?<!Sub\s)Total[:\s]*([\d,]+\.?\d*)',     # Total，但排除 Sub Total
                    r'(?<!Sub\s)Total\s*([\d,]+\.?\d*)',
                    r'([\d,]+\.?\d*)\s*(?<!Sub\s)Total',
                ]
            
                for pattern in siahuat_amount_patterns:
                    matches = re.findall(pattern, text, re.IGNORECASE)
                    if matches:
                        amount_found = matches[0]
                        print(f"🔍 DEBUG: Siahuat使用模式 '{pattern}' 找到金额: {amount_found}")
                        break
            
            # Siahuat特定：如果没找到Amount Due，尝试查找GST后的总金额
            if not amount_found:
                print("🔍 DEBUG: 尝试Siahuat特定的GST后总金额查找")
                # 查找GST行，然后找下一行的金额
                for i, line in enumerate(lines):
                    if 'GST' in line and re.search(r'\d+\.?\d*', line):
                        print(f"🔍 DEBUG: 找到GST行: {line}")
                        # 查找GST行中的金额
                        gst_amount_match = re.search(r'([\d,]+\.?\d*)', line)
                        if gst_amount_match:
                            gst_amount = gst_amount_match.group(1)
                            print(f"🔍 DEBUG: GST金额: {gst_amount}")
                            # 查找下一行的Amount Due
                            if i + 1 < len(lines):
                                next_line = lines[i + 1].strip()
                                print(f"🔍 DEBUG: GST下一行: {next_line}")
                                if 'Amount Due' in next_line:
                                    amount_match = re.search(r'([\d,]+\.?\d*)', next_line)
                                    if amount_match:
                                        amount_found = amount_match.group(1)
                                        print(f"🔍 DEBUG: GST后找到Amount Due: {amount_found}")
                                        break
            
            # Siahuat特定：如果还是没找到，尝试查找最后的数字金额
            if not amount_found:
                print("🔍 DEBUG: 尝试Siahuat特定的最后金额查找")
                # 从后往前查找包含数字的行
                for line in reversed(lines):
                    line = line.strip()
                    if line and re.search(r'\d', line):
                        # 查找行中的金额（排除行号等小数字）
                        amount_matches = re.findall(r'(\d+\.?\d*)', line)
                        if amount_matches:
                            # 选择最大的数字作为金额
                            potential_amounts = [float(m) for m in amount_matches if float(m) > 10]  # 排除小于10的数字
                            if potential_amounts:
                                amount_found = str(max(potential_amounts))
                                print(f"🔍 DEBUG: Siahuat在行 '{line}' 找到金额: {amount_found}")
                                break
            
            # 新增：如果还是没找到，尝试查找所有合理的金额
            if not amount_found:
                print("🔍 DEBUG: 尝试查找所有合理的金额")
                # 查找所有可能的金额模式
                all_amount_patterns = [
                    r'(\d+\.?\d*)',  # 基本数字模式
                    r'(\d{1,3}(?:,\d{3})*\.?\d*)',  # 带逗号的金额
                ]
                
                all_amounts = []
                for pattern in all_amount_patterns:
                    matches = re.findall(pattern, text)
                    for match in matches:
                        try:
                            # 清理金额字符串
                            clean_amount = match.replace(',', '')
                            num = float(clean_amount)
                            # 过滤合理的金额范围（排除页码、日期等）
                            if 10 <= num <= 100000:  # 扩大范围到100,000
                                all_amounts.append((num, match))
                        except ValueError:
                            continue
                
                if all_amounts:
                    # 按金额大小排序，选择最大的
                    all_amounts.sort(key=lambda x: x[0], reverse=True)
                    amount_found = all_amounts[0][1]
                    print(f"🔍 DEBUG: 从所有金额中选择最大的: {amount_found}")
                    print(f"🔍 DEBUG: 找到的所有金额: {[f'{num:.2f}' for num, _ in all_amounts[:5]]}")
            
            # 新增：如果还是没找到，尝试查找所有合理的金额
            if not amount_found:
                print("🔍 DEBUG: 尝试查找所有合理的金额")
                # 查找所有可能的金额模式
                all_amount_patterns = [
                    r'(\d+\.?\d*)',  # 基本数字模式
                    r'(\d{1,3}(?:,\d{3})*\.?\d*)',  # 带逗号的金额
                ]
                
                all_amounts = []
                for pattern in all_amount_patterns:
                    matches = re.findall(pattern, text)
                    for match in matches:
                        try:
                            # 清理金额字符串
                            clean_amount = match.replace(',', '')
                            num = float(clean_amount)
                            # 过滤合理的金额范围（排除页码、日期等）
                            if 10 <= num <= 100000:  # 扩大范围到100,000
                                all_amounts.append((num, match))
                        except ValueError:
                            continue
                
                if all_amounts:
                    # 按金额大小排序，选择最大的
                    all_amounts.sort(key=lambda x: x[0], reverse=True)
                    amount_found = all_amounts[0][1]
                    print(f"🔍 DEBUG: 从所有金额中选择最大的: {amount_found}")
                    print(f"🔍 DEBUG: 找到的所有金额: {[f'{num:.2f}' for num, _ in all_amounts[:5]]}")
            
            # 新增：如果仍然没找到，尝试查找Invoice号码附近的金额
            if not amount_found and inv_matches:
                print("🔍 DEBUG: 尝试查找Invoice号码附近的金额")
                lines = text.split('\n')
                for inv in inv_matches:
                    for i, line in enumerate(lines):
                        if inv in line:
                            print(f"🔍 DEBUG: 找到Invoice {inv} 在第{i+1}行: {line}")
                            # 查找该行及附近行的金额
                            for j in range(max(0, i-2), min(len(lines), i+3)):
                                nearby_line = lines[j].strip()
                                if nearby_line and re.search(r'\d', nearby_line):
                                    amount_matches = re.findall(r'(\d+\.?\d*)', nearby_line)
                                    potential_amounts = []
                                    for m in amount_matches:
                                        try:
                                            num = float(m)
                                            if 10 <= num <= 100000:
                                                potential_amounts.append(num)
                                        except ValueError:
                                            continue
                                    
                                    if potential_amounts:
                                        amount_found = str(max(potential_amounts))
                                        print(f"🔍 DEBUG: 在Invoice {inv} 附近找到金额: {amount_found}")
                                        break
                            if amount_found:
                                break
                    if amount_found:
                        break
            
            print(f"🔍 DEBUG: Siahuat最终找到的金额: {amount_found}")
            
            # 首先去重Invoice号码
            unique_inv_matches = list(set(inv_matches)) if inv_matches else []
            print(f"🔍 DEBUG: 去重后的Invoice数量: {len(unique_inv_matches)}")
            
            # 不再使用单一金额分配给所有Invoice，而是跳过这个错误逻辑
            # 直接进入智能匹配阶段
            print(f"🔍 DEBUG: 跳过单一金额分配，进入智能匹配阶段")
            print(f"🔍 DEBUG: 找到的全局金额: {amount_found} (仅用于调试)")
            print(f"🔍 DEBUG: Invoice号码数量: {len(inv_matches)}, 去重后数量: {len(unique_inv_matches)}")
            
            # 移除错误的备用分配逻辑 - 这个逻辑会在智能匹配之前给Invoice分配错误金额
            # 直接跳到智能匹配阶段
            print("🔍 DEBUG: 跳过备用分配，直接进入智能Amount Due匹配阶段")
            
            # 新增：智能Invoice-金额匹配
            if unique_inv_matches:
                print("🔍 DEBUG: 开始智能Invoice-金额匹配...")
                print(f"🔍 DEBUG: 需要匹配的Invoice数量: {len(unique_inv_matches)}")
                
                # 按行分析，查找每个Invoice附近的金额
                lines = text.split('\n')
                print(f"🔍 DEBUG: 文本总行数: {len(lines)}")
                
                for inv in unique_inv_matches:
                    if inv not in data:  # 如果还没有匹配到金额
                        print(f"🔍 DEBUG: 为Invoice {inv} 查找附近的Amount Due...")
                        
                        # 查找包含该Invoice号码的行
                        inv_lines = []
                        for i, line in enumerate(lines):
                            if inv in line:
                                inv_lines.append((i, line))
                        
                        print(f"🔍 DEBUG: Invoice {inv} 出现在 {len(inv_lines)} 行")
                        
                        if inv_lines:
                            # 分析每个包含Invoice的行，并在更大范围内查找Amount Due
                            for line_num, line_content in inv_lines:
                                print(f"🔍 DEBUG: 第{line_num+1}行: {line_content}")
                                
                                # 首先检查这个Invoice是否是Tax Invoice（而不是Delivery Order）
                                is_tax_invoice = False
                                if 'TAX' in line_content.upper() and 'INVOICE' in line_content.upper():
                                    is_tax_invoice = True
                                    print(f"🔍 DEBUG: ✅ 这是Tax Invoice行，将搜索Amount Due")
                                elif 'DELIVERY' in line_content.upper() and 'ORDER' in line_content.upper():
                                    print(f"🔍 DEBUG: ❌ 这是Delivery Order行，跳过（没有Amount Due）")
                                    continue
                                else:
                                    # 如果无法明确区分，检查前后行是否有Tax Invoice标识
                                    check_range = range(max(0, line_num-2), min(len(lines), line_num+3))
                                    for check_idx in check_range:
                                        check_line = lines[check_idx].strip().upper()
                                        if 'TAX' in check_line and 'INVOICE' in check_line:
                                            is_tax_invoice = True
                                            print(f"🔍 DEBUG: ✅ 在第{check_idx+1}行找到Tax Invoice标识")
                                            break
                                        elif 'DELIVERY' in check_line and 'ORDER' in check_line:
                                            print(f"🔍 DEBUG: ❌ 在第{check_idx+1}行找到Delivery Order标识，跳过")
                                            break
                                    
                                    if not is_tax_invoice:
                                        print(f"🔍 DEBUG: ⚠️ 无法确定Invoice类型，将继续搜索Amount Due")
                                        is_tax_invoice = True  # 默认尝试搜索
                                
                                if not is_tax_invoice:
                                    continue
                                
                                # 在该Tax Invoice页面范围内查找Amount Due
                                amount_due_found = False
                                # 扩大搜索范围到整个Invoice页面（假设每个Invoice大约20-50行）
                                search_range = range(max(0, line_num-10), min(len(lines), line_num+100))
                                print(f"🔍 DEBUG: Tax Invoice搜索范围: 第{max(1, line_num-9)}行到第{min(len(lines), line_num+100)}行")
                                
                                for j in search_range:
                                    nearby_line = lines[j].strip()
                                    # 改进Amount Due的检测，考虑OCR可能的错误
                                    if nearby_line and (
                                        'Amount Due' in nearby_line or 
                                        'Amount' in nearby_line and 'Due' in nearby_line or
                                        'AmountDue' in nearby_line or
                                        'AMOUNT DUE' in nearby_line.upper() or
                                        'Amount' in nearby_line and 'Due:' in nearby_line
                                    ):
                                        print(f"🔍 DEBUG: 第{j+1}行找到Amount Due: {nearby_line}")
                                        
                                        # 多种Amount Due格式的精确提取，优化匹配精度
                                        amount_due_patterns = [
                                            r'Amount\s*Due\s*[:\s]*([0-9,]+\.[0-9]{2})',  # Amount Due: 489.34 (精确小数点)
                                            r'Amount\s*Due\s*[:\s]*([0-9,]+\.?[0-9]*)',  # Amount Due: 489 或 489.34
                                            r'AmountDue\s*[:\s]*([0-9,]+\.[0-9]{2})',     # AmountDue:489.34
                                            r'Amount\s*Due[^\d]*?([0-9,]+\.[0-9]{2})',    # Amount Due [非数字] 489.34
                                        ]
                                        
                                        amount_extracted = False
                                        for pattern in amount_due_patterns:
                                            amount_due_match = re.search(pattern, nearby_line, re.IGNORECASE)
                                            if amount_due_match:
                                                amount = amount_due_match.group(1)
                                                # 应用OCR错误修复
                                                corrected_amount = self._fix_ocr_amount_errors(amount)
                                                # 验证金额的合理性
                                                try:
                                                    amount_float = float(corrected_amount.replace(',', ''))
                                                    if (5 <= amount_float <= 100000 and 
                                                        not self._is_likely_non_amount(corrected_amount, nearby_line)):
                                                        data[inv] = corrected_amount
                                                        print(f"🔍 DEBUG: ✅ Invoice {inv} 匹配到Amount Due: {corrected_amount}")
                                                        amount_due_found = True
                                                        amount_extracted = True
                                                        break
                                                    else:
                                                        print(f"🔍 DEBUG: ⚠️ 金额 {corrected_amount} 不合理，继续搜索")
                                                except ValueError:
                                                    print(f"🔍 DEBUG: ⚠️ 无法解析金额 {corrected_amount}")
                                                    pass
                                        
                                        if not amount_extracted:
                                            print(f"🔍 DEBUG: ❌ 在Amount Due行无法提取有效金额: {nearby_line}")
                                            # 尝试在下一行或下几行查找金额
                                            for offset in range(1, 6):  # 扩大到6行
                                                if j + offset < len(lines):
                                                    next_line = lines[j + offset].strip()
                                                    if next_line:
                                                        # 寻找只包含金额的行
                                                        amount_only_patterns = [
                                                            r'^([0-9,]+\.[0-9]{2})$',  # 纯金额行
                                                            r'^\s*([0-9,]+\.[0-9]{2})\s*$',  # 前后有空格的金额
                                                            r'[:\s]+([0-9,]+\.[0-9]{2})\s*$',  # 冒号后的金额
                                                        ]
                                                        for pattern in amount_only_patterns:
                                                            amount_only_match = re.search(pattern, next_line)
                                                            if amount_only_match:
                                                                amount = amount_only_match.group(1)
                                                                # 应用OCR错误修复
                                                                corrected_amount = self._fix_ocr_amount_errors(amount)
                                                                try:
                                                                    amount_float = float(corrected_amount.replace(',', ''))
                                                                    if (5 <= amount_float <= 5000 and 
                                                                        not self._is_likely_non_amount(corrected_amount, next_line)):
                                                                        data[inv] = corrected_amount
                                                                        print(f"🔍 DEBUG: ✅ Invoice {inv} 在第{j+offset+1}行找到Amount Due: {corrected_amount} (原始: {amount})")
                                                                        amount_due_found = True
                                                                        amount_extracted = True
                                                                        break
                                                                except ValueError:
                                                                    pass
                                                        if amount_extracted:
                                                            break
                                        
                                        if amount_due_found:
                                            break
                                        
                                        if amount_due_found:
                                            break
                                
                                if amount_due_found:
                                    break
                                else:
                                    print(f"🔍 DEBUG: ❌ Tax Invoice {inv} 在第{line_num+1}行附近100行范围内没有找到Amount Due")
                                    
                                    # 最后的fallback: 在整个Tax Invoice页面范围内查找合理的小金额
                                    print(f"🔍 DEBUG: 🔄 启用fallback策略，在Tax Invoice页面查找合理金额...")
                                    page_range = range(max(0, line_num-10), min(len(lines), line_num+100))
                                    candidate_amounts = []
                                    
                                    for k in page_range:
                                        page_line = lines[k].strip()
                                        if page_line:
                                            # 查找所有可能的金额
                                            amounts_in_line = re.findall(r'(\d+\.\d{2})', page_line)
                                            for amt in amounts_in_line:
                                                # 应用OCR错误修复
                                                corrected_amt = self._fix_ocr_amount_errors(amt)
                                                try:
                                                    amt_float = float(corrected_amt)
                                                    # 优先选择合理的Invoice金额范围，排除明显的非金额数字
                                                    if 10 <= amt_float <= 1000 and not self._is_likely_non_amount(corrected_amt, page_line):
                                                        candidate_amounts.append((amt_float, corrected_amt, k+1))
                                                except ValueError:
                                                    pass
                                
                                    if candidate_amounts:
                                        # 选择最合理的金额（中等大小，靠近页面末尾的）
                                        candidate_amounts.sort(key=lambda x: (x[2], x[0]))  # 按行号和金额排序
                                        best_amount = candidate_amounts[-1][1]  # 选择最后一个（靠近页面底部）
                                        data[inv] = best_amount
                                        print(f"🔍 DEBUG: 🎯 Fallback策略: Invoice {inv} -> 页面合理金额: {best_amount}")
                                        amount_due_found = True
                                    # 调试：显示搜索范围内的一些行
                                    print(f"🔍 DEBUG: 显示搜索范围内的部分行 (第{max(1, line_num-4)}行到第{min(len(lines), line_num+50)}行):")
                                    debug_range = range(max(0, line_num-2), min(len(lines), line_num+10))
                                    for debug_idx in debug_range:
                                        debug_line = lines[debug_idx].strip()
                                        if debug_line:
                                            print(f"🔍 DEBUG:   第{debug_idx+1}行: {debug_line[:100]}...")  # 只显示前100字符
                        else:
                            print(f"🔍 DEBUG: ❌ 没有找到包含Invoice {inv} 的行")
                
                # 如果还有Invoice没有金额，使用全局金额分配
                unmatched_invs = [inv for inv in unique_inv_matches if inv not in data]
                if unmatched_invs:
                    print(f"🔍 DEBUG: 还有 {len(unmatched_invs)} 个Invoice没有金额，使用全局分配...")
                    print(f"🔍 DEBUG: 未匹配的Invoice: {unmatched_invs}")
                    
                    # 查找所有可用金额，优先选择较小的合理金额（减少大数字干扰）
                    global_amounts = []
                    for pattern in [r'(\d+\.\d{2})', r'(\d{1,3}(?:,\d{3})*\.\d{2})']:  # 只匹配有小数点的金额
                        matches = re.findall(pattern, text)
                        for match in matches:
                            try:
                                clean_amount = match.replace(',', '')
                                num = float(clean_amount)
                                # 更严格的金额筛选，避免大数字干扰
                                if 10 <= num <= 1000:
                                    global_amounts.append((num, match))
                                elif 1000 < num <= 5000:
                                    # 中等金额降低优先级
                                    global_amounts.append((num - 1000, match))  # 降低权重
                            except ValueError:
                                continue
                    
                    if global_amounts:
                        # 按金额排序，去重
                        global_amounts = list(set(global_amounts))
                        global_amounts.sort(key=lambda x: x[0], reverse=True)
                        print(f"🔍 DEBUG: 全局可用金额 (前10个): {[f'{num:.2f}' for num, _ in global_amounts[:10]]}")
                        
                        # 为未匹配的Invoice分配金额
                        for i, inv in enumerate(unmatched_invs):
                            if i < len(global_amounts):
                                assigned_amount = global_amounts[i][1]
                                data[inv] = assigned_amount
                                print(f"🔍 DEBUG: 🌐 全局分配: Invoice {inv} -> 金额: {assigned_amount}")
                            else:
                                # 使用最后一个金额
                                if global_amounts:
                                    last_amount = global_amounts[-1][1]
                                    data[inv] = last_amount
                                    print(f"🔍 DEBUG: 🌐 全局分配: Invoice {inv} -> 金额: {last_amount}")
                    else:
                        print(f"🔍 DEBUG: ❌ 没有找到合适的全局金额")
                else:
                    print("🔍 DEBUG: ✅ 所有Invoice都已匹配到金额")
            else:
                print("🔍 DEBUG: ❌ 没有找到任何Invoice号码，无法进行匹配")
            
            print(f"🔍 DEBUG: 最终Invoice数据: {data}")
            print(f"🔍 DEBUG: 匹配成功的Invoice数量: {len(data)}")
            return data
            
        except Exception as e:
            print(f"🔍 DEBUG: Siahuat Invoice数据提取失败: {e}")
            import traceback
            print(f"🔍 DEBUG: 错误详情: {traceback.format_exc()}")
            return {}
    
    def _extract_soa_data(self, text):
        """从SOA PDF提取Invoice号码和Dr金额 - 专门针对Siahuat SOA模板优化"""
        data = {}
        try:
            import re
            
            print("🔍 DEBUG: 开始提取Siahuat SOA数据")
            
            # ===== SIAHUAT SOA SPECIFIC PATTERNS =====
            # 查找Invoice号码模式 - Siahuat格式: INV-SH250603XXX
            inv_pattern = r'INV-SH\d+'
            inv_matches = re.findall(inv_pattern, text)
            print(f"🔍 DEBUG: 找到Siahuat SOA中的Invoice号码: {inv_matches}")
            
            # 按行处理，查找包含Invoice号码和Dr金额的行
            lines = text.split('\n')
            for idx, line in enumerate(lines):
                line = line.strip()
                if line and 'INV-SH' in line:
                    print(f"🔍 DEBUG: 处理Siahuat SOA行: {line}")
                    
                    # 提取Invoice号码
                    inv_match = re.search(inv_pattern, line)
                    if inv_match:
                        inv = inv_match.group()
                        
                        # Siahuat SOA特定的Dr金额查找模式
                        # 根据实际SOA模板，Dr金额通常在行的末尾
                        siahuat_dr_patterns = [
                            r'Dr\s*([\d,]+\.?\d*)\s*(?:$|Balance|Cr)',  # 明確抓 Dr 後金額
                            r'([\d,]+\.?\d*)\s*Dr',                      # 金額在前，接 Dr
                        ]  # 不再使用行末金額以避免抓到 Balance
                        
                        dr_amount = None
                        for pattern in siahuat_dr_patterns:
                            matches = re.findall(pattern, line, re.IGNORECASE)
                            if matches:
                                # 过滤掉行号等小数字，选择合理的金额
                                potential_amounts = []
                                for m in matches:
                                    try:
                                        num = float(m.replace(',', ''))
                                        # Siahuat的Dr金额通常在10-10000之间
                                        if 10 <= num <= 10000:
                                            potential_amounts.append(num)
                                    except ValueError:
                                        continue
                                
                                if potential_amounts:
                                    dr_amount = str(max(potential_amounts))
                                    print(f"🔍 DEBUG: Siahuat SOA使用模式 '{pattern}' 找到Dr金额: {dr_amount}")
                                    break
                        
                        # 若本行仍未取到，先在本行抓取成對金額（第一個視為 Dr，第二個視為 Balance）
                        if not dr_amount:
                            dec_pat = r'(\d{1,3}(?:,\d{3})*\.\d{2}|\d+\.\d{2})'
                            pair = re.findall(dec_pat, line)
                            if len(pair) >= 2:
                                dr_amount = pair[0]
                                print(f"🔍 DEBUG: 本行雙金額，取第一個為Dr: Dr={pair[0]}, Balance={pair[1]}")
                            elif len(pair) == 1:
                                dr_amount = pair[0]
                                print(f"🔍 DEBUG: 本行單一金額，視為Dr: {pair[0]}")

                        # 若本行仍沒有數字，再向後幾行找第一個金額視為 Dr
                        if not dr_amount:
                            lookahead_max = 2
                            dec_pat = r'(\d{1,3}(?:,\d{3})*\.\d{2}|\d+\.\d{2})'
                            for j in range(idx, min(idx + 1 + lookahead_max, len(lines))):
                                row = lines[j]
                                m = re.findall(dec_pat, row)
                                if len(m) >= 2:
                                    dr_amount = m[0]
                                    print(f"🔍 DEBUG: 前瞻雙金額，取第一個為Dr，第{j+1}行: Dr={m[0]}, Balance={m[1]}")
                                    break
                                elif len(m) == 1:
                                    dr_amount = m[0]
                                    print(f"🔍 DEBUG: 前瞻單一金額，視為Dr，第{j+1}行: {m[0]}")
                                    break

                        if dr_amount:
                            if inv not in data:
                                data[inv] = dr_amount
                                print(f"🔍 DEBUG: Siahuat SOA {inv} -> Dr金额: {dr_amount}")
                            else:
                                print(f"🔍 DEBUG: 已有Dr金額 {data[inv]}，忽略後續值 {dr_amount}")
                        else:
                            # 回退：若沒有明確 'Dr' 標記，則取該行數字中倒數第二個（最後一個通常是 Balance）
                            nums = re.findall(r'([0-9]{1,3}(?:,[0-9]{3})*\.\d{2}|\d+\.\d{2})', line)
                            # 過濾合理金額
                            nums_clean = []
                            for s in nums:
                                try:
                                    val = float(s.replace(',', ''))
                                    if 1 <= val <= 100000:
                                        nums_clean.append(s)
                                except Exception:
                                    pass
                            if len(nums_clean) >= 2:
                                dr_guess = nums_clean[-2]
                                if inv not in data:
                                    data[inv] = dr_guess
                                    print(f"🔍 DEBUG: 無Dr標記，使用倒數第二個數字作為Dr: {dr_guess}")
                                else:
                                    print(f"🔍 DEBUG: 已有Dr金額 {data[inv]}，忽略回退值 {dr_guess}")
                            elif len(nums_clean) == 1:
                                dr_guess = nums_clean[0]
                                if inv not in data:
                                    data[inv] = dr_guess
                                    print(f"🔍 DEBUG: 無Dr標記，僅一個數字，視為Dr: {dr_guess}")
                                else:
                                    print(f"🔍 DEBUG: 已有Dr金額 {data[inv]}，忽略回退值 {dr_guess}")
                            else:
                                print(f"🔍 DEBUG: 未找到Siahuat SOA {inv} 的Dr金额")
            
            print(f"🔍 DEBUG: Siahuat SOA数据提取完成，共找到 {len(data)} 个项目")
            return data
            
        except Exception as e:
            print(f"🔍 DEBUG: Siahuat SOA数据提取失败: {e}")
            import traceback
            print(f"🔍 DEBUG: 错误详情: {traceback.format_exc()}")
            return {}
    
    def _extract_fallback_data(self, text, source_name):
        """备用数据提取方法"""
        data = {}
        
        try:
            import re
            
            # 查找所有可能的金额
            amounts = re.findall(r'[\$]?[\d,]+\.?\d*', text)
            
            # 为每个金额创建一个项目名称
            for i, amount in enumerate(amounts):
                item_name = f"项目{i+1}_{source_name}"
                data[item_name] = amount
                
        except Exception as e:
            print(f"备用数据提取失败: {e}")
        
        return data
    
    def _test_invoice_extraction_fix(self):
        """测试Invoice金额提取修复"""
        print("🧪 测试: 修复后的Invoice金额提取逻辑")
        
        # 创建模拟的PDF文本数据，包含多个Invoice和不同金额
        test_text = """
        SIAHUAT TRADING SDN BHD
        
        Invoice: INV-SH250603201
        Amount Due: 150.50
        
        Invoice: INV-SH250603202  
        Amount Due: 275.75
        
        Invoice: INV-SH250603203
        Amount Due: 432.10
        
        Invoice: INV-SH250603204
        Amount Due: 89.25
        """
        
        # 测试提取
        result = self._extract_invoice_data(test_text)
        
        print(f"🧪 测试结果:")
        for inv, amount in result.items():
            print(f"  {inv} -> {amount}")
        
        # 验证是否每个Invoice都有不同的金额
        unique_amounts = set(result.values())
        if len(unique_amounts) == len(result):
            print("✅ 测试通过: 每个Invoice都有独立的金额")
        else:
            print("❌ 测试失败: 仍有Invoice使用相同金额")
        
        return len(unique_amounts) == len(result)
    
    def _display_reconciliation_results(self):
        """显示核对结果"""
        for result in self.reconciliation_results:
            self.tree.insert('', 'end', values=(
                result['item'],
                result['pdf_value'],
                result['soa_value'],
                result['difference'],
                result['status']
            ))
    
    def _export_results(self):
        """导出结果"""
        if not self.reconciliation_results:
            messagebox.showwarning("警告", "沒有可導出的結果！")
            return
        
        try:
            file_path = filedialog.asksaveasfilename(
                title="導出核對結果 / Export reconciliation results",
                defaultextension=".xlsx",
                filetypes=[
                    ("Excel files", "*.xlsx"),
                    ("CSV files", "*.csv"),
                    ("All files", "*.*")
                ]
            )
            
            if file_path:
                if file_path.lower().endswith('.csv'):
                    self._export_to_csv(file_path)
                else:
                    self._export_to_excel(file_path)
                
                messagebox.showinfo("成功", f"結果已導出到：{file_path}")
        
        except Exception as e:
            messagebox.showerror("錯誤", f"導出失敗：{str(e)}")
    
    def _export_to_excel(self, file_path):
        """导出到Excel"""
        import openpyxl
        
        wb = openpyxl.Workbook()
        ws = wb.active
        ws.title = "SOA核对结果"
        
        # 写入标题
        headers = ['項目', 'PDF1值', 'PDF2值', '差異', '狀態']
        for col, header in enumerate(headers, 1):
            ws.cell(row=1, column=col, value=header)
        
        # 写入数据
        for row, result in enumerate(self.reconciliation_results, 2):
            ws.cell(row=row, column=1, value=result['item'])
            ws.cell(row=row, column=2, value=result['pdf_value'])
            ws.cell(row=row, column=3, value=result['soa_value'])
            ws.cell(row=row, column=4, value=result['difference'])
            ws.cell(row=row, column=5, value=result['status'])
        
        wb.save(file_path)
        wb.close()
    
    def _export_to_csv(self, file_path):
        """导出到CSV"""
        import csv
        
        with open(file_path, 'w', newline='', encoding='utf-8') as file:
            writer = csv.writer(file)
            
            # 写入标题
            writer.writerow(['項目', 'PDF1值', 'PDF2值', '差異', '狀態'])
            
            # 写入数据
            for result in self.reconciliation_results:
                writer.writerow([
                    result['item'],
                    result['pdf_value'],
                    result['soa_value'],
                    result['difference'],
                    result['status']
                ])
    
    def _generate_report(self):
        """生成报告"""
        if not self.reconciliation_results:
            messagebox.showwarning("警告", "沒有可生成報告的結果！")
            return
        
        try:
            # 创建报告内容
            report_content = self._create_report_content()
            
            # 显示报告
            self._show_report_window(report_content)
            
        except Exception as e:
            messagebox.showerror("錯誤", f"生成報告失敗：{str(e)}")
    
    def _create_report_content(self):
        """创建报告内容"""
        total_items = len(self.reconciliation_results)
        matched_items = sum(1 for r in self.reconciliation_results if r['status'] == "✅ 匹配")
        unmatched_items = total_items - matched_items
        
        report = f"""
PDF 文件核对报告 / PDF Files Reconciliation Report
{'='*50}

总结 / Summary:
- 总项目数 / Total Items: {total_items}
- 匹配项目 / Matched Items: {matched_items}
- 未匹配项目 / Unmatched Items: {unmatched_items}
- 匹配率 / Match Rate: {(matched_items/total_items*100):.1f}%

详细结果 / Detailed Results:
{'-'*50}
"""
        
        for result in self.reconciliation_results:
            report += f"""
项目 / Item: {result['item']}
PDF1值 / PDF1 Value: {result['pdf_value']}
PDF2值 / PDF2 Value: {result['soa_value']}
差异 / Difference: {result['difference']}
状态 / Status: {result['status']}
{'-'*30}
"""
        
        return report
    
    def _show_report_window(self, report_content):
        """显示报告窗口 - 添加置顶和搜索功能"""
        report_window = ctk.CTkToplevel(self)
        report_window.title("PDF 文件核对报告 / PDF Files Reconciliation Report")
        report_window.geometry("900x700")
        report_window.resizable(True, True)
        
        # 设置窗口置顶
        report_window.attributes('-topmost', True)
        report_window.lift()
        report_window.focus_force()
        
        # 搜索框架
        search_frame = ctk.CTkFrame(report_window, fg_color='transparent')
        search_frame.pack(fill='x', padx=20, pady=(20, 10))
        
        # 搜索标签
        search_label = ctk.CTkLabel(search_frame, text="搜索 / Search:", font=FONT_MID)
        search_label.pack(side='left', padx=(0, 10))
        
        # 搜索输入框
        search_var = ctk.StringVar()
        search_entry = ctk.CTkEntry(search_frame, textvariable=search_var, 
                                   placeholder_text="输入Invoice号码或金额进行搜索...", 
                                   width=300, font=FONT_MID)
        search_entry.pack(side='left', padx=(0, 10))
        
        # 搜索按钮
        def perform_search():
            search_term = search_var.get().strip().lower()
            if not search_term:
                # 如果搜索框为空，显示全部内容
                report_text.delete('1.0', 'end')
                report_text.insert('1.0', report_content)
                return
            
            # 搜索匹配的内容
            search_results = []
            lines = report_content.split('\n')
            current_item = []
            in_item = False
            
            for line in lines:
                if line.startswith('项目 / Item:') or line.startswith('项目/ Item:'):
                    if in_item and current_item:
                        # 检查当前项目是否匹配搜索条件
                        item_text = '\n'.join(current_item)
                        if search_term in item_text.lower():
                            search_results.extend(current_item)
                            search_results.append('-' * 30)
                        current_item = []
                    current_item = [line]
                    in_item = True
                elif in_item:
                    current_item.append(line)
            
            # 检查最后一个项目
            if in_item and current_item:
                item_text = '\n'.join(current_item)
                if search_term in item_text.lower():
                    search_results.extend(current_item)
            
            # 显示搜索结果
            if search_results:
                search_content = '\n'.join(search_results)
                report_text.delete('1.0', 'end')
                report_text.insert('1.0', f"搜索结果 / Search Results for '{search_term}':\n{'-'*50}\n{search_content}")
            else:
                report_text.delete('1.0', 'end')
                report_text.insert('1.0', f"未找到匹配 '{search_term}' 的结果 / No results found for '{search_term}'")
        
        search_btn = ctk.CTkButton(search_frame, text="搜索 / Search", 
                                  command=perform_search, 
                                  fg_color=ACCENT_GREEN, font=FONT_MID)
        search_btn.pack(side='left', padx=(0, 10))
        
        # 清除搜索按钮
        def clear_search():
            search_var.set("")
            report_text.delete('1.0', 'end')
            report_text.insert('1.0', report_content)
        
        clear_btn = ctk.CTkButton(search_frame, text="清除 / Clear", 
                                 command=clear_search, 
                                 fg_color=ACCENT_PURPLE, font=FONT_MID)
        clear_btn.pack(side='left')
        
        # 报告内容
        report_text = ctk.CTkTextbox(report_window, font=FONT_MID)
        report_text.pack(fill='both', expand=True, padx=20, pady=(0, 20))
        report_text.insert('1.0', report_content)
        
        # 按钮框架
        button_frame = ctk.CTkFrame(report_window, fg_color='transparent')
        button_frame.pack(fill='x', padx=20, pady=(0, 20))
        
        # 关闭按钮
        ctk.CTkButton(
            button_frame,
            text="關閉 / Close",
            command=report_window.destroy,
            fg_color=ACCENT_BLUE,
            font=FONT_MID
        ).pack(side='right')
        
        # 绑定回车键搜索
        search_entry.bind('<Return>', lambda event: perform_search())
        
        # 设置焦点到搜索框
        search_entry.focus()

    def _run_auto_f5_deduction(self):
        """自动F5扣分：检查周三12点后的订单"""
        from datetime import datetime, timedelta
        import os
        from tkinter import messagebox
        
        folder = self.download_folder_var.get()
        if not folder:
            messagebox.showwarning("警告", "请先选择下载文件夹！")
            return
        
        # 计算本周三12点的时间
        today = datetime.now()
        days_until_wednesday = (2 - today.weekday()) % 7  # 2 = Wednesday
        if days_until_wednesday == 0:  # 如果今天是周三
            wednesday_noon = today.replace(hour=12, minute=0, second=0, microsecond=0)
        else:
            wednesday_noon = (today + timedelta(days=days_until_wednesday)).replace(hour=12, minute=0, second=0, microsecond=0)
        
        # 检查邮件日志文件
        month_name = today.strftime('%b').title()
        week_of_month = get_week_of_month(today)
        save_path = os.path.join(folder, f"{month_name} - Week {week_of_month}")
        log_file = os.path.join(save_path, "email_bodies_log.txt")
        
        if not os.path.exists(log_file):
            messagebox.showinfo("信息", "未找到邮件日志文件，请先下载邮件！")
            return
        
        # 读取邮件日志，检查周三12点后的订单
        late_orders = []
        try:
            with open(log_file, "r", encoding="utf-8") as f:
                content = f.read()
            
            # 解析邮件内容
            email_blocks = content.split("——— 邮件")
            for block in email_blocks[1:]:  # 跳过第一个空块
                lines = block.strip().splitlines()
                if len(lines) < 3:
                    continue
                
                # 提取邮件时间（假设格式：时间在主题行中）
                subject_line = ""
                for line in lines:
                    if line.startswith("[主题]"):
                        subject_line = line
                        break
                
                # 检查是否包含时间信息
                if "周三" in subject_line or "wednesday" in subject_line.lower():
                    # 这里可以添加更复杂的时间解析逻辑
                    # 暂时标记为需要检查的邮件
                    late_orders.append(f"邮件主题: {subject_line}")
        
        except Exception as e:
            messagebox.showerror("错误", f"读取邮件日志失败: {e}")
            return
        
        # 显示结果
        if late_orders:
            result_text = f"发现 {len(late_orders)} 个可能迟交的订单（周三12点后）：\n\n"
            result_text += "\n".join(late_orders)
            result_text += "\n\n建议进行F5扣分处理。"
            messagebox.showwarning("F5扣分提醒", result_text)
        else:
            messagebox.showinfo("F5扣分检查", "未发现周三12点后的迟交订单。")
    
    def _show_manual_f5_deduction(self):
        """显示手动F5扣分界面"""
        from tkinter import messagebox
        import tkinter as tk
        
        # 创建手动扣分窗口
        deduction_window = tk.Toplevel(self)
        deduction_window.title("手动F5扣分 / Manual F5 Deduction")
        deduction_window.geometry("600x500")
        deduction_window.configure(bg="#f1f5f9")
        
        # 标题
        title_label = tk.Label(
            deduction_window,
            text="手动F5扣分系统",
            font=("Microsoft YaHei", 18, "bold"),
            bg="#f1f5f9",
            fg="#1e3a8a"
        )
        title_label.pack(pady=20)
        
        # 扣分原因选择
        reason_frame = tk.Frame(deduction_window, bg="#f1f5f9")
        reason_frame.pack(pady=10)
        
        tk.Label(
            reason_frame,
            text="扣分原因 / Deduction Reason:",
            font=("Microsoft YaHei", 12, "bold"),
            bg="#f1f5f9"
        ).pack(anchor="w")
        
        reason_var = tk.StringVar(value="迟交订单")
        reasons = [
            "迟交订单 / Late Order",
            "订单格式错误 / Wrong Order Format", 
            "数量错误 / Wrong Quantity",
            "其他 / Others"
        ]
        
        reason_menu = tk.OptionMenu(reason_frame, reason_var, *reasons)
        reason_menu.config(font=("Microsoft YaHei", 11), width=25)
        reason_menu.pack(pady=5)
        
        # 扣分分数
        score_frame = tk.Frame(deduction_window, bg="#f1f5f9")
        score_frame.pack(pady=10)
        
        tk.Label(
            score_frame,
            text="扣分分数 / Deduction Score:",
            font=("Microsoft YaHei", 12, "bold"),
            bg="#f1f5f9"
        ).pack(anchor="w")
        
        score_var = tk.StringVar(value="5")
        scores = ["1", "2", "3", "5", "10", "15", "20"]
        
        score_menu = tk.OptionMenu(score_frame, score_var, *scores)
        score_menu.config(font=("Microsoft YaHei", 11), width=15)
        score_menu.pack(pady=5)
        
        # 备注输入
        note_frame = tk.Frame(deduction_window, bg="#f1f5f9")
        note_frame.pack(pady=10)
        
        tk.Label(
            note_frame,
            text="备注 / Notes:",
            font=("Microsoft YaHei", 12, "bold"),
            bg="#f1f5f9"
        ).pack(anchor="w")
        
        note_text = tk.Text(note_frame, height=4, width=50, font=("Microsoft YaHei", 11))
        note_text.pack(pady=5)
        
        # 扣分按钮
        def apply_deduction():
            reason = reason_var.get()
            score = score_var.get()
            note = note_text.get("1.0", "end-1c")
            
            if not note.strip():
                messagebox.showwarning("警告", "请输入扣分备注！")
                return
            
            # 这里可以添加扣分记录保存逻辑
            result_text = f"F5扣分已应用：\n\n"
            result_text += f"扣分原因: {reason}\n"
            result_text += f"扣分分数: {score}\n"
            result_text += f"备注: {note}\n\n"
            result_text += "扣分记录已保存。"
            
            messagebox.showinfo("扣分成功", result_text)
            deduction_window.destroy()
        
        button_frame = tk.Frame(deduction_window, bg="#f1f5f9")
        button_frame.pack(pady=20)
        
        apply_btn = tk.Button(
            button_frame,
            text="应用扣分 / Apply Deduction",
            command=apply_deduction,
            font=("Microsoft YaHei", 12, "bold"),
            bg="#dc2626",
            fg="white",
            padx=20,
            pady=10,
            relief="flat"
        )
        apply_btn.pack(side="left", padx=10)
        
        cancel_btn = tk.Button(
            button_frame,
            text="取消 / Cancel",
            command=deduction_window.destroy,
            font=("Microsoft YaHei", 12, "bold"),
            bg="#6b7280",
            fg="white",
            padx=20,
            pady=10,
            relief="flat"
        )
        cancel_btn.pack(side="left", padx=10)
    
    def _extract_outlet_from_subject(self, subject):
        """
        从邮件主题中提取门市名称，使用配置文件中的门市映射
        """
        try:
            # 获取配置文件路径
            config_file = self.config_file_var.get()
            if not config_file or not os.path.exists(config_file):
                print(f"[警告] 配置文件不存在: {config_file}")
                return self._fallback_extract_outlet(subject)
            
            # 读取配置文件中的门市信息
            import pandas as pd
            try:
                # 读取OUTLET工作表
                df = pd.read_excel(config_file, sheet_name="OUTLET")
                
                # 构建门市映射字典
                outlet_mapping = {}
                for _, row in df.iterrows():
                    short_name = str(row['Short Name']).strip().upper()
                    full_name = str(row['Outlet Full Name']).strip().lower()
                    email_name = str(row['Name in Email']).strip().lower()
                    
                    # 将各种名称映射到短名称
                    if short_name and short_name != 'nan':
                        outlet_mapping[full_name] = short_name
                        outlet_mapping[email_name] = short_name
                        
                        # 也添加一些常见的变体
                        if ' ' in full_name:
                            words = full_name.split()
                            for word in words:
                                if len(word) >= 2:
                                    outlet_mapping[word] = short_name
                
                # 将主题转换为小写进行匹配
                subject_lower = subject.lower()
                
                # 尝试匹配门市名称
                for key, value in outlet_mapping.items():
                    if key in subject_lower and key != 'nan':
                        print(f"[DEBUG] 匹配到门市: {key} -> {value}")
                        return value
                
                # 如果没有匹配到，尝试提取第一个单词作为门市名称
                words = subject.split()
                if words:
                    first_word = words[0].strip('-_').upper()
                    if len(first_word) >= 2:  # 至少2个字符
                        print(f"[DEBUG] 使用第一个单词作为门市: {first_word}")
                        return first_word
                
                print(f"[DEBUG] 未找到匹配的门市，使用默认方法")
                return self._fallback_extract_outlet(subject)
                
            except Exception as e:
                print(f"[错误] 读取配置文件失败: {e}")
                return self._fallback_extract_outlet(subject)
                
        except Exception as e:
            print(f"[错误] 配置文件处理失败: {e}")
            return self._fallback_extract_outlet(subject)
    
    def _fallback_extract_outlet(self, subject):
        """
        备用门市提取方法（当配置文件不可用时使用）
        """
        # 常见的门市名称映射（作为备用）
        fallback_mapping = {
            'west mall': 'WWP',
            'westgate': 'WG',
            '313': '313',
            'tpy': 'TPY',
            'oasis': 'OASIS',
            'hbb': 'HBB',
            'nex': 'NEX',
            'sm': 'SM',
            'fn': 'FN',
            'imm': 'IMM',
            'npc': 'NPC',
            'tcm': 'TCM',
            'yts': 'YTS',
            'pp': 'PP',
            'csq': 'CSQ',
            'hlm': 'HLM',
            't1': 'image.pngT1',
            'hm': 'HM',
            'skmrt': 'SKMRT',
            'skg': 'SKG',
            'bgm': 'BGM',
            'amk': 'AMK',
            'resendgtm': 'GTM',
            'plq': 'PLQ',
            'j8': 'J8',
            'junction 8': 'J8',
            'tpc': 'TPC'
        }
        
        # 将主题转换为小写进行匹配
        subject_lower = subject.lower()
        
        # 尝试匹配门市名称
        for key, value in fallback_mapping.items():
            if key in subject_lower:
                return value
        
        # 如果没有匹配到，尝试提取第一个单词作为门市名称
        words = subject.split()
        if words:
            first_word = words[0].strip('-_').upper()
            if len(first_word) >= 2:  # 至少2个字符
                return first_word
        
        # 默认返回未知门市
        return "UNKNOWN"


if __name__ == '__main__':
    try:
        app = SushiExpressApp()
        app.mainloop()
    except Exception as e:
        messagebox.showerror("Error", f"Startup failed: {e}")
        sys.exit(1)
