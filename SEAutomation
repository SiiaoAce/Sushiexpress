import os
import sys
import threading
import time
import re
import copy
import csv
import traceback
from datetime import datetime, timedelta
from collections import defaultdict
from dateutil.parser import parse
import customtkinter as ctk
from tkinter import filedialog, messagebox, simpledialog
from openpyxl import load_workbook, Workbook
from openpyxl.utils import get_column_letter
import codecs
import pandas as pd
from PIL import Image, ImageDraw, ImageFont
from openpyxl.cell.cell import MergedCell
import glob
import xlwings as xw
import tkinter.ttk as ttk
import tempfile
import uuid
import win32com.client
import base64
import pywintypes
import openpyxl
from openpyxl.styles import Alignment, Font, PatternFill, Border, Side
from calendar import monthcalendar

def normalize_supplier_name(name):
    return name.lower().replace(" ", "").replace("(", "").replace(")", "").replace(".", "").replace("_", "")

def get_week_of_month(dt):
    """計算日期在當月是第幾週（從1開始）"""
    # 使用更簡單的邏輯：直接計算日期在當月是第幾週
    # 1-7日為第1週，8-14日為第2週，以此類推
    week_number = (dt.day - 1) // 7 + 1
    return week_number

def find_supplier_file(supplier_name, files):
    norm_supplier = normalize_supplier_name(supplier_name)
    candidates = []
    for f in files:
        # 只要檔名有供應商名稱就算
        norm_f = normalize_supplier_name(os.path.splitext(f)[0])
        if norm_supplier in norm_f:
            candidates.append(f)
    if len(candidates) == 1:
        return candidates[0]
    elif len(candidates) > 1:
        for f in candidates:
            if f.startswith(supplier_name):
                return f
        return candidates[0]
    return None

# ======== 资源路径处理 ========
def resource_path(relative_path):
    """获取资源文件的绝对路径"""
    try:
        base_path = sys._MEIPASS
    except AttributeError:
        base_path = os.path.abspath(".")
    return os.path.join(base_path, relative_path)

# ========== 全局配置 ==========
LOGO_PATH = resource_path("SELOGO22 - 01.png")
PASSWORD = "OPS123"
VERSION = "6.6.0"
DEVELOPER = "OPS - Voon Kee"

# 主题配置
ctk.set_appearance_mode("dark")
ctk.set_default_color_theme("blue")

# 颜色定义
DARK_BG = "#0f172a"
DARK_PANEL = "#1e293b"
ACCENT_BLUE = "#3b82f6"
BTN_HOVER = "#60a5fa"
ACCENT_GREEN = "#10b981"
ACCENT_RED = "#ef4444"
ACCENT_PURPLE = "#8b5cf6"
ENTRY_BG = "#334155"
TEXT_COLOR = "#e2e8f0"
PANEL_BG = "#1e293b"
TEXTBOX_BG = "#0f172a"

# 字体配置
FONT_TITLE = ("Microsoft JhengHei", 24, "bold")
FONT_BIGBTN = ("Microsoft JhengHei", 16, "bold")
FONT_MID = ("Microsoft JhengHei", 14)
FONT_SUB = ("Microsoft JhengHei", 12)
FONT_ZH = ("Microsoft JhengHei", 12)
FONT_EN = ("Segoe UI", 11, "italic")
FONT_LOG = ("Consolas", 14)

# ========== 多语言支持 ==========
def t(text):
    translations = {
        "mapping_not_available": "分店供应商对应数据不可用\nOutlet-supplier mapping not available",
        "log_not_available": "日志数据不可用\nLog data not available",
        "info": "信息\nInformation",
        "processing": "處理中...\nProcessing...",
        "please_wait": "請稍候...\nPlease wait...",
        "error": "錯誤\nError",
        "login": "系統登錄\nSystem Login",
        "password": "輸入密碼...\nEnter password...",
        "login_btn": "登入\nLogin",
        "exit_confirm": "確定要退出應用程序嗎？\nAre you sure you want to exit the application?",
        "incorrect_pw": "密碼不正確，請重試\nIncorrect password, please try again",
        "main_title": "Sushi Express 自動化工具\nSushi Express Automation Tool",
        "select_function": "請選擇要執行的功能\nPlease select a function",
        "download_title": "Outlook 訂單下載\nOutlook Order Download",
        "download_desc": "下載本週的 Weekly Order 附件\nDownload weekly order attachments",
        "browse": "瀏覽...\nBrowse...",
        "start_download": "開始下載\nStart Download",
        "back_to_menu": "返回主菜單\nBack to Main Menu",
        "checklist_title": "Weekly Order 檢查表\nWeekly Order Checklist",
        "checklist_desc": "請選擇包含供應商訂單的資料夾\nSelect folder with supplier orders",
        "run_check": "執行檢查\nRun Check",
        "automation_title": "訂單自動整合\nOrder Automation",
        "automation_desc": "請選擇三個必要的資料夾\nSelect required folders",
        "source_folder": "來源資料夾 (Weekly Orders)\nSource Folder (Weekly Orders)",
        "supplier_folder": "供應商資料夾 (Supplier)\nSupplier Folder",
        "outlet_folder": "分店資料夾 (Outlet)\nOutlet Folder",
        "start_automation": "開始整合檔案\nStart Automation",
        "processing_orders": "處理訂單\nProcessing Orders",
        "outlet_suppliers": "分店供應商對應\nOutlet-Supplier Mapping",
        "exit_system": "退出系統\nExit System",
        "select_account": "選擇 Outlook 帳號\nSelect Outlook Account",
        "enter_index": "請輸入序號：\nPlease enter index:",
        "download_summary": "下載摘要\nDownload Summary",
        "auto_download": "自動下載\nAuto Downloaded",
        "skipped": "跳過\nSkipped",
        "saved_to": "保存到\nSaved to",
        "check_results": "檢查結果\nCheck Results",
        "success": "成功\nSuccess",
        "warning": "警告\nWarning",
        "folder_warning": "請先選擇所有必要的資料夾\nPlease select all required folders",
        "close": "關閉\nClose",
        "order_processing": "訂單處理進度\nOrder Processing Progress",
        "outlet_supplier_mapping": "分店-供應商對應關係\nOutlet-Supplier Mapping",
        "select_folder": "選擇文件夾\nSelect Folder",
        "view_mapping": "查看分店供應商對應\nView Outlet-Supplier Mapping",
        "view_log": "查看完整日誌\nView Full Log",
        "supplier_files": "已處理的供應商文件\nProcessed Supplier Files",
        "outlet_files": "已處理的分店文件\nProcessed Outlet Files",
        "outlet_orders": "分店訂購情況\nOutlet Orders",
        "supplier_orders": "供應商訂購情況\nSupplier Orders",
        "send_emails": "發送郵件\nSend Emails",
        "operation_supplies": "營運用品\nOperation Supplies",
    }
    return translations.get(text, text)

def get_contrast_color(bg_color):
    # 簡單亮色/暗色對比
    if isinstance(bg_color, str) and bg_color.startswith('#'):
        r = int(bg_color[1:3], 16)
        g = int(bg_color[3:5], 16)
        b = int(bg_color[5:7], 16)
        luminance = (0.299*r + 0.587*g + 0.114*b)
        return '#000000' if luminance > 186 else '#ffffff'
    return '#ffffff'

# ========== 工具函数 ==========
def load_image(path, max_size=(400, 130)):
    """安全加载图像"""
    try:
        if not os.path.exists(path):
            img = Image.new('RGB', max_size, color=DARK_BG[:3])
            draw = ImageDraw.Draw(img)
            font = ImageFont.truetype("arial.ttf", 24)
            draw.text((10,10), "Logo Missing", fill="white", font=font)
        else:
            img = Image.open(path)
        img.thumbnail(max_size, Image.LANCZOS)
        return ctk.CTkImage(img, size=img.size)
    except Exception as e:
        print(f"Error loading image: {e}")
        return None

# ========== 自定义UI组件 ==========
class GlowButton(ctk.CTkButton):
    """发光效果按钮（美化版）"""
    def __init__(self, master, text=None, glow_color=ACCENT_BLUE, **kwargs):
        super().__init__(master, text=text, **kwargs)
        self._glow_color = glow_color
        self._setup_style()
        self._bind_events()

    def _setup_style(self):
        self.configure(
            border_width=0,
            fg_color=self._glow_color,
            hover_color=self._adjust_color(self._glow_color, 40),
            text_color=get_contrast_color(self._glow_color),
            corner_radius=22,  # 更圆角
            font=("Microsoft JhengHei", 20, "bold"),  # 更大更粗
            height=70,  # 更高
            width=340,  # 更宽
            anchor="center"
        )

    def _bind_events(self):
        self.bind("<Enter>", self._on_enter)
        self.bind("<Leave>", self._on_leave)

    def _on_enter(self, event=None):
        self.configure(border_width=4, border_color=self._adjust_color(self._glow_color, 60), fg_color=self._adjust_color(self._glow_color, 20))

    def _on_leave(self, event=None):
        self.configure(border_width=0, fg_color=self._glow_color)
    
    @staticmethod
    def _adjust_color(color, amount):
        if isinstance(color, tuple) and len(color) >= 3:
            r, g, b = color[:3]
            adjusted = tuple(min(255, max(0, x + amount)) for x in (r, g, b))
            if len(color) == 4:
                return adjusted + (color[3],)
            return adjusted
        else:
            color = color.lstrip('#')
            rgb = tuple(int(color[i:i+2], 16) for i in (0, 2, 4))
            adjusted = tuple(min(255, max(0, x + amount)) for x in rgb)
            return f"#{adjusted[0]:02x}{adjusted[1]:02x}{adjusted[2]:02x}"

class ProgressPopup(ctk.CTkToplevel):
    """进度显示弹窗"""
    def __init__(self, parent, title, start_date=None, end_date=None, outlet_count=None):
        super().__init__(parent)
        self.title(title)
        self.geometry("900x700")
        self.transient(parent)
        self.grab_set()
        self.parent = parent
        self.configure(fg_color=DARK_BG)
        self.log_text = ctk.CTkTextbox(
            self,
            wrap="word",
            font=FONT_LOG,
            fg_color=TEXTBOX_BG,
            text_color=TEXT_COLOR,
            corner_radius=10
        )
        self.log_text.pack(fill="both", expand=True, padx=20, pady=20)
        self.log_text.configure(state="normal")
        if start_date and end_date:
            self.log_text.insert("end", f"📅 抓取日期範圍: {start_date} ~ {end_date}\n")
        self.log_text.configure(state="disabled")
        self.outlet_count_label = ctk.CTkLabel(
            self,
            text=f"🏪 已下載分店數量: {outlet_count if outlet_count is not None else 0} 間",
            font=("Microsoft JhengHei", 18, "bold"),
            text_color="#10b981"
        )
        self.outlet_count_label.pack(pady=(0, 10))
        close_btn = GlowButton(
            self,
            text=t("close"),
            command=self.destroy_popup,
            width=120,
            height=40
        )
        close_btn.pack(pady=10)
    def update_outlet_count(self, count):
        if self.outlet_count_label:
            self.outlet_count_label.configure(text=f"🏪 已下載分店數量: {count} 間")
    def destroy_popup(self):
        self.destroy()
        self.parent.progress_popup = None
    def log(self, message):
        self.log_text.configure(state="normal")
        self.log_text.insert("end", message)
        self.log_text.see("end")
        self.log_text.configure(state="disabled")
        # 強制更新UI
        self.update()

class MappingPopup(ctk.CTkToplevel):
    """分店-供应商映射显示"""
    def __init__(self, parent, title):
        super().__init__(parent)
        self.title(title)
        self.geometry("900x700")
        self.transient(parent)
        self.grab_set()
        self.parent = parent
        self.configure(fg_color=DARK_BG)
        
        self.mapping_text = ctk.CTkTextbox(
            self,
            wrap="word",
            font=FONT_LOG,
            fg_color=TEXTBOX_BG,
            text_color=TEXT_COLOR,
            corner_radius=10
        )
        self.mapping_text.pack(fill="both", expand=True, padx=20, pady=20)
        self.mapping_text.configure(state="disabled")
        
        close_btn = GlowButton(
            self,
            text=t("close"),
            command=self.destroy_popup,
            width=120,
            height=40
        )
        close_btn.pack(pady=10)
    
    def destroy_popup(self):
        self.destroy()
        self.parent.mapping_popup = None
    
    def update_mapping(self, mapping):
        self.mapping_text.configure(state="normal")
        self.mapping_text.delete("1.0", "end")
        self.mapping_text.insert("1.0", mapping)
        self.mapping_text.configure(state="disabled")

class ScrollableMessageBox(ctk.CTkToplevel):
    """可滚动消息框"""
    def __init__(self, parent, title, message):
        super().__init__(parent)
        self.title(title)
        self.geometry("900x700")
        self.transient(parent)
        self.grab_set()
        self.configure(fg_color=DARK_BG)
        
        self.text_box = ctk.CTkTextbox(
            self,
            wrap="word",
            font=FONT_LOG,
            fg_color=TEXTBOX_BG,
            text_color=TEXT_COLOR,
            corner_radius=10
        )
        self.text_box.pack(fill="both", expand=True, padx=20, pady=20)
        self.text_box.insert("1.0", message)
        self.text_box.configure(state="disabled")
        
        close_btn = GlowButton(
            self,
            text=t("close"),
            command=self.destroy,
            width=120,
            height=40
        )
        close_btn.pack(pady=10)

class EmailConfirmationDialog(ctk.CTkToplevel):
    """邮件发送确认对话框（只顯示純文字，保留空行）"""
    def __init__(self, parent, mail_item, supplier_name, outlet_name, attachment_path, on_confirm):
        super().__init__(parent)
        self.title(f"确认邮件 - {supplier_name}")
        self.geometry("800x700")
        self.transient(parent)
        self.grab_set()
        self.mail_item = mail_item
        self.on_confirm = on_confirm
        self.attachment_path = attachment_path
        self.configure(fg_color=DARK_BG)
        info_frame = ctk.CTkFrame(self, fg_color=DARK_PANEL, corner_radius=12)
        info_frame.pack(fill="x", padx=20, pady=10)
        ctk.CTkLabel(info_frame, text=f"收件人(To)/To: {mail_item.To}", font=FONT_MID).pack(anchor="w", padx=10, pady=5)
        ctk.CTkLabel(info_frame, text=f"抄送(CC)/CC: {mail_item.CC}", font=FONT_MID).pack(anchor="w", padx=10, pady=5)
        ctk.CTkLabel(info_frame, text=f"主题/Subject: {mail_item.Subject}", font=FONT_MID).pack(anchor="w", padx=10, pady=5)
        ctk.CTkLabel(info_frame, text=f"供应商/Supplier: {supplier_name}", font=FONT_MID).pack(anchor="w", padx=10, pady=5)
        ctk.CTkLabel(info_frame, text=f"分店/Outlet: {outlet_name}", font=FONT_MID).pack(anchor="w", padx=10, pady=5)
        if attachment_path:
            file_name = os.path.basename(attachment_path)
            ctk.CTkLabel(info_frame, text=f"附件/Attachment: {file_name}", font=FONT_MID).pack(anchor="w", padx=10, pady=5)
        body_frame = ctk.CTkFrame(self, fg_color=DARK_PANEL, corner_radius=12)
        body_frame.pack(fill="both", expand=True, padx=20, pady=10)
        ctk.CTkLabel(body_frame, text="邮件正文/Email Body:", font=FONT_BIGBTN).pack(anchor="w", padx=10, pady=5)
        # 只顯示純文字，保留空行，避免名字被拆行
        import html
        raw_html = mail_item.HTMLBody or ""
        import re
        # 1. 只把結束分行標籤換成換行
        text = re.sub(r'(<br\s*/?>|</div>|</p>|</li>|</tr>|</td>)', '\n', raw_html, flags=re.IGNORECASE)
        # 2. 把開始標籤直接移除（不換行）
        text = re.sub(r'(<div>|<p>|<li>|<tr>|<td>)', '', text, flags=re.IGNORECASE)
        # 3. 移除其他 HTML 標籤
        text = re.sub(r'<[^>]+>', '', text)
        # 4. decode HTML entity
        text = html.unescape(text)
        # 5. 移除開頭/結尾多餘空白
        text = text.strip()
        self.body_text = ctk.CTkTextbox(body_frame, wrap="word", height=300, font=FONT_MID)
        self.body_text.pack(fill="both", expand=True, padx=10, pady=5)
        self.body_text.insert("1.0", text)
        self.body_text.configure(state="disabled")
        btn_frame = ctk.CTkFrame(self, fg_color="transparent")
        btn_frame.pack(fill="x", padx=20, pady=10)
        ctk.CTkButton(
            btn_frame, 
            text="发送邮件/Send Email", 
            command=self._send_email,
            fg_color=ACCENT_GREEN,
            hover_color=BTN_HOVER
        ).pack(side="right", padx=10)
        ctk.CTkButton(
            btn_frame, 
            text="取消/Cancel", 
            command=self.destroy
        ).pack(side="right", padx=10)
        ctk.CTkButton(
            btn_frame, 
            text="编辑正文/Edit Body", 
            command=self._edit_body,
            fg_color=ACCENT_BLUE,
            hover_color=BTN_HOVER
        ).pack(side="left", padx=10)
    def _edit_body(self):
        self.body_text.configure(state="normal")
    def _send_email(self):
        try:
            # 1. 读取文本框内容
            body = self.body_text.get("1.0", "end-1c")

            # 2. 计算"月+周"英文字符串
            today = datetime.now()
            # 获取完整英文月份名称，如 "July"
            month_name = today.strftime("%B")
            # 使用正確的週數計算方法
            week_of_month = get_week_of_month(today)
            # 构造 "July Week 3"
            month_week_str = f"{month_name} Week {week_of_month}"

            # 3. 在模板中替换占位符
            body = body.replace("{week_no}", month_week_str)

            # 4. 转成 HTML 并发送
            html_body = body.replace("\n", "<br>")
            self.mail_item.HTMLBody = html_body
            self.mail_item.Send()
            self.on_confirm(True, "邮件发送成功！")
        except Exception as e:
            self.on_confirm(False, f"发送失败：{e}")
        finally:
            self.destroy()

class NavigationButton(ctk.CTkButton):
    """自定义导航按钮，支持选中状态"""
    def __init__(self, master, text, command, **kwargs):
        super().__init__(master, text=text, command=command, **kwargs)
        self.default_color = DARK_PANEL
        self.selected_color = ACCENT_BLUE
        self.hover_color = BTN_HOVER
        self.is_selected = False
        self.default_border_color = ACCENT_BLUE
        self.selected_border_color = ACCENT_GREEN
        self.configure(
            fg_color=self.default_color,
            hover_color=self.hover_color,
            text_color=get_contrast_color(self.default_color),
            border_width=2,
            border_color=self.default_border_color,
            corner_radius=10,
            font=FONT_BIGBTN,
            height=50,
            anchor="center"
        )
        self._bind_events()
    def _bind_events(self):
        self.bind("<Enter>", self._on_enter)
        self.bind("<Leave>", self._on_leave)
    def _on_enter(self, event=None):
        if not self.is_selected:
            self.configure(fg_color=self._adjust_color(self.default_color, 20))
    def _on_leave(self, event=None):
        if not self.is_selected:
            self.configure(fg_color=self.default_color)
    def select(self):
        self.is_selected = True
        self.configure(
            fg_color=self.selected_color,
            border_width=2,
            border_color=self.selected_border_color,
            text_color=get_contrast_color(self.selected_color)
        )
    def deselect(self):
        self.is_selected = False
        self.configure(
            fg_color=self.default_color,
            border_width=2,
            border_color=self.default_border_color,
            text_color=get_contrast_color(self.default_color)
        )
    @staticmethod
    def _adjust_color(color, amount):
        if isinstance(color, str) and color.startswith("#"):
            color = color.lstrip('#')
            rgb = tuple(int(color[i:i+2], 16) for i in (0, 2, 4))
            adjusted = tuple(min(255, max(0, x + amount)) for x in rgb)
            return f"#{adjusted[0]:02x}{adjusted[1]:02x}{adjusted[2]:02x}"
        return color

# ========== 送货日期验证工具 ==========
class DeliveryDateValidator:
    """送货日期验证工具"""
    
    DAYS_MAPPING = {
        'mon': 0, 'monday': 0, '星期一': 0,
        'tue': 1, 'tuesday': 1, '星期二': 1,
        'wed': 2, 'wednesday': 2, '星期三': 2,
        'thu': 3, 'thursday': 3, '星期四': 3,
        'fri': 4, 'friday': 4, '星期五': 4,
        'sat': 5, 'saturday': 5, '星期六': 5,
        'sun': 6, 'sunday': 6, '星期日': 6
    }

    def __init__(self, config_file=None):
        self.schedule = defaultdict(dict)
        if config_file:
            self.load_config(config_file)
    
    def load_config(self, config_file):
        """加载送货日期配置"""
        try:
            with open(config_file, mode='r', encoding='utf-8-sig') as f:
                reader = csv.DictReader(f)
                for row in reader:
                    supplier = row['supplier'].strip().upper()
                    outlet = row['outlet_code'].strip().upper()
                    days = self.parse_delivery_days(row['delivery_days'])
                    
                    if outlet == "ALL":
                        self.schedule[supplier]['*'] = days
                    else:
                        self.schedule[supplier][outlet] = days
        except Exception as e:
            raise Exception(f"加载送货配置失败: {str(e)}")

    def parse_delivery_days(self, days_str):
        """解析送货日期字符串"""
        days = set()
        for day in days_str.split(','):
            day = day.strip().lower()
            if day in self.DAYS_MAPPING:
                days.add(self.DAYS_MAPPING[day])
        return days

    def get_delivery_days(self, supplier, outlet_code):
        supplier = supplier.strip().upper()
        outlet_code = outlet_code.strip().upper()
        outlet_specific = self.schedule.get(supplier, {}).get(outlet_code)
        if outlet_specific is not None:
            return outlet_specific
        return self.schedule.get(supplier, {}).get('*', set())

    def validate_order(self, supplier, outlet_code, order_date, log_callback=None):
        supplier = supplier.strip().upper()
        outlet_code = outlet_code.strip().upper()
        delivery_days = self.get_delivery_days(supplier, outlet_code)
        
        if not delivery_days:
            return True
        
        try:
            if isinstance(order_date, (int, float)):
                order_date = datetime(1899, 12, 30) + timedelta(days=order_date)
            else:
                order_date = parse(str(order_date), fuzzy=True)
            
            order_weekday = order_date.weekday()
            
            if order_weekday not in delivery_days:
                day_name = ['Monday', 'Tuesday', 'Wednesday', 'Thursday',
                           'Friday', 'Saturday', 'Sunday'][order_weekday]
                if log_callback:
                    log_callback(
                        f"❌ 送货日期错误: {outlet_code} 向 {supplier} 下单\n"
                        f"  订单日期: {order_date.strftime('%Y-%m-%d')} ({day_name})\n"
                        f"  允许送货日: {self.format_days(delivery_days)}"
                    )
                return False
            return True
        except Exception as e:
            if log_callback:
                log_callback(f"⚠️ 日期解析失败: {supplier}-{outlet_code} ({order_date}): {str(e)}")
            return False

    def format_days(self, day_numbers):
        """将数字转换为星期名称"""
        days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 
               'Friday', 'Saturday', 'Sunday']
        return ", ".join(days[d] for d in sorted(day_numbers))

# ========== 统一配置管理器 ==========
class UnifiedConfigManager:
    """管理统一的Excel配置文件"""
    
    def __init__(self, config_path=None):
        self.config_path = config_path
        self.outlets = []
        self.suppliers = []
        self.delivery_schedule = []
        self.email_templates = {}
        self.supplier_requirements = {}
        
        if config_path:
            self.load_config(config_path)
    
    def load_config(self, config_path):
        """从Excel文件加载配置"""
        try:
            wb = load_workbook(config_path, data_only=True)
            
            # 读取分店信息
            if "Outlets" in wb.sheetnames:
                ws = wb["Outlets"]
                for row in ws.iter_rows(min_row=2, values_only=True):
                    if row and row[0]:
                        self.outlets.append({
                            "code": row[0].strip().upper() if isinstance(row[0], str) else str(row[0]).strip().upper(),
                            "name": row[1].strip() if len(row) > 1 and isinstance(row[1], str) else str(row[1]).strip() if len(row) > 1 and row[1] is not None else "",
                            "email": row[2].strip().lower() if len(row) > 2 and isinstance(row[2], str) else str(row[2]).strip().lower() if len(row) > 2 and row[2] is not None else "",
                            "address": row[3].strip() if len(row) > 3 and isinstance(row[3], str) else str(row[3]).strip() if len(row) > 3 and row[3] is not None else "",
                            "delivery_day": row[4].strip() if len(row) > 4 and isinstance(row[4], str) else str(row[4]).strip() if len(row) > 4 and row[4] is not None else "",
                            "brand": row[5].strip() if len(row) > 5 and isinstance(row[5], str) else str(row[5]).strip() if len(row) > 5 and row[5] is not None else "Dine-In"
                        })
            
            # 读取供应商信息
            if "Suppliers" in wb.sheetnames:
                ws = wb["Suppliers"]
                for row in ws.iter_rows(min_row=2, values_only=True):
                    if row and row[0]:
                        self.suppliers.append({
                            "name": row[0].strip() if isinstance(row[0], str) else str(row[0]).strip(),
                            "email": row[1].strip().lower() if len(row) > 1 and isinstance(row[1], str) else str(row[1]).strip().lower() if len(row) > 1 and row[1] is not None else "",
                            "contact": row[2].strip() if len(row) > 2 and isinstance(row[2], str) else str(row[2]).strip() if len(row) > 2 and row[2] is not None else "",
                            "phone": row[3].strip() if len(row) > 3 and isinstance(row[3], str) else str(row[3]).strip() if len(row) > 3 and row[3] is not None else ""
                        })
            
            # 读取配送日程
            if "Delivery Schedule" in wb.sheetnames:
                ws = wb["Delivery Schedule"]
                for row in ws.iter_rows(min_row=2, values_only=True):
                    if row and row[0]:
                        self.delivery_schedule.append({
                            "supplier": row[0].strip() if isinstance(row[0], str) else str(row[0]).strip(),
                            "outlet_code": row[1].strip().upper() if len(row) > 1 and isinstance(row[1], str) else str(row[1]).strip().upper() if len(row) > 1 and row[1] is not None else "ALL",
                            "delivery_days": row[2].strip() if len(row) > 2 and isinstance(row[2], str) else str(row[2]).strip() if len(row) > 2 and row[2] is not None else ""
                        })
            
            # 读取邮件模板
            if "Email Templates" in wb.sheetnames:
                ws = wb["Email Templates"]
                for row in ws.iter_rows(min_row=2, values_only=True):
                    if row and len(row) > 0 and row[0]:
                        self.email_templates[row[0].strip() if isinstance(row[0], str) else str(row[0]).strip()] = {
                            "subject": row[1].strip() if len(row) > 1 and isinstance(row[1], str) else str(row[1]).strip() if len(row) > 1 and row[1] is not None else "",
                            "body": row[2].strip() if len(row) > 2 and isinstance(row[2], str) else str(row[2]).strip() if len(row) > 2 and row[2] is not None else ""
                        }
            
            # 读取供应商要求
            if "Supplier Requirements" in wb.sheetnames:
                ws = wb["Supplier Requirements"]
                for row in ws.iter_rows(min_row=2, values_only=True):
                    if row and row[0]:
                        supplier_name = row[0].strip() if isinstance(row[0], str) else str(row[0]).strip()
                        # 修正：正確分割、去空格、轉大寫
                        outlet_codes = []
                        if len(row) > 1 and row[1] is not None:
                            for code in str(row[1]).replace("\n", ",").replace("，", ",").split(","):
                                code = code.strip().upper()
                                if code:
                                    outlet_codes.append(code)
                        self.supplier_requirements[supplier_name] = outlet_codes
            
            return True, f"成功加载配置文件: {len(self.outlets)} 分店, {len(self.suppliers)} 供应商"
        except Exception as e:
            return False, f"加载配置文件失败: {str(e)}"
    
    def get_outlet(self, code):
        # 根據分店代碼獲取分店全名
        if not code:
            return None
        if isinstance(code, str):
            code = code.strip().upper()
        else:
            code = str(code).upper()
        for outlet in self.outlets:
            if outlet['short_name'].upper() == code:
                return outlet['full_name']
        return None
    
    def get_supplier(self, name):
        # 根據供應商名稱獲取標準名稱
        if not name:
            return None
        if isinstance(name, str):
            name = name.strip().upper()
        else:
            name = str(name).upper()
        for supplier in self.suppliers:
            if supplier['name'].upper() == name:
                return supplier['name']
        return None
    
    def get_delivery_schedule(self, supplier, outlet_code):
        """获取特定供应商-分店的配送日程"""
        for schedule in self.delivery_schedule:
            if schedule["supplier"] == supplier and schedule["outlet_code"] == outlet_code:
                return schedule["delivery_days"]
        
        for schedule in self.delivery_schedule:
            if schedule["supplier"] == supplier and schedule["outlet_code"] == "ALL":
                return schedule["delivery_days"]
        
        return None
    
    def get_required_outlets(self, supplier_name):
        # 用 normalize 方式找 key，确保匹配
        key = str(supplier_name).strip().upper()
        for k in self.supplier_requirements:
            if str(k).strip().upper() == key:
                return self.supplier_requirements[k]
        return []

# ========== 邮件发送管理器 ==========
class EmailSender:
    """处理邮件发送功能"""

    def __init__(self, config_manager=None):
        self.config_manager = config_manager
        # 加载 GIF 图片资源
        self.email_gif = self._load_email_gif()

    def _load_email_gif(self):
        """加载邮件签名 GIF 图片"""
        try:
            gif_path = resource_path("email_gif.gif")
            if os.path.exists(gif_path):
                with open(gif_path, "rb") as f:
                    return f.read()
            return None
        except Exception as e:
            print(f"Error loading email GIF: {str(e)}")
            return None

    def _get_standard_subject(self, supplier_name):
        """生成标准邮件主题"""
        now = datetime.now()
        month_name = now.strftime("%B")
        week_in_month = get_week_of_month(now)
        return f"Sushi Express Weekly Order - {supplier_name} - {month_name} - Week {week_in_month}"

    def get_to_cc_emails(self, supplier_name, config_path):
        """根據 config excel 取得 TO/CC 郵件，並自動加 opsadmin 及 purchasing.admin，且CC不重複"""
        wb = load_workbook(config_path, data_only=True)
        to_emails = []
        cc_emails = []
        if "Suppliers" in wb.sheetnames:
            ws = wb["Suppliers"]
            for row in ws.iter_rows(min_row=2, values_only=True):
                if not row or not row[0]:
                    continue
                if str(row[0]).strip() == supplier_name:
                    typ = str(row[1]).strip().upper() if len(row) > 1 and row[1] else "TO"
                    email = str(row[2]).strip() if len(row) > 2 and row[2] else ""
                    if not email:
                        continue
                    if typ == "TO":
                        to_emails.append(email)
                    elif typ == "CC":
                        cc_emails.append(email)
        # 必須CC的名單
        must_cc = [
            "opsadmin@sushiexpress.com.sg",
            "purchasing.admin@sushiexpress.com.sg"
        ]
        for cc in must_cc:
            if cc not in cc_emails:
                cc_emails.append(cc)
        # 去重（不分大小寫）
        seen = set()
        cc_unique = []
        for e in cc_emails:
            elower = e.lower()
            if elower not in seen:
                cc_unique.append(e)
                seen.add(elower)
        return to_emails, cc_unique

    def send_email(self, to_emails, cc_emails, supplier_name, body, attachment_path=None, account_idx=None, use_content_id=True, subject=None):
        import time
        import pywintypes
        max_retries = 3
        for attempt in range(max_retries):
            try:
                import win32com.client
                import os
                import base64
                outlook = win32com.client.Dispatch("Outlook.Application")
                # --- 新增 CreateItem 自動重試 ---
                for create_attempt in range(3):
                    try:
                        mail = outlook.CreateItem(0)
                        break
                    except AttributeError as e:
                        if "CreateItem" in str(e):
                            print(f"[RETRY] Outlook COM 還沒準備好，第 {create_attempt+1} 次重試...")
                            time.sleep(2)
                            outlook = win32com.client.Dispatch("Outlook.Application")
                            continue
                        else:
                            raise
                else:
                    from tkinter import messagebox
                    messagebox.showerror("邮件发送失败", "Outlook 啟動異常，請確認 Outlook 已開啟且無彈窗。")
                    return None, "Outlook 啟動異常，請確認 Outlook 已開啟且無彈窗。"
                # --- 其餘原本的 send_email 流程 ---
                if account_idx is not None:
                    mapi = outlook.GetNamespace("MAPI")
                    accounts = [mapi.Folders.Item(i + 1) for i in range(mapi.Folders.Count)]
                    if 0 <= account_idx < len(accounts):
                        account = accounts[account_idx]
                        if hasattr(mail, 'SendUsingAccount'):
                            for acc in outlook.Session.Accounts:
                                if acc.DisplayName == account.Name:
                                    mail.SendUsingAccount = acc
                                    break
                # 處理收件人
                if isinstance(to_emails, list):
                    to_emails_fixed = ';'.join(to_emails) if to_emails else ''
                else:
                    to_emails_fixed = to_emails.replace('，', ';').replace(',', ';') if to_emails else ''
                if isinstance(cc_emails, list):
                    cc_emails_fixed = ';'.join(cc_emails) if cc_emails else ''
                else:
                    cc_emails_fixed = cc_emails.replace('，', ';').replace(',', ';') if cc_emails else ''
                mail.To = to_emails_fixed
                mail.CC = cc_emails_fixed
                if subject:
                    mail.Subject = subject
                else:
                    mail.Subject = self._get_standard_subject(supplier_name)
                # 添加 GIF 簽名
                possible_gif_paths = [
                    "email_gif.gif",
                    os.path.join(os.path.dirname(__file__), "email_gif.gif"),
                    os.path.join(os.getcwd(), "email_gif.gif"),
                    os.path.abspath("email_gif.gif")
                ]
                signature_gif_path = None
                for path in possible_gif_paths:
                    if os.path.exists(path):
                        signature_gif_path = path
                        break
                print(f"[DEBUG] 檢查 GIF 文件路徑: {possible_gif_paths}")
                print(f"[DEBUG] 找到的 GIF 文件: {signature_gif_path}")
                print(f"[DEBUG] 當前工作目錄: {os.getcwd()}")
                print(f"[DEBUG] 腳本目錄: {os.path.dirname(__file__)}")
                html_body = body
                if not any(tag in body.lower() for tag in ['<br', '<p', '<div', '<table', '<ul', '<ol', '<li', '<b', '<strong', '<em', '<span']):
                    html_body = body.replace('\n', '<br>')
                if signature_gif_path and os.path.exists(signature_gif_path):
                    if use_content_id:
                        # Content-ID 方式（新版 Outlook 兼容）
                        cid = "sigimg001"
                        signature_html = f"""
                        <br><br>
                        <img src=\"cid:{cid}\" alt=\"Signature\" style=\"max-width: 400px;\">
                        """
                        html_body += signature_html
                        mail.HTMLBody = html_body
                        att = mail.Attachments.Add(os.path.abspath(signature_gif_path))
                        att.PropertyAccessor.SetProperty("http://schemas.microsoft.com/mapi/proptag/0x3712001F", cid)
                        print(f"[DEBUG] 已用 Content-ID 插入 GIF 簽名")
                    else:
                        # base64 方式（舊版 Outlook 兼容）
                        with open(signature_gif_path, 'rb') as f:
                            gif_data = base64.b64encode(f.read()).decode()
                        signature_html = f"""
                        <br><br>
                        <img src=\"data:image/gif;base64,{gif_data}\" alt=\"Signature\" style=\"max-width: 400px;\">
                        """
                        html_body += signature_html
                        mail.HTMLBody = html_body
                        print(f"[DEBUG] 已用 base64 插入 GIF 簽名")
                else:
                    mail.HTMLBody = html_body
                # 添加订单附件
                if attachment_path and os.path.exists(attachment_path):
                    mail.Attachments.Add(attachment_path)
                return mail
            except pywintypes.com_error as e:
                if hasattr(e, 'args') and len(e.args) > 0 and e.args[0] == -2147418111:
                    print(f"[RETRY] Outlook 忙碌中，第 {attempt+1} 次重試...")
                    time.sleep(2)
                    continue
                else:
                    import traceback
                    print(traceback.format_exc())
                    from tkinter import messagebox
                    messagebox.showerror("邮件发送失败", f"{str(e)}\n\n{traceback.format_exc()}")
                    return None, f"创建邮件失败: {str(e)}"
            except Exception as e:
                import traceback
                print(traceback.format_exc())
                from tkinter import messagebox
                messagebox.showerror("邮件发送失败", f"{str(e)}\n\n{traceback.format_exc()}")
                return None, f"创建邮件失败: {str(e)}"
        # 如果重試後還是失敗
        from tkinter import messagebox
        messagebox.showerror("邮件发送失败", "Outlook 忙碌，重试多次仍失败。请稍后再试。")
        return None, "Outlook 忙碌，重试多次仍失败。请稍后再试。"

# ========== 订单自动化核心 ==========
class OrderAutomation:
    """订单自动化工具"""
    
    def __init__(self, outlet_config=None):
        # outlet_config: list of dicts with keys 'short_name', 'full_name'
        self.outlet_name_map = {}
        if outlet_config:
            for o in outlet_config:
                full = o.get('full_name', '').strip().lower()
                short = o.get('short_name', '').strip().upper()
                if full:
                    self.outlet_name_map[full] = short
                if short:
                    self.outlet_name_map[short.lower()] = short
    def get_short_code(self, f5val):
        val = (str(f5val) or '').strip().lower()
        if val in self.outlet_name_map:
            return self.outlet_name_map[val]
        # 雙向模糊比對
        for full, short in self.outlet_name_map.items():
            if full in val or val in full:
                return short
            # 單字比對
            for word in val.split():
                if word and word in full:
                    return short
        return 'UNKNOWN'

    @staticmethod
    def is_valid_date(cell_value, next_week_start, next_week_end):
        """检查是否为有效日期"""
        try:
            if isinstance(cell_value, (int, float)):
                base_date = datetime(1899, 12, 30)
                parsed = base_date + timedelta(days=cell_value)
            else:
                parsed = parse(str(cell_value), fuzzy=True, dayfirst=False)
            # 對於 Amendment 檔案，我們接受任何日期，不限制在特定週期內
            return True  # 暫時接受所有日期
        except:
            return False

    @classmethod
    def find_delivery_date_row(cls, ws, next_week_start, next_week_end, max_rows=200, file_path=None):
        """查找送货日期行"""
        valid_col_range = range(5, 12)
        invalid_labels = ["total", "total:", "sub-total", "sub-total:", "no. of cartons", "no. of cartons:"]
        found_blocks = []
        for i, row in enumerate(ws.iter_rows(min_row=1, max_row=max_rows)):
            cols = []
            for j, cell in enumerate(row):
                if j not in valid_col_range:
                    continue
                val = cell.value
                if cls.is_valid_date(val, next_week_start, next_week_end):
                    cols.append(j)
            if cols:
                found_blocks.append((i + 1, cols))
        for header_row, cols in found_blocks:
            for row_idx in range(header_row + 1, header_row + 200):
                label_val = ws.cell(row=row_idx, column=5).value
                label = str(label_val).lower().strip() if label_val else ""
                if any(invalid in label for invalid in invalid_labels):
                    continue
                for col_idx in cols:
                    qty_val = ws.cell(row=row_idx, column=col_idx+1).value
                    if isinstance(qty_val, (int, float)) and qty_val > 0:
                        return header_row, cols
        return None, []

    @classmethod
    def run_automation(cls, source_folder, supplier_folder, 
                      outlet_config=None, delivery_config=None,
                      log_callback=None, mapping_callback=None):
        """运行订单自动化（仅生成 supplier 文件）"""
        now = datetime.now()
        today = now.date()
        this_monday = today - timedelta(days=today.weekday())
        next_monday = this_monday + timedelta(days=7)
        next_sunday = next_monday + timedelta(days=6)
        start_of_period = datetime.combine(next_monday, datetime.min.time())
        end_of_period = datetime.combine(next_sunday, datetime.max.time())
        save_path = os.path.join(source_folder, f"next_week_order_log_{now.strftime('%Y%m%d_%H%M%S')}.txt")
        log_lines = [f"🎯 Next Week Order Integration Log\n", f"Scan Start Time: {now}\n", f"Target Week: {start_of_period.date()} to {end_of_period.date()}\n"]
        
        date_validator = DeliveryDateValidator(delivery_config) if delivery_config else None
        
        outlet_mapping = {}
        if outlet_config:
            try:
                outlet_mapping = {o['short_name']: o for o in outlet_config}
                if log_callback:
                    log_callback(f"✅ 已加载分店配置: {len(outlet_mapping)} 个分店")
            except Exception as e:
                if log_callback:
                    log_callback(f"⚠️ 分店配置加载失败: {str(e)}")
        
        # 新增：建立一個 OrderAutomation 實例用於 get_short_code
        oa_instance = cls(outlet_config) if outlet_config else cls()
        
        supplier_to_outlets = defaultdict(list)
        
        def log(message, include_timestamp=True):
            timestamp = datetime.now().strftime("%H:%M:%S") if include_timestamp else ""
            log_line = f"[{timestamp}] {message}" if include_timestamp else message
            log_lines.append(log_line + "\n")
            if log_callback:
                log_callback(log_line + "\n")

        files = [f for f in os.listdir(source_folder)
                 if f.endswith((".xlsx", ".xls")) and not f.startswith("~$")]
        total_files = len(files)

        if total_files == 0:
            log("未找到Excel文件\nNo Excel files found in source folder. Exiting.")
            return False, "在源文件夹中未找到Excel文件"

        log(f"找到 {total_files} 个Excel文件\nFound {total_files} Excel files")
        log(f"目标周期: {start_of_period.strftime('%Y-%m-%d')} 到 {end_of_period.strftime('%Y-%m-%d')}\nTarget period: {start_of_period.strftime('%Y-%m-%d')} to {end_of_period.strftime('%Y-%m-%d')}")
        log(f"🔍 專注於下週訂單，忽略其他週期\n🔍 Focus on next week orders only, ignore other periods")

        for idx, file in enumerate(files):
            full_path = os.path.join(source_folder, file)
            try:
                # log(f"\n处理文件 {idx+1}/{total_files}: {file}\nProcessing file {idx+1}/{total_files}: {file}")
                wb = load_workbook(full_path, data_only=True)
                # log(f"工作表: {', '.join(wb.sheetnames)}\nWorksheets: {', '.join(wb.sheetnames)}")
                for sheetname in wb.sheetnames:
                    ws = wb[sheetname]
                    if ws.sheet_state != "visible":
                        continue  # 跳過隱藏工作表不 log，不顯示任何訊息
                    outlet_short = file.split('_')[0].strip() if '_' in file else file.split('.')[0].strip()
                    # log(f"  工作表: {sheetname}, 文件名分店简称: '{outlet_short}'\n  Sheet: {sheetname}, Short Name (from filename): '{outlet_short}'")
                    has_order = False
                    week_days = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']
                    for row in range(1, ws.max_row):
                        row_vals = [str(ws.cell(row=row, column=col).value).strip() if ws.cell(row=row, column=col).value else '' for col in range(6, 13)]
                        weekday_count = sum(day in row_vals for day in week_days)
                        if 'Mon' in row_vals and weekday_count >= 3:
                            date_row = row + 1
                            date_cols = []
                            for idx2, col in enumerate(range(6, 13)):
                                val = ws.cell(row=date_row, column=col).value
                                parsed = None
                                try:
                                    if val:
                                        sval = str(val)
                                        if re.match(r"^\d{1,2}-[A-Za-z]{3,}$", sval):
                                            year = start_of_period.year
                                            sval = f"{sval}-{year}"
                                        if isinstance(val, (int, float)):
                                            base_date = datetime(1899, 12, 30)
                                            parsed = base_date + timedelta(days=val)
                                        else:
                                            parsed = parse(sval, fuzzy=True, dayfirst=False)
                                except Exception:
                                    pass
                                if parsed and start_of_period.date() <= parsed.date() <= end_of_period.date():
                                    date_cols.append(col)
                            if date_cols:
                                for r in range(date_row+1, min(date_row+30, ws.max_row+1)):
                                    found_order_this_row = False
                                    for c in date_cols:
                                        val = ws.cell(row=r, column=c).value
                                        if isinstance(val, (datetime,)):
                                            if val.date() > end_of_period.date():
                                                found_order_this_row = True
                                                break
                                        elif isinstance(val, (int, float)) and val > 0:
                                            has_order = True
                                            found_order_this_row = True
                                            break
                                    if found_order_this_row:
                                        break
                            if has_order:
                                break
                    if has_order:
                        # 只記錄有訂單的廠商與分店，不記錄細節
                        supplier_to_outlets[sheetname].append((outlet_short, full_path, sheetname))
            except Exception as e:
                error_msg = f"❌ 处理文件出错: {file}\n❌ Error processing {file}: {str(e)}\n{traceback.format_exc()}"
                log(error_msg)
        
        log("\n📊 下週訂單整合結果 / Next Week Order Integration Results:")
        for supplier, outlets in supplier_to_outlets.items():
            outlet_list = [str(o[0]) if o[0] else "UNKNOWN" for o in outlets]
            log(f"  📦 {supplier}: {', '.join(outlet_list)}")
        log(f"\n🎯 只處理下週訂單，共 {sum(len(outlets) for outlets in supplier_to_outlets.values())} 個門市有訂單")
        log("\nCreating supplier files...")
        supplier_files = []
        import xlwings as xw
        for sheetname, outlet_file_pairs in supplier_to_outlets.items():
            supplier_path = os.path.join(supplier_folder, f"{sheetname}_Week_{now.isocalendar()[1]}.xlsx")
            # 先建立空檔案
            if not os.path.exists(supplier_path):
                from openpyxl import Workbook
                wb = Workbook()
                wb.save(supplier_path)
            app = xw.App(visible=False)
            try:
                wb_dest = app.books.open(supplier_path)
                for outlet, src_file, original_sheet in outlet_file_pairs:
                    try:
                        wb_src = app.books.open(src_file)
                        sht = wb_src.sheets[original_sheet]
                        dest_sheet_name = outlet if outlet else original_sheet
                        # 刪除同名分頁
                        for s in wb_dest.sheets:
                            if s.name == dest_sheet_name:
                                s.delete()
                        sht.api.Copy(Before=wb_dest.sheets[0].api)
                        wb_dest.sheets[0].name = dest_sheet_name
                        wb_src.close()
                        log(f"  ✅ {dest_sheet_name} 已複製進 {os.path.basename(supplier_path)}（格式/公式完整保留）")
                    except Exception as e:
                        log(f"    ❌ Failed to copy {outlet} in {sheetname}: {str(e)}\n{traceback.format_exc()}")
                wb_dest.save()
                wb_dest.close()
                supplier_files.append(os.path.basename(supplier_path))
            finally:
                app.quit()
        result_text = "\n🎯 下週訂單整合完成 / Next Week Order Integration Complete:\n"
        result_text += f"📦 已處理供應商文件: {len(supplier_files)}\n"
        result_text += f"📅 目標週期: {start_of_period.strftime('%Y-%m-%d')} 到 {end_of_period.strftime('%Y-%m-%d')}\n\n"
        result_text += "📋 供應商文件列表:\n" + "\n".join([f"  ✅ {file}" for file in supplier_files])
        log(result_text)
        try:
            with open(save_path, "w", encoding="utf-8") as logfile:
                logfile.writelines(log_lines)
            log(f"\nLog saved at: {save_path}")
            return True, f"订单整合完成！\n\n日志文件保存至:\n{save_path}\n\n{result_text}"
        except Exception as e:
            log(f"❌ Failed to write log file: {e}")
            return False, f"订单整合完成但日志保存失败:\n{str(e)}"

# ========== 增强版订单检查器 ==========
class EnhancedOrderChecker:
    """使用配置文件的订单检查器"""
    
    def __init__(self, config_manager=None):
        self.config_manager = config_manager
        # 新增：建立 full name/short name/email name normalize 映射到 short name
        self.fullname_to_short = {}
        if config_manager and hasattr(config_manager, 'config_path'):
            import pandas as pd
            import os
            config_path = config_manager.config_path if hasattr(config_manager, 'config_path') else None
            if config_path and os.path.exists(config_path):
                try:
                    df = pd.read_excel(config_path, sheet_name=None)
                    outlet_df = None
                    for key in df.keys():
                        if key.strip().lower() == "outlet":
                            outlet_df = df[key]
                            break
                    if outlet_df is not None:
                        for _, row in outlet_df.iterrows():
                            short = str(row.get("Short Name", "")).strip()
                            full = str(row.get("Outlet Full Name", "")).strip()
                            email_name = str(row.get("Name in Email", "")).strip()
                            for n in [short, full, email_name]:
                                n_norm = self._normalize(n)
                                if n and n_norm:
                                    self.fullname_to_short[n_norm] = short
                except Exception as e:
                    print("[EnhancedOrderChecker] Outlet mapping read error:", e)

    @staticmethod
    def _normalize(text):
        """标准化文本"""
        import re
        if not text:
            return ""
        # 只去除空格，保留括号内容以区分不同供应商
        return re.sub(r'[\s]', '', str(text).lower())

    def get_outlet_shortname(self, f5_value):
        """智能获取分店简称，优先用 config mapping"""
        import re
        
        if not f5_value or not isinstance(f5_value, str):
            return f"[EMPTY] {f5_value}"
        
        # 先嘗試完整匹配
        n = self._normalize(f5_value)
        if n in self.fullname_to_short:
            return self.fullname_to_short[n]
        
        # 處理包含配送日期資訊的 F5 值
        # 例如: "Sushi Express West Mall (MON,WED,FRI,SAT)" -> "Sushi Express West Mall"
        # 但保留包含門市代碼的括號，如 "Sushi Takeout CityVibe (GTM)"
        delivery_pattern = r'\s*\([A-Z]{2,4},[A-Z]{2,4},[A-Z]{2,4},[A-Z]{2,4}\)\s*$'
        cleaned_f5 = re.sub(delivery_pattern, '', f5_value.strip())
        
        if cleaned_f5 != f5_value:
            n = self._normalize(cleaned_f5)
            if n in self.fullname_to_short:
                return self.fullname_to_short[n]
        
        # fallback: 原有 hardcode/正则逻辑（可选）
        # ... existing code ...
        return f"[UNKNOWN] {f5_value}"

    def run_checklist(self, folder, log_callback=None, as_table=False):
        date_validator = None
        if self.config_manager:
            delivery_schedules = self.config_manager.delivery_schedule
            if delivery_schedules:
                date_validator = DeliveryDateValidator()
                date_validator.schedule = defaultdict(dict)
                for row in delivery_schedules:
                    supplier = row['supplier']
                    outlet = row['outlet_code']
                    days = DeliveryDateValidator().parse_delivery_days(row['delivery_days'])
                    if outlet == "ALL":
                        date_validator.schedule[supplier]['*'] = days
                    else:
                        date_validator.schedule[supplier][outlet] = days
        supplier_keywords = {}
        if self.config_manager:
            for supplier in self.config_manager.suppliers:
                supplier_keywords[supplier["name"]] = [supplier["name"].lower()]
        must_have_outlets = {}
        if self.config_manager:
            for supplier in self.config_manager.suppliers:
                must_have_outlets[supplier["name"]] = self.config_manager.get_required_outlets(supplier["name"])
        try:
            files = [f for f in os.listdir(folder) if f.endswith(".xlsx") and not f.startswith("~$")]
            def file_key(f):
                import re
                base = f.split("_Week_")[0]
                return self._normalize(base)
            normalized_files = {file_key(f): f for f in files}
            output = []
            table = []
            for supplier, keywords in supplier_keywords.items():
                matches = self._find_supplier_file(normalized_files, keywords)
                if not matches:
                    if as_table:
                        table.append({
                            "supplier": supplier,
                            "outlet": "-",
                            "cover_status": "❌",
                            "remark": "Supplier file not found"
                        })
                    else:
                        output.append(f"\n❌ {supplier} - Supplier file not found.")
                    continue
                for match in matches:
                    result, table_rows = self._process_supplier_file(
                        folder, match, must_have_outlets[supplier], 
                        date_validator, log_callback, as_table=True, supplier=supplier
                    )
                if as_table:
                    table.extend(table_rows)
                else:
                    output.extend(result)
            if as_table:
                return table
            return "\n".join(output)
        except Exception as e:
            if as_table:
                return [{"supplier": "-", "outlet": "-", "cover_status": "❌", "remark": f"Error: {str(e)}"}]
            return f"❌ Error running checklist: {str(e)}\n{traceback.format_exc()}"

    @classmethod
    def _find_supplier_file(cls, normalized_files, keywords):
        matches = []
        for k in keywords:
            nk = cls._normalize(k)
            for nf, of in normalized_files.items():
                if nf == nk:
                    matches.append(of)
        if matches:
            return matches
        # 不再做唯一模糊匹配，避免误配
        return None

    def _process_supplier_file(self, folder, filename, required_outlets, date_validator=None, log_callback=None, as_table=False, supplier=None):
        import os
        from openpyxl import load_workbook
        import tkinter.messagebox as messagebox
        output = []
        table = []
        found = set()
        unidentified = []
        date_errors = []
        unknown_f5 = set()
        try:
            wb = load_workbook(os.path.join(folder, filename), data_only=True)
            for s in wb.sheetnames:
                # 跳过 sheet 名为 'Sheet' 或空白的 sheet
                if not s.strip() or s.strip().lower() == 'sheet':
                    continue
                try:
                    f5 = wb[s]["F5"].value
                    code = self.get_outlet_shortname(f5)
                    sheet_name = s.strip().upper()
                    short_name_mismatch = False
                    
                    # 處理特殊情況：如果 F5 映射結果與工作表名稱不同，但都指向同一個門市
                    # 例如：F5→BUGIS, Sheet→BJ，但都指向 SushiPlus Bugis
                    if code != sheet_name and "[UNKNOWN]" not in code and "[EMPTY]" not in code:
                        # 檢查是否都映射到同一個門市
                        f5_normalized = self._normalize(f5) if f5 else ""
                        sheet_normalized = self._normalize(sheet_name)
                        
                        # 如果 F5 映射和工作表名稱都指向同一個門市，則不視為 mismatch
                        if f5_normalized in self.fullname_to_short and sheet_normalized in self.fullname_to_short:
                            if self.fullname_to_short[f5_normalized] == self.fullname_to_short[sheet_normalized]:
                                short_name_mismatch = False
                            else:
                                short_name_mismatch = True
                        else:
                            short_name_mismatch = True
                    if "[UNKNOWN]" in code or "[EMPTY]" in code:
                        unidentified.append((s, f5))
                        unknown_f5.add(str(f5).strip() if f5 else "[空白]")
                        if as_table:
                            table.append({
                                "supplier": supplier,
                                "outlet": s,
                                "cover_status": "⚠️",
                                "remark": f"F5 error: {f5}" + (f"; Short name mismatch: F5→{code}, Sheet→{sheet_name}" if short_name_mismatch else "")
                            })
                    else:
                        found.add(code)
                        date_status = "-"
                        remark = ""
                        if date_validator:
                            delivery_date = wb[s]['F8'].value if 'F8' in wb[s] else None
                            if delivery_date:
                                is_valid = date_validator.validate_order(
                                    supplier,
                                    code,
                                    delivery_date,
                                    log_callback
                                )
                                if not is_valid:
                                    date_status = "❌"
                                    remark = "Invalid delivery date"
                                    date_errors.append(code)
                                else:
                                    date_status = "✔️"
                            else:
                                date_status = "⚠️"
                                remark = ""
                        if short_name_mismatch:
                            if remark:
                                remark += "; "
                            remark += f"Short name mismatch: F5→{code}, Sheet→{sheet_name}"
                        if as_table:
                            table.append({
                                "supplier": supplier,
                                "outlet": code,
                                "cover_status": "✔️",
                                "remark": remark
                            })
                except Exception as e:
                    unidentified.append((s, f"[F5 error: {e}]") )
                    if as_table:
                        table.append({
                            "supplier": supplier,
                            "outlet": s,
                            "cover_status": "⚠️",
                            "remark": f"F5 error: {e} (sheet: {s}, file: {filename})"
                        })
            required = set([str(x).strip().upper() for x in required_outlets])
            found = set([str(x).strip().upper() for x in found])
            print(f"[DEBUG] supplier={supplier}")
            print(f"[DEBUG] required={required}")
            print(f"[DEBUG] found={found}")
            print(f"[DEBUG] missing={required - found}")
            print(f"[DEBUG] all sheet names in {filename}: {wb.sheetnames}")
            print(f"[DEBUG] unidentified sheets: {unidentified}")
            print(f"[DEBUG] unknown F5 values: {unknown_f5}")
            print(f"[DEBUG] F5 to code mappings:")
            for s in wb.sheetnames:
                if not s.strip() or s.strip().lower() == 'sheet':
                    continue
                try:
                    f5 = wb[s]["F5"].value
                    code = self.get_outlet_shortname(f5)
                    print(f"  Sheet: {s}, F5: {f5}, Code: {code}")
                except Exception as e:
                    print(f"  Sheet: {s}, F5 Error: {e}")
            
            # 檢查 missing outlet 是否有對應的 sheet 但 F5 和 sheet name 不一致
            missing_with_sheet_mismatch = set()
            for sheet_name in wb.sheetnames:
                if not sheet_name.strip() or sheet_name.strip().lower() == 'sheet':
                    continue
                sheet_name_upper = sheet_name.strip().upper()
                if sheet_name_upper in required and sheet_name_upper not in found:
                    try:
                        f5 = wb[sheet_name]["F5"].value
                        code = self.get_outlet_shortname(f5)
                        if code != sheet_name_upper and "[UNKNOWN]" not in code and "[EMPTY]" not in code:
                            missing_with_sheet_mismatch.add(sheet_name_upper)
                    except:
                        pass
            
            for o in sorted(required - found):
                if as_table:
                    if o in missing_with_sheet_mismatch:
                        # 有 sheet 但 F5 和 sheet name 不一致
                        table.append({
                            "supplier": supplier,
                            "outlet": o,
                            "cover_status": "⚠️",
                            "remark": f"Short name mismatch: Sheet→{o}"
                        })
                    else:
                        # 真正的 missing outlet
                        table.append({
                            "supplier": supplier,
                            "outlet": o,
                            "cover_status": "❌",
                            "remark": "Missing outlet"
                        })
            if as_table:
                # 检查结束后，弹窗提醒所有未能 mapping 的 F5 内容
                if unknown_f5:
                    msg = "以下 F5 内容未能自动 mapping 到 short name，请补充到 config 的 OUTLET sheet：\n" + "\n".join(f"- {f5val}" for f5val in sorted(unknown_f5))
                    try:
                        messagebox.showwarning("智能提示/Smart Reminder", msg)
                    except Exception:
                        print("[智能提示]", msg)
                return output, table
            # 原本文字报表
            output.append(f"\n=== {filename} ===")
            output.append(f"📊 Required: {len(required)}, Found: {len(found)}, Missing: {len(required - found)}")
            for o in sorted(required & found):
                output.append(f"✔️ {o}")
            for o in sorted(required - found):
                output.append(f"❌ {o}")
            for s, v in unidentified:
                output.append(f"⚠️ {s} => {v}")
            if unknown_f5:
                output.append("[智能提示] 以下 F5 内容未能自动 mapping 到 short name，请补充到 config 的 OUTLET sheet：")
                for f5val in sorted(unknown_f5):
                    output.append(f"  - {f5val}")
            return output, table
        except Exception as e:
            if as_table:
                return [{"supplier": "-", "outlet": "-", "cover_status": "❌", "remark": f"Error: {str(e)}"}]
            return f"❌ Error running checklist: {str(e)}\n{traceback.format_exc()}"

# ========== 增强版订单自动化 ==========
class EnhancedOrderAutomation(OrderAutomation):
    """支持邮件发送的订单自动化"""
    
    def __init__(self, config_manager=None):
        super().__init__()
        self.config_manager = config_manager
        self.email_sender = EmailSender(config_manager)
    
    def run_automation(self, source_folder, supplier_folder, 
                      log_callback=None, mapping_callback=None, 
                      email_callback=None):
        """运行自动化流程（仅 supplier 整合）"""
        success, result = super().run_automation(
            source_folder, supplier_folder, 
            log_callback=log_callback, mapping_callback=mapping_callback
        )
        if not success:
            return success, result
        supplier_files = []
        for file in os.listdir(supplier_folder):
            if file.endswith(".xlsx") and "Week" in file:
                supplier_name = file.split("_")[0]
                supplier_files.append({
                    "path": os.path.join(supplier_folder, file),
                    "supplier": supplier_name
                })
        if self.config_manager and email_callback:
            email_callback(supplier_files)
        return success, result

class YellowHighlightedOrderAutomation(OrderAutomation):
    """只整合有黃色標記的訂單"""
    
    def __init__(self, config_manager=None):
        super().__init__()
        self.config_manager = config_manager
    
    def has_yellow_highlight(self, ws, row, col):
        """檢查指定單元格是否有黃色標記"""
        try:
            cell = ws.cell(row=row, column=col)
            if cell.fill.start_color.rgb:
                fill_color = cell.fill.start_color.rgb
                print(f"[DEBUG] Cell ({row}, {col}) RGB: {fill_color}")
                
                # 檢查常見的黃色 RGB 值
                yellow_rgbs = ['FFFF00', 'FFFFFF00', 'FF00FF00', 'FFD966', 'FFF200', 'FFEB9C', 'FFE066', 'FFD700', 'FFE135', 'FFD800', 'FFE100']
                if fill_color in yellow_rgbs:
                    print(f"[DEBUG] ✅ 找到標準黃色: {fill_color}")
                    return True
                
                # 更寬鬆的黃色檢查：R 和 G 都很高，B 很低
                if fill_color.startswith('FF') and len(fill_color) == 8:
                    rgb = fill_color[2:]  # 去掉 alpha 通道
                    r = int(rgb[0:2], 16)
                    g = int(rgb[2:4], 16)
                    b = int(rgb[4:6], 16)
                    
                    # 黃色條件：R 和 G 都 > 240，B < 50
                    if r > 240 and g > 240 and b < 50:
                        print(f"[DEBUG] ✅ 找到寬鬆黃色: R={r}, G={g}, B={b}")
                        return True
                    
                    # 更寬鬆的條件：R 和 G 都 > 200，B < 100
                    if r > 200 and g > 200 and b < 100:
                        print(f"[DEBUG] ✅ 找到非常寬鬆黃色: R={r}, G={g}, B={b}")
                        return True
                
                print(f"[DEBUG] ❌ 不是黃色: {fill_color}")
            else:
                print(f"[DEBUG] Cell ({row}, {col}) 沒有填色")
            return False
        except Exception as e:
            print(f"[DEBUG] Error checking yellow highlight: {e}")
            return False
    
    def check_file_has_yellow_highlight(self, filepath, this_week_start, this_week_end):
        """檢查檔案是否有黃色標記的單元格"""
        try:
            print(f"[DEBUG] 開始檢查檔案: {filepath}")
            wb = openpyxl.load_workbook(filepath, data_only=True)
            for sheet_name in wb.sheetnames:
                ws = wb[sheet_name]
                print(f"[DEBUG] 檢查工作表: {sheet_name}")
                
                # 尋找日期行 - 使用本週日期範圍
                date_row_result = self.find_delivery_date_row(ws, this_week_start, this_week_end, file_path=filepath)
                if date_row_result is None or date_row_result[0] is None:
                    print(f"[DEBUG] 在工作表 {sheet_name} 中找不到日期行")
                    continue
                
                date_row = date_row_result[0]  # 取得行號
                print(f"[DEBUG] 找到日期行: {date_row}")
                
                # 檢查日期行下方的數量單元格是否有黃色標記
                for row in range(date_row + 1, min(date_row + 50, ws.max_row + 1)):
                    # 檢查是否為產品行（通常有產品名稱）- 使用 E 欄與 find_delivery_date_row 一致
                    product_name = ws.cell(row=row, column=5).value  # E 欄產品名稱
                    if not product_name or str(product_name).strip() == "":
                        continue
                    
                    print(f"[DEBUG] 檢查產品行: {row}, 產品: {product_name}")
                    
                    # 檢查日期欄位（通常是 F 到 L 欄）
                    for col in range(6, 13):  # F 到 L 欄
                        cell_value = ws.cell(row=row, column=col).value
                        if cell_value and (isinstance(cell_value, (int, float)) or 
                                         (isinstance(cell_value, str) and cell_value.replace('.', '').isdigit())):
                            print(f"[DEBUG] 檢查數量格: ({row}, {col}), 值: {cell_value}")
                            # 如果數量不為0且有黃色標記
                            if self.has_yellow_highlight(ws, row, col):
                                print(f"[DEBUG] ✅ 在檔案 {filepath} 中找到黃色標記!")
                                wb.close()
                                return True
            wb.close()
            print(f"[DEBUG] ❌ 在檔案 {filepath} 中沒有找到黃色標記")
            return False
        except Exception as e:
            print(f"[DEBUG] Error checking yellow highlight in {filepath}: {e}")
            return False
    
    def run_automation(self, source_folder, supplier_folder, log_callback=None, mapping_callback=None):
        from datetime import datetime, timedelta
        import os
        import openpyxl
        import xlwings as xw
        import traceback

        now = datetime.now()
        today = now.date()
        this_monday = today - timedelta(days=today.weekday())
        this_sunday = this_monday + timedelta(days=6)
        start_of_period = datetime.combine(this_monday, datetime.min.time())
        end_of_period = datetime.combine(this_sunday, datetime.max.time())
        save_path = os.path.join(source_folder, f"yellow_highlight_order_log_{now.strftime('%Y%m%d_%H%M%S')}.txt")
        log_lines = [
            f"🎯 Amendment Order Integration Log\n",
            f"Scan Start Time: {now}\n",
            f"Target Week: {start_of_period.date()} to {end_of_period.date()}\n"
        ]

        def log(message, include_timestamp=True):
            timestamp = datetime.now().strftime("%H:%M:%S") if include_timestamp else ""
            log_line = f"[{timestamp}] {message}" if include_timestamp else message
            log_lines.append(log_line + "\n")
            if log_callback:
                log_callback(log_line + "\n")

        files = [f for f in os.listdir(source_folder) if f.endswith((".xlsx", ".xls")) and not f.startswith("~$")]
        total_files = len(files)
        if total_files == 0:
            log("未找到Excel文件\nNo Excel files found in source folder. Exiting.")
            return False, "在源文件夹中未找到Excel文件"
        log(f"找到 {total_files} 个Excel文件\nFound {total_files} Excel files")
        log(f"目标周期: {start_of_period.strftime('%Y-%m-%d')} 到 {end_of_period.strftime('%Y-%m-%d')}")
        log(f"🔍 專注於本週訂單，忽略其他週期")

        # 1. 找出所有有黃色標記的 (門市, 廠商) sheet
        supplier_to_outlets = {}  # supplier: set(outlet)
        for filename in files:
            filepath = os.path.join(source_folder, filename)
            try:
                wb = openpyxl.load_workbook(filepath, data_only=True)
                for sheetname in wb.sheetnames:
                    ws = wb[sheetname]
                    # 跳過隱藏 sheet
                    if hasattr(ws, 'sheet_state') and ws.sheet_state != "visible":
                        continue
                    found_yellow = False
                    for row in ws.iter_rows():
                        for cell in row:
                            fill = cell.fill
                            if fill and fill.fgColor and hasattr(fill.fgColor, 'rgb'):
                                rgb = fill.fgColor.rgb
                                if isinstance(rgb, str) and (rgb.upper() == 'FFFFFF00' or rgb.upper() == 'FFFF00'):
                                    found_yellow = True
                                    break
                        if found_yellow:
                            break
                    if found_yellow:
                        supplier_to_outlets.setdefault(sheetname, set()).add(filepath)
                        log(f"✅ {filename} 發現黃色標記: {sheetname}")
                wb.close()
            except Exception as e:
                log(f"❌ 檢查 {filename} 發生錯誤: {e}")
        log("")
        log(f"📊 統計結果:")
        log(f"   - 總檔案數: {len(files)}")
        log(f"   - 有黃色標記的廠商: {len(supplier_to_outlets)}")
        log("")
        if not supplier_to_outlets:
            log("❌ 沒有找到任何有黃色標記的廠商")
            return False, "沒有找到任何有黃色標記的廠商"
        log(f"📋 準備整合以下廠商:")
        for supplier in supplier_to_outlets:
            log(f"   - {supplier}")
        log("")
        # 2. 以廠商為單位合併所有有黃色標記的門市的該廠商 sheet（用 xlwings 複製 sheet，保留格式/公式）
        supplier_files = []
        for supplier, filelist in supplier_to_outlets.items():
            try:
                supplier_path = os.path.join(supplier_folder, f"{supplier}_Amendment_{now.isocalendar()[1]}.xlsx")
                # 先建立空檔案
                if not os.path.exists(supplier_path):
                    from openpyxl import Workbook
                    wb = Workbook()
                    wb.save(supplier_path)
                app = xw.App(visible=False)
                try:
                    wb_dest = app.books.open(supplier_path)
                    for src_file in filelist:
                        try:
                            wb_src = app.books.open(src_file)
                            if supplier in [sht.name for sht in wb_src.sheets]:
                                sht = wb_src.sheets[supplier]
                                dest_sheet_name = os.path.splitext(os.path.basename(src_file))[0]
                                # 刪除同名分頁
                                for s in wb_dest.sheets:
                                    if s.name == dest_sheet_name:
                                        s.delete()
                                sht.api.Copy(Before=wb_dest.sheets[0].api)
                                wb_dest.sheets[0].name = dest_sheet_name
                            wb_src.close()
                        except Exception as e:
                            log(f"    ❌ Failed to copy {supplier} in {os.path.basename(src_file)}: {str(e)}\n{traceback.format_exc()}")
                    wb_dest.save()
                    wb_dest.close()
                    supplier_files.append(os.path.basename(supplier_path))
                    log(f"  ✅ 已整合: {os.path.basename(supplier_path)}")
                finally:
                    app.quit()
            except Exception as e:
                log(f"❌ 整合 {supplier} 發生錯誤: {e}\n{traceback.format_exc()}")
        result_text = f"\n🎯 本週訂單整合完成 / Amendment Order Integration Complete:\n"
        result_text += f"📦 已處理供應商文件: {len(supplier_files)}\n"
        result_text += f"📅 目標週期: {this_monday.strftime('%Y-%m-%d')} 到 {this_sunday.strftime('%Y-%m-%d')}\n\n"
        result_text += "📋 供應商文件列表:\n" + "\n".join([f"  ✅ {file}" for file in supplier_files])
        log(result_text)
        try:
            with open(save_path, "w", encoding="utf-8") as logfile:
                logfile.writelines(log_lines)
            log(f"\nLog saved at: {save_path}")
            return True, f"Amendment Order 整合完成！\n\n日志文件保存至:\n{save_path}\n\n{result_text}"
        except Exception as e:
            log(f"❌ Failed to write log file: {e}")
            return False, f"Amendment Order 整合完成但日志保存失败:\n{str(e)}"



# ========== 订单自动化核心 ==========
class OrderAutomation:
    """订单自动化工具"""
    
    def __init__(self, outlet_config=None):
        # outlet_config: list of dicts with keys 'short_name', 'full_name'
        self.outlet_name_map = {}
        if outlet_config:
            for o in outlet_config:
                full = o.get('full_name', '').strip().lower()
                short = o.get('short_name', '').strip().upper()
                if full:
                    self.outlet_name_map[full] = short
                if short:
                    self.outlet_name_map[short.lower()] = short
    def get_short_code(self, f5val):
        val = (str(f5val) or '').strip().lower()
        if val in self.outlet_name_map:
            return self.outlet_name_map[val]
        # 雙向模糊比對
        for full, short in self.outlet_name_map.items():
            if full in val or val in full:
                return short
            # 單字比對
            for word in val.split():
                if word and word in full:
                    return short
        return 'UNKNOWN'

    @staticmethod
    def is_valid_date(cell_value, next_week_start, next_week_end):
        """检查是否为有效日期"""
        try:
            if isinstance(cell_value, (int, float)):
                base_date = datetime(1899, 12, 30)
                parsed = base_date + timedelta(days=cell_value)
            else:
                parsed = parse(str(cell_value), fuzzy=True, dayfirst=False)
            # 對於 Amendment 檔案，我們接受任何日期，不限制在特定週期內
            return True  # 暫時接受所有日期
        except:
            return False

    @classmethod
    def find_delivery_date_row(cls, ws, next_week_start, next_week_end, max_rows=200, file_path=None):
        """查找送货日期行"""
        valid_col_range = range(5, 12)
        invalid_labels = ["total", "total:", "sub-total", "sub-total:", "no. of cartons", "no. of cartons:"]
        found_blocks = []
        for i, row in enumerate(ws.iter_rows(min_row=1, max_row=max_rows)):
            cols = []
            for j, cell in enumerate(row):
                if j not in valid_col_range:
                    continue
                val = cell.value
                if cls.is_valid_date(val, next_week_start, next_week_end):
                    cols.append(j)
            if cols:
                found_blocks.append((i + 1, cols))
        for header_row, cols in found_blocks:
            for row_idx in range(header_row + 1, header_row + 200):
                label_val = ws.cell(row=row_idx, column=5).value
                label = str(label_val).lower().strip() if label_val else ""
                if any(invalid in label for invalid in invalid_labels):
                    continue
                for col_idx in cols:
                    qty_val = ws.cell(row=row_idx, column=col_idx+1).value
                    if isinstance(qty_val, (int, float)) and qty_val > 0:
                        return header_row, cols
        return None, []

    @classmethod
    def run_automation(cls, source_folder, supplier_folder, 
                      outlet_config=None, delivery_config=None,
                      log_callback=None, mapping_callback=None):
        """运行订单自动化（仅生成 supplier 文件）"""
        now = datetime.now()
        today = now.date()
        this_monday = today - timedelta(days=today.weekday())
        next_monday = this_monday + timedelta(days=7)
        next_sunday = next_monday + timedelta(days=6)
        start_of_period = datetime.combine(next_monday, datetime.min.time())
        end_of_period = datetime.combine(next_sunday, datetime.max.time())
        save_path = os.path.join(source_folder, f"next_week_order_log_{now.strftime('%Y%m%d_%H%M%S')}.txt")
        log_lines = [f"🎯 Next Week Order Integration Log\n", f"Scan Start Time: {now}\n", f"Target Week: {start_of_period.date()} to {end_of_period.date()}\n"]
        
        date_validator = DeliveryDateValidator(delivery_config) if delivery_config else None
        
        outlet_mapping = {}
        if outlet_config:
            try:
                outlet_mapping = {o['short_name']: o for o in outlet_config}
                if log_callback:
                    log_callback(f"✅ 已加载分店配置: {len(outlet_mapping)} 个分店")
            except Exception as e:
                if log_callback:
                    log_callback(f"⚠️ 分店配置加载失败: {str(e)}")
        
        # 新增：建立一個 OrderAutomation 實例用於 get_short_code
        oa_instance = cls(outlet_config) if outlet_config else cls()
        
        supplier_to_outlets = defaultdict(list)
        
        def log(message, include_timestamp=True):
            timestamp = datetime.now().strftime("%H:%M:%S") if include_timestamp else ""
            log_line = f"[{timestamp}] {message}" if include_timestamp else message
            log_lines.append(log_line + "\n")
            if log_callback:
                log_callback(log_line + "\n")

        files = [f for f in os.listdir(source_folder)
                 if f.endswith((".xlsx", ".xls")) and not f.startswith("~$")]
        total_files = len(files)

        if total_files == 0:
            log("未找到Excel文件\nNo Excel files found in source folder. Exiting.")
            return False, "在源文件夹中未找到Excel文件"

        log(f"找到 {total_files} 个Excel文件\nFound {total_files} Excel files")
        log(f"目标周期: {start_of_period.strftime('%Y-%m-%d')} 到 {end_of_period.strftime('%Y-%m-%d')}\nTarget period: {start_of_period.strftime('%Y-%m-%d')} to {end_of_period.strftime('%Y-%m-%d')}")
        log(f"🔍 專注於下週訂單，忽略其他週期\n🔍 Focus on next week orders only, ignore other periods")

        for idx, file in enumerate(files):
            full_path = os.path.join(source_folder, file)
            try:
                # log(f"\n处理文件 {idx+1}/{total_files}: {file}\nProcessing file {idx+1}/{total_files}: {file}")
                wb = load_workbook(full_path, data_only=True)
                # log(f"工作表: {', '.join(wb.sheetnames)}\nWorksheets: {', '.join(wb.sheetnames)}")
                for sheetname in wb.sheetnames:
                    ws = wb[sheetname]
                    if ws.sheet_state != "visible":
                        continue  # 跳過隱藏工作表不 log，不顯示任何訊息
                    outlet_short = file.split('_')[0].strip() if '_' in file else file.split('.')[0].strip()
                    # log(f"  工作表: {sheetname}, 文件名分店简称: '{outlet_short}'\n  Sheet: {sheetname}, Short Name (from filename): '{outlet_short}'")
                    has_order = False
                    week_days = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']
                    for row in range(1, ws.max_row):
                        row_vals = [str(ws.cell(row=row, column=col).value).strip() if ws.cell(row=row, column=col).value else '' for col in range(6, 13)]
                        weekday_count = sum(day in row_vals for day in week_days)
                        if 'Mon' in row_vals and weekday_count >= 3:
                            date_row = row + 1
                            date_cols = []
                            for idx2, col in enumerate(range(6, 13)):
                                val = ws.cell(row=date_row, column=col).value
                                parsed = None
                                try:
                                    if val:
                                        sval = str(val)
                                        if re.match(r"^\d{1,2}-[A-Za-z]{3,}$", sval):
                                            year = start_of_period.year
                                            sval = f"{sval}-{year}"
                                        if isinstance(val, (int, float)):
                                            base_date = datetime(1899, 12, 30)
                                            parsed = base_date + timedelta(days=val)
                                        else:
                                            parsed = parse(sval, fuzzy=True, dayfirst=False)
                                except Exception:
                                    pass
                                if parsed and start_of_period.date() <= parsed.date() <= end_of_period.date():
                                    date_cols.append(col)
                            if date_cols:
                                for r in range(date_row+1, min(date_row+30, ws.max_row+1)):
                                    found_order_this_row = False
                                    for c in date_cols:
                                        val = ws.cell(row=r, column=c).value
                                        if isinstance(val, (datetime,)):
                                            if val.date() > end_of_period.date():
                                                found_order_this_row = True
                                                break
                                        elif isinstance(val, (int, float)) and val > 0:
                                            has_order = True
                                            found_order_this_row = True
                                            break
                                    if found_order_this_row:
                                        break
                            if has_order:
                                break
                    if has_order:
                        # 只記錄有訂單的廠商與分店，不記錄細節
                        supplier_to_outlets[sheetname].append((outlet_short, full_path, sheetname))
            except Exception as e:
                error_msg = f"❌ 处理文件出错: {file}\n❌ Error processing {file}: {str(e)}\n{traceback.format_exc()}"
                log(error_msg)
        
        log("\n📊 下週訂單整合結果 / Next Week Order Integration Results:")
        for supplier, outlets in supplier_to_outlets.items():
            outlet_list = [str(o[0]) if o[0] else "UNKNOWN" for o in outlets]
            log(f"  📦 {supplier}: {', '.join(outlet_list)}")
        log(f"\n🎯 只處理下週訂單，共 {sum(len(outlets) for outlets in supplier_to_outlets.values())} 個門市有訂單")
        log("\nCreating supplier files...")
        supplier_files = []
        import xlwings as xw
        for sheetname, outlet_file_pairs in supplier_to_outlets.items():
            supplier_path = os.path.join(supplier_folder, f"{sheetname}_Week_{now.isocalendar()[1]}.xlsx")
            # 先建立空檔案
            if not os.path.exists(supplier_path):
                from openpyxl import Workbook
                wb = Workbook()
                wb.save(supplier_path)
            app = xw.App(visible=False)
            try:
                wb_dest = app.books.open(supplier_path)
                for outlet, src_file, original_sheet in outlet_file_pairs:
                    try:
                        wb_src = app.books.open(src_file)
                        sht = wb_src.sheets[original_sheet]
                        dest_sheet_name = outlet if outlet else original_sheet
                        # 刪除同名分頁
                        for s in wb_dest.sheets:
                            if s.name == dest_sheet_name:
                                s.delete()
                        sht.api.Copy(Before=wb_dest.sheets[0].api)
                        wb_dest.sheets[0].name = dest_sheet_name
                        wb_src.close()
                        log(f"  ✅ {dest_sheet_name} 已複製進 {os.path.basename(supplier_path)}（格式/公式完整保留）")
                    except Exception as e:
                        log(f"    ❌ Failed to copy {outlet} in {sheetname}: {str(e)}\n{traceback.format_exc()}")
                wb_dest.save()
                wb_dest.close()
                supplier_files.append(os.path.basename(supplier_path))
            finally:
                app.quit()
        result_text = "\n🎯 下週訂單整合完成 / Next Week Order Integration Complete:\n"
        result_text += f"📦 已處理供應商文件: {len(supplier_files)}\n"
        result_text += f"📅 目標週期: {start_of_period.strftime('%Y-%m-%d')} 到 {end_of_period.strftime('%Y-%m-%d')}\n\n"
        result_text += "📋 供應商文件列表:\n" + "\n".join([f"  ✅ {file}" for file in supplier_files])
        log(result_text)
        try:
            with open(save_path, "w", encoding="utf-8") as logfile:
                logfile.writelines(log_lines)
            log(f"\nLog saved at: {save_path}")
            return True, f"订单整合完成！\n\n日志文件保存至:\n{save_path}\n\n{result_text}"
        except Exception as e:
            log(f"❌ Failed to write log file: {e}")
            return False, f"订单整合完成但日志保存失败:\n{str(e)}"

# ========== 增强版订单检查器 ==========
class EnhancedOrderChecker:
    """使用配置文件的订单检查器"""
    
    def __init__(self, config_manager=None):
        self.config_manager = config_manager
        # 新增：建立 full name/short name/email name normalize 映射到 short name
        self.fullname_to_short = {}
        if config_manager and hasattr(config_manager, 'config_path'):
            import pandas as pd
            import os
            config_path = config_manager.config_path if hasattr(config_manager, 'config_path') else None
            if config_path and os.path.exists(config_path):
                try:
                    df = pd.read_excel(config_path, sheet_name=None)
                    outlet_df = None
                    for key in df.keys():
                        if key.strip().lower() == "outlet":
                            outlet_df = df[key]
                            break
                    if outlet_df is not None:
                        for _, row in outlet_df.iterrows():
                            short = str(row.get("Short Name", "")).strip()
                            full = str(row.get("Outlet Full Name", "")).strip()
                            email_name = str(row.get("Name in Email", "")).strip()
                            for n in [short, full, email_name]:
                                n_norm = self._normalize(n)
                                if n and n_norm:
                                    self.fullname_to_short[n_norm] = short
                except Exception as e:
                    print("[EnhancedOrderChecker] Outlet mapping read error:", e)

    @staticmethod
    def _normalize(text):
        """标准化文本"""
        import re
        if not text:
            return ""
        # 只去除空格，保留括号内容以区分不同供应商
        return re.sub(r'[\s]', '', str(text).lower())

    def get_outlet_shortname(self, f5_value):
        """智能获取分店简称，优先用 config mapping"""
        import re
        
        if not f5_value or not isinstance(f5_value, str):
            return f"[EMPTY] {f5_value}"
        
        # 先嘗試完整匹配
        n = self._normalize(f5_value)
        if n in self.fullname_to_short:
            return self.fullname_to_short[n]
        
        # 處理包含配送日期資訊的 F5 值
        # 例如: "Sushi Express West Mall (MON,WED,FRI,SAT)" -> "Sushi Express West Mall"
        # 但保留包含門市代碼的括號，如 "Sushi Takeout CityVibe (GTM)"
        delivery_pattern = r'\s*\([A-Z]{2,4},[A-Z]{2,4},[A-Z]{2,4},[A-Z]{2,4}\)\s*$'
        cleaned_f5 = re.sub(delivery_pattern, '', f5_value.strip())
        
        if cleaned_f5 != f5_value:
            n = self._normalize(cleaned_f5)
            if n in self.fullname_to_short:
                return self.fullname_to_short[n]
        
        # fallback: 原有 hardcode/正则逻辑（可选）
        # ... existing code ...
        return f"[UNKNOWN] {f5_value}"

    def run_checklist(self, folder, log_callback=None, as_table=False):
        date_validator = None
        if self.config_manager:
            delivery_schedules = self.config_manager.delivery_schedule
            if delivery_schedules:
                date_validator = DeliveryDateValidator()
                date_validator.schedule = defaultdict(dict)
                for row in delivery_schedules:
                    supplier = row['supplier']
                    outlet = row['outlet_code']
                    days = DeliveryDateValidator().parse_delivery_days(row['delivery_days'])
                    if outlet == "ALL":
                        date_validator.schedule[supplier]['*'] = days
                    else:
                        date_validator.schedule[supplier][outlet] = days
        supplier_keywords = {}
        if self.config_manager:
            for supplier in self.config_manager.suppliers:
                supplier_keywords[supplier["name"]] = [supplier["name"].lower()]
        must_have_outlets = {}
        if self.config_manager:
            for supplier in self.config_manager.suppliers:
                must_have_outlets[supplier["name"]] = self.config_manager.get_required_outlets(supplier["name"])
        try:
            files = [f for f in os.listdir(folder) if f.endswith(".xlsx") and not f.startswith("~$")]
            def file_key(f):
                import re
                base = f.split("_Week_")[0]
                return self._normalize(base)
            normalized_files = {file_key(f): f for f in files}
            output = []
            table = []
            for supplier, keywords in supplier_keywords.items():
                matches = self._find_supplier_file(normalized_files, keywords)
                if not matches:
                    if as_table:
                        table.append({
                            "supplier": supplier,
                            "outlet": "-",
                            "cover_status": "❌",
                            "remark": "Supplier file not found"
                        })
                    else:
                        output.append(f"\n❌ {supplier} - Supplier file not found.")
                    continue
                for match in matches:
                    result, table_rows = self._process_supplier_file(
                        folder, match, must_have_outlets[supplier], 
                        date_validator, log_callback, as_table=True, supplier=supplier
                    )
                if as_table:
                    table.extend(table_rows)
                else:
                    output.extend(result)
            if as_table:
                return table
            return "\n".join(output)
        except Exception as e:
            if as_table:
                return [{"supplier": "-", "outlet": "-", "cover_status": "❌", "remark": f"Error: {str(e)}"}]
            return f"❌ Error running checklist: {str(e)}\n{traceback.format_exc()}"

    @classmethod
    def _find_supplier_file(cls, normalized_files, keywords):
        matches = []
        for k in keywords:
            nk = cls._normalize(k)
            for nf, of in normalized_files.items():
                if nf == nk:
                    matches.append(of)
        if matches:
            return matches
        # 不再做唯一模糊匹配，避免误配
        return None

    def _process_supplier_file(self, folder, filename, required_outlets, date_validator=None, log_callback=None, as_table=False, supplier=None):
        import os
        from openpyxl import load_workbook
        import tkinter.messagebox as messagebox
        output = []
        table = []
        found = set()
        unidentified = []
        date_errors = []
        unknown_f5 = set()
        try:
            wb = load_workbook(os.path.join(folder, filename), data_only=True)
            for s in wb.sheetnames:
                # 跳过 sheet 名为 'Sheet' 或空白的 sheet
                if not s.strip() or s.strip().lower() == 'sheet':
                    continue
                try:
                    f5 = wb[s]["F5"].value
                    code = self.get_outlet_shortname(f5)
                    sheet_name = s.strip().upper()
                    short_name_mismatch = False
                    
                    # 處理特殊情況：如果 F5 映射結果與工作表名稱不同，但都指向同一個門市
                    # 例如：F5→BUGIS, Sheet→BJ，但都指向 SushiPlus Bugis
                    if code != sheet_name and "[UNKNOWN]" not in code and "[EMPTY]" not in code:
                        # 檢查是否都映射到同一個門市
                        f5_normalized = self._normalize(f5) if f5 else ""
                        sheet_normalized = self._normalize(sheet_name)
                        
                        # 如果 F5 映射和工作表名稱都指向同一個門市，則不視為 mismatch
                        if f5_normalized in self.fullname_to_short and sheet_normalized in self.fullname_to_short:
                            if self.fullname_to_short[f5_normalized] == self.fullname_to_short[sheet_normalized]:
                                short_name_mismatch = False
                            else:
                                short_name_mismatch = True
                        else:
                            short_name_mismatch = True
                    if "[UNKNOWN]" in code or "[EMPTY]" in code:
                        unidentified.append((s, f5))
                        unknown_f5.add(str(f5).strip() if f5 else "[空白]")
                        if as_table:
                            table.append({
                                "supplier": supplier,
                                "outlet": s,
                                "cover_status": "⚠️",
                                "remark": f"F5 error: {f5}" + (f"; Short name mismatch: F5→{code}, Sheet→{sheet_name}" if short_name_mismatch else "")
                            })
                    else:
                        found.add(code)
                        date_status = "-"
                        remark = ""
                        if date_validator:
                            delivery_date = wb[s]['F8'].value if 'F8' in wb[s] else None
                            if delivery_date:
                                is_valid = date_validator.validate_order(
                                    supplier,
                                    code,
                                    delivery_date,
                                    log_callback
                                )
                                if not is_valid:
                                    date_status = "❌"
                                    remark = "Invalid delivery date"
                                    date_errors.append(code)
                                else:
                                    date_status = "✔️"
                            else:
                                date_status = "⚠️"
                                remark = ""
                        if short_name_mismatch:
                            if remark:
                                remark += "; "
                            remark += f"Short name mismatch: F5→{code}, Sheet→{sheet_name}"
                        if as_table:
                            table.append({
                                "supplier": supplier,
                                "outlet": code,
                                "cover_status": "✔️",
                                "remark": remark
                            })
                except Exception as e:
                    unidentified.append((s, f"[F5 error: {e}]") )
                    if as_table:
                        table.append({
                            "supplier": supplier,
                            "outlet": s,
                            "cover_status": "⚠️",
                            "remark": f"F5 error: {e} (sheet: {s}, file: {filename})"
                        })
            required = set([str(x).strip().upper() for x in required_outlets])
            found = set([str(x).strip().upper() for x in found])
            print(f"[DEBUG] supplier={supplier}")
            print(f"[DEBUG] required={required}")
            print(f"[DEBUG] found={found}")
            print(f"[DEBUG] missing={required - found}")
            print(f"[DEBUG] all sheet names in {filename}: {wb.sheetnames}")
            print(f"[DEBUG] unidentified sheets: {unidentified}")
            print(f"[DEBUG] unknown F5 values: {unknown_f5}")
            print(f"[DEBUG] F5 to code mappings:")
            for s in wb.sheetnames:
                if not s.strip() or s.strip().lower() == 'sheet':
                    continue
                try:
                    f5 = wb[s]["F5"].value
                    code = self.get_outlet_shortname(f5)
                    print(f"  Sheet: {s}, F5: {f5}, Code: {code}")
                except Exception as e:
                    print(f"  Sheet: {s}, F5 Error: {e}")
            
            # 檢查 missing outlet 是否有對應的 sheet 但 F5 和 sheet name 不一致
            missing_with_sheet_mismatch = set()
            for sheet_name in wb.sheetnames:
                if not sheet_name.strip() or sheet_name.strip().lower() == 'sheet':
                    continue
                sheet_name_upper = sheet_name.strip().upper()
                if sheet_name_upper in required and sheet_name_upper not in found:
                    try:
                        f5 = wb[sheet_name]["F5"].value
                        code = self.get_outlet_shortname(f5)
                        if code != sheet_name_upper and "[UNKNOWN]" not in code and "[EMPTY]" not in code:
                            missing_with_sheet_mismatch.add(sheet_name_upper)
                    except:
                        pass
            
            for o in sorted(required - found):
                if as_table:
                    if o in missing_with_sheet_mismatch:
                        # 有 sheet 但 F5 和 sheet name 不一致
                        table.append({
                            "supplier": supplier,
                            "outlet": o,
                            "cover_status": "⚠️",
                            "remark": f"Short name mismatch: Sheet→{o}"
                        })
                    else:
                        # 真正的 missing outlet
                        table.append({
                            "supplier": supplier,
                            "outlet": o,
                            "cover_status": "❌",
                            "remark": "Missing outlet"
                        })
            if as_table:
                # 检查结束后，弹窗提醒所有未能 mapping 的 F5 内容
                if unknown_f5:
                    msg = "以下 F5 内容未能自动 mapping 到 short name，请补充到 config 的 OUTLET sheet：\n" + "\n".join(f"- {f5val}" for f5val in sorted(unknown_f5))
                    try:
                        messagebox.showwarning("智能提示/Smart Reminder", msg)
                    except Exception:
                        print("[智能提示]", msg)
                return output, table
            # 原本文字报表
            output.append(f"\n=== {filename} ===")
            output.append(f"📊 Required: {len(required)}, Found: {len(found)}, Missing: {len(required - found)}")
            for o in sorted(required & found):
                output.append(f"✔️ {o}")
            for o in sorted(required - found):
                output.append(f"❌ {o}")
            for s, v in unidentified:
                output.append(f"⚠️ {s} => {v}")
            if unknown_f5:
                output.append("[智能提示] 以下 F5 内容未能自动 mapping 到 short name，请补充到 config 的 OUTLET sheet：")
                for f5val in sorted(unknown_f5):
                    output.append(f"  - {f5val}")
            return output, table
        except Exception as e:
            if as_table:
                return [{"supplier": "-", "outlet": "-", "cover_status": "❌", "remark": f"Error: {str(e)}"}]
            return f"❌ Error running checklist: {str(e)}\n{traceback.format_exc()}"

# ========== 增强版订单自动化 ==========
class EnhancedOrderAutomation(OrderAutomation):
    """支持邮件发送的订单自动化"""
    
    def __init__(self, config_manager=None):
        super().__init__()
        self.config_manager = config_manager
        self.email_sender = EmailSender(config_manager)
    
    def run_automation(self, source_folder, supplier_folder, 
                      log_callback=None, mapping_callback=None, 
                      email_callback=None):
        """运行自动化流程（仅 supplier 整合）"""
        success, result = super().run_automation(
            source_folder, supplier_folder, 
            log_callback=log_callback, mapping_callback=mapping_callback
        )
        if not success:
            return success, result
        supplier_files = []
        for file in os.listdir(supplier_folder):
            if file.endswith(".xlsx") and "Week" in file:
                supplier_name = file.split("_")[0]
                supplier_files.append({
                    "path": os.path.join(supplier_folder, file),
                    "supplier": supplier_name
                })
        if self.config_manager and email_callback:
            email_callback(supplier_files)
        return success, result

class YellowHighlightedOrderAutomation(OrderAutomation):
    """只整合有黃色標記的訂單"""
    
    def __init__(self, config_manager=None):
        super().__init__()
        self.config_manager = config_manager
    
    def has_yellow_highlight(self, ws, row, col):
        """檢查指定單元格是否有黃色標記"""
        try:
            cell = ws.cell(row=row, column=col)
            if cell.fill.start_color.rgb:
                fill_color = cell.fill.start_color.rgb
                print(f"[DEBUG] Cell ({row}, {col}) RGB: {fill_color}")
                
                # 檢查常見的黃色 RGB 值
                yellow_rgbs = ['FFFF00', 'FFFFFF00', 'FF00FF00', 'FFD966', 'FFF200', 'FFEB9C', 'FFE066', 'FFD700', 'FFE135', 'FFD800', 'FFE100']
                if fill_color in yellow_rgbs:
                    print(f"[DEBUG] ✅ 找到標準黃色: {fill_color}")
                    return True
                
                # 更寬鬆的黃色檢查：R 和 G 都很高，B 很低
                if fill_color.startswith('FF') and len(fill_color) == 8:
                    rgb = fill_color[2:]  # 去掉 alpha 通道
                    r = int(rgb[0:2], 16)
                    g = int(rgb[2:4], 16)
                    b = int(rgb[4:6], 16)
                    
                    # 黃色條件：R 和 G 都 > 240，B < 50
                    if r > 240 and g > 240 and b < 50:
                        print(f"[DEBUG] ✅ 找到寬鬆黃色: R={r}, G={g}, B={b}")
                        return True
                    
                    # 更寬鬆的條件：R 和 G 都 > 200，B < 100
                    if r > 200 and g > 200 and b < 100:
                        print(f"[DEBUG] ✅ 找到非常寬鬆黃色: R={r}, G={g}, B={b}")
                        return True
                
                print(f"[DEBUG] ❌ 不是黃色: {fill_color}")
            else:
                print(f"[DEBUG] Cell ({row}, {col}) 沒有填色")
            return False
        except Exception as e:
            print(f"[DEBUG] Error checking yellow highlight: {e}")
            return False
    
    def check_file_has_yellow_highlight(self, filepath, this_week_start, this_week_end):
        """檢查檔案是否有黃色標記的單元格"""
        try:
            print(f"[DEBUG] 開始檢查檔案: {filepath}")
            wb = openpyxl.load_workbook(filepath, data_only=True)
            for sheet_name in wb.sheetnames:
                ws = wb[sheet_name]
                print(f"[DEBUG] 檢查工作表: {sheet_name}")
                
                # 尋找日期行 - 使用本週日期範圍
                date_row_result = self.find_delivery_date_row(ws, this_week_start, this_week_end, file_path=filepath)
                if date_row_result is None or date_row_result[0] is None:
                    print(f"[DEBUG] 在工作表 {sheet_name} 中找不到日期行")
                    continue
                
                date_row = date_row_result[0]  # 取得行號
                print(f"[DEBUG] 找到日期行: {date_row}")
                
                # 檢查日期行下方的數量單元格是否有黃色標記
                for row in range(date_row + 1, min(date_row + 50, ws.max_row + 1)):
                    # 檢查是否為產品行（通常有產品名稱）- 使用 E 欄與 find_delivery_date_row 一致
                    product_name = ws.cell(row=row, column=5).value  # E 欄產品名稱
                    if not product_name or str(product_name).strip() == "":
                        continue
                    
                    print(f"[DEBUG] 檢查產品行: {row}, 產品: {product_name}")
                    
                    # 檢查日期欄位（通常是 F 到 L 欄）
                    for col in range(6, 13):  # F 到 L 欄
                        cell_value = ws.cell(row=row, column=col).value
                        if cell_value and (isinstance(cell_value, (int, float)) or 
                                         (isinstance(cell_value, str) and cell_value.replace('.', '').isdigit())):
                            print(f"[DEBUG] 檢查數量格: ({row}, {col}), 值: {cell_value}")
                            # 如果數量不為0且有黃色標記
                            if self.has_yellow_highlight(ws, row, col):
                                print(f"[DEBUG] ✅ 在檔案 {filepath} 中找到黃色標記!")
                                wb.close()
                                return True
            wb.close()
            print(f"[DEBUG] ❌ 在檔案 {filepath} 中沒有找到黃色標記")
            return False
        except Exception as e:
            print(f"[DEBUG] Error checking yellow highlight in {filepath}: {e}")
            return False
    
    def run_automation(self, source_folder, supplier_folder, log_callback=None, mapping_callback=None):
        from datetime import datetime, timedelta
        import os
        import openpyxl
        import xlwings as xw
        import traceback

        now = datetime.now()
        today = now.date()
        this_monday = today - timedelta(days=today.weekday())
        this_sunday = this_monday + timedelta(days=6)
        start_of_period = datetime.combine(this_monday, datetime.min.time())
        end_of_period = datetime.combine(this_sunday, datetime.max.time())
        save_path = os.path.join(source_folder, f"yellow_highlight_order_log_{now.strftime('%Y%m%d_%H%M%S')}.txt")
        log_lines = [
            f"🎯 Amendment Order Integration Log\n",
            f"Scan Start Time: {now}\n",
            f"Target Week: {start_of_period.date()} to {end_of_period.date()}\n"
        ]

        def log(message, include_timestamp=True):
            timestamp = datetime.now().strftime("%H:%M:%S") if include_timestamp else ""
            log_line = f"[{timestamp}] {message}" if include_timestamp else message
            log_lines.append(log_line + "\n")
            if log_callback:
                log_callback(log_line + "\n")

        files = [f for f in os.listdir(source_folder) if f.endswith((".xlsx", ".xls")) and not f.startswith("~$")]
        total_files = len(files)
        if total_files == 0:
            log("未找到Excel文件\nNo Excel files found in source folder. Exiting.")
            return False, "在源文件夹中未找到Excel文件"
        log(f"找到 {total_files} 个Excel文件\nFound {total_files} Excel files")
        log(f"目标周期: {start_of_period.strftime('%Y-%m-%d')} 到 {end_of_period.strftime('%Y-%m-%d')}")
        log(f"🔍 專注於本週訂單，忽略其他週期")

        # 1. 找出所有有黃色標記的 (門市, 廠商) sheet
        supplier_to_outlets = {}  # supplier: set(outlet)
        for filename in files:
            filepath = os.path.join(source_folder, filename)
            try:
                wb = openpyxl.load_workbook(filepath, data_only=True)
                for sheetname in wb.sheetnames:
                    ws = wb[sheetname]
                    # 跳過隱藏 sheet
                    if hasattr(ws, 'sheet_state') and ws.sheet_state != "visible":
                        continue
                    found_yellow = False
                    for row in ws.iter_rows():
                        for cell in row:
                            fill = cell.fill
                            if fill and fill.fgColor and hasattr(fill.fgColor, 'rgb'):
                                rgb = fill.fgColor.rgb
                                if isinstance(rgb, str) and (rgb.upper() == 'FFFFFF00' or rgb.upper() == 'FFFF00'):
                                    found_yellow = True
                                    break
                        if found_yellow:
                            break
                    if found_yellow:
                        supplier_to_outlets.setdefault(sheetname, set()).add(filepath)
                        log(f"✅ {filename} 發現黃色標記: {sheetname}")
                wb.close()
            except Exception as e:
                log(f"❌ 檢查 {filename} 發生錯誤: {e}")
        log("")
        log(f"📊 統計結果:")
        log(f"   - 總檔案數: {len(files)}")
        log(f"   - 有黃色標記的廠商: {len(supplier_to_outlets)}")
        log("")
        if not supplier_to_outlets:
            log("❌ 沒有找到任何有黃色標記的廠商")
            return False, "沒有找到任何有黃色標記的廠商"
        log(f"📋 準備整合以下廠商:")
        for supplier in supplier_to_outlets:
            log(f"   - {supplier}")
        log("")
        # 2. 以廠商為單位合併所有有黃色標記的門市的該廠商 sheet（用 xlwings 複製 sheet，保留格式/公式）
        supplier_files = []
        for supplier, filelist in supplier_to_outlets.items():
            try:
                supplier_path = os.path.join(supplier_folder, f"{supplier}_Amendment_{now.isocalendar()[1]}.xlsx")
                # 先建立空檔案
                if not os.path.exists(supplier_path):
                    from openpyxl import Workbook
                    wb = Workbook()
                    wb.save(supplier_path)
                app = xw.App(visible=False)
                try:
                    wb_dest = app.books.open(supplier_path)
                    for src_file in filelist:
                        try:
                            wb_src = app.books.open(src_file)
                            if supplier in [sht.name for sht in wb_src.sheets]:
                                sht = wb_src.sheets[supplier]
                                dest_sheet_name = os.path.splitext(os.path.basename(src_file))[0]
                                # 刪除同名分頁
                                for s in wb_dest.sheets:
                                    if s.name == dest_sheet_name:
                                        s.delete()
                                sht.api.Copy(Before=wb_dest.sheets[0].api)
                                wb_dest.sheets[0].name = dest_sheet_name
                            wb_src.close()
                        except Exception as e:
                            log(f"    ❌ Failed to copy {supplier} in {os.path.basename(src_file)}: {str(e)}\n{traceback.format_exc()}")
                    wb_dest.save()
                    wb_dest.close()
                    supplier_files.append(os.path.basename(supplier_path))
                    log(f"  ✅ 已整合: {os.path.basename(supplier_path)}")
                finally:
                    app.quit()
            except Exception as e:
                log(f"❌ 整合 {supplier} 發生錯誤: {e}\n{traceback.format_exc()}")
        result_text = f"\n🎯 本週訂單整合完成 / Amendment Order Integration Complete:\n"
        result_text += f"📦 已處理供應商文件: {len(supplier_files)}\n"
        result_text += f"📅 目標週期: {this_monday.strftime('%Y-%m-%d')} 到 {this_sunday.strftime('%Y-%m-%d')}\n\n"
        result_text += "📋 供應商文件列表:\n" + "\n".join([f"  ✅ {file}" for file in supplier_files])
        log(result_text)
        try:
            with open(save_path, "w", encoding="utf-8") as logfile:
                logfile.writelines(log_lines)
            log(f"\nLog saved at: {save_path}")
            return True, f"Amendment Order 整合完成！\n\n日志文件保存至:\n{save_path}\n\n{result_text}"
        except Exception as e:
            log(f"❌ Failed to write log file: {e}")
            return False, f"Amendment Order 整合完成但日志保存失败:\n{str(e)}"

# ========== 主应用程序 ==========
class SushiExpressApp(ctk.CTk):
    """主应用程序"""
    
    def __init__(self):
        super().__init__()
        self.title(f"Sushi Express Automation Tool v{VERSION}")
        self.geometry("1400x900")
        self.minsize(1200,800)
        self.configure(fg_color=DARK_BG)
        self.iconbitmap(resource_path("SELOGO22 - 01.ico"))
        self.protocol("WM_DELETE_WINDOW", self._on_close)
        # 初始化所有用到的 StringVar
        self.download_folder_var = ctk.StringVar()
        self.config_file_var = ctk.StringVar()
        self.checklist_folder_var = ctk.StringVar()
        self.master_config_var = ctk.StringVar()
        self.folder_vars = {}
        self.master_file_var = ctk.StringVar()
        self.output_folder_var = ctk.StringVar()
        self.email_supplier_folder_var = ctk.StringVar()
        self.email_master_config_var = ctk.StringVar()
        self.source_folder_var = ctk.StringVar()  # 添加缺失的属性
        self.supplier_folder_var = ctk.StringVar()  # 添加缺失的属性
        self.append_outlet_files_var = ctk.StringVar()  # 添加缺失的属性
        self.append_supplier_folder_var = ctk.StringVar()  # 添加缺失的属性
        self.summary_supplier_files_var = ctk.StringVar()  # 添加缺失的属性
        self.progress_popup = None
        self.mapping_popup = None
        self.outlet_config_var = ctk.StringVar()
        self.email_dialogs = []
        self.current_function = None
        self.nav_buttons = {}
        self.selected_outlook_account_idx = None
        self.checklist_search_var = ctk.StringVar()
        self._setup_ui()
        self.show_login()
    
    def _setup_ui(self):
        self.main_container = ctk.CTkFrame(self, fg_color="transparent")
        self.main_container.pack(fill="both", expand=True, padx=20, pady=20)

        # 左側導航欄
        self.nav_frame = ctk.CTkFrame(
            self.main_container,
            fg_color=DARK_PANEL,
            corner_radius=24,
            width=300
        )
        self.nav_frame.pack(side="left", fill="y", padx=(0, 10), pady=10)
        self.nav_frame.pack_propagate(False)

        # 加入 LOGO
        logo_img = load_image(LOGO_PATH, max_size=(220, 80))
        if logo_img:
            logo_label = ctk.CTkLabel(self.nav_frame, image=logo_img, text="")
            logo_label.image = logo_img  # 防止被垃圾回收
            logo_label.pack(pady=(18, 8))

        nav_title = ctk.CTkLabel(
            self.nav_frame,
            text="功能菜单\nFunction Menu",
            font=FONT_TITLE,
            text_color=ACCENT_BLUE,
            justify="center"
        )
        nav_title.pack(pady=20)
        ctk.CTkFrame(self.nav_frame, height=2, fg_color=ACCENT_BLUE).pack(fill="x", padx=20, pady=10)

        # 按鈕容器
        self.button_container = ctk.CTkFrame(self.nav_frame, fg_color="transparent")
        self.button_container.pack(fill="both", expand=True, padx=10, pady=10)

        # 右側內容區
        self.content_container = ctk.CTkFrame(
            self.main_container,
            fg_color=DARK_PANEL,
            corner_radius=24
        )
        self.content_container.pack(side="right", fill="both", expand=True, padx=10, pady=10)
        self.content_container.pack_propagate(False)

        # 右側內容區的標題區域
        self.content_header = ctk.CTkFrame(self.content_container, fg_color="transparent")
        self.content_header.pack(fill="x", padx=20, pady=20)

        self.function_title = ctk.CTkLabel(
            self.content_header, 
            text="", 
            font=FONT_TITLE,
            text_color=ACCENT_BLUE
        )
        self.function_title.pack(side="left")
        
        self.function_subtitle = ctk.CTkLabel(
            self.content_header, 
            text="", 
            font=FONT_SUB,
            text_color=TEXT_COLOR
        )
        self.function_subtitle.pack(side="left", padx=20)
        
        # 右侧内容区的主体
        self.content_body = ctk.CTkFrame(self.content_container, fg_color="transparent")
        self.content_body.pack(fill="both", expand=True, padx=20, pady=20)
        
        # 添加返回主菜单按钮
        back_frame = ctk.CTkFrame(self.content_container, fg_color="transparent")
        back_frame.pack(fill="x", padx=20, pady=10)
        ctk.CTkButton(
            back_frame, 
            text="返回主菜单\nBack to Main Menu", 
            command=self.show_main_menu,
            fg_color=ACCENT_PURPLE,
            hover_color=BTN_HOVER
        ).pack(side="right")
    
    def _on_close(self):
        print("on_close called")
        self.destroy()
    
    def show_login(self):
        """显示登录界面"""
        for w in self.content_container.winfo_children():
            if w != self.content_header and w != self.content_body:
                w.destroy()
        
        # 清空内容区
        for w in self.content_body.winfo_children():
            w.destroy()
        
        # 创建登录界面
        login_frame = ctk.CTkFrame(
            self.content_body, 
            fg_color=DARK_PANEL, 
            corner_radius=24,
            width=450, 
            height=400
        )
        login_frame.place(relx=0.5, rely=0.5, anchor="center")
        
        self.pwd_entry = ctk.CTkEntry(
            login_frame, 
            show="*", 
            font=FONT_MID,  # 改成較小字體
            width=300, 
            placeholder_text=t("password"), 
            fg_color=ENTRY_BG, 
            height=45
        )
        self.pwd_entry.pack(pady=(40,20))
        self.pwd_entry.bind("<Return>", lambda e: self._try_login())
        
        ctk.CTkButton(
            login_frame, 
            text=t("login_btn"), 
            command=self._try_login, 
            width=200,
            font=FONT_BIGBTN
        ).pack(pady=(0,20))
        
        ctk.CTkLabel(
            login_frame, 
            text=f"Version {VERSION} | {DEVELOPER}", 
            font=FONT_MID,
            text_color="#64748B"
        ).pack(side="bottom", pady=10)
        
        # 设置标题
        self.function_title.configure(text="系统登录\nSystem Login", font=FONT_TITLE)
        self.function_subtitle.configure(text="请输入密码進入系统\nPlease enter password to access the system", font=FONT_MID)
    
    def _try_login(self):
        """尝试登录"""
        if self.pwd_entry.get() == PASSWORD:
            self.show_main_menu()
        else:
            messagebox.showerror(t("error"), t("incorrect_pw"))
    
    def show_main_menu(self):
        # 清空内容区
        for w in self.content_body.winfo_children():
            w.destroy()

        # 设置标题
        self.function_title.configure(text=t("main_title"))
        self.function_subtitle.configure(text=t("select_function"))

        # 创建欢迎界面
        welcome_frame = ctk.CTkFrame(self.content_body, fg_color="transparent")
        welcome_frame.pack(fill="both", expand=True, padx=50, pady=50)

        welcome_text = (
            "欢迎使用Sushi Express 自动化工具\n"
            "Welcome to Sushi Express Automation Tool\n\n"
            "请从左侧菜单选择您需要的功能\n"
            "Please select a function from the left menu"
        )

        ctk.CTkLabel(
            welcome_frame,
            text=welcome_text,
            font=FONT_MID,
            text_color=TEXT_COLOR,
            justify="center"
        ).pack(expand=True)

        # **每次都重建按鈕**
        self._create_navigation_buttons()
    
    def _create_navigation_buttons(self):
        for widget in self.button_container.winfo_children():
            widget.destroy()
        inner_frame = ctk.CTkFrame(self.button_container, fg_color="transparent")
        inner_frame.pack(expand=True)
        functions = [
            ("download_title", self.show_download_ui, ACCENT_BLUE),
            ("automation_title", self.show_automation_ui, ACCENT_GREEN),
            ("checklist_title", self.show_checklist_ui, ACCENT_PURPLE),
            ("send_emails", self.show_email_sending_ui, ACCENT_RED),
            ("operation_supplies", self.show_operation_supplies_ui, "#F97316"),
            ("exit_system", self._on_close, "#64748B")
        ]
        for func_key, command, color in functions:
            btn = NavigationButton(
                inner_frame,
                text=t(func_key),
                command=command if func_key == "exit_system" else lambda c=command, k=func_key: self._select_function(c, k),
                fg_color=DARK_PANEL,
                anchor="center",
                border_width=2,
                border_color=ACCENT_BLUE,
                corner_radius=10,
                font=FONT_BIGBTN,
                text_color=get_contrast_color(DARK_PANEL),
                height=50
            )
            btn.pack(fill="x", pady=7, padx=10)
            self.nav_buttons[func_key] = btn
        # 新增：用戶指南按鈕
        help_btn = NavigationButton(
            inner_frame,
            text="用户指南\nUser Guide",
            command=self.show_user_guide,
            fg_color=ACCENT_PURPLE,
            anchor="center",
            border_width=2,
            border_color=ACCENT_PURPLE,
            corner_radius=10,
            font=FONT_BIGBTN,
            text_color=get_contrast_color(ACCENT_PURPLE),
            height=50
        )
        help_btn.pack(fill="x", pady=7, padx=10)
    
    def _select_function(self, command, func_key):
        """选择功能"""
        # 取消之前选中的按钮
        if self.current_function:
            self.nav_buttons[self.current_function].deselect()
        
        # 选中当前按钮
        self.nav_buttons[func_key].select()
        self.current_function = func_key
        
        # 执行功能
        command()
    
    def _show_function_ui(self, title_key, subtitle_key, content_callback):
        """显示功能界面"""
        # 清空内容区
        for w in self.content_body.winfo_children():
            w.destroy()
        
        # 设置标题
        self.function_title.configure(text=t(title_key))
        # 副標題統一放大
        if isinstance(subtitle_key, tuple):
            text = subtitle_key[0]
        else:
            text = t(subtitle_key)
        self.function_subtitle.configure(text=text, font=FONT_TITLE)
        
        # 创建内容框架
        content_frame = ctk.CTkFrame(self.content_body, fg_color="transparent")
        content_frame.pack(fill="both", expand=True, padx=20, pady=20)
        
        # 构建功能UI
        content_callback(content_frame)
    
    # 下面是各个功能界面的修改，只需要将原来的show_xxx_ui方法改为使用_show_function_ui

    def show_download_ui(self):
        """显示下载界面"""
        def build(c):
            # 创建表单框架
            form_frame = ctk.CTkFrame(c, fg_color="transparent")
            form_frame.pack(fill="both", expand=True, padx=50, pady=20)

            # 下载文件夹
            row1 = ctk.CTkFrame(form_frame)
            row1.pack(fill="x", pady=15)
            ctk.CTkLabel(row1, text="下载文件夹\nDownload Folder:", font=FONT_MID, anchor="w", justify="left").pack(side="left", padx=10)
            ctk.CTkEntry(row1, textvariable=self.download_folder_var, font=FONT_MID, state="readonly", width=400).pack(side="left", expand=True, fill="x", padx=5)
            # 美化的瀏覽按鈕
            browse_btn = ctk.CTkButton(
                row1,
                text="浏览...\nBrowse...",
                font=("Microsoft YaHei", 11, "bold"),
                command=self._select_download_folder,
                corner_radius=8,
                hover_color="#1976d2",
                height=30
            )
            browse_btn.pack(side="left", padx=5)

            # 分店配置文件
            row2 = ctk.CTkFrame(form_frame)
            row2.pack(fill="x", pady=15)
            ctk.CTkLabel(row2, text="分店配置文件（可选）\nOutlet Config (Optional):", font=FONT_MID, anchor="w", justify="left").pack(side="left", padx=10)
            ctk.CTkEntry(row2, textvariable=self.config_file_var, font=FONT_MID, state="readonly", width=400).pack(side="left", expand=True, fill="x", padx=5)
            # 美化的瀏覽按鈕
            browse_btn2 = ctk.CTkButton(
                row2,
                text="浏览...\nBrowse...",
                font=("Microsoft YaHei", 11, "bold"),
                command=self._select_config_file,
                corner_radius=8,
                hover_color="#1976d2",
                height=30
            )
            browse_btn2.pack(side="left", padx=5)

            # 开始下载按钮
            btn_frame = ctk.CTkFrame(c, fg_color="transparent")
            btn_frame.pack(pady=30)

            # 主要下載按鈕
            GlowButton(
                btn_frame,
                text="開始下載\nStart Download",
                command=self._run_download,
                glow_color=ACCENT_BLUE
            ).pack(fill="x", expand=True, padx=10, pady=5)

            # Amendment 下載按鈕
            GlowButton(
                btn_frame,
                text="下載 Amendment\nDownload Amendments",
                command=self._run_download_amendments,
                glow_color="#ef4444"
            ).pack(fill="x", expand=True, padx=10, pady=5)

            # 查看邮件内容按钮
            def show_extracted_bodies():
                from tkinter import messagebox
                import os
                import tkinter as tk
                folder = self.download_folder_var.get()
                week_no = datetime.now().isocalendar()[1]
                save_path = os.path.join(folder, f"Week_{week_no}")
                log_file = os.path.join(save_path, "email_bodies_log.txt")
                bodies = getattr(OutlookDownloader, 'extracted_bodies', [])
                if not bodies and os.path.exists(log_file):
                    with open(log_file, "r", encoding="utf-8") as f:
                        content = f.read()
                    bodies = content.split("\n\n——— 邮件 ") if content else []
                    if bodies and not bodies[0].startswith("——— 邮件 "):
                        bodies[0] = "——— 邮件 1 ———\n" + bodies[0]
                    bodies = [b if b.startswith("——— 邮件 ") else "——— 邮件 " + b for b in bodies]
                if not bodies:
                    messagebox.showinfo("无内容", "请先下载邮件，再查看邮件内容！")
                    return
                # 创建显示窗口
                win = tk.Toplevel(self)
                win.title("邮件内容提取结果/Extracted Email Bodies")
                win.geometry("900x700")
                from tkinter import scrolledtext
                text_widget = scrolledtext.ScrolledText(win, wrap="word", font=("Microsoft JhengHei", 14), bg="#f1f5f9", fg="#22292f")
                text_widget.pack(fill="both", expand=True, padx=10, pady=10)
                content = "\n\n".join(bodies)
                text_widget.insert("1.0", content)
                text_widget.configure(state="disabled")

            GlowButton(
                btn_frame,
                text="查看邮件内容\nCheck Email Bodies",
                command=show_extracted_bodies,
                width=300,
                height=48,
                glow_color=ACCENT_GREEN
            ).pack(pady=10)

        self._show_function_ui(
            "download_title",
            "download_desc",
            build
        )

    def show_checklist_ui(self):
        """显示检查表界面"""
        def build(c):
            self.checklist_folder_var = ctk.StringVar()
            self.master_config_var = ctk.StringVar()
            # 创建表单框架
            form_frame = ctk.CTkFrame(c, fg_color="transparent")
            form_frame.pack(fill="both", expand=True, padx=50, pady=5)
            # 订单文件夹
            row1 = ctk.CTkFrame(form_frame)
            row1.pack(fill="x", pady=5)
            ctk.CTkLabel(row1, text="訂單文件夾\nOrder Folder:", font=FONT_BIGBTN).pack(side="left", padx=10)
            ctk.CTkEntry(row1, textvariable=self.checklist_folder_var, font=FONT_MID, state="readonly", width=250).pack(side="left", expand=True, fill="x", padx=5)
            checklist_browse_btn = ctk.CTkButton(
                row1, 
                text=str(t("browse")), 
                font=("Microsoft YaHei", 11, "bold"),
                command=self._select_checklist_folder,
                corner_radius=8,
                hover_color="#1976d2",
                height=30
            )
            checklist_browse_btn.pack(side="left", padx=5)
            # 统一配置文件
            row3 = ctk.CTkFrame(form_frame)
            row3.pack(fill="x", pady=5)
            ctk.CTkLabel(row3, text="統一配置文件\nMaster Config (Excel):", font=FONT_BIGBTN).pack(side="left", padx=10)
            ctk.CTkEntry(row3, textvariable=self.master_config_var, font=FONT_MID, state="readonly", width=250).pack(side="left", expand=True, fill="x", padx=5)
            checklist_config_browse_btn = ctk.CTkButton(
                row3, 
                text="瀏覽...\nBrowse...", 
                font=("Microsoft YaHei", 11, "bold"),
                command=lambda: self._select_config_file(self.master_config_var, [("Excel files", "*.xlsx")]),
                corner_radius=8,
                hover_color="#1976d2",
                height=30
            )
            checklist_config_browse_btn.pack(side="left", padx=5)
            # 搜索區（永遠顯示）
            search_frame = ctk.CTkFrame(c, fg_color="transparent")
            search_frame.pack(fill="x", pady=5)
            # 移除搜尋範圍下拉選單
            # if not hasattr(self, 'checklist_search_scope_var'):
            #     self.checklist_search_scope_var = ctk.StringVar(value="全部")
            # scope_options = ["全部", "供應商", "分店"]
            # scope_menu = ctk.CTkOptionMenu(search_frame, variable=self.checklist_search_scope_var, values=scope_options, width=90, font=FONT_MID)
            # scope_menu.pack(side="left", padx=4)
            # Supplier 下拉選單
            if not hasattr(self, 'checklist_supplier_filter_var'):
                self.checklist_supplier_filter_var = ctk.StringVar(value="全部")
            if not hasattr(self, 'checklist_outlet_filter_var'):
                self.checklist_outlet_filter_var = ctk.StringVar(value="全部")
            def get_unique_suppliers():
                return ["全部"] + sorted(list({row["supplier"] for row in getattr(self, '_checklist_table_data', []) if row["supplier"]}))
            def get_unique_outlets():
                return ["全部"] + sorted(list({row["outlet"] for row in getattr(self, '_checklist_table_data', []) if row["outlet"]}))
            ctk.CTkLabel(search_frame, text="Supplier", font=("Microsoft JhengHei", 16, "bold"), text_color="#3b82f6").pack(side="left", padx=(0,2))
            self.supplier_menu = ctk.CTkOptionMenu(
                search_frame, variable=self.checklist_supplier_filter_var, values=get_unique_suppliers(), width=140, font=("Microsoft JhengHei", 15, "bold"),
                fg_color="#3b82f6", button_color="#3b82f6", button_hover_color="#2563eb", text_color="#fff", corner_radius=16,
                command=lambda _: self._filter_checklist_table())
            self.supplier_menu.pack(side="left", padx=4)
            ctk.CTkLabel(search_frame, text="Outlet", font=("Microsoft JhengHei", 16, "bold"), text_color="#3b82f6").pack(side="left", padx=(10,2))
            self.outlet_menu = ctk.CTkOptionMenu(
                search_frame, variable=self.checklist_outlet_filter_var, values=get_unique_outlets(), width=140, font=("Microsoft JhengHei", 15, "bold"),
                fg_color="#3b82f6", button_color="#3b82f6", button_hover_color="#2563eb", text_color="#fff", corner_radius=16,
                command=lambda _: self._filter_checklist_table())
            self.outlet_menu.pack(side="left", padx=4)
            ctk.CTkLabel(search_frame, text="搜索/Filter:", font=("Microsoft JhengHei", 15, "bold"), text_color="#3b82f6").pack(side="left", padx=6)
            if not hasattr(self, 'checklist_search_var'):
                self.checklist_search_var = ctk.StringVar()
            search_entry = ctk.CTkEntry(search_frame, textvariable=self.checklist_search_var, font=("Microsoft JhengHei", 14), width=180, corner_radius=10, border_width=2, border_color="#3b82f6")
            search_entry.pack(side="left", padx=4)
            search_entry.bind("<KeyRelease>", lambda e: self._filter_checklist_table())
            def set_search_keyword(keyword):
                self.checklist_search_var.set(keyword)
                self._filter_checklist_table()
            ctk.CTkButton(
                search_frame, text="Missing", width=90, height=34, font=("Microsoft JhengHei", 15, "bold"),
                fg_color="#2563eb", hover_color="#60a5fa", text_color="#fff", corner_radius=16, border_width=2, border_color="#fff",
                command=lambda: set_search_keyword("missing")
            ).pack(side="left", padx=6)
            ctk.CTkButton(
                search_frame, text="Mismatch", width=100, height=34, font=("Microsoft JhengHei", 15, "bold"),
                fg_color="#f59e42", hover_color="#fbbf24", text_color="#fff", corner_radius=16, border_width=2, border_color="#fff",
                command=lambda: set_search_keyword("mismatch")
            ).pack(side="left", padx=6)
            # 表格區（永遠顯示，沒資料時顯示空表格）
            table_frame = ctk.CTkFrame(c, fg_color="transparent")
            table_frame.pack(fill="both", expand=True, padx=10, pady=10)
            import tkinter.ttk as ttk
            style = ttk.Style()
            style.theme_use('default')
            style.configure("Custom.Treeview", background="#1e293b", fieldbackground="#1e293b", foreground="#e2e8f0", rowheight=28, font=("Microsoft JhengHei", 12))
            style.configure("Custom.Treeview.Heading", background="#334155", foreground="#60a5fa", font=("Microsoft JhengHei", 13, "bold"))
            style.map("Custom.Treeview", background=[('selected', '#334155')])
            if not hasattr(self, 'checklist_table'):
                self.checklist_table = None
            self.checklist_table = ttk.Treeview(
                table_frame, 
                columns=("supplier", "outlet", "cover_status", "remark"), 
                show="headings", 
                height=8,
                style="Custom.Treeview"
            )
            col_labels = [
                ("supplier", "供應商/Supplier"),
                ("outlet", "分店/Outlet"),
                ("cover_status", "覆蓋狀態/Cover"),
                ("remark", "備註/Remark")
            ]
            for col, label in col_labels:
                self.checklist_table.heading(col, text=label)
                self.checklist_table.column(col, width=140 if col!="remark" else 300, anchor="center")
            self.checklist_table.pack(fill="both", expand=True)
            self.checklist_table.bind("<Double-1>", self._on_checklist_row_double_click)
            # 複製/匯出按鈕（永遠顯示）
            btn_frame = ctk.CTkFrame(c, fg_color="transparent")
            btn_frame.pack(pady=10)
            btns = [
                ("匯出Excel\nExport Excel", self._export_checklist_table, "#10b981"),
                ("查看必要門市\nView Required Outlets", self._show_required_outlets_window, "#8b5cf6"),
                ("交叉檢查\nCross Check", self._run_cross_check_email_log, "#f59e42"),
            ]
            for txt, cmd, color in btns:
                GlowButton(
                    btn_frame,
                    text=txt,
                    command=cmd,
                    width=90,
                    height=28,
                    glow_color=color
                ).pack(side="left", padx=4, pady=2)
            for col in range(2):
                btn_frame.grid_columnconfigure(col, weight=1)
            # Run Check 按鈕（大、中文在上英文在下，置中，永遠顯示）
            run_btn_frame = ctk.CTkFrame(c, fg_color="transparent")
            run_btn_frame.pack(fill="x", pady=15)
            GlowButton(
                run_btn_frame,
                text="執行檢查\nRun Check",
                command=self._run_enhanced_checklist,
                width=200,
                height=56,
                glow_color="#a78bfa"
            ).pack(anchor="center")
            # 初始化表格數據
            if not hasattr(self, '_checklist_table_data'):
                self._checklist_table_data = []
            self._refresh_checklist_table()
        
        self._show_function_ui(
            "checklist_title", 
            "checklist_desc", 
            build
        )
    def _run_enhanced_checklist(self):
        folder = self.checklist_folder_var.get()
        master_config = self.master_config_var.get()
        if not folder or not master_config:
            messagebox.showwarning(t("warning"), t("folder_warning"))
            return
        config_mgr = UnifiedConfigManager(master_config)
        checker = EnhancedOrderChecker(config_mgr)
        table = checker.run_checklist(folder, as_table=True)
        self._checklist_table_data = table
        self._refresh_checklist_table()
        # ====== 新增 cross check with email log ======
        import os
        email_log_path = os.path.join(folder, "email_bodies_log.txt")
        if os.path.exists(email_log_path):
            with open(email_log_path, "r", encoding="utf-8") as f:
                content = f.read()
            import re
            # 假設格式：——— 郵件 N ———\n[發件人] ...\n[主題] ...\n[內容]\n 1. Aries\n 2. Changcheng ...
            cross_check_result = []
            for block in content.split("——— 郵件"):
                lines = block.strip().splitlines()
                if not lines or len(lines) < 3:
                    continue
                outlet = lines[1].replace("[發件人]", "").strip() if lines[1].startswith("[發件人]") else ""
                claimed = []
                for line in lines[3:]:
                    m = re.match(r"\d+\.\s*(.+)", line)
                    if m:
                        claimed.append(m.group(1).strip())
                # cross check: 檢查 claimed 是否有出現在 checklist table
                found = set()
                for row in table:
                    if outlet and outlet in row["outlet"] and row["supplier"] in claimed and row["cover_status"] == "✔️":
                        found.add(row["supplier"])
                missed = [s for s in claimed if s not in found]
                if missed:
                    cross_check_result.append(f"[警告] {outlet} 聲稱下單但未整合到: {', '.join(missed)}")
            if cross_check_result:
                messagebox.showwarning("Cross Check Result", "\n".join(cross_check_result))
            else:
                messagebox.showinfo("Cross Check Result", "所有門市聲稱下單的供應商都已整合！")
        else:
            messagebox.showinfo("Cross Check Result", "找不到 email_bodies_log.txt！")
    def _refresh_checklist_table(self):
        # 清空表格
        for row in self.checklist_table.get_children():
            self.checklist_table.delete(row)
        # 插入數據
        for row in self._checklist_table_data:
            values = (row["supplier"], row["outlet"], row["cover_status"], row["remark"])
            self.checklist_table.insert("", "end", values=values)
    def _filter_checklist_table(self):
        keyword = self.checklist_search_var.get().lower()
        scope = getattr(self, 'checklist_search_scope_var', None)
        scope_val = scope.get() if scope else "全部"
        supplier_val = getattr(self, 'checklist_supplier_filter_var', None)
        supplier_selected = supplier_val.get() if supplier_val else "全部"
        outlet_val = getattr(self, 'checklist_outlet_filter_var', None)
        outlet_selected = outlet_val.get() if outlet_val else "全部"
        def normalize(text):
            import re
            return re.sub(r'[^a-zA-Z0-9]', '', str(text)).lower()
        norm_keyword = normalize(keyword)
        def row_match(row):
            # 供應商/門市下拉選單
            if supplier_selected != "全部" and row["supplier"] != supplier_selected:
                return False
            if outlet_selected != "全部" and row["outlet"] != outlet_selected:
                return False
            # 搜尋範圍
            if not norm_keyword:
                return True
            if scope_val == "全部":
                return norm_keyword in normalize(row["supplier"]) or norm_keyword in normalize(row["outlet"]) or norm_keyword in row["cover_status"] or norm_keyword in row["remark"].lower()
            elif scope_val == "供應商":
                return norm_keyword in normalize(row["supplier"])
            elif scope_val == "分店":
                return norm_keyword in normalize(row["outlet"])
            return True
        filtered = [row for row in self._checklist_table_data if row_match(row)]
        for row in self.checklist_table.get_children():
            self.checklist_table.delete(row)
        for row in filtered:
            values = (row["supplier"], row["outlet"], row["cover_status"], row["remark"])
            self.checklist_table.insert("", "end", values=values)
        # 動態刷新下拉選單內容
        if hasattr(self, 'supplier_menu'):
            current = self.checklist_supplier_filter_var.get()
            suppliers = ["全部"] + sorted(list({row["supplier"] for row in self._checklist_table_data if row["supplier"]}))
            self.supplier_menu.configure(values=suppliers)
            if current not in suppliers:
                self.checklist_supplier_filter_var.set("全部")
        if hasattr(self, 'outlet_menu'):
            current = self.checklist_outlet_filter_var.get()
            outlets = ["全部"] + sorted(list({row["outlet"] for row in self._checklist_table_data if row["outlet"]}))
            self.outlet_menu.configure(values=outlets)
            if current not in outlets:
                self.checklist_outlet_filter_var.set("全部")
    def _copy_checklist_table(self):
        import pyperclip
        rows = ["\t".join(["供应商", "分店", "覆蓋狀態", "備註"])]
        for row in self._checklist_table_data:
            rows.append("\t".join([str(row["supplier"]), str(row["outlet"]), str(row["cover_status"]), str(row["remark"])]))
        pyperclip.copy("\n".join(rows))
        messagebox.showinfo("複製成功", "報表已複製到剪貼簿！")
    def _export_checklist_table(self):
        import pandas as pd
        from tkinter import filedialog
        df = pd.DataFrame(self._checklist_table_data)
        file = filedialog.asksaveasfilename(defaultextension=".xlsx", filetypes=[("Excel files", "*.xlsx")])
        if file:
            df.to_excel(file, index=False)
            messagebox.showinfo("匯出成功", f"已匯出到 {file}")
    def _on_checklist_row_double_click(self, event):
        item = self.checklist_table.selection()
        if not item:
            return
        values = self.checklist_table.item(item[0], "values")
        detail = f"供应商: {values[0]}\n分店: {values[1]}\n覆蓋狀態: {values[2]}\n備註: {values[3]}"
        ScrollableMessageBox(self, "详细信息", detail)
    
    def show_automation_ui(self):
        """显示自动化界面"""
        def build(c):
            import os
            import traceback
            from datetime import datetime, timedelta
            import openpyxl
            self.folder_vars = {}
            self.master_config_var = ctk.StringVar()
            # 创建表单框架
            form_frame = ctk.CTkFrame(c, fg_color="transparent")
            form_frame.pack(side="top", fill="x", expand=False, padx=30, pady=10)
            # 只保留一組 Supplier Folder 欄位
            folders = [
                ("source_folder", "來源資料夾\nSource Folder (Weekly Orders)"),
                ("supplier_folder", "供應商文件夾\nSupplier Folder")
            ]
            for key, label in folders:
                row = ctk.CTkFrame(form_frame)
                row.pack(fill="x", pady=8)
                var = ctk.StringVar()
                self.folder_vars[key] = var
                ctk.CTkLabel(row, text=label, font=("Microsoft JhengHei", 12, "bold"), anchor="w", justify="left").pack(side="left", padx=8)
                ctk.CTkEntry(row, textvariable=var, font=FONT_MID, state="readonly", width=400).pack(side="left", expand=True, fill="x", padx=5)
                # 美化的瀏覽按鈕
                automation_browse_btn = ctk.CTkButton(
                    row, 
                    text="瀏覽...\nBrowse...", 
                    font=("Microsoft YaHei", 11, "bold"),
                    command=lambda k=key: self._select_folder(k),
                    corner_radius=8,
                    hover_color="#1976d2",
                    height=30
                )
                automation_browse_btn.pack(side="left", padx=5)
            # 统一配置文件
            row3 = ctk.CTkFrame(form_frame)
            row3.pack(fill="x", pady=8)
            ctk.CTkLabel(row3, text="統一配置文件\nMaster Config (Excel):", font=("Microsoft JhengHei", 12, "bold")).pack(side="left", padx=8)
            ctk.CTkEntry(row3, textvariable=self.master_config_var, font=FONT_MID, state="readonly", width=400).pack(side="left", expand=True, fill="x", padx=5)
            # 美化的瀏覽按鈕
            automation_config_browse_btn = ctk.CTkButton(
                row3, 
                text=t("browse"), 
                font=("Microsoft YaHei", 11, "bold"),
                command=lambda: self._select_config_file(self.master_config_var, [("Excel files", "*.xlsx")]),
                corner_radius=8,
                hover_color="#1976d2",
                height=30
            )
            automation_config_browse_btn.pack(side="left", padx=5)
            # 開始自動化按鈕
            btn_frame = ctk.CTkFrame(form_frame, fg_color="transparent")
            btn_frame.pack(pady=(15, 0))
            
            # 創建水平排列的按鈕容器
            button_row = ctk.CTkFrame(btn_frame, fg_color="transparent")
            button_row.pack(anchor="center")
            
            # 左邊按鈕：Amendment Order 整合改單
            GlowButton(
                button_row, 
                text="整合改單\nAmendment Order",
                command=self._run_yellow_highlighted_automation,
                width=280,
                height=50,
                glow_color="#f59e0b",
                corner_radius=18
            ).pack(side="left", padx=(0, 10))
            
            # 右邊按鈕：Consolidate Order 整合訂單
            GlowButton(
                button_row, 
                text="整合訂單\nConsolidate Order",
                command=self._run_enhanced_automation,
                width=280,
                height=50,
                glow_color="#22c55e",
                corner_radius=18
            ).pack(side="left")
            # ========== 補單區塊（移到上面） ==========
            append_frame = ctk.CTkFrame(c, fg_color=DARK_PANEL, corner_radius=16)
            append_frame.pack(side="top", fill="x", expand=False, padx=30, pady=(8, 0))
            ctk.CTkLabel(
                append_frame,
                text="補加門市訂單\nAppend Outlet Order",
                font=("Microsoft JhengHei", 12, "bold"),
                text_color=ACCENT_BLUE,
                anchor="w",
                justify="left"
            ).pack(anchor="w", padx=8, pady=(8, 3))
            # 選擇要補的門市訂單檔案（可多選）
            self.append_outlet_files_var = ctk.StringVar()
            # ===== 檔案清單顯示區 =====
            def select_append_files():
                from tkinter import filedialog
                files = filedialog.askopenfilenames(
                    title="選擇要補的門市訂單/Select Outlet Order Files",
                    filetypes=[("Excel files", "*.xlsx")]
                )
                if files:
                    self.append_outlet_files_var.set(";".join(files))
            rowa = ctk.CTkFrame(append_frame)
            rowa.pack(fill="x", pady=3)
            ctk.CTkLabel(rowa, text="選擇要補的門市訂單檔案\nSelect Outlet Order Files:", font=("Microsoft JhengHei", 11)).pack(side="left", padx=8)
            ctk.CTkEntry(rowa, textvariable=self.append_outlet_files_var, font=FONT_MID, state="readonly", width=400).pack(side="left", expand=True, fill="x", padx=5)
            # 美化的瀏覽按鈕（統一樣式）
            browse_btn_a = ctk.CTkButton(
                rowa, 
                text="浏览...\nBrowse...", 
                font=("Microsoft YaHei", 11, "bold"),
                command=select_append_files, 
                corner_radius=8,
                hover_color="#1976d2",
                height=30
            )
            browse_btn_a.pack(side="left", padx=5)
            # 選擇已整合的Supplier檔案資料夾
            self.append_supplier_folder_var = ctk.StringVar()
            rowb = ctk.CTkFrame(append_frame)
            rowb.pack(fill="x", pady=3)
            ctk.CTkLabel(rowb, text="選擇已整合的Supplier檔案資料夾\nSelect Supplier Folder:", font=("Microsoft JhengHei", 11)).pack(side="left", padx=8)
            ctk.CTkEntry(rowb, textvariable=self.append_supplier_folder_var, font=FONT_MID, state="readonly", width=400).pack(side="left", expand=True, fill="x", padx=5)
            # 美化的瀏覽按鈕
            browse_btn_b = ctk.CTkButton(
                rowb, 
                text="浏览...\nBrowse...", 
                font=("Microsoft YaHei", 11, "bold"),
                command=lambda: self._select_folder_var(self.append_supplier_folder_var),
                corner_radius=8,
                hover_color="#1976d2",
                height=30
            )
            browse_btn_b.pack(side="left", padx=5)
            # 補單主按鈕（GlowButton 樣式，與 Summary/Automation 一致）
            def run_append_order():
                import os
                import shutil
                from openpyxl import load_workbook, Workbook
                import xlwings as xw
                from tkinter import messagebox
                from datetime import datetime, timedelta
                import re
                outlet_files = self.append_outlet_files_var.get().split(";")
                supplier_folder = self.append_supplier_folder_var.get()
                if not outlet_files or not supplier_folder:
                    messagebox.showwarning("警告", "請選擇要補的門市訂單檔案和已整合的Supplier資料夾！")
                    return
                # 計算下週一與下週日
                today = datetime.now().date()
                this_monday = today - timedelta(days=today.weekday())
                next_monday = this_monday + timedelta(days=7)
                next_sunday = next_monday + timedelta(days=6)
                for outlet_file in outlet_files:
                    if not outlet_file.strip():
                        continue
                    try:
                        wb_outlet = load_workbook(outlet_file, data_only=False)
                        for sheet_name in wb_outlet.sheetnames:
                            ws = wb_outlet[sheet_name]
                            # 判斷這個 sheet 是否有下週的訂單（與 order automation 一致）
                            has_next_week_order = False
                            for row in ws.iter_rows(min_row=1, max_row=min(30, ws.max_row)):
                                row_vals = [str(cell.value).strip() if cell.value else '' for cell in row]
                                if any(re.match(r"\d{1,2}-[A-Za-z]{3,}$", v) for v in row_vals):
                                    # 找到日期列
                                    for cell in row:
                                        val = cell.value
                                        parsed = None
                                        try:
                                            if val:
                                                sval = str(val)
                                                if re.match(r"^\d{1,2}-[A-Za-z]{3,}$", sval):
                                                    year = next_monday.year
                                                    sval = f"{sval}-{year}"
                                                if isinstance(val, (int, float)):
                                                    base_date = datetime(1899, 12, 30)
                                                    parsed = base_date + timedelta(days=val)
                                                else:
                                                    parsed = datetime.strptime(sval, "%d-%b-%Y")
                                        except Exception:
                                            pass
                                        if parsed and next_monday <= parsed.date() <= next_sunday:
                                            has_next_week_order = True
                                            break
                                if has_next_week_order:
                                    break
                            if not has_next_week_order:
                                continue  # 跳過沒有下週訂單的 sheet
                            supplier_name = sheet_name.strip()
                            supplier_file = os.path.join(supplier_folder, f"{supplier_name}_Week_Append.xlsx")
                            if not os.path.exists(supplier_file):
                                wb_supplier = Workbook()
                                if 'Sheet' in wb_supplier.sheetnames:
                                    del wb_supplier['Sheet']
                                wb_supplier.save(supplier_file)
                            app = xw.App(visible=False)
                            try:
                                wb_supp = app.books.open(supplier_file)
                                wb_out = app.books.open(outlet_file)
                                for sht in wb_out.sheets:
                                    if sht.name.strip() == supplier_name:
                                        for s in wb_supp.sheets:
                                            if s.name == sht.name:
                                                s.delete()
                                        sht.api.Copy(Before=wb_supp.sheets[0].api)
                                        wb_supp.sheets[0].name = sht.name
                                wb_supp.save()
                                wb_supp.close()
                                wb_out.close()
                            finally:
                                app.quit()
                    except Exception as e:
                        messagebox.showerror("錯誤", f"處理 {outlet_file} 時發生錯誤：{e}")
                messagebox.showinfo("完成", "補加門市訂單已完成！(僅補有下週訂單的門市)")
            GlowButton(
                append_frame,
                text="補加門市訂單\nAppend Outlet Order",
                command=run_append_order,
                width=300,
                height=40,
                glow_color=ACCENT_BLUE,
                corner_radius=18
            ).pack(pady=(8, 0))
            
            # ========== 產生 Summary 區塊 ==========
            summary_frame = ctk.CTkFrame(c, fg_color=DARK_PANEL, corner_radius=16)
            summary_frame.pack(side="top", fill="x", expand=False, padx=30, pady=(8, 0))
            ctk.CTkLabel(summary_frame, text="產生 Summary Sheet\nGenerate Summary Sheet", font=("Microsoft JhengHei", 12, "bold"), text_color=ACCENT_GREEN, anchor="w", justify="left").pack(anchor="w", padx=8, pady=(8,3))
            self.summary_supplier_files_var = ctk.StringVar()
            def select_summary_files():
                from tkinter import filedialog
                files = filedialog.askopenfilenames(title="選擇要產生 Summary 的 Supplier 檔案/Select Supplier Files", filetypes=[("Excel files", "*.xlsx")])
                if files:
                    self.summary_supplier_files_var.set(";".join(files))
            row_sum = ctk.CTkFrame(summary_frame)
            row_sum.pack(fill="x", pady=3)
            ctk.CTkLabel(row_sum, text="選擇 Supplier 檔案\nSelect Supplier Files:", font=("Microsoft JhengHei", 11)).pack(side="left", padx=8)
            ctk.CTkEntry(row_sum, textvariable=self.summary_supplier_files_var, font=FONT_MID, state="readonly", width=400).pack(side="left", expand=True, fill="x", padx=5)
            browse_btn_sum = ctk.CTkButton(
                row_sum, 
                text="浏览...\nBrowse...", 
                font=("Microsoft YaHei", 11, "bold"),
                command=select_summary_files,
                corner_radius=8,
                hover_color="#1976d2",
                height=30
            )
            browse_btn_sum.pack(side="left", padx=5)

            import re
            from dateutil.parser import parse
            def create_supplier_summary(filepath):
                print("[DEBUG] 開始產生 summary (產品名+公式行數量主流程)...")
                import openpyxl
                from openpyxl.styles import Alignment, Font, PatternFill, Border, Side
                from openpyxl.utils import get_column_letter
                from datetime import datetime, timedelta
                # 取得下週一到下週日日期
                today = datetime.now().date()
                this_monday = today - timedelta(days=today.weekday())
                next_monday = this_monday + timedelta(days=7)
                next_sunday = next_monday + timedelta(days=6)
                week_dates = [(next_monday + timedelta(days=i)) for i in range(7)]  # 包含週日
                week_days = [d.strftime('%a') for d in week_dates]
                week_dates_str = [d.strftime('%d-%b') for d in week_dates]
                wb = openpyxl.load_workbook(filepath, data_only=True)
                product_map = {}  # (eng, chi) -> {short: (full, [qtys...])}
                all_outlets = set()
                for sheet in wb.sheetnames:
                    if sheet in ("Sheet", "Summary"):
                        continue
                    ws = wb[sheet]
                    if ws.sheet_state != "visible":
                        continue
                    short_name = sheet
                    full_name = ws["F5"].value if ws["F5"].value else sheet
                    all_outlets.add((short_name, full_name))
                    last_row = ws.max_row
                    row = 1
                    while row <= last_row:
                        val = ws.cell(row=row, column=2).value  # B欄
                        if val and "description" in str(val).strip().lower():
                            date_row_idx = row  # 日期列和 Description 同一行
                            date_cols = list(range(6, 13))  # F~L (包含週日)
                            # 解析日期列
                            date_vals = []
                            for col in date_cols:
                                cell_val = ws.cell(row=date_row_idx, column=col).value
                                try:
                                    if isinstance(cell_val, str):
                                        date_val = datetime.strptime(cell_val.strip(), "%d-%b")
                                        date_val = date_val.replace(year=next_monday.year)
                                        date_vals.append(date_val.date())
                                    elif isinstance(cell_val, datetime):
                                        date_vals.append(cell_val.date())
                                    else:
                                        date_vals.append(None)
                                except Exception:
                                    date_vals.append(None)
                            print(f"[DEBUG] sheet={sheet}, row={row}, date_row_idx={date_row_idx}, date_vals={date_vals}, next_monday={next_monday}, next_sunday={next_sunday}")
                            # 判斷這一區塊是否屬於下週
                            if not any(d and next_monday <= d <= next_sunday for d in date_vals):
                                row += 1
                                continue
                            # 產品行從 row+1 開始，直到遇到空白或 sub-total
                            prod_row = row + 1
                            while prod_row <= last_row:
                                eng = ws.cell(row=prod_row, column=2).value
                                chi = ws.cell(row=prod_row, column=3).value
                                if not eng or str(eng).strip() == "" or str(eng).strip().lower().startswith("="):
                                    break
                                if "sub-total" in str(eng).lower():
                                    prod_row += 1
                                    continue
                                qtys = []
                                # 動態確定這個廠商的日期範圍
                                valid_dates = [d for d in date_vals if d and next_monday <= d <= next_sunday]
                                max_days = len(valid_dates) if valid_dates else 7  # 預設7天，但根據實際日期調整
                                
                                for idx, col in enumerate(date_cols):
                                    val = ws.cell(row=prod_row, column=col).value
                                    if date_vals[idx] and next_monday <= date_vals[idx] <= next_sunday:
                                        try:
                                            qtys.append(int(val) if val is not None else 0)
                                        except Exception:
                                            try:
                                                qtys.append(float(val) if val is not None else 0)
                                            except Exception:
                                                qtys.append(0)
                                    else:
                                        qtys.append(0)
                                
                                # 如果這個廠商只有6天資料，確保qtys陣列長度為6
                                if len(valid_dates) == 6:
                                    qtys = qtys[:6]  # 只保留前6天的資料
                                key = (eng, chi)
                                if key not in product_map:
                                    product_map[key] = {}
                                product_map[key][short_name] = (full_name, qtys)
                                prod_row += 1
                            row = prod_row
                        else:
                            row += 1
                # 建立 summary sheet ... (後續不變)
                # 建立 summary sheet
                if "Summary" in wb.sheetnames:
                    del wb["Summary"]
                ws_sum = wb.create_sheet("Summary")
                # 樣式
                header_fill = PatternFill("solid", fgColor="B7B7E1")
                date_fill = PatternFill("solid", fgColor="C6E0B4")
                center = Alignment(horizontal="center", vertical="center")
                bold = Font(bold=True)
                thin = Side(border_style="thin", color="000000")
                border = Border(left=thin, right=thin, top=thin, bottom=thin)
                # 寫入每個產品區塊，橫向排列，最多3個一排，超過自動換行
                col_offset = 2
                row_offset = 2
                products = list(product_map.items())
                max_per_row = 3
                for idx, ((eng, chi), outlet_map) in enumerate(products):
                    block_idx = idx % max_per_row
                    block_row = idx // max_per_row
                    start_col = col_offset + block_idx * 9
                    start_row = row_offset + block_row * (len(all_outlets)+7)  # 7: 標題+欄+日期+TOTAL+空白
                    # 動態確定這個產品區塊的實際天數
                    actual_days = 7  # 預設7天
                    for short, full in sorted(all_outlets):
                        qtys = outlet_map.get(short, (full, [0]*7))[1]
                        if qtys and len(qtys) == 6:  # 如果發現有6天的資料
                            actual_days = 6
                            break
                    
                    # 標題合併（根據實際天數調整）
                    merge_end_col = start_col + actual_days + 1  # +1 是因為有 Short Name 和 Full Name 兩欄
                    ws_sum.merge_cells(start_row=start_row, start_column=start_col, end_row=start_row, end_column=merge_end_col)
                    ws_sum.cell(row=start_row, column=start_col, value=eng).fill = header_fill
                    ws_sum.cell(row=start_row, column=start_col, value=eng).font = bold
                    ws_sum.cell(row=start_row, column=start_col, value=eng).alignment = center
                    ws_sum.merge_cells(start_row=start_row+1, start_column=start_col, end_row=start_row+1, end_column=merge_end_col)
                    ws_sum.cell(row=start_row+1, column=start_col, value=chi).fill = header_fill
                    ws_sum.cell(row=start_row+1, column=start_col, value=chi).font = bold
                    ws_sum.cell(row=start_row+1, column=start_col, value=chi).alignment = center
                    # 欄標題
                    ws_sum.cell(row=start_row+2, column=start_col, value="Short Name").font = bold
                    ws_sum.cell(row=start_row+2, column=start_col+1, value="Full Name").font = bold
                    # Full Name 欄寬
                    ws_sum.column_dimensions[get_column_letter(start_col+1)].width = 34.71
                    # 根據實際天數生成日期標題
                    for i in range(actual_days):
                        c = start_col+2+i
                        if i < len(week_days) and i < len(week_dates_str):
                            wd = week_days[i]
                            dt = week_dates_str[i]
                        ws_sum.cell(row=start_row+2, column=c, value=wd).fill = date_fill
                        ws_sum.cell(row=start_row+3, column=c, value=dt).fill = date_fill
                        ws_sum.cell(row=start_row+2, column=c, value=wd).alignment = center
                        ws_sum.cell(row=start_row+3, column=c, value=dt).alignment = center
                    ws_sum.cell(row=start_row+3, column=start_col, value="").fill = date_fill
                    ws_sum.cell(row=start_row+3, column=start_col+1, value="").fill = date_fill
                    # 分店資料（所有分店都列出，沒數量填0）
                    row_idx = start_row+4
                    for short, full in sorted(all_outlets):
                        qtys = outlet_map.get(short, (full, [0]*7))[1]  # 預設7天
                        if all(q == 0 or q == None for q in qtys):
                            continue  # 跳過全為0的分店
                        ws_sum.cell(row=row_idx, column=start_col, value=short)
                        ws_sum.cell(row=row_idx, column=start_col+1, value=full)
                        for i, qty in enumerate(qtys):
                            ws_sum.cell(row=row_idx, column=start_col+2+i, value=(qty if qty not in (0, None) else ''))
                        row_idx += 1
                    # TOTAL 行
                    ws_sum.cell(row=row_idx, column=start_col, value="TOTAL").font = bold
                    # 動態確定這個產品區塊的實際天數
                    actual_days = 7  # 預設7天
                    for short, full in sorted(all_outlets):
                        qtys = outlet_map.get(short, (full, [0]*7))[1]
                        if qtys and len(qtys) == 6:  # 如果發現有6天的資料
                            actual_days = 6
                            break
                    
                    for i in range(actual_days):  # 根據實際天數
                        col_letter = get_column_letter(start_col+2+i)
                        total_formula = f"=SUM({col_letter}{start_row+4}:{col_letter}{row_idx-1})"
                        ws_sum.cell(row=row_idx, column=start_col+2+i, value=total_formula)
                        ws_sum.cell(row=row_idx, column=start_col+2+i).font = bold
                        ws_sum.cell(row=row_idx, column=start_col+2+i).alignment = center
                    # 格式化區塊
                    for r in range(start_row, row_idx+1):
                        for c in range(start_col, start_col+actual_days+2):  # +2 是因為有 Short Name 和 Full Name 兩欄
                            ws_sum.cell(row=r, column=c).border = border
                # 將 Summary 移到第一個 sheet
                wb._sheets = [ws_sum] + [s for s in wb._sheets if s != ws_sum]
                wb.save(filepath)
                print(f"[DEBUG] 已寫入 Summary sheet: {filepath}")

            def run_generate_summary():
                from tkinter import messagebox
                import traceback
                import tempfile
                import msoffcrypto
                import shutil
                import os

                file_list = self.summary_supplier_files_var.get().split(";")
                file_list = [f for f in file_list if f.strip()]
                if not file_list:
                    messagebox.showwarning("未選擇檔案", "請先選擇要產生 Summary 的 Supplier 檔案！")
                    return
                for file_path in file_list:
                    try:
                        print(f"[DEBUG] 嘗試讀取: {file_path}")
                        # xlwings 只能處理未加密的 xlsx
                        # 若加密，先解密到暫存檔
                        tmp_path = None
                        try:
                            create_supplier_summary(file_path)
                        except Exception as e:
                            print(f"[DEBUG] xlwings 讀取失敗，嘗試解密: {e}")
                            with open(file_path, "rb") as f:
                                office_file = msoffcrypto.OfficeFile(f)
                                office_file.load_key(password="Apple")
                                with tempfile.NamedTemporaryFile(delete=False, suffix=".xlsx") as tmp:
                                    office_file.decrypt(tmp)
                                    tmp_path = tmp.name
                            create_supplier_summary(tmp_path)
                            # 覆蓋原檔
                            shutil.copyfile(tmp_path, file_path)
                            os.remove(tmp_path)
                        print(f"[DEBUG] 已寫入: {file_path}")
                    except Exception as e:
                        import traceback
                        messagebox.showerror("錯誤", f"處理檔案 {file_path} 時發生錯誤：\n{str(e)}\n{traceback.format_exc()}")
                        print(f"[DEBUG] 發生錯誤: {e}")
                        continue
                messagebox.showinfo("完成", "Summary 已成功產生並插入到所選檔案！")

            GlowButton(
                summary_frame,
                text="產生 Summary\nGenerate Summary",
                command=run_generate_summary,
                width=300,
                height=40,
                glow_color="#8B5CF6"  # 改為更好看的紫色
            ).pack(pady=(8, 0))
 

        
        self._show_function_ui(
            "automation_title", 
            "automation_desc", 
            build
        )
    
    def show_email_sending_ui(self):
        """显示邮件发送界面"""
        def build(c):
            import os
            self.email_supplier_folder_var = ctk.StringVar()
            self.email_master_config_var = ctk.StringVar()
            
            # 创建表单框架
            form_frame = ctk.CTkFrame(c, fg_color="transparent")
            form_frame.pack(fill="both", expand=True, padx=30, pady=10)
            # 供应商文件夹
            row1 = ctk.CTkFrame(form_frame)
            row1.pack(fill="x", pady=8)
            ctk.CTkLabel(row1, text="供應商文件夾\nSupplier Folder:", font=("Microsoft JhengHei", 12, "bold")).pack(side="left", padx=8)
            ctk.CTkEntry(row1, textvariable=self.email_supplier_folder_var, font=FONT_MID, state="readonly", width=400).pack(side="left", expand=True, fill="x", padx=5)
            email_browse_btn = ctk.CTkButton(
                row1, 
                text="瀏覽...\nBrowse...", 
                font=("Microsoft YaHei", 11, "bold"),
                command=lambda: self._select_folder_var(self.email_supplier_folder_var),
                corner_radius=8,
                hover_color="#1976d2",
                height=30
            )
            email_browse_btn.pack(side="left", padx=5)
            # 统一配置文件
            row2 = ctk.CTkFrame(form_frame)
            row2.pack(fill="x", pady=8)
            ctk.CTkLabel(row2, text="統一配置文件\nMaster Config (Excel):", font=("Microsoft JhengHei", 12, "bold")).pack(side="left", padx=8)
            ctk.CTkEntry(row2, textvariable=self.email_master_config_var, font=FONT_MID, state="readonly", width=400).pack(side="left", expand=True, fill="x", padx=5)
            browse_btn_email_config = ctk.CTkButton(
                row2,
                text="瀏覽...\nBrowse...",
                font=("Microsoft YaHei", 11, "bold"),
                command=lambda: self._select_config_file(self.email_master_config_var, [("Excel files", "*.xlsx")]),
                corner_radius=8,
                hover_color="#1976d2",
                height=30
            )
            browse_btn_email_config.pack(side="left", padx=5)
            # 新增：供應商選擇區域
            supplier_frame = ctk.CTkFrame(form_frame)
            supplier_frame.pack(fill="x", pady=8)
            ctk.CTkLabel(supplier_frame, text="選擇供應商\nSelect Supplier:", font=("Microsoft JhengHei", 12, "bold")).pack(side="left", padx=8)
            self.supplier_combobox = ctk.CTkComboBox(supplier_frame, values=["請先選擇文件夾和配置文件"], state="readonly", width=300)
            self.supplier_combobox.pack(side="left", padx=5)
            
            # 美化：自訂主旨/Custom Subject 行
            subject_option_frame = ctk.CTkFrame(form_frame, fg_color="#232e3c", corner_radius=14, height=48)
            subject_option_frame.pack(fill="x", pady=10, padx=2)
            subject_option_frame.pack_propagate(False)
            # 彩色icon/條
            accent = ctk.CTkLabel(subject_option_frame, text="★", font=("Segoe UI Emoji", 22), text_color="#38bdf8", width=32)
            accent.pack(side="left", padx=(12, 8), pady=0)
            self.use_custom_subject_var = ctk.BooleanVar(value=False)
            custom_subject_checkbox = ctk.CTkCheckBox(
                subject_option_frame,
                text="自訂主旨\nCustom Subject",
                variable=self.use_custom_subject_var,
                font=("Microsoft JhengHei", 14, "bold"),
                width=30,
                height=30,
                border_width=3,
                corner_radius=8,
                fg_color="#2563eb",
                hover_color="#1d4ed8",
                border_color="#60a5fa",
                text_color="#fff",
                checkbox_height=24,
                checkbox_width=24,
                command=lambda: self._toggle_subject_entry()
            )
            custom_subject_checkbox.pack(side="left", padx=(0, 18), pady=0)
            ctk.CTkLabel(subject_option_frame, text="郵件主旨\nEmail Subject:", font=("Microsoft JhengHei", 14, "bold"), text_color="#e0e7ef").pack(side="left", padx=(0, 12), pady=0)
            self.email_subject_var = ctk.StringVar()
            self.email_subject_entry = ctk.CTkEntry(subject_option_frame, textvariable=self.email_subject_var, font=("Microsoft JhengHei", 14), width=520, height=32, border_width=3, corner_radius=10, fg_color="#f1f5f9", text_color="#222", border_color="#38bdf8", state="disabled")
            self.email_subject_entry.pack(side="left", padx=(0, 18), fill="x", expand=True, pady=0)

            def _toggle_subject_entry(self=None):
                if self is None:
                    return
                if self.use_custom_subject_var.get():
                    self.email_subject_entry.configure(state="normal", fg_color="#fff", text_color="#222", border_color="#2563eb")
                else:
                    self.email_subject_entry.configure(state="disabled", fg_color="#f1f5f9", text_color="#222", border_color="#38bdf8")
            self._toggle_subject_entry = _toggle_subject_entry.__get__(self)
            
            # 更新供應商列表的函數
            def update_supplier_list():
                folder = self.email_supplier_folder_var.get()
                master_config = self.email_master_config_var.get()
                if not folder or not master_config:
                    self.supplier_combobox.configure(values=["請先選擇文件夾和配置文件"])
                    return
                
                try:
                    # 讀取配置文件中的供應商
                    wb = load_workbook(master_config, data_only=True)
                    supplier_dict = {}  # 使用 dict 來保存每個供應商的第一個 email
                    if "Suppliers" in wb.sheetnames:
                        ws = wb["Suppliers"]
                        for row in ws.iter_rows(min_row=2, values_only=True):
                            if row and row[0]:
                                supplier = str(row[0]).strip()
                                if supplier not in supplier_dict:  # 只保存每個供應商的第一個 email
                                    supplier_dict[supplier] = str(row[2]).strip() if len(row) > 2 else ""
                    files = [f for f in os.listdir(folder) if f.endswith(".xlsx") and not f.startswith("~$")]
                    available_suppliers = []
                    for supplier in supplier_dict:
                        for file in files:
                            # 只要檔名有對應廠商名稱（不限定 _Week_）
                            if supplier in file and supplier not in available_suppliers:
                                available_suppliers.append(supplier)
                    if available_suppliers:
                        self.supplier_combobox.configure(values=sorted(available_suppliers))  # 排序顯示
                        self.supplier_combobox.set(available_suppliers[0])
                    else:
                        self.supplier_combobox.configure(values=["沒有找到匹配的供應商文件"])
                except Exception as e:
                    self.supplier_combobox.configure(values=[f"錯誤: {str(e)}"])
            
            # 綁定文件夾和配置文件變更事件
            self.email_supplier_folder_var.trace("w", lambda *args: update_supplier_list())
            self.email_master_config_var.trace("w", lambda *args: update_supplier_list())
            
            # 郵件正文body輸入框
            ctk.CTkLabel(form_frame, text="郵件正文/Email Body:", font=("Microsoft JhengHei", 12, "bold")).pack(anchor="w", padx=10, pady=(12,0))
            self.email_body_textbox = ctk.CTkTextbox(form_frame, height=100, font=("Microsoft JhengHei", 12), wrap="word")
            self.email_body_textbox.pack(fill="x", padx=10, pady=(0,8))
            
            # 模板按鈕區域
            template_frame = ctk.CTkFrame(form_frame, fg_color="transparent")
            template_frame.pack(fill="x", padx=10, pady=(0,8))
            
            # 一般訂單模板按鈕
            weekly_template_btn = ctk.CTkButton(
                template_frame,
                text="一般訂單模板\nWeekly Order Template",
                command=lambda: self._load_weekly_template(),
                fg_color="#2563eb",
                hover_color="#1d4ed8",
                font=("Microsoft YaHei", 11, "bold"),
                corner_radius=8,
                height=30
            )
            weekly_template_btn.pack(side="left", padx=(0,8))
            
            # Amendment 訂單模板按鈕
            amendment_template_btn = ctk.CTkButton(
                template_frame,
                text="Amendment 模板\nAmendment Template",
                command=lambda: self._load_amendment_template(),
                fg_color="#dc2626",
                hover_color="#b91c1c",
                font=("Microsoft YaHei", 11, "bold"),
                corner_radius=8,
                height=30
            )
            amendment_template_btn.pack(side="left")
            
            # 載入本地body預設
            default_body = "Hi Team,\n\n{month_week} order as attached.\n\nBest Regards,"
            body_path = "email_body.txt"
            if os.path.exists(body_path):
                try:
                    with open(body_path, "r", encoding="utf-8") as f:
                        saved_body = f.read()
                    # 替換模板中的變數
                    from datetime import datetime, timedelta
                    now = datetime.now()
                    # 計算下周的日期
                    days_until_next_monday = (7 - now.weekday()) % 7
                    if days_until_next_monday == 0:
                        days_until_next_monday = 7
                    next_monday = now + timedelta(days=days_until_next_monday)
                    month_name = next_monday.strftime("%B")
                    week_of_month = get_week_of_month(next_monday)
                    month_week = f"{month_name} - Week {week_of_month}"
                    
                    # 替換模板中的變數
                    saved_body = saved_body.replace("{month_week}", month_week)
                    
                    self.email_body_textbox.delete("1.0", "end")
                    self.email_body_textbox.insert("1.0", saved_body)
                except Exception:
                    self.email_body_textbox.insert("1.0", default_body)
            else:
                self.email_body_textbox.insert("1.0", default_body)
            # 保存按鈕
            def save_body():
                body = self.email_body_textbox.get("1.0", "end-1c")
                try:
                    with open("email_body.txt", "w", encoding="utf-8") as f:
                        f.write(body)
                    messagebox.showinfo("保存成功", "郵件正文已保存！")
                except Exception as e:
                    messagebox.showerror("保存失敗", f"保存失敗: {e}")
            # 美化的保存按鈕
            save_btn = ctk.CTkButton(
                form_frame, 
                text="保存郵件正文/Save Email Body", 
                command=save_body, 
                fg_color=ACCENT_GREEN, 
                hover_color=BTN_HOVER,
                font=("Microsoft YaHei", 11, "bold"),
                corner_radius=10,
                height=30
            )
            save_btn.pack(anchor="e", padx=10, pady=(0,8))
            
            # 預覽和發送按鈕
            btn_frame = ctk.CTkFrame(c, fg_color="transparent")
            btn_frame.pack(pady=15, fill="x", padx=20)
            btn_frame.grid_columnconfigure(0, weight=1)
            btn_frame.grid_columnconfigure(1, weight=1)
            # 讓按鈕自適應寬度，並在視窗窄時自動換行
            send_btn = GlowButton(
                btn_frame, 
                text="單獨發送\nSend Individual",
                command=self._preview_supplier_email,
                width=200,
                height=40,
                glow_color=ACCENT_BLUE
            )
            send_btn.grid(row=0, column=0, padx=8, pady=3, sticky="ew")
            dir_btn = GlowButton(
                btn_frame, 
                text="發送目錄\nEmail Directory",
                command=self._show_email_directory,
                width=200,
                height=40,
                glow_color=ACCENT_RED
            )
            dir_btn.grid(row=0, column=1, padx=8, pady=3, sticky="ew")
            
            # 確保按鈕在窗口縮小時也能顯示
            def on_configure(event):
                # 當窗口大小改變時，確保按鈕可見
                if event.width < 600:  # 如果窗口太窄
                    send_btn.grid(row=0, column=0, padx=5, pady=3, sticky="ew")
                    dir_btn.grid(row=1, column=0, padx=5, pady=3, sticky="ew")
                else:
                    send_btn.grid(row=0, column=0, padx=8, pady=3, sticky="ew")
                    dir_btn.grid(row=0, column=1, padx=8, pady=3, sticky="ew")
            
            # 綁定窗口大小改變事件
            c.bind("<Configure>", on_configure)
        
        self._show_function_ui(
            "send_emails",
            ("选择供应商文件夹并发送邮件\nSelect supplier folder and send emails", FONT_TITLE),
            build
        )
    
    def _load_weekly_template(self):
        """載入一般訂單模板"""
        from datetime import datetime, timedelta
        now = datetime.now()
        
        # 計算下周的日期
        # 找到下週一：如果今天是週一，下週一就是今天+7天；否則找到下一個週一
        days_until_next_monday = (7 - now.weekday()) % 7
        if days_until_next_monday == 0:
            days_until_next_monday = 7  # 如果今天是週一，下週一就是7天後
        next_monday = now + timedelta(days=days_until_next_monday)
        
        # 使用下周一的月份和週數
        month_name = next_monday.strftime("%B")
        week_of_month = get_week_of_month(next_monday)
        
        # 一般訂單模板
        weekly_template = f"Hi Team,\n\n{month_name} - Week {week_of_month} order as attached.\n\nBest Regards,"
        
        # 更新郵件正文
        self.email_body_textbox.delete("1.0", "end")
        self.email_body_textbox.insert("1.0", weekly_template)
        
        # 更新主旨（如果啟用了自訂主旨）
        if self.use_custom_subject_var.get():
            subject_template = f"{month_name} - Week {week_of_month}"
            self.email_subject_var.set(subject_template)
    
    def _load_amendment_template(self):
        """載入 Amendment 訂單模板"""
        from datetime import datetime
        now = datetime.now()
        month_name = now.strftime("%B")
        week_of_month = get_week_of_month(now)
        
        # Amendment 訂單模板
        amendment_template = f"Hi Team,\n\nAmendment order as attached.\n\nBest Regards,"
        
        # 更新郵件正文
        self.email_body_textbox.delete("1.0", "end")
        self.email_body_textbox.insert("1.0", amendment_template)
        
        # 更新主旨（如果啟用了自訂主旨）
        if self.use_custom_subject_var.get():
            subject_template = f"Sushi Express Amendment Order - {{Supplier}}"
            self.email_subject_var.set(subject_template)

    def _preview_supplier_email(self):
        """預覽選定供應商的郵件內容"""
        import os
        folder = self.email_supplier_folder_var.get()
        master_config = self.email_master_config_var.get()
        selected_supplier = self.supplier_combobox.get()
        
        if not folder or not master_config:
            messagebox.showwarning(t("warning"), t("folder_warning"))
            return
            
        if not selected_supplier or selected_supplier in ["請先選擇文件夾和配置文件", "沒有找到匹配的供應商文件"]:
            messagebox.showwarning("警告", "請先選擇供應商")
            return
        
        files = [f for f in os.listdir(folder) if f.endswith(".xlsx") and not f.startswith("~$")]
        matched_file = find_supplier_file(selected_supplier, files)
        if not matched_file:
            messagebox.showerror("錯誤", f"找不到 {selected_supplier} 的對應文件")
            return
        supplier_file = os.path.join(folder, matched_file)
        
        # 獲取郵件內容
        body = self.email_body_textbox.get("1.0", "end-1c")
        config_mgr = UnifiedConfigManager(master_config)
        email_sender = EmailSender(config_mgr)
        
        to_emails, cc_emails = email_sender.get_to_cc_emails(selected_supplier, master_config)
        from datetime import datetime, timedelta
        now = datetime.now()
        
        # 計算下周的日期
        days_until_next_monday = (7 - now.weekday()) % 7
        if days_until_next_monday == 0:
            days_until_next_monday = 7
        next_monday = now + timedelta(days=days_until_next_monday)
        
        # 使用下周一的月份和週數
        month_name = next_monday.strftime("%B")
        week_of_month = get_week_of_month(next_monday)
        
        # 處理郵件正文中的變數替換
        body = body.replace("{month_week}", f"{month_name} - Week {week_of_month}")
        
        # 處理主旨
        subject = ""
        if self.use_custom_subject_var.get():
            custom_subject = self.email_subject_var.get().strip()
            if custom_subject:
                # 替換主旨中的變數
                subject = custom_subject.replace("{week_no}", str(week_of_month)).replace("{Supplier}", selected_supplier).replace("{Month}", month_name)
            else:
                subject = f"{month_name} - Week {week_of_month}"
        else:
            subject = f"{month_name} - Week {week_of_month}"
        
        self.email_subject_var.set(subject if self.use_custom_subject_var.get() else "")
        
        # 創建預覽窗口
        preview_window = ctk.CTkToplevel(self)
        preview_window.title(f"郵件預覽 - {selected_supplier}")
        preview_window.geometry("600x500")
        preview_window.resizable(True, True)
        preview_window.attributes('-topmost', True)  # 設置視窗置頂
        preview_window.focus_force()  # 強制聚焦
        
        # 郵件信息
        info_frame = ctk.CTkFrame(preview_window)
        info_frame.pack(fill="x", padx=10, pady=10)
        
        ctk.CTkLabel(info_frame, text=f"供應商/Supplier: {selected_supplier}", font=FONT_MID).pack(anchor="w", padx=10, pady=5)
        ctk.CTkLabel(info_frame, text=f"主旨/Subject: {subject}", font=FONT_MID, wraplength=500).pack(anchor="w", padx=10, pady=5)
        
        # 收件人郵箱顯示
        to_emails_text = ", ".join(to_emails) if to_emails else "無"
        to_label = ctk.CTkLabel(info_frame, text=f"收件人/To: {to_emails_text}", font=FONT_MID, wraplength=500)
        to_label.pack(anchor="w", padx=10, pady=5)
        
        ctk.CTkLabel(info_frame, text=f"附件/Attachment: {matched_file}", font=FONT_MID).pack(anchor="w", padx=10, pady=5)
        
        # 郵件正文預覽（可編輯）
        ctk.CTkLabel(preview_window, text="郵件正文/Email Body (可編輯):", font=FONT_MID).pack(anchor="w", padx=10, pady=(10,0))
        body_textbox = ctk.CTkTextbox(preview_window, height=200, font=FONT_MID, wrap="word")
        body_textbox.pack(fill="both", expand=True, padx=10, pady=10)
        body_textbox.insert("1.0", body)
        
        # 按鈕區域
        btn_frame = ctk.CTkFrame(preview_window)
        btn_frame.pack(fill="x", padx=10, pady=10)
        
        def send_this_email():
            # 發送這封郵件（使用編輯後的內容）
            edited_body = body_textbox.get("1.0", "end-1c")
            from datetime import datetime, timedelta
            now = datetime.now()
            
            # 計算下周的日期（與模板邏輯一致）
            days_until_next_monday = (7 - now.weekday()) % 7
            if days_until_next_monday == 0:
                days_until_next_monday = 7
            next_monday = now + timedelta(days=days_until_next_monday)
            
            # 使用下周一的月份和週數
            month_name = next_monday.strftime("%B")
            week_of_month = get_week_of_month(next_monday)
            month_week = f"{month_name} - Week {week_of_month}"
            
            # 處理郵件正文中的變數替換
            edited_body = edited_body.replace("{month_week}", month_week)
            
            # 處理主旨中的變數替換
            final_subject = subject.replace("{month_week}", month_week).replace("{Supplier}", selected_supplier)
            
            mail = email_sender.send_email(
                to_emails, cc_emails, selected_supplier, edited_body,
                attachment_path=supplier_file,
                account_idx=self.selected_outlook_account_idx,
                subject=final_subject
            )
            if isinstance(mail, tuple):
                messagebox.showerror("Error", mail[1])
                return
            if not mail:
                messagebox.showerror("Error", f"无法创建邮件: {selected_supplier}")
                return
            # 直接發送，不顯示 Outlook 視窗
            try:
                mail.Send()
                messagebox.showinfo("成功", f"郵件已直接發送給 {selected_supplier}")
                preview_window.destroy()
            except Exception as e:
                messagebox.showerror("發送失敗", f"發送郵件時發生錯誤: {str(e)}")
        
        # 美化的發送按鈕
        send_btn = ctk.CTkButton(
            btn_frame, 
            text="發送此郵件/Send This Email", 
            command=send_this_email, 
            fg_color=ACCENT_RED,
            font=("Microsoft YaHei", 12, "bold"),
            corner_radius=10,
            hover_color="#d32f2f",
            height=35
        )
        send_btn.pack(side="right", padx=5)
        
        # 美化的關閉按鈕
        close_btn = ctk.CTkButton(
            btn_frame, 
            text="關閉/Close", 
            command=preview_window.destroy,
            font=("Microsoft YaHei", 12, "bold"),
            corner_radius=10,
            hover_color="#1976d2",
            height=35
        )
        close_btn.pack(side="right", padx=5)

    def _show_email_directory(self):
        """顯示郵件發送目錄"""
        import os
        
        folder = self.email_supplier_folder_var.get()
        master_config = self.email_master_config_var.get()
        
        if not folder or not master_config:
            messagebox.showwarning(t("warning"), t("folder_warning"))
            return
            
        def destroy_window():
            """正確清理視窗及其子元件"""
            try:
                # 先清理所有行框架
                for row_frame, _ in row_frames:
                    for widget in row_frame.winfo_children():
                        widget.destroy()
                    row_frame.destroy()
                row_frames.clear()
                
                # 清理其他框架和元件
                for widget in scroll_frame.winfo_children():
                    widget.destroy()
                scroll_frame.destroy()
                
                for widget in table_frame.winfo_children():
                    widget.destroy()
                table_frame.destroy()
                
                for widget in batch_frame.winfo_children():
                    widget.destroy()
                batch_frame.destroy()
                
                # 最後銷毀視窗
                directory_window.destroy()
            except Exception as e:
                print(f"Error during window cleanup: {e}")
                # 如果清理過程出錯，強制關閉視窗
                try:
                    directory_window.destroy()
                except:
                    pass
        
        # 獲取所有可用的供應商和文件
        files = [f for f in os.listdir(folder) if f.endswith(".xlsx") and not f.startswith("~$")]
        master_config_path = self.email_master_config_var.get()
        config_mgr = UnifiedConfigManager(master_config_path)
        email_sender = EmailSender(config_mgr)
        
        # 讀取配置文件中的供應商，使用 dict 來去重複
        wb = load_workbook(master_config_path, data_only=True)
        supplier_dict = {}  # 使用 dict 來保存每個供應商的第一個 email
        if "Suppliers" in wb.sheetnames:
            ws = wb["Suppliers"]
            seen_suppliers = set()  # 使用 set 來記錄已處理的供應商
            for row in ws.iter_rows(min_row=2, values_only=True):
                if row and row[0]:
                    supplier = str(row[0]).strip()
                    if supplier not in seen_suppliers:  # 只處理每個供應商的第一個 email
                        seen_suppliers.add(supplier)
                        to_emails, cc_emails = email_sender.get_to_cc_emails(supplier, master_config_path)
                        supplier_dict[supplier] = {
                            'to_emails': to_emails,
                            'cc_emails': cc_emails
                        }

        # 創建目錄窗口
        directory_window = ctk.CTkToplevel(self)
        directory_window.title("郵件發送目錄 / Email Directory")
        directory_window.geometry("1200x800")  # 加大視窗尺寸
        directory_window.resizable(True, True)
        directory_window.attributes('-topmost', True)  # 設置視窗置頂
        directory_window.focus_force()  # 強制聚焦

        # 標題
        title_label = ctk.CTkLabel(directory_window, text="供應商郵件發送目錄\nSupplier Email Directory", font=FONT_TITLE)
        title_label.pack(pady=10)

        # 創建表格框架
        table_frame = ctk.CTkFrame(directory_window)
        table_frame.pack(fill="both", expand=True, padx=20, pady=10)

        # 表格標題（增加間距和背景色）
        header_frame = ctk.CTkFrame(table_frame, fg_color=ACCENT_BLUE)
        header_frame.pack(fill="x", padx=10, pady=10)

        ctk.CTkLabel(header_frame, text="供應商/Supplier", font=FONT_MID, width=150, text_color="#ffffff").pack(side="left", padx=5)
        ctk.CTkLabel(header_frame, text="收件人/To", font=FONT_MID, width=400, text_color="#ffffff").pack(side="left", padx=5)
        ctk.CTkLabel(header_frame, text="附件/Attachment", font=FONT_MID, width=250, text_color="#ffffff").pack(side="left", padx=5)
        ctk.CTkLabel(header_frame, text="操作/Action", font=FONT_MID, width=100, text_color="#ffffff").pack(side="left", padx=5)

        # 搜尋框架
        search_frame = ctk.CTkFrame(table_frame)
        search_frame.pack(fill="x", padx=10, pady=5)

        ctk.CTkLabel(search_frame, text="搜尋供應商 / Search Supplier:", font=FONT_MID).pack(side="left", padx=5)
        search_var = ctk.StringVar()
        search_entry = ctk.CTkEntry(search_frame, textvariable=search_var, width=300)
        search_entry.pack(side="left", padx=5)

        # 滾動框架
        scroll_frame = ctk.CTkScrollableFrame(table_frame)
        scroll_frame.pack(fill="both", expand=True, padx=10, pady=5)

        # 儲存所有行框架的引用，用於搜尋過濾
        row_frames = []
        email_list = []
        supplier_check_vars = {}  # 新增：每個供應商的勾選狀態
        sent_status = {}  # 新增：記錄已發送狀態

        def filter_rows(*args):
            """根據搜尋文字過濾行"""
            search_text = search_var.get().lower()
            visible_count = 0
            for row_frame, supplier_name in row_frames:
                if search_text in supplier_name.lower():
                    row_frame.pack(fill="x", padx=5, pady=5)
                    visible_count += 1
                else:
                    row_frame.pack_forget()
            # 更新總結信息
            summary_label.configure(text=f"總共找到 {len(email_list)} 個供應商，顯示 {visible_count} 個")

        # 綁定搜尋事件
        search_var.trace("w", filter_rows)

        # 只處理每個供應商一次
        processed_suppliers = set()  # 使用 set 來記錄已處理的供應商
        for supplier in supplier_dict:
            if supplier in processed_suppliers:
                continue
            processed_suppliers.add(supplier)

            matched_file = find_supplier_file(supplier, files)
            if matched_file:
                to_emails = supplier_dict[supplier]['to_emails']
                cc_emails = supplier_dict[supplier]['cc_emails']

                row_frame = ctk.CTkFrame(scroll_frame)
                row_frames.append((row_frame, supplier))
                row_frame.pack(fill="x", padx=5, pady=5)

                var = ctk.BooleanVar(value=True)
                supplier_check_vars[supplier] = var
                check_btn = ctk.CTkCheckBox(row_frame, variable=var, text="", width=24)
                check_btn.pack(side="left", padx=5)
                supplier_label = ctk.CTkLabel(row_frame, text=supplier, font=FONT_MID, width=150)
                supplier_label.pack(side="left", padx=5)
                to_emails_text = ", ".join(to_emails) if to_emails else "無"
                to_label = ctk.CTkLabel(row_frame, text=to_emails_text, font=FONT_MID, width=400, wraplength=380)
                to_label.pack(side="left", padx=5)
                attachment_label = ctk.CTkLabel(row_frame, text=matched_file, font=FONT_MID, width=250)
                attachment_label.pack(side="left", padx=5)
                status_label = ctk.CTkLabel(row_frame, text="", font=FONT_MID, width=40)
                status_label.pack(side="left", padx=5)
                sent_status[supplier] = status_label

                def create_send_function(supplier, to_emails, cc_emails, attachment_file):
                    def send_email():
                        # ...原本內容...
                        pass
                    return send_email

                send_btn = ctk.CTkButton(
                    row_frame, 
                    text="發送/Send", 
                    command=create_send_function(supplier, to_emails, cc_emails, matched_file),
                    width=80,
                    height=30,
                    fg_color=ACCENT_RED,
                    font=("Microsoft YaHei", 11, "bold"),
                    corner_radius=8,
                    hover_color="#d32f2f"
                )
                send_btn.pack(side="right", padx=5)
                email_list.append({
                    'supplier': supplier,
                    'to_emails': to_emails,
                    'cc_emails': cc_emails,
                    'attachment': matched_file
                })
        # 批量發送按鈕
        batch_frame = ctk.CTkFrame(directory_window)
        batch_frame.pack(fill="x", padx=20, pady=10)
        
        def batch_send_selected():
            import threading
            import time
            from tkinter import messagebox
            selected_suppliers = [s for s, v in supplier_check_vars.items() if v.get()]
            if not selected_suppliers:
                messagebox.showwarning("未選擇", "請先勾選要發送的供應商！")
                return
            # 彈出進度視窗
            progress_win = ctk.CTkToplevel(directory_window)
            progress_win.title("郵件發送進度/Email Send Progress")
            progress_win.geometry("600x600")
            ctk.CTkLabel(progress_win, text="郵件發送進度", font=FONT_TITLE).pack(pady=10)
            progress_frame = ctk.CTkScrollableFrame(progress_win)
            progress_frame.pack(fill="both", expand=True, padx=10, pady=10)
            progress_labels = {}
            for supplier in selected_suppliers:
                lbl = ctk.CTkLabel(progress_frame, text=f"{supplier} ...", font=FONT_MID)
                lbl.pack(anchor="w", pady=2)
                progress_labels[supplier] = lbl
            def send_all():
                for idx, supplier in enumerate(selected_suppliers):
                    entry = next((e for e in email_list if e['supplier'] == supplier), None)
                    if not entry:
                        progress_labels[supplier].configure(text=f"{supplier} - 檔案/郵件資料缺失", text_color=ACCENT_RED)
                        continue
                    try:
                        body = self.email_body_textbox.get("1.0", "end-1c")
                        from datetime import datetime, timedelta
                        today = datetime.now().date()
                        this_monday = today - timedelta(days=today.weekday())
                        next_monday = this_monday + timedelta(days=7)
                        target_date = next_monday
                        month_name = target_date.strftime("%B")
                        week_of_month = get_week_of_month(target_date)
                        month_week = f"{month_name} - Week {week_of_month}"
                        body_filled = body.replace("{month_week}", month_week)
                        subject = f"Sushi Express Weekly Order - {supplier} - {month_name} - Week {week_of_month}"
                        mail = email_sender.send_email(
                            entry['to_emails'], entry['cc_emails'], supplier, body_filled,
                            attachment_path=os.path.join(folder, entry['attachment']),
                            account_idx=self.selected_outlook_account_idx,
                            subject=subject
                        )
                        if isinstance(mail, tuple) or not mail:
                            progress_labels[supplier].configure(text=f"{supplier} ✗ {mail[1] if isinstance(mail, tuple) else ''}", text_color=ACCENT_RED)
                            sent_status[supplier].configure(text="✗", text_color=ACCENT_RED)
                            continue
                        try:
                            mail.Send()
                            progress_labels[supplier].configure(text=f"{supplier} ✔ 已發送", text_color=ACCENT_GREEN)
                            sent_status[supplier].configure(text="✔", text_color=ACCENT_GREEN)
                        except Exception as e:
                            progress_labels[supplier].configure(text=f"{supplier} ✗ {str(e)}", text_color=ACCENT_RED)
                            sent_status[supplier].configure(text="✗", text_color=ACCENT_RED)
                    except Exception as e:
                        progress_labels[supplier].configure(text=f"{supplier} ✗ {str(e)}", text_color=ACCENT_RED)
                        sent_status[supplier].configure(text="✗", text_color=ACCENT_RED)
                    time.sleep(2)  # 緩衝 2 秒
            threading.Thread(target=send_all).start()
        # 新增「發送勾選」按鈕
        send_selected_btn = ctk.CTkButton(
            batch_frame, 
            text="發送勾選郵件\nSend Selected",
            command=batch_send_selected,
            width=200,
            height=50,
            fg_color=ACCENT_GREEN,
            font=("Microsoft YaHei", 12, "bold"),
            corner_radius=10,
            hover_color="#059669"
        )
        send_selected_btn.pack(side="right", padx=10)
        
        # 總結信息
        summary_label = ctk.CTkLabel(directory_window, text=f"總共找到 {len(email_list)} 個供應商可以發送郵件", font=FONT_MID)
        summary_label.pack(pady=10)

    def _show_batch_result(self, success_count, failed_count, failed_suppliers):
        """顯示批量發送結果"""
        from tkinter import messagebox
        
        result_window = ctk.CTkToplevel(self)
        result_window.title("批量發送結果 / Batch Send Result")
        result_window.geometry("500x400")
        result_window.resizable(True, True)
        result_window.attributes('-topmost', True)  # 設置視窗置頂
        result_window.focus_force()  # 強制聚焦
        
        # 標題
        title_label = ctk.CTkLabel(result_window, text="批量發送結果\nBatch Send Result", font=FONT_TITLE)
        title_label.pack(pady=10)
        
        # 結果摘要
        summary_frame = ctk.CTkFrame(result_window)
        summary_frame.pack(fill="x", padx=20, pady=10)
        
        ctk.CTkLabel(summary_frame, text=f"成功發送: {success_count} 個供應商", 
                    font=FONT_MID, text_color=ACCENT_GREEN).pack(anchor="w", padx=10, pady=5)
        ctk.CTkLabel(summary_frame, text=f"發送失敗: {failed_count} 個供應商", 
                    font=FONT_MID, text_color=ACCENT_RED).pack(anchor="w", padx=10, pady=5)
        
        # 失敗詳情
        if failed_suppliers:
            ctk.CTkLabel(result_window, text="失敗詳情 / Failed Details:", font=FONT_MID).pack(anchor="w", padx=20, pady=(10,0))
            
            # 滾動框架顯示失敗詳情
            scroll_frame = ctk.CTkScrollableFrame(result_window)
            scroll_frame.pack(fill="both", expand=True, padx=20, pady=10)
            
            for supplier in failed_suppliers:
                ctk.CTkLabel(scroll_frame, text=f"• {supplier}", 
                            font=FONT_MID, text_color=ACCENT_RED).pack(anchor="w", padx=10, pady=2)
        
        # 美化的關閉按鈕
        close_btn = ctk.CTkButton(
            result_window, 
            text="關閉/Close", 
            command=result_window.destroy,
            font=("Microsoft YaHei", 12, "bold"),
            corner_radius=10,
            hover_color="#1976d2",
            height=35
        )
        close_btn.pack(pady=10)



    def _send_supplier_emails(self):
        import os
        folder = self.email_supplier_folder_var.get()
        master_config = self.email_master_config_var.get()
        if not folder or not master_config:
            messagebox.showwarning(t("warning"), t("folder_warning"))
            return
        # 選擇Outlook帳號（只選一次）
        if self.selected_outlook_account_idx is None:
            try:
                import win32com.client
                outlook = win32com.client.Dispatch("Outlook.Application").GetNamespace("MAPI")
                accounts = [outlook.Folders.Item(i + 1) for i in range(outlook.Folders.Count)]
                account_names = [acct.Name for acct in accounts]
                from tkinter import simpledialog
                # 建立一個置頂的臨時視窗作為 parent
                import tkinter as tk
                top = tk.Toplevel()
                top.attributes('-topmost', True)
                top.withdraw()  # 不顯示內容，只做為 parent
                idx = simpledialog.askinteger(
                    "選擇Outlook帳號/Select Outlook Account",
                    "\n".join([f"[{i}] {name}" for i, name in enumerate(account_names)]) + "\n請輸入序號/Please enter index:",
                    minvalue=0, maxvalue=len(account_names)-1,
                    parent=top
                )
                top.destroy()
                if idx is None:
                    messagebox.showwarning("取消/Cancelled", "未選擇帳號，已取消發送/No account selected, sending cancelled.")
                    return
                self.selected_outlook_account_idx = idx
            except Exception as e:
                messagebox.showerror("錯誤/Error", f"獲取Outlook帳號失敗/Failed to get Outlook accounts: {e}")
            return
        # 取得body內容，並保存到本地
        body = self.email_body_textbox.get("1.0", "end-1c")
        try:
            with open("email_body.txt", "w", encoding="utf-8") as f:
                f.write(body)
        except Exception:
            pass
        # 檢查是否有選定的供應商
        selected_supplier = getattr(self, 'supplier_combobox', None)
        if selected_supplier:
            selected_supplier_name = selected_supplier.get()
            if selected_supplier_name and selected_supplier_name not in ["請先選擇文件夾和配置文件", "沒有找到匹配的供應商文件"]:
                files = [f for f in os.listdir(folder) if f.endswith(".xlsx") and not f.startswith("~$")]
                config_mgr = UnifiedConfigManager(master_config)
                email_sender = EmailSender(config_mgr)
                matched_file = find_supplier_file(selected_supplier_name, files)
                if not matched_file:
                    messagebox.showerror("錯誤", f"找不到 {selected_supplier_name} 的對應文件")
                    return
                supplier_file = os.path.join(folder, matched_file)
                to_emails, cc_emails = email_sender.get_to_cc_emails(selected_supplier_name, master_config)
                from datetime import datetime
                now = datetime.now()
                week_no = now.isocalendar()[1]
                body_filled = body.replace("{week_no}", str(week_no))
                subject = f"Sushi Express Weekly Order - {selected_supplier_name} - {now.strftime('%B')} - Week {week_no}"
                mail = email_sender.send_email(
                    to_emails, cc_emails, selected_supplier_name, body_filled,
                    attachment_path=supplier_file,
                    account_idx=self.selected_outlook_account_idx,
                    subject=subject
                )
                if isinstance(mail, tuple):
                    messagebox.showerror("Error", mail[1])
                    return
                if not mail:
                    messagebox.showerror("Error", f"无法创建邮件: {selected_supplier_name}")
                    return
                messagebox.showinfo("成功", f"郵件已發送給 {selected_supplier_name}")
                return
        
        # 如果沒有選定供應商，則發送給所有供應商（原有邏輯）
        files = [f for f in os.listdir(folder) if f.endswith(".xlsx") and not f.startswith("~$")]
        config_mgr = UnifiedConfigManager(master_config)
        email_sender = EmailSender(config_mgr)
        supplier_names = set()
        wb = load_workbook(master_config, data_only=True)
        if "Suppliers" in wb.sheetnames:
            ws = wb["Suppliers"]
            for row in ws.iter_rows(min_row=2, values_only=True):
                if row and row[0]:
                    supplier_names.add(str(row[0]).strip())
        from datetime import datetime
        email_list = []
        matched_files = set()
        for sname in supplier_names:
            matched_file = find_supplier_file(sname, files)
            if not matched_file:
                continue
            matched_files.add(matched_file)
            supplier_file = os.path.join(folder, matched_file)
            to_emails, cc_emails = email_sender.get_to_cc_emails(sname, master_config)
            now = datetime.now()
            week_no = now.isocalendar()[1]
            body_filled = body.replace("{week_no}", str(week_no))
            subject = f"Sushi Express Weekly Order - {sname} - {now.strftime('%B')} - Week {week_no}"
            mail = email_sender.send_email(
                to_emails, cc_emails, sname, body_filled,
                attachment_path=supplier_file,
                account_idx=self.selected_outlook_account_idx,
                subject=subject
            )
            if isinstance(mail, tuple):
                messagebox.showerror("Error", mail[1])
                continue
            if not mail:
                messagebox.showerror("Error", f"无法创建邮件: {sname}")
                continue
            email_list.append((mail, sname, supplier_file))
        unmatched_files = [f for f in files if f not in matched_files]
        if unmatched_files:
            messagebox.showwarning("未配對檔案", f"以下檔案未配對到任何Supplier，未發送郵件：\n" + "\n".join(unmatched_files))
        for mail, matched_supplier, supplier_file in email_list:
            def on_confirm(success, msg, ms=matched_supplier):
                if success:
                    messagebox.showinfo("Success", f"{ms} 郵件已發送！")
                else:
                    messagebox.showinfo("已取消/Cancelled", f"{ms} 郵件未發送。")
            EmailConfirmationDialog(self, mail, matched_supplier, "-", supplier_file, on_confirm)
    
    def show_operation_supplies_ui(self):
        """显示运营用品界面"""
        def build(c):
            self.master_file_var = ctk.StringVar()
            self.output_folder_var = ctk.StringVar()
            
            # 创建表单框架
            form_frame = ctk.CTkFrame(c, fg_color="transparent")
            form_frame.pack(fill="both", expand=True, padx=50, pady=20)
            
            # 主文件选择
            row1 = ctk.CTkFrame(form_frame)
            row1.pack(fill="x", pady=15)
            ctk.CTkLabel(row1, text="选择主文件/Select Master File:", font=FONT_MID).pack(side="left", padx=10)
            ctk.CTkEntry(row1, textvariable=self.master_file_var, font=FONT_MID, state="readonly", width=400).pack(side="left", expand=True, fill="x", padx=5)
            ctk.CTkButton(row1, text=t("browse"), font=FONT_MID, command=self._select_master_file).pack(side="left", padx=5)
            
            # 输出文件夹选择
            row2 = ctk.CTkFrame(form_frame)
            row2.pack(fill="x", pady=15)
            ctk.CTkLabel(row2, text="选择输出文件夹/Select Output Folder:", font=FONT_MID).pack(side="left", padx=10)
            ctk.CTkEntry(row2, textvariable=self.output_folder_var, font=FONT_MID, state="readonly", width=400).pack(side="left", expand=True, fill="x", padx=5)
            # 美化的瀏覽按鈕
            browse_btn_output = ctk.CTkButton(
                row2, 
                text="瀏覽...\nBrowse...", 
                font=("Microsoft YaHei", 11, "bold"),
                command=self._select_output_folder,
                corner_radius=8,
                hover_color="#1976d2",
                height=30
            )
            browse_btn_output.pack(side="left", padx=5)
            
            # 开始处理按钮
            btn_frame = ctk.CTkFrame(c, fg_color="transparent")
            btn_frame.pack(pady=30)
            GlowButton(
                btn_frame, 
                text="开始处理/Start Processing",
                command=self._run_operation_supplies,
                width=300,
                height=60,
                glow_color="#F97316"
            ).pack()
        
        self._show_function_ui(
            "operation_supplies",
            ("处理运营用品月订单\nProcess monthly operation supplies orders", FONT_TITLE),
            build
        )

    def _select_master_file(self):
        """选择主文件"""
        f = filedialog.askopenfilename(title=t("select_folder"), filetypes=[("Excel","*.xlsx;*.xls")])
        if f: self.master_file_var.set(f)

    def _select_output_folder(self):
        """选择输出文件夹"""
        f = filedialog.askdirectory(title=t("select_folder"))
        if f: self.output_folder_var.set(f)

    def _run_operation_supplies(self):
        """运行运营用品处理"""
        mf, of = self.master_file_var.get(), self.output_folder_var.get()
        if not mf or not of: messagebox.showwarning(t("warning"), t("folder_warning")); return
        p = ProgressPopup(self, t("processing"))
        self.progress_popup = p
        def logcb(m): p.log(m)
        threading.Thread(target=lambda: self._thread_task(lambda: OperationSuppliesOrder.process_order(mf, of, logcb))).start()

    def _thread_task(self, fn, show_message=True):
        """线程任务"""
        try:
            result = fn()
            if show_message:
                self.after(0, lambda: messagebox.showinfo(t("success"), result))
        except Exception as e:
            error_msg = str(e)
            self.after(0, lambda: messagebox.showerror(t("error"), f"操作失败: {error_msg}"))

    def _select_download_folder(self):
        f = filedialog.askdirectory(title=t("select_folder"))
        if f:
            self.download_folder_var.set(f)

    def _select_checklist_folder(self):
        f = filedialog.askdirectory(title=t("select_folder"))
        if f:
            self.checklist_folder_var.set(f)

    def _run_download(self):
        """執行下載"""
        folder = self.download_folder_var.get()
        config_file = self.config_file_var.get()
        if not folder:
            messagebox.showwarning("警告", "請選擇下載資料夾！")
            return
        
        # 計算下載日期範圍
        from datetime import datetime, timedelta
        today = datetime.now()
        days_since_last_friday = (today.weekday() - 4) % 7 or 7
        start_of_period = (today - timedelta(days=days_since_last_friday)).replace(hour=0, minute=0, second=0, microsecond=0)
        end_of_period = today.replace(hour=23, minute=59, second=59, microsecond=999999)
        start_date = start_of_period.strftime("%Y-%m-%d")
        end_date = end_of_period.strftime("%Y-%m-%d")
        
        # 創建進度彈窗，顯示日期範圍
        p = ProgressPopup(self, "下載中...", start_date, end_date, 0)
        self.progress_popup = p
        
        def log_callback(message):
            # 每個消息後面添加空行
            p.log(message + "\n")
            print(message)  # 同時輸出到控制台
        
        self._thread_task(
            lambda: OutlookDownloader.download_weekly_orders(
                folder, config_file, self.selected_outlook_account_idx,
                callback=log_callback, progress_popup=p
            ),
            show_message=False
        )



    def _run_download_amendments(self):
        """執行 Amendment 下載"""
        folder = self.download_folder_var.get()
        config_file = self.config_file_var.get()
        if not folder:
            messagebox.showwarning("警告", "請選擇下載資料夾！")
            return
        
        # 計算下載日期範圍
        from datetime import datetime, timedelta
        today = datetime.now()
        days_since_last_friday = (today.weekday() - 4) % 7 or 7
        start_of_period = (today - timedelta(days=days_since_last_friday)).replace(hour=0, minute=0, second=0, microsecond=0)
        end_of_period = today.replace(hour=23, minute=59, second=59, microsecond=999999)
        start_date = start_of_period.strftime("%Y-%m-%d")
        end_date = end_of_period.strftime("%Y-%m-%d")
        
        # 創建進度彈窗，顯示日期範圍
        p = ProgressPopup(self, "下載 Amendment 中...", start_date, end_date, 0)
        self.progress_popup = p
        
        def log_callback(message):
            # 每個消息後面添加空行
            p.log(message + "\n")
            print(message)  # 同時輸出到控制台
        
        self._thread_task(
            lambda: OutlookDownloader.download_amendment_orders(
                folder, config_file, self.selected_outlook_account_idx,
                callback=log_callback, progress_popup=p
            ),
            show_message=False
        )

    def _run_enhanced_automation(self):
        source = self.folder_vars.get("source_folder", ctk.StringVar()).get()
        supplier = self.folder_vars.get("supplier_folder", ctk.StringVar()).get()
        master_config = self.master_config_var.get()
        if not source or not supplier or not master_config:
            messagebox.showwarning(t("warning"), t("folder_warning"))
            return
        p = ProgressPopup(self, t("processing"))
        self.progress_popup = p
        def logcb(m): p.log(m)
        config_mgr = UnifiedConfigManager(master_config)
        auto = EnhancedOrderAutomation(config_mgr)
        import threading
        def run_and_show_count():
            result = auto.run_automation(source, supplier, log_callback=logcb)[1]
            # 統計已整理分店數量
            import re
            outlet_count = 0
            for line in result.splitlines():
                m = re.match(r"- (.+)_Week", line)
                if m:
                    outlet_count += 1
            # 在 popup 下方顯示
            if hasattr(p, 'outlet_count_label') and p.outlet_count_label:
                p.outlet_count_label.configure(text=f"🏪 已整理分店數量: {outlet_count} 間", text_color="#10b981")
            else:
                import customtkinter as ctk
                p.outlet_count_label = ctk.CTkLabel(
                    p,
                    text=f"🏪 已整理分店數量: {outlet_count} 間",
                    font=("Microsoft JhengHei", 18, "bold"),
                    text_color="#10b981"
                )
                p.outlet_count_label.pack(pady=(0, 10))
        threading.Thread(target=run_and_show_count).start()

    def _run_yellow_highlighted_automation(self):
        """只整合有黃色標記的訂單"""
        source = self.folder_vars.get("source_folder", ctk.StringVar()).get()
        supplier = self.folder_vars.get("supplier_folder", ctk.StringVar()).get()
        master_config = self.master_config_var.get()
        if not source or not supplier or not master_config:
            messagebox.showwarning(t("warning"), t("folder_warning"))
            return
        
        p = ProgressPopup(self, "處理黃色標記訂單中...")
        self.progress_popup = p
        def logcb(m): p.log(m)
        
        config_mgr = UnifiedConfigManager(master_config)
        auto = YellowHighlightedOrderAutomation(config_mgr)
        
        import threading
        def run_and_show_count():
            result = auto.run_automation(source, supplier, log_callback=logcb)[1]
            # 統計已整理分店數量
            import re
            outlet_count = 0
            for line in result.splitlines():
                m = re.match(r"- (.+)_Week", line)
                if m:
                    outlet_count += 1
            # 在 popup 下方顯示
            if hasattr(p, 'outlet_count_label') and p.outlet_count_label:
                p.outlet_count_label.configure(text=f"🏪 已整理分店數量: {outlet_count} 間", text_color="#f59e0b")
            else:
                import customtkinter as ctk
                p.outlet_count_label = ctk.CTkLabel(
                    p,
                    text=f"🏪 已整理分店數量: {outlet_count} 間",
                    font=("Microsoft JhengHei", 18, "bold"),
                    text_color="#f59e0b"
                )
                p.outlet_count_label.pack(pady=(0, 10))
        threading.Thread(target=run_and_show_count).start()

    def _select_config_file(self, var=None, filetypes=None):
        f = filedialog.askopenfilename(title=t("select_folder"), filetypes=filetypes or [("Excel files", "*.xlsx;*.xls")])
        if f:
            if var:
                var.set(f)
            else:
                self.config_file_var.set(f)

    def _select_master_config(self):
        """选择主配置文件"""
        from tkinter import filedialog
        f = filedialog.askopenfilename(
            title="选择主配置文件/Select Master Config File",
            filetypes=[("Excel files", "*.xlsx;*.xls")]
        )
        if f:
            self.master_config_var.set(f)

    def _select_folder(self, key):
        f = filedialog.askdirectory(title=t("select_folder"))
        if f:
            self.folder_vars[key].set(f)

    def _select_folder_var(self, var):
        f = filedialog.askdirectory(title=t("select_folder"))
        if f:
            var.set(f)

    def _show_required_outlets_window(self):
        import pandas as pd
        import tkinter.ttk as ttk
        master_config = self.master_config_var.get()
        df_req = pd.read_excel(master_config, sheet_name="Supplier Requirements")
        config_suppliers = set(str(row[0]).strip() for _, row in df_req.iterrows() if str(row[0]).strip())

        win = ctk.CTkToplevel(self)
        win.title("必要門市清單/Required Outlets List")
        win.geometry("800x500")
        ctk.CTkLabel(win, text="📋 供應商/Supplier        ❗缺漏分店/Missing Outlets", font=FONT_BIGBTN).pack(pady=10)
        frame = ctk.CTkFrame(win)
        frame.pack(fill="both", expand=True, padx=10, pady=10)
        tree = ttk.Treeview(frame, columns=("supplier", "missing"), show="headings", height=16)
        tree.heading("supplier", text="📋 供應商/Supplier")
        tree.heading("missing", text="❗缺漏分店/Missing Outlets")
        tree.column("supplier", width=180, anchor="center")
        tree.column("missing", width=600, anchor="w")

        # 1. 分組整理 missing outlet，只針對 config supplier
        missing_by_supplier = {}
        for row in getattr(self, '_checklist_table_data', []):
            if row.get("cover_status") == "❌":
                supplier = str(row.get("supplier", "")).strip()
                outlet = str(row.get("outlet", "")).strip()
                if supplier in config_suppliers:
                    if supplier not in missing_by_supplier:
                        missing_by_supplier[supplier] = []
                    missing_by_supplier[supplier].append(outlet)

        # 2. 顯示
        for supplier in config_suppliers:
            if supplier in missing_by_supplier:
                tree.insert("", "end", values=(supplier, ", ".join(missing_by_supplier[supplier])))
        tree.pack(fill="both", expand=True)

        # 若沒有任何缺漏
        if not any(missing_by_supplier.values()):
            tree.insert("", "end", values=("✔ All covered", ""))

        # 複製按鈕
        def copy_selected():
            items = tree.selection()
            if not items:
                return
            import pyperclip
            rows = []
            for item in items:
                vals = tree.item(item, "values")
                rows.append("\t".join(vals))
            pyperclip.copy("\n".join(rows))
            messagebox.showinfo("複製成功/Copy Success", "已複製到剪貼簿！/Copied to clipboard!")
        ctk.CTkButton(win, text="複製所選/Copy Selected", command=copy_selected).pack(pady=5)

    def show_user_guide(self):
        """显示用户指南"""
        try:
            guide_path = resource_path("UserGuide.txt")
            if os.path.exists(guide_path):
                with open(guide_path, "r", encoding="utf-8") as f:
                    content = f.read()
                ScrollableMessageBox(self, "用户指南", content)
            else:
                messagebox.showwarning("指南缺失", "用户指南文件未找到")
        except Exception as e:
            messagebox.showerror("错误", f"无法加载用户指南: {str(e)}")

    def _run_cross_check_email_log(self):
        import os
        import re
        import pandas as pd
        import customtkinter as ctk
        folder = self.checklist_folder_var.get()
        table = getattr(self, '_checklist_table_data', [])
        config_path = self.master_config_var.get()
        email_log_path = os.path.join(folder, "email_bodies_log.txt")
        if not os.path.exists(email_log_path):
            from tkinter import messagebox
            messagebox.showinfo("交叉檢查結果\nCross Check Result", "找不到 email_bodies_log.txt！\nEmail log not found!")
            return
        # 1. 讀取 OUTLET mapping
        outlet_map = {}
        unknown_records = []  # 收集 unknown 郵件資訊
        if os.path.exists(config_path):
            try:
                df = pd.read_excel(config_path, sheet_name=None)
                outlet_df = None
                for key in df.keys():
                    if key.strip().lower() in ["outlets", "outlet"]:
                        outlet_df = df[key]
                        break
                if outlet_df is not None:
                    for _, row in outlet_df.iterrows():
                        short = str(row[0]).strip().upper() if pd.notna(row[0]) else ''
                        full = str(row[1]).strip() if pd.notna(row[1]) else ''
                        email = str(row[2]).strip().lower() if pd.notna(row[2]) else ''
                        # 支援 Alias/Keyword 欄（第4欄或第5欄，允許多個逗號分隔）
                        alias_col = None
                        for idx in range(3, len(row)):
                            colname = str(outlet_df.columns[idx]).strip().lower()
                            if colname in ["alias", "keyword", "別名", "關鍵字"]:
                                alias_col = idx
                                break
                        aliases = []
                        if alias_col is not None and pd.notna(row[alias_col]):
                            aliases = [a.strip() for a in str(row[alias_col]).split(",") if a.strip()]
                        # 建立 mapping
                        for key in [short, full, email] + aliases:
                            k = key.strip().lower().replace(" ", "")
                            if k:
                                outlet_map[k] = short
            except Exception as e:
                print(f"[DEBUG] 讀 config 出錯: {e}")
        def normalize_name(name):
            if not name:
                return ""
            import re
            name = re.sub(r'\(.*?\)', '', name)
            name = re.sub(r'update', '', name, flags=re.IGNORECASE)
            name = re.sub(r'[^a-zA-Z0-9]', '', name)
            return name.strip().upper()
        def is_supplier_match(s1, s2):
            n1, n2 = normalize_name(s1), normalize_name(s2)
            return n1 in n2 or n2 in n1 or (len(n1) > 3 and n1[:4] in n2) or (len(n2) > 3 and n2[:4] in n1)
        def is_cover_status_ok(status):
            return any(x in status for x in ['✔', '✓'])
        # ===== Outlet mapping 與新版比對 function =====
        short_to_full = {}
        full_to_short = {}
        email_name_to_short = {}
        outlet_all_names = set()
        # 修正 master_config 未定义为 config_path
        if os.path.exists(config_path):
            try:
                df = pd.read_excel(config_path, sheet_name=None)
                outlet_df = None
                for key in df.keys():
                    if key.strip().lower() == "outlet":
                        outlet_df = df[key]
                        break
                if outlet_df is not None:
                    for _, row in outlet_df.iterrows():
                        short = str(row.get("Short Name", "")).strip()
                        full = str(row.get("Outlet Full Name", "")).strip()
                        email_name = str(row.get("Name in Email", "")).strip()
                        n_short = normalize_name(short)
                        n_full = normalize_name(full)
                        n_email = normalize_name(email_name)
                        if short:
                            short_to_full[n_short] = full
                            outlet_all_names.add(n_short)
                        if full:
                            full_to_short[n_full] = short
                            outlet_all_names.add(n_full)
                        if email_name:
                            email_name_to_short[n_email] = short
                            outlet_all_names.add(n_email)
            except Exception as e:
                print("Outlet mapping read error:", e)
        def is_outlet_match(req_outlet, ordered_outlet):
            n_req = normalize_name(req_outlet)
            n_ordered = normalize_name(ordered_outlet)
            # 三者任兩個 normalize 後有 match 就 True
            if n_req and n_ordered and n_req == n_ordered:
                return True
            if n_req in outlet_all_names or n_ordered in outlet_all_names:
                return True
            for n in outlet_all_names:
                if n == n_req or n == n_ordered:
                    return True
            return False
        # 2. 解析 email log
        with open(email_log_path, "r", encoding="utf-8") as f:
            content = f.read()
        outlet_results = {}
        import re
        blocks = re.split(r"——— ?邮件 ?\d+ ?———", content)
        for block in blocks:
            lines = [l.strip() for l in block.strip().splitlines() if l.strip()]
            if not lines or len(lines) < 2:
                continue
            outlet_raw = ""
            for l in lines:
                m = re.match(r"\[发件人\](.+)", l)
                if m:
                    outlet_raw = m.group(1).strip()
                    break
            if not outlet_raw:
                continue
            outlet_norm = normalize_name(outlet_raw)
            outlet_short = outlet_map.get(outlet_norm.lower(), outlet_raw)
            # 先 map 成 short，再找 config excel 的全名
            outlet_full = outlet_raw
            if os.path.exists(config_path):
                try:
                    df = pd.read_excel(config_path, sheet_name=None)
                    outlet_df = None
                    for key in df.keys():
                        if key.strip().lower() == "outlet":
                            outlet_df = df[key]
                            break
                    if outlet_df is not None:
                        for _, row in outlet_df.iterrows():
                            short = str(row.get("Short Name", "")).strip()
                            full = str(row.get("Outlet Full Name", "")).strip()
                            if short and short == outlet_short:
                                outlet_full = full
                                break
                except Exception as e:
                    pass
            outlet_norm_full = normalize_name(outlet_full)
            claimed = []
            for line in lines:
                m = re.match(r"\d+\.\s*(.+)", line)
                if m:
                    claimed.append(m.group(1).strip())
            found = set()
            for row in table:
                row_outlet_norm = normalize_name(row["outlet"])
                # outlet 比對加強：允許 substring/前4碼
                outlet_match = is_outlet_match(row["outlet"], outlet_full)
                for s in claimed:
                    supplier_match = is_supplier_match(row["supplier"], s)
                    cover_ok = is_cover_status_ok(row["cover_status"])
                    print(f"[DEBUG] 比對: supplier: {normalize_name(row['supplier'])} <-> {normalize_name(s)} | outlet: {row['outlet']} <-> {outlet_full} | outlet_match: {outlet_match} | cover: {row['cover_status']} => {cover_ok}")
                    if outlet_full and outlet_match and supplier_match and cover_ok:
                        found.add(s)
            outlet_results[outlet_full] = []
            for supplier in claimed:
                if supplier in found:
                    outlet_results[outlet_full].append((supplier, True))
                else:
                    outlet_results[outlet_full].append((supplier, False))
        # 將 outlet_results 轉成表格資料
        table_data = []
        for outlet, suppliers in outlet_results.items():
            for supplier, ok in suppliers:
                status = "✔ 有整合！\nIntegrated!" if ok else "✗ 沒有整合！\nNot Integrated!"
                table_data.append((supplier, outlet, status, ok))
        class CrossCheckResultTable(ctk.CTkToplevel):
            def __init__(self, master, table_data):
                super().__init__(master)
                self.title("交叉檢查結果\nCross Check Result")
                self.geometry("700x700")
                self.search_var = ctk.StringVar()
                ctk.CTkLabel(self, text="搜尋/分店/供應商\nSearch Outlet/Supplier").pack(pady=(10, 0))
                search_entry = ctk.CTkEntry(self, textvariable=self.search_var)
                search_entry.pack(fill="x", padx=10)
                search_entry.bind("<KeyRelease>", self.update_filter)
                import tkinter as tk
                from tkinter import ttk
                frame = ctk.CTkFrame(self)
                frame.pack(fill="both", expand=True, padx=10, pady=10)
                columns = ("supplier", "outlet", "status")
                self.tree = ttk.Treeview(frame, columns=columns, show="headings", height=25)
                self.tree.heading("supplier", text="供應商\nSupplier")
                self.tree.heading("outlet", text="分店\nOutlet")
                self.tree.heading("status", text="狀態\nStatus")
                self.tree.column("supplier", width=180)
                self.tree.column("outlet", width=120)
                self.tree.column("status", width=180)
                self.tree.pack(fill="both", expand=True)
                vsb = ttk.Scrollbar(frame, orient="vertical", command=self.tree.yview)
                self.tree.configure(yscroll=vsb.set)
                vsb.pack(side="right", fill="y")
                self.full_data = [(s, o, st) for s, o, st, _ in table_data]
                self.update_table(self.full_data)
                ctk.CTkButton(self, text="關閉\nClose", command=self.destroy).pack(pady=10)
            def update_table(self, data):
                for row in self.tree.get_children():
                    self.tree.delete(row)
                for supplier, outlet, status in data:
                    self.tree.insert("", "end", values=(supplier, outlet, status))
            def update_filter(self, event=None):
                keyword = self.search_var.get().lower()
                filtered = [row for row in self.full_data if keyword in row[0].lower() or keyword in row[1].lower()]
                self.update_table(filtered)
        CrossCheckResultTable(self, table_data)

    def show_download_summary(self, start_date, end_date, outlet_count):
        # 清空內容區
        for w in self.content_body.winfo_children():
            w.destroy()
        frame = ctk.CTkFrame(self.content_body, fg_color="#1e293b", corner_radius=18)
        frame.pack(fill="both", expand=True, padx=60, pady=60)
        ctk.CTkLabel(
            frame,
            text=f"📅 抓取日期範圍\n{start_date} ~ {end_date}",
            font=("Microsoft JhengHei", 24, "bold"),
            text_color="#3b82f6"
        ).pack(pady=(30, 10))
        ctk.CTkFrame(frame, height=2, fg_color="#60a5fa").pack(fill="x", padx=20, pady=10)
        ctk.CTkLabel(
            frame,
            text=f"🏪 已下載分店數量\n{outlet_count} 間",
            font=("Microsoft JhengHei", 28, "bold"),
            text_color="#10b981"
        ).pack(pady=(10, 30))

# ========== Outlook下载器 ==========
class OutlookDownloader:
    """Outlook订单下载器"""
    
    OUTLET_MAP = {
        "century": "CSQ", "clementi": "TCM", "funan": "FN", "heartbeat": "HBB",
        "heartland": "HLM", "hillion": "HM", "hougang": "HGM", "imm": "IMM",
        "jurong": "JP", "nex": "NEX", "north point city": "NPG", "north point": "NPC",
        "parkway": "PP", "paya lebar": "PLQ", "sengkang grand": "SKG", "seletar": "SM",
        "sun plaza": "SP", "waterway": "WWP", "westgate": "WG", "white sands": "WS",
        "cityvibe": "GTM", "tampines smrt": "TSMRT", "woodlands": "WL", "toa payoh": "TPY",
        "junction 8": "J8TO", "hougang mrt": "HGTO", "oasis": "OASIS", "sengkang mrt": "SKMRT",
        "yew tee": "YTS", "poiz": "TPC", "central kitchen": "CK GOGO", "bugis": "Bugis",
        "313": "Sushi+ 313", "tampines one": "T1", "ang mo kio": "AMK", "canberra": "CBP",
        "gombak": "BKG", "pasir ris": "PRM", "lavendar": "VHL", "west mall": "WSM"
    }
    
    @staticmethod
    def get_smtp_address(msg):
        """取得郵件的 SMTP 格式寄件人，強化 fallback，支援 Exchange 郵件"""
        try:
            if hasattr(msg, "SenderEmailType") and msg.SenderEmailType == "SMTP":
                return str(msg.SenderEmailAddress).lower().strip()
            if hasattr(msg, "Sender") and hasattr(msg.Sender, "GetExchangeUser"):
                try:
                    ex_user = msg.Sender.GetExchangeUser()
                    if ex_user and hasattr(ex_user, "PrimarySmtpAddress"):
                        smtp = str(ex_user.PrimarySmtpAddress).lower().strip()
                        if smtp:
                            return smtp
                except Exception:
                    pass
            # 新增：用 MAPI 屬性抓 SMTP
            try:
                mapi = msg.Sender
                smtp = mapi.PropertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/proptag/0x39FE001E")
                if smtp:
                    return str(smtp).lower().strip()
            except Exception:
                pass
            # fallback: 直接用 SenderEmailAddress（即使是 EX）
            if hasattr(msg, "SenderEmailAddress"):
                email_addr = str(msg.SenderEmailAddress).lower().strip()
                if email_addr:
                    return email_addr
            # fallback: 直接用 SenderName
            if hasattr(msg, "SenderName"):
                return str(msg.SenderName).lower().strip()
        except Exception:
            pass
        return ""

    @classmethod
    def read_outlet_config(cls, config_file):
        import pandas as pd
        df = pd.read_excel(config_file)
        outlets = []
        emails = []
        for _, row in df.iterrows():
            # 強制用 column C (index 2) 作為 email，並轉小寫
            email = str(row.iloc[2]).strip().lower() if len(row) > 2 and not pd.isna(row.iloc[2]) else ''
            short_name = str(row.iloc[0]).strip() if len(row) > 0 and not pd.isna(row.iloc[0]) else ''
            if not email or not short_name:
                continue
            emails.append(email)
            outlets.append({
                'email': email,
                'short_name': short_name,
            })
        print('[DEBUG] All emails from config:', emails)
        return outlets

    @classmethod
    def download_weekly_orders(cls, destination_folder, config_file=None, account_idx=None, callback=None, progress_popup=None):
        import win32com.client
        from datetime import datetime, timedelta
        import os
        import re
        import pandas as pd
        import hashlib
        # 取得今天日期
        today = datetime.now()
        week_no = today.isocalendar()[1]
        
        # ====== 正確回推到上週五 ======
        # today.weekday(): 0=Mon, 4=Fri, 6=Sun
        days_since_last_friday = (today.weekday() - 4) % 7 or 7
        start_of_period = (today - timedelta(days=days_since_last_friday)).replace(hour=0, minute=0, second=0, microsecond=0)
        end_of_period = today.replace(hour=23, minute=59, second=59, microsecond=999999)
        
        save_path = os.path.join(destination_folder, f"Week_{week_no}")
        os.makedirs(save_path, exist_ok=True)
        
        # ====== 檢查已下載檔案記錄 ======
        downloaded_log_file = os.path.join(save_path, "downloaded_files_log.txt")
        downloaded_files = set()
        if os.path.exists(downloaded_log_file):
            try:
                with open(downloaded_log_file, 'r', encoding='utf-8') as f:
                    for line in f:
                        line = line.strip()
                        if line:
                            downloaded_files.add(line)
                if callback:
                    callback(f"📋 已載入 {len(downloaded_files)} 個已下載檔案記錄")
            except Exception as e:
                if callback:
                    callback(f"⚠️ 載入已下載記錄失敗: {e}")
        
        def save_downloaded_file_info(filename, sender_email, subject, received_time):
            """記錄已下載的檔案資訊"""
            try:
                with open(downloaded_log_file, 'a', encoding='utf-8') as f:
                    file_info = f"{filename}|{sender_email}|{subject}|{received_time}"
                    f.write(file_info + "\n")
                    downloaded_files.add(file_info)
            except Exception as e:
                if callback:
                    callback(f"⚠️ 記錄下載資訊失敗: {e}")
        
        def is_file_already_downloaded(filename, sender_email, subject, received_time):
            """檢查檔案是否已經下載過"""
            file_info = f"{filename}|{sender_email}|{subject}|{received_time}"
            return file_info in downloaded_files

        # ===== 讀 config，建立 email -> short_name 映射 =====
        email_to_short = {}  # email(lowercase) -> short_name
        name_to_short = {}   # name(lowercase)  -> short_name
        if config_file and os.path.exists(config_file):
            try:
                df = pd.read_excel(config_file)
                for _, row in df.iterrows():
                    email = str(row.iloc[2]).strip().lower() if len(row) > 2 and not pd.isna(row.iloc[2]) else ''
                    short_name = str(row.iloc[0]).strip() if len(row) > 0 and not pd.isna(row.iloc[0]) else ''
                    name_in_email = str(row.iloc[4]).strip().lower() if len(row) > 4 and not pd.isna(row.iloc[4]) else ''
                    if email and short_name:
                        email_to_short[email] = short_name
                    if name_in_email and short_name:
                        name_to_short[name_in_email] = short_name
            except Exception as e:
                pass

        # 選擇帳號
        outlook = win32com.client.Dispatch("Outlook.Application").GetNamespace("MAPI")
        accounts = [outlook.Folders.Item(i + 1) for i in range(outlook.Folders.Count)]
        if account_idx is None:
            from tkinter import simpledialog
            account_names = [acct.Name for acct in accounts]
            # 嘗試找到主視窗
            import tkinter as tk
            main_window = None
            for w in tk._default_root.winfo_children():
                if hasattr(w, 'attributes'):
                    main_window = w
                    break

            # 確保主視窗在最頂層
            if main_window:
                main_window.attributes('-topmost', True)
                main_window.lift()  # 提升到最頂層
                main_window.focus_force()  # 強制獲得焦點

            idx = simpledialog.askinteger(
                t("select_account"),
                "\n".join([f"[{i}] {name}" for i, name in enumerate(account_names)]) + "\n" + t("enter_index"),
                minvalue=0, maxvalue=len(account_names)-1,
                parent=main_window if main_window else None
            )

            # 恢復主視窗設置
            if main_window:
                main_window.attributes('-topmost', False)

            if idx is None:
                # if callback:
                #     callback("❌ 未選擇帳號，已取消下載")
                return
            account_idx = idx
        account_folder = accounts[account_idx]
        # 遞迴抓取所有子資料夾的郵件
        def collect_messages_from_subfolders(folder):
            all_messages = []
            try:
                if hasattr(folder, 'DefaultItemType') and folder.DefaultItemType == 0:
                    print(f"[DEBUG] Scanning folder: {folder.Name}")
                    items = folder.Items
                    items.Sort("[ReceivedTime]", True)
                    count = 0
                    for msg in items:
                        try:
                            if msg.Class == 43:
                                received = getattr(msg, 'ReceivedTime', None)
                                subject = getattr(msg, 'Subject', '')
                                if received:
                                    # 若 received 有 tzinfo，轉成 naive
                                    if hasattr(received, 'tzinfo') and received.tzinfo is not None:
                                        received_naive = received.replace(tzinfo=None)
                                    else:
                                        received_naive = received
                                    if start_of_period <= received_naive <= end_of_period:
                                        print(f"[DEBUG] Message: ReceivedTime={received}, Subject={subject}")
                                        all_messages.append(msg)
                                        count += 1
                        except Exception as e:
                            print(f"[DEBUG] Error reading message in {folder.Name}: {e}")
                    print(f"[DEBUG] Folder '{folder.Name}' matched messages: {count}")
            except Exception as e:
                print(f"[DEBUG] Exception in collect_messages_from_subfolders: {e} (Folder: {getattr(folder, 'Name', '')})")
            for sub in folder.Folders:
                all_messages.extend(collect_messages_from_subfolders(sub))
            return all_messages
        messages = collect_messages_from_subfolders(account_folder)
        if callback:
            callback(f"📬 取得郵件數量（限制上週五起，含所有子資料夾）: {len(messages)}")
        # 只保留 config 裡 email/name 的最新一封郵件
        latest_msg_by_sender = {}
        for msg in messages:
            try:
                sender_email = cls.get_smtp_address(msg).strip().lower()
                sender_name = getattr(msg, "SenderName", "").strip().lower()
                key = None
                if sender_email in email_to_short:
                    key = sender_email
                elif sender_name in name_to_short:
                    key = sender_name
                if not key:
                    continue
                if key not in latest_msg_by_sender or msg.ReceivedTime > latest_msg_by_sender[key].ReceivedTime:
                    latest_msg_by_sender[key] = msg
            except Exception:
                continue
        # 為每個門市收集所有郵件，按時間排序
        all_messages_by_sender = {}
        for msg in messages:
            try:
                sender_email = cls.get_smtp_address(msg).strip().lower()
                sender_name = getattr(msg, "SenderName", "").strip().lower()
                key = None
                if sender_email in email_to_short:
                    key = sender_email
                elif sender_name in name_to_short:
                    key = sender_name
                if not key:
                    continue
                if key not in all_messages_by_sender:
                    all_messages_by_sender[key] = []
                all_messages_by_sender[key].append(msg)
            except Exception:
                continue
        # 按時間排序每個門市的郵件
        for key in all_messages_by_sender:
            all_messages_by_sender[key].sort(key=lambda x: x.ReceivedTime, reverse=True)
        downloaded = 0
        skipped = 0
        manual_confirmed = 0
        downloaded_short_names = set()
        downloaded_emails = set()  # 新增：統計有下載 weekly order 的 email
        # ===== 只保留一份下載邏輯 =====
        for key, messages_list in all_messages_by_sender.items():
            try:
                # 先找 short_name
                if key in email_to_short:
                    short_name = email_to_short[key]
                elif key in name_to_short:
                    short_name = name_to_short[key]
                else:
                    continue
                excel_found = False
                
                # 遍歷該門市的所有郵件，按時間順序
                for msg in messages_list:
                    attachments = msg.Attachments
                    if attachments.Count == 0:
                        continue
                    
                    # 檢查是否有 Excel 附件
                    excel_attachments = []
                    for att in attachments:
                        filename = att.FileName
                        name_lower = filename.lower()
                        # 檢查是否為 Excel 文件
                        if name_lower.endswith('.xlsx') or name_lower.endswith('.xls'):
                            # 跳過包含 amendment 或 amend 關鍵字的附件
                            amendment_keywords = ['amendment', 'amend', 'admentmend', 'adment', 'amendmend', 'amendement']
                            if any(keyword in name_lower for keyword in amendment_keywords):
                                if callback:
                                    callback(f"⏩ 跳過 amendment 檔案: {filename}")
                                    callback("")  # 添加空行
                                continue
                            excel_attachments.append(att)
                    
                    # 額外檢查：如果郵件主旨包含 amendment，也跳過
                    subject = getattr(msg, 'Subject', '') or ''
                    subject_lower = subject.lower()
                    amendment_keywords = ['amendment', 'amend', 'admentmend', 'adment', 'amendmend', 'amendement']
                    if any(keyword in subject_lower for keyword in amendment_keywords):
                        if callback:
                            callback(f"⏩ 跳過 amendment 主旨郵件: {subject}")
                            callback("")  # 添加空行
                        continue
                    
                    # 如果沒有 Excel 附件，繼續下一封郵件
                    if not excel_attachments:
                        continue
                    
                    # 找到 Excel 附件，下載第一個
                    att = excel_attachments[0]
                    filename = att.FileName
                    save_filename = f"{short_name}_WeeklyOrder_{week_no}.xlsx"
                    full_path = os.path.join(save_path, save_filename)
                    base, ext = os.path.splitext(full_path)
                    counter = 1
                    while os.path.exists(full_path):
                        full_path = f"{base} ({counter}){ext}"
                        counter += 1
                    
                    # 檢查是否已經下載過
                    sender_email = cls.get_smtp_address(msg).strip().lower()
                    subject = getattr(msg, 'Subject', '') or ''
                    received_time = getattr(msg, 'ReceivedTime', '').strftime('%Y-%m-%d %H:%M:%S') if hasattr(msg, 'ReceivedTime') else ''
                    
                    if is_file_already_downloaded(filename, sender_email, subject, received_time):
                        if callback:
                            callback(f"⏩ 跳過已下載檔案: {filename} (from {key})")
                        continue
                    
                    att.SaveAsFile(full_path)
                    
                    # 記錄下載資訊
                    save_downloaded_file_info(filename, sender_email, subject, received_time)
                    
                    print(f"[DEBUG] Downloaded from sender_email: {key}")
                    downloaded_emails.add(key)  # 新增：記錄有下載的 email
                    downloaded += 1
                    downloaded_short_names.add(short_name)
                    excel_found = True
                    if progress_popup:
                        progress_popup.update_outlet_count(len(downloaded_short_names))
                    if callback:
                        callback(f"[AUTO] {os.path.basename(full_path)} (from {key})")
                        callback("")  # 添加空行
                    break  # 找到 Excel 附件後跳出循環
                
                # 如果該門市的所有郵件都沒有 Excel 附件
                if not excel_found:
                    if callback:
                        callback(f"⏩ 跳過 {key} - 所有郵件都沒有 Excel 附件")
                        callback("")  # 添加空行
                    skipped += 1
                    
            except Exception as e:
                if callback:
                    callback(f"❌ Failed to process a message: {e}")
                skipped += 1
        config_short_names = set(email_to_short.values())
        not_downloaded = config_short_names - downloaded_short_names
        summary = (
            f"\n=== Download Summary ===\n"
            f"Downloaded (auto): {downloaded}\n"
            f"Skipped: {skipped}\n"
            f"Saved to: {save_path}\n"
            f"\n=== 檔案下載結果 ===\n"
            f"已下載: {', '.join(sorted(downloaded_short_names)) if downloaded_short_names else '無'}\n"
            f"未下載: {', '.join(sorted(not_downloaded)) if not_downloaded else '無'}"
        )
        if callback:
            callback(summary)
        # 額外：呼叫主畫面美化顯示
        try:
            # 取得抓取日期範圍
            start_date = start_of_period.strftime("%Y-%m-%d")
            end_date = end_of_period.strftime("%Y-%m-%d")
            outlet_count = len(downloaded_short_names)
            # 嘗試取得 app 實例並顯示
            import tkinter as tk
            for w in tk._default_root.winfo_children():
                if hasattr(w, 'show_download_summary'):
                    w.show_download_summary(start_date, end_date, outlet_count)
                    break
        except Exception:
            pass

        # ====== 下載邏輯結束後，整理所有郵件的 body（只保留正文，無數字開頭判斷） ======
        bodies = []
        signature_keywords = [
            'best regards', 'regards', 'thanks', 'thank you', 'cheers', 'sincerely', '此致', '敬礼', '祝好', '謝謝', '感謝', '致敬', '敬上', '顺祝商祺', '顺颂时祺', '顺颂商祺', '顺致敬意', 'With regards', 'Yours faithfully', 'Yours sincerely', 'Yours truly', 'Kind regards', 'BR', '敬請', '順頌']
        import re
        for idx, msg in enumerate(latest_msg_by_sender.values(), 1):
            try:
                sender = getattr(msg, 'SenderName', '')
                subject = getattr(msg, 'Subject', '')
                body = getattr(msg, 'Body', '') or ''
                body_lines = body.splitlines()
                cut_idx = len(body_lines)
                for i, line in enumerate(body_lines):
                    l = line.strip().lower()
                    if any(kw in l for kw in signature_keywords):
                        cut_idx = i
                        break
                clean_body = '\n'.join(body_lines[:cut_idx]).strip()
                if not clean_body:
                    clean_body = "(无正文)"
                pretty = f"——— 邮件 {idx} ———\n[发件人] {sender}\n[主题] {subject}\n[内容]\n" + clean_body
                bodies.append(pretty)
            except Exception:
                continue
        cls.extracted_bodies = bodies
        # 自動寫出 email_bodies_log.txt
        try:
            log_file = os.path.join(save_path, "email_bodies_log.txt")
            with open(log_file, "w", encoding="utf-8") as f:
                f.write("\n\n".join(bodies))
        except Exception as e:
            pass

        print("[DEBUG] config_file:", config_file)
        print("[DEBUG] save_path:", save_path)
        print("[DEBUG] email_to_short:", email_to_short)
        print("[DEBUG] messages count:", len(messages))
        for msg in messages:
            try:
                sender_email = cls.get_smtp_address(msg).strip().lower()
                if not sender_email:
                    print("[DEBUG] msg.Sender:", getattr(msg, "Sender", None))
                    print("[DEBUG] msg.SenderName:", getattr(msg, "SenderName", None))
                    print("[DEBUG] msg.SenderEmailAddress:", getattr(msg, "SenderEmailAddress", None))
                    print("[DEBUG] msg.SenderEmailType:", getattr(msg, "SenderEmailType", None))
                print("[DEBUG] sender_email:", sender_email)
            except Exception as e:
                print("[DEBUG] error getting sender_email:", e)
        # 在流程結束時自動關閉console（僅限exe且有console時）
        if getattr(sys, 'frozen', False) and sys.stdout and sys.stdout.isatty():
            import time
            print("[DEBUG] Download process finished. Console will close in 5 seconds...")
            time.sleep(5)
            sys.exit(0)

        print("[DEBUG] All sender_email with weekly order downloaded:", list(downloaded_emails))

    @classmethod
    def download_amendment_orders(cls, destination_folder, config_file=None, account_idx=None, callback=None, progress_popup=None):
        """專門下載 Amendment 訂單"""
        import win32com.client
        from datetime import datetime, timedelta
        import os
        import re
        import pandas as pd
        
        # 取得今天日期
        today = datetime.now()
        week_no = today.isocalendar()[1]
        
        # ====== 正確回推到上週五 ======
        days_since_last_friday = (today.weekday() - 4) % 7 or 7
        start_of_period = (today - timedelta(days=days_since_last_friday)).replace(hour=0, minute=0, second=0, microsecond=0)
        end_of_period = today.replace(hour=23, minute=59, second=59, microsecond=999999)
        
        save_path = os.path.join(destination_folder, f"Week_{week_no}_Amendment")
        os.makedirs(save_path, exist_ok=True)
        
        # ====== 檢查已下載檔案記錄 ======
        downloaded_log_file = os.path.join(save_path, "downloaded_amendment_log.txt")
        downloaded_files = set()
        if os.path.exists(downloaded_log_file):
            try:
                with open(downloaded_log_file, 'r', encoding='utf-8') as f:
                    for line in f:
                        line = line.strip()
                        if line:
                            downloaded_files.add(line)
                if callback:
                    callback(f"📋 已載入 {len(downloaded_files)} 個已下載 Amendment 檔案記錄")
            except Exception as e:
                if callback:
                    callback(f"⚠️ 載入已下載 Amendment 記錄失敗: {e}")
        
        def save_downloaded_amendment_info(filename, sender_email, subject, received_time):
            """記錄已下載的 Amendment 檔案資訊"""
            try:
                with open(downloaded_log_file, 'a', encoding='utf-8') as f:
                    file_info = f"{filename}|{sender_email}|{subject}|{received_time}"
                    f.write(file_info + "\n")
                    downloaded_files.add(file_info)
            except Exception as e:
                if callback:
                    callback(f"⚠️ 記錄 Amendment 下載資訊失敗: {e}")
        
        def is_amendment_already_downloaded(filename, sender_email, subject, received_time):
            """檢查 Amendment 檔案是否已經下載過"""
            file_info = f"{filename}|{sender_email}|{subject}|{received_time}"
            return file_info in downloaded_files
        
        # ===== 讀 config，建立 email -> short_name 映射 =====
        email_to_short = {}  # email(lowercase) -> short_name
        name_to_short = {}   # name(lowercase)  -> short_name
        if config_file and os.path.exists(config_file):
            try:
                df = pd.read_excel(config_file)
                for _, row in df.iterrows():
                    email = str(row.iloc[2]).strip().lower() if len(row) > 2 and not pd.isna(row.iloc[2]) else ''
                    short_name = str(row.iloc[0]).strip() if len(row) > 0 and not pd.isna(row.iloc[0]) else ''
                    name_in_email = str(row.iloc[4]).strip().lower() if len(row) > 4 and not pd.isna(row.iloc[4]) else ''
                    if email and short_name:
                        email_to_short[email] = short_name
                    if name_in_email and short_name:
                        name_to_short[name_in_email] = short_name
            except Exception as e:
                pass
        
        # 選擇帳號
        outlook = win32com.client.Dispatch("Outlook.Application").GetNamespace("MAPI")
        accounts = [outlook.Folders.Item(i + 1) for i in range(outlook.Folders.Count)]
        if account_idx is None:
            from tkinter import simpledialog
            account_names = [acct.Name for acct in accounts]
            # 嘗試找到主視窗
            import tkinter as tk
            main_window = None
            for w in tk._default_root.winfo_children():
                if hasattr(w, 'attributes'):
                    main_window = w
                    break
            
            # 確保主視窗在最頂層
            if main_window:
                main_window.attributes('-topmost', True)
                main_window.lift()  # 提升到最頂層
                main_window.focus_force()  # 強制獲得焦點
            
            idx = simpledialog.askinteger(
                "選擇帳號",
                "\n".join([f"[{i}] {name}" for i, name in enumerate(account_names)]) + "\n請輸入帳號索引:",
                minvalue=0, maxvalue=len(account_names)-1,
                parent=main_window if main_window else None
            )
            
            # 恢復主視窗設置
            if main_window:
                main_window.attributes('-topmost', False)
            
            if idx is None:
                return
            account_idx = idx
        account_folder = accounts[account_idx]
        
        # 遞迴抓取所有子資料夾的郵件
        def collect_messages_from_subfolders(folder):
            all_messages = []
            try:
                if hasattr(folder, 'DefaultItemType') and folder.DefaultItemType == 0:
                    items = folder.Items
                    items.Sort("[ReceivedTime]", True)
                    count = 0
                    for msg in items:
                        try:
                            if msg.Class == 43:
                                received = getattr(msg, 'ReceivedTime', None)
                                subject = getattr(msg, 'Subject', '')
                                if received:
                                    if hasattr(received, 'tzinfo') and received.tzinfo is not None:
                                        received_naive = received.replace(tzinfo=None)
                                    else:
                                        received_naive = received
                                    if start_of_period <= received_naive <= end_of_period:
                                        all_messages.append(msg)
                                        count += 1
                        except Exception as e:
                            pass
            except Exception as e:
                pass
            for sub in folder.Folders:
                all_messages.extend(collect_messages_from_subfolders(sub))
            return all_messages
        
        messages = collect_messages_from_subfolders(account_folder)
        if callback:
            callback(f"📬 取得郵件數量（Amendment 模式）: {len(messages)}")
        
        # 為每個門市收集所有郵件，按時間排序
        all_messages_by_sender = {}
        for msg in messages:
            try:
                sender_email = cls.get_smtp_address(msg).strip().lower()
                sender_name = getattr(msg, "SenderName", "").strip().lower()
                key = None
                if sender_email in email_to_short:
                    key = sender_email
                elif sender_name in name_to_short:
                    key = sender_name
                if not key:
                    continue
                if key not in all_messages_by_sender:
                    all_messages_by_sender[key] = []
                all_messages_by_sender[key].append(msg)
            except Exception:
                continue
        
        # 按時間排序每個門市的郵件
        for key in all_messages_by_sender:
            all_messages_by_sender[key].sort(key=lambda x: x.ReceivedTime, reverse=True)
        
        downloaded = 0
        skipped = 0
        downloaded_short_names = set()
        
        # ===== Amendment 下載邏輯 =====
        for key, messages_list in all_messages_by_sender.items():
            try:
                # 先找 short_name
                if key in email_to_short:
                    short_name = email_to_short[key]
                elif key in name_to_short:
                    short_name = name_to_short[key]
                else:
                    continue
                amendment_found = False
                
                # 遍歷該門市的所有郵件，按時間順序
                for msg in messages_list:
                    attachments = msg.Attachments
                    if attachments.Count == 0:
                        continue
                    
                    # 檢查是否有 Amendment Excel 附件
                    amendment_attachments = []
                    for att in attachments:
                        filename = att.FileName
                        name_lower = filename.lower()
                        # 檢查是否為 Excel 文件且包含 amendment 關鍵字
                        if name_lower.endswith('.xlsx') or name_lower.endswith('.xls'):
                            # 擴展關鍵字搜尋，包含常見的拼寫錯誤
                            amendment_keywords = ['amendment', 'amend', 'admentmend', 'adment', 'amendmend', 'amendement']
                            if any(keyword in name_lower for keyword in amendment_keywords):
                                amendment_attachments.append(att)
                    
                    # 檢查郵件主旨是否包含 amendment
                    subject = getattr(msg, 'Subject', '') or ''
                    subject_lower = subject.lower()
                    # 擴展關鍵字搜尋，包含常見的拼寫錯誤
                    amendment_keywords = ['amendment', 'amend', 'admentmend', 'adment', 'amendmend', 'amendement']
                    is_amendment_subject = any(keyword in subject_lower for keyword in amendment_keywords)
                    
                    # 如果沒有 Amendment 附件且主旨也不是 Amendment，繼續下一封郵件
                    if not amendment_attachments and not is_amendment_subject:
                        continue
                    
                    # 找到 Amendment 附件，下載第一個
                    if amendment_attachments:
                        att = amendment_attachments[0]
                        filename = att.FileName
                        save_filename = f"{short_name}_Amendment_{week_no}.xlsx"
                        full_path = os.path.join(save_path, save_filename)
                        base, ext = os.path.splitext(full_path)
                        counter = 1
                        while os.path.exists(full_path):
                            full_path = f"{base} ({counter}){ext}"
                            counter += 1
                        
                        # 檢查是否已經下載過
                        sender_email = cls.get_smtp_address(msg).strip().lower()
                        received_time = getattr(msg, 'ReceivedTime', '').strftime('%Y-%m-%d %H:%M:%S') if hasattr(msg, 'ReceivedTime') else ''
                        
                        if is_amendment_already_downloaded(filename, sender_email, subject, received_time):
                            if callback:
                                callback(f"⏩ 跳過已下載 Amendment: {filename} (from {key})")
                            continue
                        
                        att.SaveAsFile(full_path)
                        
                        # 記錄下載資訊
                        save_downloaded_amendment_info(filename, sender_email, subject, received_time)
                        
                        downloaded += 1
                        downloaded_short_names.add(short_name)
                        amendment_found = True
                        if progress_popup:
                            progress_popup.update_outlet_count(len(downloaded_short_names))
                        if callback:
                            callback(f"[AMENDMENT] {os.path.basename(full_path)} (from {key})")
                        break  # 找到 Amendment 附件後跳出循環
                    
                    # 如果主旨包含 amendment 但沒有 amendment 附件，下載第一個 Excel 附件
                    elif is_amendment_subject:
                        excel_attachments = []
                        for att in attachments:
                            filename = att.FileName
                            name_lower = filename.lower()
                            if name_lower.endswith('.xlsx') or name_lower.endswith('.xls'):
                                excel_attachments.append(att)
                        
                        if excel_attachments:
                            att = excel_attachments[0]
                        filename = att.FileName
                        save_filename = f"{short_name}_Amendment_{week_no}.xlsx"
                        full_path = os.path.join(save_path, save_filename)
                        base, ext = os.path.splitext(full_path)
                        counter = 1
                        while os.path.exists(full_path):
                            full_path = f"{base} ({counter}){ext}"
                            counter += 1
                        
                        # 檢查是否已經下載過
                        sender_email = cls.get_smtp_address(msg).strip().lower()
                        received_time = getattr(msg, 'ReceivedTime', '').strftime('%Y-%m-%d %H:%M:%S') if hasattr(msg, 'ReceivedTime') else ''
                        
                        if is_amendment_already_downloaded(filename, sender_email, subject, received_time):
                            if callback:
                                callback(f"⏩ 跳過已下載 Amendment: {filename} (from {key})")
                            continue
                        
                        att.SaveAsFile(full_path)
                        
                        # 記錄下載資訊
                        save_downloaded_amendment_info(filename, sender_email, subject, received_time)
                        
                        downloaded += 1
                        downloaded_short_names.add(short_name)
                        amendment_found = True
                        if progress_popup:
                            progress_popup.update_outlet_count(len(downloaded_short_names))
                        if callback:
                            callback(f"[AMENDMENT] {os.path.basename(full_path)} (from {key})")
                        break  # 找到 Amendment 附件後跳出循環
                
                # 如果該門市的所有郵件都沒有 Amendment 附件
                if not amendment_found:
                    if callback:
                        callback(f"⏩ 跳過 {key} - 沒有找到 Amendment 檔案")
                    skipped += 1
                    
            except Exception as e:
                if callback:
                    callback(f"❌ Failed to process Amendment message: {e}")
                skipped += 1
        
        config_short_names = set(email_to_short.values())
        not_downloaded = config_short_names - downloaded_short_names
        summary = (
            f"\n=== Amendment Download Summary ===\n"
            f"Downloaded Amendment: {downloaded}\n"
            f"Skipped: {skipped}\n"
            f"Saved to: {save_path}\n"
            f"\n=== Amendment 檔案下載結果 ===\n"
            f"已下載: {', '.join(sorted(downloaded_short_names)) if downloaded_short_names else '無'}\n"
            f"未下載: {', '.join(sorted(not_downloaded)) if not_downloaded else '無'}"
        )
        if callback:
            callback(summary)

    @classmethod
    def _collect_messages(cls, folder, start_date, end_date, allowed_senders):
        """遍歷所有子資料夾，收集本週所有郵件（只保留 config 裡的 sender）"""
        messages = []
        try:
            items = folder.Items
            items.Sort("[ReceivedTime]", True)
            for msg in items:
                try:
                    received = getattr(msg, 'ReceivedTime', None)
                    msg_class = getattr(msg, 'Class', None)
                    subject = getattr(msg, 'Subject', '')
                    sender_type = getattr(msg, 'SenderEmailType', '')
                    sender_addr = getattr(msg, 'SenderEmailAddress', '')
                    primary_smtp = ''
                    if sender_type == 'EX':
                        try:
                            ex_user = msg.Sender.GetExchangeUser()
                            if ex_user and hasattr(ex_user, 'PrimarySmtpAddress'):
                                primary_smtp = str(ex_user.PrimarySmtpAddress).lower()
                        except Exception as e:
                            print(f"[DEBUG] Error getting PrimarySmtpAddress: {e}")
                    if received:
                        if hasattr(received, 'tzinfo') and received.tzinfo is not None:
                            received_naive = received.replace(tzinfo=None)
                        else:
                            received_naive = received
                        if start_date <= received_naive <= end_date:
                            sender_email = clean_email(cls.get_smtp_sender(msg))
                            print(f"[DEBUG] 收件日: {received_naive}, 主旨: {subject}, SenderEmailType: {sender_type}, SenderEmailAddress: {sender_addr}, PrimarySmtpAddress: {primary_smtp}, 比對用 sender_email: {sender_email}, msg_class: {msg_class}")
                            if allowed_senders and sender_email in allowed_senders:
                                if msg_class == 43:
                                    messages.append(msg)
                except Exception as e:
                    print(f"[DEBUG] Error reading message: {e}")
        except Exception as e:
            print(f"[DEBUG] Error accessing folder {folder.Name}: {e}")
        for sub in folder.Folders:
            messages.extend(cls._collect_messages(sub, start_date, end_date, allowed_senders))
        return messages

    @classmethod
    def _download_attachments(cls, messages, save_path, email_to_outlet=None, week_no=None):
        result = {
            "downloaded": 0,
            "skipped": 0,
            "matched_outlets": [],
            "unmatched_emails": set()
        }
        allowed_senders = set(email_to_outlet.keys()) if email_to_outlet else set()
        for msg in messages:
            try:
                sender_email = clean_email(cls.get_smtp_address(msg))
                subject = getattr(msg, "Subject", "") or ""
                attachments = msg.Attachments
                short_name = email_to_outlet.get(sender_email, "")
                if not short_name:
                    result['unmatched_emails'].add(sender_email)
                    continue
                for att in attachments:
                    filename = att.FileName
                    name_lower = filename.lower()
                    subject_lower = subject.lower()
                    # 多重關鍵字判斷
                    is_weekly = any(
                        kw in subject_lower or kw in name_lower
                        for kw in ["weekly order", "order form", "ordering"]
                    )
                    if is_weekly:
                        new_filename = f"{short_name}_WeeklyOrder-Week{week_no}{os.path.splitext(filename)[1]}"
                        save_file = os.path.join(save_path, new_filename)
                        att.SaveAsFile(save_file)
                        print(f"✅ Downloaded: {save_file}")
                        result['downloaded'] += 1
                        result['matched_outlets'].append(short_name)
                    else:
                        result['skipped'] += 1
            except Exception as e:
                print(f"Error downloading attachment: {e}")
                result['skipped'] += 1
        return result

    extracted_bodies = []

    @staticmethod
    def get_smtp_sender(msg):
        try:
            sender = msg.Sender
            if sender is not None:
                if sender.AddressEntryUserType == 0:  # olExchangeUserAddressEntry
                    ex_user = sender.GetExchangeUser()
                    if ex_user is not None:
                        return ex_user.PrimarySmtpAddress.lower()
                elif sender.AddressEntryUserType == 5:  # olSmtpAddressEntry
                    return sender.Address.lower()
            return str(getattr(msg, 'SenderEmailAddress', '')).lower()
        except Exception as e:
            print(f"[DEBUG] get_smtp_sender: Exception: {e}")
            return str(getattr(msg, 'SenderEmailAddress', '')).lower()

# ========== 运营用品订单 ==========
class OperationSuppliesOrder:
    """运营用品订单处理"""
    
    @staticmethod
    def get_monthly_order_data(master_file):
        """获取月度订单数据"""
        try:
            wb = load_workbook(master_file, data_only=True)
            data_sheet = wb["Data"]
            
            outlets = []
            for row in data_sheet.iter_rows(min_row=2, max_col=7, values_only=True):
                if row[1] and row[2]:
                    outlets.append({
                        "brand": row[1],
                        "outlet": row[2],
                        "short_name": row[3],
                        "full_name": row[4],
                        "address": row[5],
                        "delivery_day": row[6]
                    })
            
            orders = defaultdict(dict)
            unit_prices = defaultdict(dict)
            
            for supplier in ["Freshening", "Legacy", "Unikleen"]:
                if supplier in wb.sheetnames:
                    ws = wb[supplier]
                    
                    if supplier == "Freshening":
                        unit_prices[supplier] = [ws[f'D{i}'].value for i in range(12, 46)]
                    elif supplier == "Legacy":
                        unit_prices[supplier] = [ws[f'D{i}'].value for i in range(12, 15)]
                    else:
                        unit_prices[supplier] = [ws[f'D{i}'].value for i in range(12, 30)]
            
            for outlet in outlets:
                sheet_name = outlet["short_name"]
                if sheet_name in wb.sheetnames:
                    ws = wb[sheet_name]
                    
                    freshening = []
                    for row in range(4, 38):
                        cell_value = ws[f'L{row}'].value
                        freshening.append(cell_value if cell_value is not None else 0)
                    
                    legacy = []
                    for row in range(41, 44):
                        cell_value = ws[f'L{row}'].value
                        legacy.append(cell_value if cell_value is not None else 0)
                    
                    unikleen = []
                    for row in range(47, 65):
                        cell_value = ws[f'L{row}'].value
                        unikleen.append(cell_value if cell_value is not None else 0)
                    
                    orders[sheet_name] = {
                        "freshening": freshening,
                        "legacy": legacy,
                        "unikleen": unikleen
                    }
            
            templates = {}
            for supplier in ["Freshening", "Legacy", "Unikleen"]:
                if supplier in wb.sheetnames:
                    templates[supplier] = wb[supplier]
            
            return outlets, orders, templates, unit_prices
        except Exception as e:
            return None, f"Error reading master file: {str(e)}"

    @staticmethod
    def _is_number(val):
        try:
            float(val)
            return True
        except (TypeError, ValueError):
            return False

    @classmethod
    def calculate_order_amounts(cls, orders, unit_prices):
        """计算订单金额"""
        amounts = defaultdict(dict)
        for outlet, order_data in orders.items():
            for supplier in ["freshening", "legacy", "unikleen"]:
                items = order_data.get(supplier, [])
                prices = unit_prices.get(supplier.capitalize(), [])
                if len(prices) < len(items):
                    prices = prices + [0] * (len(items) - len(prices))
                total = sum(
                    float(qty) * float(price)
                    for qty, price in zip(items, prices)
                    if cls._is_number(qty) and cls._is_number(price)
                )
                amounts[outlet][supplier] = total
        return amounts

    @classmethod
    def check_moq(cls, outlets, orders, unit_prices, log_callback=None):
        """检查MOQ"""
        results = {
            "freshening": defaultdict(list),
            "legacy": defaultdict(list),
            "unikleen": defaultdict(list)
        }
        
        amounts = cls.calculate_order_amounts(orders, unit_prices)
        
        for outlet in outlets:
            short_name = outlet["short_name"]
            brand_type = outlet["brand"]
            amount = amounts.get(short_name, {}).get("freshening", 0)
            
            if brand_type == "Dine-In" and amount < 150:
                results["freshening"]["below_moq"].append(f"{short_name} (${amount:.2f} < $150)")
            elif brand_type == "GOGO" and amount < 100:
                results["freshening"]["below_moq"].append(f"{short_name} (${amount:.2f} < $100)")
            elif brand_type == "CNK" and amount < 150:
                results["freshening"]["below_moq"].append(f"{short_name} (${amount:.2f} < $150)")
            elif amount > 0:
                results["freshening"]["above_moq"].append(f"{short_name} (${amount:.2f})")
        
        for outlet in outlets:
            short_name = outlet["short_name"]
            quantities = orders.get(short_name, {}).get("legacy", [])
            
            total = sum(q for q in quantities if isinstance(q, (int, float)))
            cartons = total
            
            if cartons < 2 and total > 0:
                results["legacy"]["below_moq"].append(f"{short_name} ({cartons} ctn < 2 ctn)")
            elif total > 0:
                results["legacy"]["above_moq"].append(f"{short_name} ({cartons} ctn)")
        
        for outlet in outlets:
            short_name = outlet["short_name"]
            amount = amounts.get(short_name, {}).get("unikleen", 0)
            
            if amount < 80 and amount > 0:
                results["unikleen"]["below_moq"].append(f"{short_name} (${amount:.2f} < $80)")
            elif amount > 0:
                results["unikleen"]["above_moq"].append(f"{short_name} (${amount:.2f})")
        
        summary = "=== MOQ 檢查結果 (顯示訂購金額) ===\n"
        
        for supplier in ["freshening", "legacy", "unikleen"]:
            summary += f"\n** {supplier.capitalize()} **\n"
            
            if results[supplier]["below_moq"]:
                summary += "❌ 未達MOQ:\n"
                summary += "\n".join([f"  - {outlet}" for outlet in results[supplier]["below_moq"]]) + "\n"
            
            if results[supplier]["above_moq"]:
                summary += "✅ 已達MOQ:\n"
                summary += "\n".join([f"  - {outlet}" for outlet in results[supplier]["above_moq"]]) + "\n"
            
            if not results[supplier]["below_moq"] and not results[supplier]["above_moq"]:
                summary += "⚠️ 沒有訂單\n"
        
        if log_callback:
            log_callback(summary)
        
        return results, summary, amounts

    @classmethod
    def safe_set_cell_value(cls, ws, addr, value):
        from openpyxl.cell.cell import MergedCell
        cell = ws[addr]
        if not isinstance(cell, MergedCell):
            cell.value = value

    @classmethod
    def generate_supplier_files(
        cls, master_file, output_folder,
        outlets, orders, templates, amounts, log_callback=None
    ):
        """只訂一次貨：下月1號之後的第一個送貨日，且保證格式/公式/條件格式"""
        from openpyxl import Workbook
        from openpyxl.utils import get_column_letter
        import copy

        now = datetime.now()
        next_month = (now.month % 12) + 1
        year = now.year + (now.month // 12)
        saved = []

        for sup, tmpl_ws in templates.items():
            if log_callback: log_callback(f"\n--- Generating {sup} files ---")

            weekday_to_col = {
                'mon': 6, 'tue': 7, 'wed': 8, 'thu': 9, 'fri': 10, 'sat': 11, 'sun': 12
            }
            first_day = datetime(year, next_month, 1)
            first_wd_num = first_day.weekday()  # 0=Mon, 6=Sun
            first_wd = first_day.strftime("%a").lower()[:3]

            wb_out = Workbook()
            if wb_out.active is not None:
                wb_out.remove(wb_out.active)
            cnt = 0
            for o in outlets:
                sn = o["short_name"]
                data_list = orders.get(sn, {}).get(sup.lower(), [])
                nums = []
                for x in data_list:
                    try:
                        nums.append(float(x))
                    except:
                        nums.append(0.0)
                if not any(nums):
                    continue
                ws_new = wb_out.create_sheet(title=sn)
                # 複製模板內容
                for row in tmpl_ws.iter_rows():
                    for cell in row:
                        nc = ws_new.cell(row=cell.row, column=cell.column)
                        nc.value = cell.value
                        if cell.has_style:
                            nc.font = copy.copy(cell.font)
                            nc.border = copy.copy(cell.border)
                            nc.fill = copy.copy(cell.fill)
                            nc.number_format = cell.number_format
                            nc.protection = copy.copy(cell.protection)
                            nc.alignment = copy.copy(cell.alignment)
                if hasattr(tmpl_ws.conditional_formatting, '_cf_rules'):
                    for sqref, rules in tmpl_ws.conditional_formatting._cf_rules.items():
                        if isinstance(rules, list):
                            for rule in rules:
                                ws_new.conditional_formatting.add(sqref, rule)
                        else:
                            ws_new.conditional_formatting.add(sqref, rules)
                for ci in range(1, tmpl_ws.max_column+1):
                    cl = get_column_letter(ci)
                    ws_new.column_dimensions[cl].width = tmpl_ws.column_dimensions[cl].width
                for ri in range(1, tmpl_ws.max_row+1):
                    ws_new.row_dimensions[ri].height = tmpl_ws.row_dimensions[ri].height
                for mr in tmpl_ws.merged_cells.ranges:
                    ws_new.merge_cells(str(mr))
                # F5/F6
                cls.safe_set_cell_value(ws_new, "F5", o["full_name"])
                cls.safe_set_cell_value(ws_new, "F6", o["address"])
                # Freshening 寫入
                if sup == "Freshening":
                    cls.safe_set_cell_value(ws_new, "F8", o["delivery_day"])
                    # 解析所有送貨日
                    days = []
                    rawd = o["delivery_day"]
                    if isinstance(rawd, (int, float)):
                        d0 = datetime(1899, 12, 30) + timedelta(days=rawd)
                        days = [d0.strftime("%a").lower()[:3]]
                    else:
                        for p in str(rawd).split("/"):
                            if isinstance(p, str):
                                kd = p.strip().lower()[:3]
                            else:
                                kd = str(p).lower()[:3]
                            if kd in weekday_to_col:
                                days.append(kd)
                    days = list(dict.fromkeys(days))
                    # 找出下月1號之後的第一個送貨日
                    day_num_map = {'mon':0,'tue':1,'wed':2,'thu':3,'fri':4,'sat':5,'sun':6}
                    delivery_nums = [day_num_map[d] for d in days if d in day_num_map]
                    next_delivery = None
                    after = [d for d in delivery_nums if d >= first_wd_num]
                    if after:
                        next_delivery_num = min(after)
                    elif delivery_nums:
                        next_delivery_num = min(delivery_nums)
                    else:
                        next_delivery_num = None
                    # 反查 weekday_to_col
                    next_delivery_wd = None
                    for k, v in day_num_map.items():
                        if v == next_delivery_num:
                            next_delivery_wd = k
                            break
                    if next_delivery_wd and next_delivery_wd in weekday_to_col:
                        col = weekday_to_col[next_delivery_wd]
                        # 決定 row 起點
                        if first_wd in ['fri','sat','sun']:
                            base_row = 51
                        else:
                            base_row = 12
                        for row_idx, qty in enumerate(nums):
                            excel_row = base_row + row_idx
                            cls.safe_set_cell_value(ws_new, f"{get_column_letter(col)}{excel_row}", qty)
                elif sup == "Legacy":
                    # 只訂一次貨，找下月1號之後的第一個送貨日
                    days = ['mon','tue','wed','thu','fri']
                    day_num_map = {'mon':0,'tue':1,'wed':2,'thu':3,'fri':4}
                    delivery_nums = [day_num_map[d] for d in days if d in day_num_map]
                    after = [d for d in delivery_nums if d >= first_wd_num]
                    if after:
                        next_delivery_num = min(after)
                    elif delivery_nums:
                        next_delivery_num = min(delivery_nums)
                    else:
                        next_delivery_num = None
                    next_delivery_wd = None
                    for k, v in day_num_map.items():
                        if v == next_delivery_num:
                            next_delivery_wd = k
                            break
                    if next_delivery_wd and next_delivery_wd in weekday_to_col:
                        col = weekday_to_col[next_delivery_wd]
                        row = 12
                        for idx, qty in enumerate(nums):
                            cls.safe_set_cell_value(ws_new, f"{get_column_letter(col)}{row}", qty if idx == 0 else 0)
                elif sup == "Unikleen":
                    # 只訂一次貨，直接用下月1號是星期幾
                    col = weekday_to_col[first_wd]
                    row = 12
                    cls.safe_set_cell_value(ws_new, f"{get_column_letter(col)}{row}", nums[0] if len(nums) > 0 else 0)
                cnt += 1
            # 保存
            if cnt:
                fn = f"{sup}_Order_{year}_{next_month:02d}.xlsx"
                path = os.path.join(output_folder, fn)
                wb_out.save(path)
                saved.append(fn)
                if log_callback: log_callback(f"✅ Saved {fn} ({cnt} sheets)")
            else:
                if log_callback: log_callback(f"⚠️ {sup} 無訂單，未生成檔案")

        return True, saved

    @classmethod
    def process_order(cls, master_file, output_folder, log_callback=None, progress_callback=None):
        """处理订单"""
        try:
            if log_callback:
                log_callback(f"讀取主文件: {os.path.basename(master_file)}")
            outlets, orders, templates, unit_prices = cls.get_monthly_order_data(master_file)
            
            if not outlets:
                return False, "無法讀取分店數據，請檢查Data工作表"
            
            if log_callback:
                log_callback("\n計算訂購金額並檢查MOQ要求...")
            moq_results, moq_summary, amounts = cls.check_moq(outlets, orders, unit_prices, log_callback)
            
            if log_callback:
                log_callback("\n生成供應商訂單文件並顯示訂購金額...")
            success, supplier_files = cls.generate_supplier_files(
                master_file, output_folder, outlets, orders, templates, amounts, log_callback
            )
            
            if not success:
                return False, supplier_files
            
            result = (
                f"=== 營運用品月訂單處理完成 ===\n"
                f"成功生成 {len(saved)} 個供應商訂單文件\n"
                f"保存位置: {output_folder}\n"
                f"生成文件: {', '.join(saved)}"
            )
            
            if log_callback:
                log_callback(result)
            
            return True, saved
            
        except Exception as e:
            error_msg = f"處理訂單時發生錯誤: {str(e)}"
            if log_callback:
                log_callback(error_msg)
            return False, error_msg
            
# ====== 在檔案開頭（import 之後）新增 ======
def clean_email(val):
    if not val:
        return ""
    import re
    # 去除所有空白字符（空格、Tab、换行、全角空格等），并转小写
    return re.sub(r"\s+", "", str(val)).lower().strip()

# ========== 支援公式自動計算的 cell 讀取（已棄用，改用 data_only=True） ==========
def get_cell_value_with_formula_support(ws, row, col, file_path=None, sheet_name=None):
    # 現在直接使用 cell.value，因為檔案已經用 data_only=True 讀取
    return ws.cell(row=row, column=col).value

# ========== 批量處理公式的優化版本 ==========
def process_formula_cells_batch(ws, file_path=None, sheet_name=None, max_rows=150):
    """批量處理所有公式 cell，一次啟動 Excel 處理整個檔案"""
    if not file_path or not sheet_name:
        return ws
    
    try:
        import xlwings as xw
        print(f"[DEBUG] 啟動 Excel 處理公式: {file_path}")
        app = xw.App(visible=False)
        wb = app.books.open(file_path)
        ws_xl = wb.sheets[sheet_name]
        
        # 掃描所有需要處理的 cell
        formula_cells = []
        for row in range(1, min(max_rows, ws.max_row + 1)):
            for col in range(1, ws.max_column + 1):
                cell = ws.cell(row=row, column=col)
                
                # 跳過合併儲存格
                if isinstance(cell, MergedCell):
                    continue
                
                val = cell.value
                
                # 檢查是否為公式（只處理真正的公式，不是 None）
                is_formula = (isinstance(val, str) and val.startswith("=")) or \
                            (hasattr(val, '__class__') and 'ArrayFormula' in str(val.__class__))
                
                if is_formula:
                    formula_cells.append((row, col))
        
        # 批量讀取所有公式 cell 的值
        if formula_cells:
            print(f"[DEBUG] 找到 {len(formula_cells)} 個公式 cell，開始批量處理")
            for row, col in formula_cells:
                try:
                    display_value = ws_xl.range((row, col)).value
                    # 更新 openpyxl 的 cell 值
                    ws.cell(row=row, column=col).value = display_value
                except Exception as e:
                    print(f"[DEBUG] 處理公式失敗 row={row} col={col}: {e}")
        
        wb.close()
        app.quit()
        print(f"[DEBUG] Excel 處理完成")
        
    except Exception as e:
        print(f"[DEBUG] 批量處理公式失敗: {e}")
    
    return ws

# ========== 入口点 ==========
if __name__ == '__main__':
    try:
        app = SushiExpressApp()
        app.mainloop()
    except Exception as e:
        messagebox.showerror("Error", f"Startup failed: {e}")
        sys.exit(1)
